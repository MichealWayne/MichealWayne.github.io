<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条读书笔记 | Wayne的博客</title><meta name="description" content="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条读书笔记 - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><script>(function (w) {w.frontjsConfig={token:"81a82620fb0dca7680f2f06be134fa4f",behaviour:8,FPSThreshold:10};w.frontjsTmpData = {r:[],e:[],l:[]};w.frontjsTmpCollector = function (ev) {(ev.message ? window.frontjsTmpData.e : window.frontjsTmpData.r).push([new Date().getTime(), ev])};w.FrontJS = {addEventListener: function (t, f) {w.frontjsTmpData.l.push([t, f]);return f;},removeEventListener: function (t, f) {for (var i = 0; i < w.frontjsTmpData.l.length; i++) {t === w.frontjsTmpData.l[i][0] && f === w.frontjsTmpData.l[i][1] && w.frontjsTmpData.l.splice(i, 1);}return f;}};w.document.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("load", function () {var n = w.document.createElement("script");n.src = "https://frontjs-static.pgyer.com/dist/current/frontjs.web.min.js"; w.document.body.appendChild(n);}, true);})(window);</script><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">Home</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">Archive</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">About</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="search" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条读书笔记</h1><span class="post-date">Jun 2, 2024</span><span class="post-tag"><a href="/tags/笔记/">笔记</a><a href="/tags/python/">python</a></span><img src="/images/notes/20240317/p-logo.png" class="bgimage"><div class="post-content"><h1 id="【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-75-～-90-条（测试与调试、协作开发）读书笔记"><a href="#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-75-～-90-条（测试与调试、协作开发）读书笔记" class="headerlink" title="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条（测试与调试、协作开发）读书笔记"></a>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条（测试与调试、协作开发）读书笔记</h1><p>（书基于 Python 3.7+ 语法规范）</p>
<p>知识点概括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repr函数</span><br><span class="line">unittest模块</span><br><span class="line">TestCase类</span><br><span class="line">mock函数与Mock类</span><br><span class="line">pdb模块</span><br><span class="line">breakpoint函数</span><br><span class="line">tracemalloc模块</span><br><span class="line">PyPI</span><br><span class="line">venv工具</span><br><span class="line">requirements.txt文件</span><br><span class="line">warnings模块</span><br></pre></td></tr></table></figure>
<h2 id="9-测试与调试"><a href="#9-测试与调试" class="headerlink" title="9.测试与调试"></a>9.测试与调试</h2><p>Python语言没有编译期的静态类型检查机制，所以Python解释器无法确保程序一定能够正确运行。当然，在静态分析的过程中，可以选用类型注解帮助我们发现各种bug。</p>
<p>即便源代码里写着某个函数，你也未必能够保证，程序在需要调用这个函数的时候，它一定得到了定义。这种动态特征既有好处，又有风险。</p>
<p>程序正式发布之前，为什么不把它全面测试好呢？编译期的静态类型检查并不能完全确保程序必定能够正常运行。无论是用动态语言编程，还是用静态语言编程，我们都必须对写出来的代码做测试。</p>
<p>它与其他语言相比，更需要通过测试来确保代码准确无误。然而这也有好的地方：Python的动态机制虽然有风险，但若能适当加以运用，则可以帮助我们相当顺利地测试代码并调试程序。</p>
<h3 id="第75条、通过repr字符串输出调试信息"><a href="#第75条、通过repr字符串输出调试信息" class="headerlink" title="第75条、通过repr字符串输出调试信息"></a>第75条、通过repr字符串输出调试信息</h3><p>调试Python程序时，我们可以通过print函数与格式字符串，或者利用内置的logging模块，相当深入地观察程序的运行情况。Python的内部状态一般都可以通过普通的属性访问到。</p>
<p>print函数可以把开发者传给它的值显示成便于认读的那种字符串。例如，最简单的用法是直接把字符串传给它，这样就可以打印出不带引号的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'foo bar'</span>)</span><br></pre></td></tr></table></figure>
<p>这种写法跟下面几种写法是等效的：</p>
<ul>
<li>先把字符串传给str函数，然后把str函数返回的内容传给print；把字符串写在<code>%</code>操作符的右侧，让它替换操作符左侧那个格式字符串里的<code>&#39;%s&#39;</code>；把表示字符串值的那个变量，按照默认格式写在f-string中，交给print去打印；</li>
<li>调用内置的format函数；</li>
<li>明确调用<strong>format</strong>特殊方法；</li>
<li>明确调用<strong>str</strong>特殊方法。</li>
</ul>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_value = <span class="string">'foo bar'</span></span><br><span class="line">print(str(my_value))</span><br><span class="line">print(<span class="string">'%s'</span> % my_value)</span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;my_value&#125;</span>'</span>)</span><br><span class="line">print(format(my_value))</span><br><span class="line">print(my_value.__format__(<span class="string">'s'</span>))</span><br><span class="line">print(my_value.__str__())</span><br></pre></td></tr></table></figure>
<p>然而问题在于，用这种方式来打印，不太容易看清这个值究竟是什么类型以及它具体是由哪些部分组成的。例如，如果按照默认方式调用print函数，那么我们无法区分打印出来的这个5，到底是数字5，还是字符串’5’。</p>
<p>如果要用print调试程序，那么类型的区别就很重要。所以，我们需要打印的应该是对象的repr版本。这个版本可以通过内置的repr函数获得，该函数会返回对象的可打印表示形式（printable representation），这也是对象最为清晰且易于理解的表示形式。对于大多数内置类型来说，repr返回的字符串是个有效的Python表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'\x07'</span></span><br><span class="line">print(repr(a))</span><br></pre></td></tr></table></figure>
<p>把repr返回的值传给内置的eval函数，应该会得到一个跟原来相同的Python对象（当然，实际中eval函数的使用必须相当谨慎）。</p>
<p>用print调试程序的时候，应该先把要打印的值传给repr，然后将repr返回的内容传给print去打印，以明确体现出类型之间的差别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(repr(<span class="number">5</span>)); <span class="comment"># 5</span></span><br><span class="line">print(repr(<span class="string">'5'</span>)); <span class="comment"># '5'</span></span><br></pre></td></tr></table></figure>
<p>还有两种写法也能实现相同的效果，一种是把要打印的值放在<code>%</code>操作符的右边，让它替换左边的<code>&#39;%r&#39;</code>格式化字符串，另一种是在f-string中使用<code>!r</code>转换类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%r'</span> % <span class="number">5</span>)</span><br><span class="line">print(<span class="string">'%r'</span> % <span class="string">'5'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第76条、在TestCase子类里验证相关的行为"><a href="#第76条、在TestCase子类里验证相关的行为" class="headerlink" title="第76条、在TestCase子类里验证相关的行为"></a>第76条、在TestCase子类里验证相关的行为</h3><p>在Python中编写测试的最经典办法是使用内置的unittest模块。</p>
<p>为了定义测试用例，需要再创建一个文件，将其命名为test_utils.py或utils_test.py，命名方案可以根据你的风格来选。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilsTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bytes</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.assertEqual(<span class="string">'hello'</span>, to_str(<span class="string">b'hello'</span>))</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_str</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.assertEqual(<span class="string">'incorrect'</span>, to_str(<span class="string">'hello'</span>))</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>测试用例需要安排到TestCase的子类中。在这样的子类中，每个以test开头的方法都表示一项测试用例。如果test方法在运行过程中没有抛出任何异常（assert语句所触发的AssertionError也算异常），那么这项测试用例就是成功的，否则就是失败。其中一项测试用例失败，并不影响系统继续执行TestCase子类里的其他test方法，所以我们最后能够看到总的结果，知道其中有多少项测试用例成功，多少项失败，而不是只要遇到测试用例失败，就立刻停止整套测试。</p>
<p>我们还可以在test方法中指定断点，这样能够直接从此处激活调试器（debugger），以观察详细的出错原因。</p>
<p>TestCase类提供了一些辅助方法，可以在测试用例中做断言。例如，assertEqual方法可以确认两者是否相等，assertTrue可以确认Boolean表达式是否为True，此外还有很多以assert开头的方法（在Python解释器界面输入help(TestCase)，可以查看所有的方法）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assert_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssertTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_assert_helper</span><span class="params">(self)</span>:</span></span><br><span class="line">    expected = <span class="number">12</span></span><br><span class="line">    found = <span class="number">2</span> * <span class="number">5</span></span><br><span class="line">    self.assertEqual(expected, found)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_assert_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    expected = <span class="number">12</span></span><br><span class="line">    found = <span class="number">2</span> * <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> expected == found</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>TestCase还提供了assertRaises这样一个辅助方法，它可以当作情境管理器（context manager）用在with结构中），以验证该结构的主体部分是否会抛出应有的异常。这种写法跟try/except结构相似，可以很清楚地表示出受测代码应该抛出哪种异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils_error_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilsErrorTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bad</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">      to_str(object())</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bad_encoding</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.assertRaises(UnicodeDecodeError):</span><br><span class="line">      to_str(<span class="string">b'\xfa\xfa'</span>)</span><br><span class="line">  <span class="keyword">if</span> __main__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>如果测试用例需要使用比较复杂的逻辑，那么可以把这些逻辑定义成辅助方法放到TestCase子类里。但是必须注意，这种方法的名称不能以test开头，否则系统就会把它们当成测试用例来执行。在写辅助方法时，我们可能会用到TestCase类提供的各种assert方法，而且还经常会用fail方法来表示不应该出现的情况，也就是说，如果程序真的运行到了fail这里，那么意味着我们预设的某项前提条件没有得到满足。</p>
<p>TestCase类还提供了subTest辅助方法，可以让我们把相似的用例全都写在同一个test方法中，让它们成为这个用例中的子用例，这样的话，每个子用例所共用的那部分代码与逻辑只需要写一次就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data_driven_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataDrivenTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_good</span><span class="params">(self)</span>:</span></span><br><span class="line">    good_cases = [</span><br><span class="line">      (<span class="string">b'my bytes'</span>, <span class="string">'my bytes'</span>),</span><br><span class="line">      (<span class="string">'no error'</span>, <span class="string">b'no error'</span>), <span class="comment"># will fail</span></span><br><span class="line">      (<span class="string">'other str'</span>, <span class="string">'other str'</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> value, expected <span class="keyword">in</span> good_cases:</span><br><span class="line">      <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">        self.assertEqual(expected, to_str(value))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_bad</span><span class="params">(str)</span>:</span></span><br><span class="line">    bad_cases = [</span><br><span class="line">      (object(), TypeError),</span><br><span class="line">      (<span class="string">b'\xfa\xfa'</span>, UnicodeDecodeError),</span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> value, exception <span class="keyword">in</span> bad_cases:</span><br><span class="line">      <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(exception):</span><br><span class="line">          to_str(value)</span><br><span class="line">          </span><br><span class="line">  <span class="keyword">if</span> __main__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果项目比较复杂或者对测试的要求比较高，可以考虑用pytest这个开源软件包（<a href="https://pytest.org/）来测试，Python开发者给pytest制作了许多特别有用的插件。" target="_blank" rel="noopener">https://pytest.org/）来测试，Python开发者给pytest制作了许多特别有用的插件。</a></p>
</blockquote>
<h3 id="第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰"><a href="#第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰" class="headerlink" title="第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰"></a>第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰</h3><p>TestCase子类在执行其中的每个test方法之前，经常需要先把测试环境准备好，这套准备逻辑有时也叫测试装置或测试用具（test harness）。我们可以在TestCase子类中覆写setUp与tearDown方法，并把相应的准备逻辑与清理逻辑写在里面。系统在执行每个test方法之前都会先调用一遍setUp方法，并在执行完test方法之后调用一遍tearDown方法。这可以确保测试用例之间不会互相干扰，这一点，对测试工作至关重要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># environment_test.py</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentTest</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.test_dir = TemporaryDirectory()</span><br><span class="line">    self.test_path = Path(self.test_dir.name)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.test_dir.cleanup()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_modify_file</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(self.test_path / <span class="string">'data.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      <span class="comment">#...</span></span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>当程序变得复杂后，我们就不能只依赖这种彼此隔绝的单元测试了，而是需要再写一些测试，以验证模块与模块之间能否正确地交互（这可能要用到mock等工具）。这种测试叫集成测试（integration test），它跟前面的单元测试（unit test）不同。这两种测试在Python中很重要，假如不做集成测试，那就没办法确信这些模块能够协同运作。</p>
<p>对于集成测试来说，测试环境的准备与清理工作可能要占用大量计算资源，并持续比较长的时间。例如，可能要先启动数据库进程，并等待该进程把索引加载进来，然后才能开始做集成测试。这些工作的延迟很高，因此不能像做单元测试时那样，写在setUp与tearDown方法中。</p>
<h3 id="第78条、用Mock来模拟受测代码所依赖的复杂函数"><a href="#第78条、用Mock来模拟受测代码所依赖的复杂函数" class="headerlink" title="第78条、用Mock来模拟受测代码所依赖的复杂函数"></a>第78条、用Mock来模拟受测代码所依赖的复杂函数</h3><p>写测试的时候还有一个常见的问题，就是某些逻辑很难从开发环境里真实地执行，或者使用起来特别慢，这样的逻辑可以通过mock函数与Mock类来模拟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">form datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock</span><br><span class="line"></span><br><span class="line">mock = Mock(spec=get_animals)</span><br><span class="line">expected = [</span><br><span class="line">  (<span class="string">'Spot'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>)),</span><br><span class="line">  (<span class="string">'Fluffy'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">30</span>)),</span><br><span class="line">  (<span class="string">'Jojo'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">45</span>)),</span><br><span class="line">]</span><br><span class="line">mock.return_value = expected</span><br></pre></td></tr></table></figure>
<p>只要参数的取值不影响要测试的关键行为，那就可以在验证时通过ANY忽略这个参数。对于这些不太重要的参数，我们可以放宽一些，而不应该指定得太细，因为那样必须编写大量的验证代码。</p>
<p>Mock类还能够模拟调用时抛出异常的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">mock = Mock(spec=get_animals)</span><br><span class="line">mock.side_effect = MyError(<span class="string">'Whoops! Big problem'</span>)</span><br><span class="line">result = mock(database, <span class="string">'Meerkat'</span>)</span><br></pre></td></tr></table></figure>
<p>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</p>
<h3 id="第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试"><a href="#第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试" class="headerlink" title="第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试"></a>第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试</h3><p>通过Mock类实现，另一个是通过patch方法实现。可是，这两种方案都要求我们在测试的过程中重复编写很多例行代码，这会让初次阅读代码的人很难理解我们究竟要验证什么。</p>
<p>有一种办法可以改进代码，就是把受测函数所要使用的数据库接口封装起来，这样我们就不用像原来那样，专门把数据库连接（DatabaseConnection）当作参数传给受测函数了，而是可以将封装好的系统传过去。</p>
<p>Python内置的unittest.mock模块里有个Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的属性。如果想把程序完整地测一遍，那么可以重构代码，在原来直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</p>
<h3 id="第80条、考虑用pdb做交互调试"><a href="#第80条、考虑用pdb做交互调试" class="headerlink" title="第80条、考虑用pdb做交互调试"></a>第80条、考虑用pdb做交互调试</h3><p>Python内置的交互调试器（interactive debugger）就是这样一种工具，它可以检查程序状态，打印局部变量的值，还可以每次只执行一条Python语句（也就是单步执行）。</p>
<p>在其他大部分编程语言中，如果要使用调试器，那么必须先在源文件中指定断点，令程序在执行到这一行时停下来。然而Python不用这样，你可以直接在认为有问题的那行代码前加入一条指令，让程序暂停，并启动调试器，这是最简单的办法。采用这种办法来调试程序，与正常启动程序并没有什么区别。</p>
<p>用来触发调试器的指令就是Python内置的breakpoint函数。这个函数的效果与先引入内置的pdb模块然后运行set_trace函数的效果是一样的。</p>
<p>一旦运行breakpoint函数，程序会在即将执行下一条语句的地方暂停。</p>
<p>在（Pdb）提示符界面，我们可以输入局部变量的名称（或执行<code>p &lt;name&gt;命令</code>）来查看变量的取值，也可以调用Python内置的locals函数以观察所有的局部变量，还可以引入模块，检查全局状态，构造新的对象，或运行内置的help命令，甚至还能修改正在运行的程序里的某些部分，总之，对调试工作有帮助的操作都可以在这里执行。</p>
<p>另外，调试器还提供了各种特殊命令，帮我们控制程序的执行方式，并探查其执行情况。在调试界面输入help，可以看到完整的命令列表。通过下面这三条非常实用的命令，我们可以很方便地检查正在运行的这个程序：</p>
<ul>
<li><code>where</code>：打印出当前的执行调用栈（execution call stack），可以据此判断程序当前执行到了哪个位置，以及程序是在调用了哪些函数后才触发breakpoint断点的。</li>
<li><code>up</code>：把观察点沿着执行调用栈上移一层，回到当前函数调用者处，以观察位于当前断点之上的那些层面分别有什么样的局部变量。</li>
<li><code>down</code>：把观察点沿着执行调用栈下移一层。</li>
</ul>
<p>检查完程序的运行状态后，可以通过下面这五条命令决定程序接下来应该如何执行：</p>
<ul>
<li><code>step</code>：执行程序里的下一行代码，并在执行完毕后把控制权交还给调试器。如果下一行代码带有函数调用操作，那么调试器就会停在受调用的那个函数开头。</li>
<li><code>next</code>：执行当前函数的下一行代码，并在执行完毕后，返回交互调试界面。如果下一行代码带有函数调用操作，系统不会令调试器停在受调用的函数开头。</li>
<li><code>return</code>：让程序一直运行到当前函数返回为止，然后把控制权交还给调试器。</li>
<li><code>continue</code>：让程序运行到下一个断点处（那个断点可以是通过breakpoint触发的，也可以是在调试界面里设置的）。</li>
<li><code>quit</code>：退出调试界面，并且让接受调试的程序也随之终止。如果已经找到了问题，那么就可以用这个命令结束调试。如果发现寻找的方向不对，或者需要先去修改程序的代码，那么也应该运行这个命令以便重新调试。</li>
</ul>
<p>breakpoint函数可以出现在程序里的任何地方。</p>
<p>调试器还支持一项有用的功能，叫作事后调试（post-mortem debugging），当我们发现程序会抛出异常并崩溃后，想通过调试器看看它在抛出异常的那一刻，究竟是什么样子的。有时我们也不确定应该在哪里调用breakpoint函数，在这种情况下，尤其需要这项功能。</p>
<p>于是，我们用<code>python3 -m pdb -c continue &lt;program path&gt;</code>命令把这个有问题的程序放在pdb模块的控制下运行，其中<code>-c</code>选项里的continue命令会让pdb在启动受测程序之后立刻向前推进，直至遇到断点或出现异常为止。</p>
<p>还有一种办法也能触发事后调试机制，就是先在普通的Python解释器里执行受测代码，待遇到未被捕获的异常后，再引入pdb模块并调用其pm函数（通常把引入pdb模块与调用pm函数这两项操作合起来写成<code>import pdb; pdb.pm()</code>）。</p>
<h3 id="第81条、用tracemalloc来掌握内存的使用与泄漏情况"><a href="#第81条、用tracemalloc来掌握内存的使用与泄漏情况" class="headerlink" title="第81条、用tracemalloc来掌握内存的使用与泄漏情况"></a>第81条、用tracemalloc来掌握内存的使用与泄漏情况</h3><p>在Python的默认实现方式（也就是CPython）中，内存管理是通过引用计数（reference counting）执行的。如果指向某个对象的引用已经全部过期，那么受引用的对象就可以从内存中清除，从而给其他数据腾出空间。另外，CPython还内置了循环检测器（cycle detector），确保那些自我引用的对象也能够得到清除。</p>
<p>从理论上讲，这意味着Python开发者不用担心程序如何分配并释放内存的问题，因为Python系统本身以及CPython运行时环境会自动处理这些问题。但实际上，还是会有程序因为没有及时释放不再需要引用的数据而耗尽内存。想了解Python程序使用内存的情况，或找到泄漏内存的原因，是比较困难的。</p>
<p>第一种调试内存使用状况的办法，是用Python内置的gc模块把垃圾回收器目前知道的每个对象都列出来。虽然这样有点儿笨，但毕竟可以让我们迅速得知程序的内存使用状况。</p>
<p>gc.get_objects函数的缺点在于，它并没有指出这些对象究竟要如何分配。复杂的程序中，同一个类的对象可能是因为好几种不同的原因而为系统所分配的。知道对象的总数固然有意义，但更为重要的是找到分配这些对象的具体代码，这样才能查清内存泄漏的原因。</p>
<p>Python 3.4版本推出了一个新的内置模块，名为tracemalloc，它可以解决刚才讲的那个问题。tracemalloc能够追溯对象到分配它的位置，因此我们可以在执行受测模块之前与执行完毕之后，分别给内存使用情况做快照，并对比两份快照，以了解它们之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line">tracemalloc.start(<span class="number">10</span>)</span><br><span class="line">time1 = tracemalloc.take_snapshot()</span><br></pre></td></tr></table></figure>
<p>每一条记录都有size与count指标，用来表示这行代码所分配的对象总共占用多少内存以及这些对象的数量。通过这两项指标，我们很快就能发现占用内存较多的对象是由哪几行代码所分配的。tracemalloc模块还可以打印完整的栈追踪信息（当然了，这最多只能达到调用tracemalloc.start函数时设置的帧数）。</p>
<p>这样的栈追踪信息很有用处，因为它能帮我们找到程序中累计分配内存最多的函数或类。</p>
<hr>
<h2 id="10-协作开发"><a href="#10-协作开发" class="headerlink" title="10.协作开发"></a>10.协作开发</h2><p>要想与其他人一起开发Python程序，你必须仔细留意自己编写代码的方式。</p>
<h3 id="第82条、学会寻找由其他Python开发者所构建的模块"><a href="#第82条、学会寻找由其他Python开发者所构建的模块" class="headerlink" title="第82条、学会寻找由其他Python开发者所构建的模块"></a>第82条、学会寻找由其他Python开发者所构建的模块</h3><p>Python有个集中存放模块的地方，叫作Python Package Index（PyPI，网址为<a href="https://pypi.org），你可以从中安装模块，并在自己的程序里面使用。这些模块都是由Python开发者所构建并维护的，这些开发者合称Python社群。如果你面对一项自己不太熟悉的需求，那么可以去PyPI搜索一下，看看有没有哪个软件包能够帮你更快地实现目标。" target="_blank" rel="noopener">https://pypi.org），你可以从中安装模块，并在自己的程序里面使用。这些模块都是由Python开发者所构建并维护的，这些开发者合称Python社群。如果你面对一项自己不太熟悉的需求，那么可以去PyPI搜索一下，看看有没有哪个软件包能够帮你更快地实现目标。</a></p>
<p>要从PyPI安装软件包，可以在命令行界面执行pip命令（这是个递归的首字母缩略词，指<code>pip installs packages</code>）。</p>
<p>pip最好与内置的venv模块搭配使用，这样可以给不同的项目分别安装不同版本的软件包，以适应每个项目自身的要求。你可以自己创建软件包并发布到PyPI与其他开发者共享，或搭建私人的软件包仓库，让pip改从这里安装模块。</p>
<h3 id="第83条、用虚拟环境隔离项目，并重建依赖关系"><a href="#第83条、用虚拟环境隔离项目，并重建依赖关系" class="headerlink" title="第83条、用虚拟环境隔离项目，并重建依赖关系"></a>第83条、用虚拟环境隔离项目，并重建依赖关系</h3><p>程序变得比较大、比较复杂后，可能需要依赖更多的第三方Python包，那时我们可以通过python3 -m pip命令安装pytz、numpy以及其他许多模块。</p>
<p>问题在于，pip会把新的软件包默认安装到全局路径之中，这样会让涉及该模块的每一个Python程序都受到影响。有些人可能觉得这不会有什么问题：如果只安装模块，而不在Python程序里面直接引入它，那这个程序就不会受模块的影响了吧？</p>
<p>其实问题出现在间接的依赖关系上面，也就是说，直接引入的虽然不是这个模块，但你引入的其他模块却必须依赖这个模块才能运作。例如，如果你打算直接引入Sphinx模块，那就用pip install命令安装该模块，安装好之后，可以通过pipshow查看它的依赖关系。</p>
<p>同一个模块在Python的全局环境中只能存在一个版本。如果某个软件包需要使用新版模块，而另一个软件包需要使用旧版模块，那么就会遇到两难的局面：不论这个模块是否升级，这两个软件包都会有一个无法运作。这种情况通常称为dependency hell。</p>
<p>上面提到的种种问题都可以通过venv工具解决。这个工具能够创建虚拟环境（virtual environment）。从Python 3.4开始，pip与venv模块会在安装Python时一起默认安装。</p>
<p>venv可以创建彼此隔绝的Python环境，我们能够把同一个软件包的不同版本分别安装到不同的环境里面，这样就不会产生冲突了。这意味着能够在同一台电脑上面给不同的项目创建各自的环境，并在里面安装它们所需要的软件包版本。为了达到这样的效果，venv工具会把这些软件包以及它们所依赖的其他软件包都专门安装到单独的目录结构里面，使得多个环境之间不会发生冲突。这种机制，也让我们可以把项目所要求的环境在其他电脑上面重新建立起来，令程序能够可靠地运行，而不会出现意外的问题。</p>
<p>用python3 -m pip list列出这套虚拟环境之中安装的软件包，可以看到，这些软件包与前一套环境所安装的相同。</p>
<p>用版本控制系统（revision control system）与他人协作时，这样一份requirements.txt文件是很有用处的，因为你在提交代码的同时，可以把新版代码所依赖的软件包通过该文件一起提交上去，这样能够确保代码与代码所依赖的软件包总是可以同步更新。然而，有一个问题必须注意，那就是Python本身的版本并不包含在requirements.txt之中，所以必须单独管理。</p>
<p>虚拟环境有个很容易出错的地方，就是不能直接把它移动到其他路径下面，因为它里面的一些命令（例如python3）所指向的位置都是固定写好的，其中用到了这套环境的安装路径，假如移动到别处，那么这些路径就会失效。然而，这其实并不算大问题，因为我们创建虚拟环境，不是想要移动它，而是想把它的配置记录下来，以便在其他环境里面重建。所以我们要做的，仅仅是用<code>python3 -m pip freeze</code>命令把旧环境依赖的软件包保存到requirements.txt文件之中，然后在新环境里面，根据这份文件重新安装这些软件包。</p>
<h3 id="第84条、每一个函数、类与模块都要写docstring"><a href="#第84条、每一个函数、类与模块都要写docstring" class="headerlink" title="第84条、每一个函数、类与模块都要写docstring"></a>第84条、每一个函数、类与模块都要写docstring</h3><p>Python是动态语言，因此文档特别重要。Python内建了相关的机制，支持给代码块编写文档，而且与其他一些编程语言不同，Python允许我们在程序运行的过程中，直接访问这些文档。</p>
<p>例如，我们可以紧跟着函数的定义（def）语句，书写一条docstring作为这个函数的文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome</span><span class="params">(word)</span>:</span></span><br><span class="line">  <span class="string">"""Return True if the given word is a palindrome."""</span></span><br><span class="line">  <span class="keyword">return</span> word == word[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> palindrome(<span class="string">'tacocat'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> palindrome(<span class="string">'banana'</span>)</span><br></pre></td></tr></table></figure>
<p>函数的docstring可以在运行Python程序的过程中通过<strong>doc</strong>这个特殊的属性访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(repr(palindrome.__doc__))</span><br></pre></td></tr></table></figure>
<p>另外，还可以在命令行界面中，利用内置的pydoc模块在本机上启动web服务器，这台服务器能够提供当前Python解释器所能访问到的全部文档，也包括你自己编写的那些模块。</p>
<p>docstring可以关联到函数、类与模块上面，系统在编译并运行Python程序的过程中，会把确定这种关联的关系也当成工作的一部分。由于Python支持docstring并允许程序通过<strong>doc</strong>属性来访问docstring，我们会享受到以下三个好处：</p>
<ul>
<li>开发者能够在程序中访问文档信息，这会让交互式开发工作变得更加轻松。</li>
<li>这些文档是按照标准的方式定义的，因此很容易就能转换成表现力更强的格式（例如HTML）。</li>
<li>Python文档不仅可以做得很漂亮，而且与其他普通的头等Python实体一样，也能够在程序里面正常地访问，这会让开发者更乐意编写这样的文档。</li>
</ul>
<p>如果你也想像大家一样把文档写好，那就需要遵循一些与docstring有关的约定。完整的规范，可以查看PEP 257（<a href="https://www.python.org/dev/peps/pep-0257/），接下来我们重点讲述其中必须注意的几个方面。" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0257/），接下来我们重点讲述其中必须注意的几个方面。</a></p>
<h4 id="为模块编写文档"><a href="#为模块编写文档" class="headerlink" title="为模块编写文档"></a>为模块编写文档</h4><p>每个模块都要有顶级的docstring，即写在源文件开头的那个字符串。字符串的首尾都要带三重引号，这样的字符串的目的主要是介绍本模块与其中的内容。</p>
<p>在docstring里面，第一行应是一个单句，描述本模块的用途。接下来应该另起一段，详解讲述使用这个模块的用户所要知道的一些事项。另外，凡是模块里面比较重要的类与函数，都应该在docstring中予以强调，这样的话，查看这份文档的用户就可以从这些类及函数出发来熟悉模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># words.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Library for finding linguistic patterns in words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Testing how words relate to each other can be tricky sometimes!</span></span><br><span class="line"><span class="string">This module provides easy ways to determine when words you've found have special properties.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available functions:</span></span><br><span class="line"><span class="string">- palindrome: Determine if a word is a palindrome.</span></span><br><span class="line"><span class="string">- check_anagram: Determine if two words are anagrams.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>如果这个模块表示的是一个可以在命令行界面使用的工具，那么模块的docstring里面，还应该写出相关的信息并介绍该工具的用法。</p>
<h4 id="为类编写文档"><a href="#为类编写文档" class="headerlink" title="为类编写文档"></a>为类编写文档</h4><p>每个类都应该有类级别的docstring，这种文档的写法，与模块级别的docstring差不多。它的第一段，也需要用一句话来概述整个类的用途。后面的各段，可以详细讲解本类中的每一种操作。</p>
<p>类中比较重要的public属性与方法，同样应该在类级别的docstring里面加以强调。另外还需要说明，如果想编写子类，子类应该怎样与受保护的属性以及超类中的方法相交互。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>:</span></span><br><span class="line">  <span class="string">"""Represents a player of the game.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Subclasses may override the 'tick' method to provide custom animations for the player's movement depending on their power level, etc.</span></span><br><span class="line"><span class="string">  Public attributes:</span></span><br><span class="line"><span class="string">  - power: Unused power-ups(float between 0 and 1).</span></span><br><span class="line"><span class="string">  - coins: Coins found during the level(integer).</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure>
<h4 id="为函数编写文档"><a href="#为函数编写文档" class="headerlink" title="为函数编写文档"></a>为函数编写文档</h4><p>每个public函数与方法都应该有docstring。它的写法与模块和类的相同，第一段也是一个句子，描述这个函数是做什么的。接下来的那段应该描述函数的行为。然后，可以各用一段来描述函数的参数与返回值。另外，如果调用者在使用这个函数接口的时候，需要处理该函数所抛出的一些异常，那么这些异常也要解释。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word, dictionary)</span>:</span></span><br><span class="line">  <span class="string">"""Find all anagrams for a word.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  This function only runs as fast as the test for membership in the 'dictionary' container.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  	words: String of the target word.</span></span><br><span class="line"><span class="string">  	dictionary: collections.abc.Container with all strings that are known to be actual words.</span></span><br><span class="line"><span class="string">  	</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  	List of anagrams that were found. Empty if</span></span><br><span class="line"><span class="string">  	none were found.</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure>
<p>编写docstring的时候，需要注意下面几种特殊的情况：</p>
<ul>
<li>如果函数没有参数，而且返回的是个比较简单的值，那么就不用按照上面讲的那种格式分段书写了。直接用一句话来描述整个函数可能会更好。</li>
<li>如果函数没有返回值，那么最好是把描述返回值的那段完全省去，而不要专门写出返回None。</li>
<li>如果函数所抛出的异常也是接口的一部分，那么应该在docstring里面详细解释每一种异常的含义，并说明函数在什么场合会抛出这样的异常。</li>
<li>如果函数在正常使用的过程中，不会抛出异常，那么无须专门指出这一点。</li>
<li>如果函数可以接受数量可变的位置参数或关键字参数，那么应该在解释参数的那一部分用<code>*args</code>与<code>**kwargs</code>来说明这两种参数的用途。</li>
<li>如果参数有默认值，那么文档里应该提到这些默认值。</li>
<li>如果函数是个生成器，那么应该在docstring里面写明这个生成器在迭代过程中会产生什么样的值。</li>
<li>如果函数是异步协程，那么应该在docstring里面解释这个协程执行到何时会暂停。</li>
</ul>
<h4 id="用类型注解来简化docstring"><a href="#用类型注解来简化docstring" class="headerlink" title="用类型注解来简化docstring"></a>用类型注解来简化docstring</h4><p>Python现在已经支持类型注解了，这种注解有许多用途，其中一项就是简化docstring，因为原本写在docstring里面的某些含义，现在可以直接通过类型注解体现出来。下面，我们给find_anagrams函数的签名加上类型注解，以指出参数与返回值的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Container, List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word: str,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dictionary: Container[str])</span> -&gt; List[str]:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>有了这样的注解，我们就不用专门在docstring里面说明word参数是字符串了，因为现在的word参数后面有个冒号，冒号右侧标出了它的类型，即str。dictionary参数也一样，它的类型现在明确地标注成了collections.abc.Container。另外，返回值同样不用专门在docstring里面解释，因为声明函数时，已经在-&gt;符号右侧明确说明该函数会返回一份列表。这也意味着即便找不到与word参数的组成字母相同但排列顺序不同的词（或者说，找不到word参数的同字母异序词（anagram）），函数也依然要返回列表，当然这种情况下返回的列表是一份空白的列表，所以不用在docstring里面专门说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word: str,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dictionary: Container[str])</span> -&gt; List[str]:</span></span><br><span class="line">  <span class="string">"""Find all anagrams for word.</span></span><br><span class="line"><span class="string">  This function only runs as fast as the test for</span></span><br><span class="line"><span class="string">  membership in the 'dictionary' container.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  	word: Target word.</span></span><br><span class="line"><span class="string">  	dictionary: All known actual words.</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  	Anagrams that were found.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>类型注解与docstring之间的这种重复现象，也会出现在实例字段、类属性与方法中。这样的类型信息最好是只写在一个地方，而不要同时写在类型注解与docstring中，因为在修改实现代码时，可能会忘记更新其中的某一处。</p>
<h3 id="第85条、用包来安排模块，以提供稳固的API"><a href="#第85条、用包来安排模块，以提供稳固的API" class="headerlink" title="第85条、用包来安排模块，以提供稳固的API"></a>第85条、用包来安排模块，以提供稳固的API</h3><p>项目代码变多之后，我们自然需要重新调整它的结构。可能要把大函数拆成许多个小的函数，或者通过辅助类改写某个数据结构，还有可能要把各项功能分散到多个相互依赖的模块里面。</p>
<p>到了一定阶段，你就会发现模块也变得多了起来，所以还得再构建一层机制以便于管理。在Python中，这可以通过包（package）来实现，包本身也是一种模块，只不过它里面还含有其他模块。</p>
<p>大多数情况下，把名为<strong>init</strong>.py的空白文件放在某个目录中，即可令该目录成为一个包。一旦有了<strong>init</strong>.py文件，我们就可以使用相对于该目录的路径引入包中的其他py文件了。例如，现在目录结构是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.py</span><br><span class="line">mypackage/__init__.py</span><br><span class="line">mypackage/models.py</span><br><span class="line">mypackage/utils.py</span><br></pre></td></tr></table></figure>
<p>如果想在main.py里面引入utils模块，那么可以把包名（也就是mypackage）写在from后面，并把其中的模块名写在import后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> utils</span><br></pre></td></tr></table></figure>
<p>如果有些包本身位于更大的包之中，那么就把从大包到这个包之间的各层都用圆点连起来。例如，要引入bar包中的某个模块，而bar包又位于mypackage包的foo目录之下，那么就写为<code>from mypackage.foo.bar import ...</code>。包在Python程序里主要有两种用途。</p>
<h4 id="用包划分名称空间"><a href="#用包划分名称空间" class="headerlink" title="用包划分名称空间"></a>用包划分名称空间</h4><p>包的一个用途是帮助把模块安排到不同的名称空间（namespace）里面，这样的话，即便两个模块所在的文件同名，也依然能够加以区分，因为它们所在的名称空间不同。例如，下面这个程序要从两个模块里面分别引入一个属性（本例实际引入一个函数），虽然这两个模块所在的文件都叫utils.py，但我们还是可以通过模块所属的包来区分它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> log_base2_bucket</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> stringify</span><br><span class="line"></span><br><span class="line">bucket = stringify(log_base2_bucket(<span class="number">33</span>))</span><br></pre></td></tr></table></figure>
<p>这种写法有个问题，如果两个包里有同名的模块，或者两个模块里有同名的函数或类，那么后引入的那个会把先引入的覆盖掉。例如，假设analysis.utils与frontend.utils模块里都有函数叫作inspect，那么就没办法通过刚才那种写法来同时使用这两个函数了，因为第二条import语句会把第一条所引入的那个inspect覆盖掉，导致当前范围内只存在一个inspect。</p>
<p>解决办法是给import语句加上as子句，这样就能把两个inspect函数分别用不同的名称引入到当前的范围里面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> analysis_inspect</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> frontend_inspect</span><br></pre></td></tr></table></figure>
<p>as子句不仅可以给函数起别名，而且能把整个模块都换个名称，这让我们可以清晰地区分各种命名空间里面的同名实体。</p>
<p>另外一种办法是从能够区分它们的那一层开始书写访问名称。例如，可以把<code>from... import ...</code>形式的引入语句改成<code>import ...</code>形式，并且用analysis.utils.inspect与frontend. utils.inspect来区分这两个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> analysis.utils</span><br><span class="line"><span class="keyword">import</span> frontend.utils</span><br></pre></td></tr></table></figure>
<p>这种写法完全不需要使用as子句，而且由于它采用的名字比较全，初次读到这段代码的读者也可以清楚地了解到这两个inspect函数分别是在哪个包的哪个模块里面定义的。</p>
<h4 id="通过包来构建稳固的API"><a href="#通过包来构建稳固的API" class="headerlink" title="通过包来构建稳固的API"></a>通过包来构建稳固的API</h4><p>包的第二个用途是构建严谨而稳固的API，以便给外部的开发者使用。</p>
<p>如果这套API要提供给很多人使用，例如要做成开源的软件包，那么你可能想把它的功能稳定下来，以免新旧版本之间差得太大。为了做到这一点，必须隐藏软件包内部的代码结构，不要让外部的开发者依赖这套结构，只有这样，你才能重构并改善这些内部模块，而不必担心自己所做的修改会影响外部用户已经写好的那些代码。</p>
<p>Python允许我们通过<strong>all</strong>这个特殊的属性，决定模块或包里面有哪些内容应该当作API公布给外界。<strong>all</strong>的值是一份列表，用来描述可作为public API导出的所有内容名称。如果执行from foo import *这样的语句，那么只有<strong>all</strong>所列出名称的属性才会引入进来。若是foo里面没有<strong>all</strong>，那么就只会引入public属性。</p>
<p>谨慎地使用import<em>形式的引入语句。from x import y这种形式的引入语句，是很清晰的，因为它明确指出了y来自x包或x模块。引入语句还有一种写法，就是带有通配符的from foo import </em>形式，这种引入语句也很有用，尤其是在交互式的Python界面之中。然而大家必须注意，这样写会造成两方面的困难：</p>
<ul>
<li>用from … import <em>的形式引入，会让初次读到这段代码的读者弄不清某些名称究竟来自哪里。如果模块里有许多条这样的import </em>语句，那我们可能必须把受引用的模块全都查找一遍，才能确定某个名字到底是从哪个模块引入的。</li>
<li>import *形式的引入语句，会把已经引入本模块的同名实体覆盖掉，从而导致奇怪的bug，因为同一个名称，在执行这条语句之前，与执行这条语句之后，可能指向两个不同的地方。</li>
</ul>
<p>最稳妥的做法是不要采用import *的形式引入，而是通过from x import y明确指出名称y来自模块x。</p>
<p>如果不想让外界看到某些内容，那么可以在包目录中的<strong>init</strong>.py文件里面故意不引入这些内容，或者给这些只供本包内部使用的内容名称前面添加下划线。</p>
<p>假如这个包只在某个团队或某个项目内部使用，那恐怕就没必要专门通过<strong>all</strong>来指定外界能够访问到的API了。</p>
<h3 id="第86条、考虑用模块级别的代码配置不同的部署环境"><a href="#第86条、考虑用模块级别的代码配置不同的部署环境" class="headerlink" title="第86条、考虑用模块级别的代码配置不同的部署环境"></a>第86条、考虑用模块级别的代码配置不同的部署环境</h3><p>部署环境指的是程序运行在什么样的配置之下。每个程序至少要有一套部署环境，也就是生产环境（production environment）。我们之所以写程序，就是想让它能够在生产环境里面正常运行并产生预期的结果。</p>
<p>另外，我们可能还需要构建一套环境，可以方便地编写或修改程序代码，这套环境叫作开发环境（development environment），它的配置方式可能与生产环境有很大区别。例如，我们的程序可能是在单片机中开发的，但是却打算放在巨型的超级计算机上面运行。</p>
<p>venv这样的工具可以确保所有的环境里面安装的都是同一套Python软件包（参见第83条）。但是问题在于，软件在生产环境中运行的时候，通常需要依赖许多外部条件，而那些条件不太容易在开发环境里面重现。</p>
<p>要想解决这个问题，最好的办法是让程序在启动时，能够根据当前环境决定其中某些资源应该如何配置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TESTING = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> db_connection</span><br><span class="line"></span><br><span class="line">db = db_connection.Database()</span><br></pre></td></tr></table></figure>
<p>这两份文件只有一个地方不同，也就是TESTING常量的取值。程序中的其他模块可以引入<strong>main</strong>模块，并根据TESTING的值决定如何配置自己的某些属性。</p>
<p>如果环境配置起来特别复杂，那就不要使用TESTING这样单纯的Python常量，而是可以考虑构建专门的配置文件，并通过Python内置的configparser模块等解析工具来处理这种文件，把它们与程序代码分开维护。在与运维团队合作的时候，这一点尤其重要。</p>
<p>模块级别的代码不仅可以模拟外部资源，而且还有其他用途。</p>
<p>我们还可以通过os.environ查询环境变量，从而决定模块中的相关内容应该如何定义。</p>
<h3 id="第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"><a href="#第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常" class="headerlink" title="第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"></a>第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h3><p>给模块定义API时，要定义的不仅是其中的函数与类，而且还必须注意这些函数会不会抛出异常，因为这些异常实际上也接口的一部分。</p>
<p>Python语言及标准库本身有自己的异常体系，所以在开发程序的时候，开发者喜欢沿用这些内置的异常类型来报告其中的错误，而不想定义新的类型。</p>
<p>给模块定义根异常，可以让使用这个模块的API用户将他们自己的代码与这个模块所提供的API隔开，以便分别处理其中的错误。</p>
<p>API用户在处理完API所属模块有可能抛出的具体异常后，可以写一个针对模块根异常的except块，如果程序进入这个块，那就说明他使用API的方式可能有问题，例如可能忘记处理某种本来应该处理的具体异常。</p>
<p>API用户还可以再写一个except块以捕获整个Python体系之中的根异常，如果程序进入了那个块，那说明所调用的API可能实现得有问题。在模块的根异常下，可以设立几个门类，让具体的异常不要直接继承总的根异常，而是继承各自门类中那个分根异常，这样的话，使用这个模块的开发者，就可以只关注这几个门类，即便你修改了某个门类之下的具体异常，也不会影响到他们已经写好的那些代码。</p>
<h3 id="第88条、用适当的方式打破循环依赖关系"><a href="#第88条、用适当的方式打破循环依赖关系" class="headerlink" title="第88条、用适当的方式打破循环依赖关系"></a>第88条、用适当的方式打破循环依赖关系</h3><p>在引入模块的时候，Python系统会按照深度优先的顺序，对模块执行以下五步：</p>
<ul>
<li>1）在sys.path里面寻找模块的位置。</li>
<li>2）把模块的代码加载进来，并确认这些代码能够编译。</li>
<li>3）创建相应的空白模块对象表示该模块。</li>
<li>4）把这个模块插入sys.modules字典。</li>
<li>5）运行模块对象之中的代码定义该模块的内容。</li>
</ul>
<p>循环依赖之所以会出错，原因在于，执行完第4步之后，这个模块已经位于sys.modules之中了，然而它的内容这个时候可能还没有得到定义，要等到执行完第5步，才能齐备。可是，Python系统在执行import语句的时候，如果发现要引入的模块已经出现在了sys.modules里面（也就是说，那个模块已经执行完了前4步），那么就会继续执行import的下一条语句，而不会顾及模块之中的内容是否得到了定义。</p>
<p>要解决这种问题，最好的办法是重构代码，把prefs数据结构放在依赖体系的最底层，把它单独放在一个工具模块里面，app与dialog模块就可以分别引入这个工具模块，而不用像原来那样，彼此依赖对方。予以划分，有时必须重构大量的代码，才能解开两个模块之间的相互依赖关系，让它们都去依赖第三个模块。</p>
<p>除了这种解法之外，还有三个办法，也能够解除循环依赖关系。</p>
<ul>
<li>第一个办法是，调整import语句的位置。调整import语句的位置，可能会让代码变得容易出错，因为有时只要稍微改动这条import语句的位置，整个模块就没办法使用了。</li>
<li>把模块划分成引入-配置-运行这样三个环节。循环引入问题的第二个解决办法是，尽量缩减引入时所要执行的操作。我们可以让模块只把函数、类与常量定义出来，而不真的去执行操作，这样的话，Python程序在引入本模块的时候，就不会由于操作其他模块而出错了。我们可以把本模块里面，需要用到其他模块的那种操作放在configure函数中，等到本模块彻底引入完毕后，再去调用。configure函数会访问其他模块中的相关属性，以便将本模块的状态配置好。这个函数是在该模块与它所要使用的那个模块都已经彻底引入后才调用的（也就是说，这两个模块都把各自的第5步执行完了），因此，其中涉及的所有属性全都定义过了。</li>
<li>动态引入。第三个办法比前两个都简单，也就是把import语句从模块级别下移到函数或方法里面，这样就可以解除循环依赖关系了。这种import语句并不会在程序启动并初始化本模块时执行，而是等到相关函数真正运行的时候才得以触发，因此又叫作动态引入（dynamic import）。</li>
</ul>
<p>当然了，一般来说，还是应该尽量避免动态引入，因为import语句毕竟是有开销的，如果它出现在需要频繁执行的循环体里面，那么这种开销会更大。另外，由于动态引入会推迟代码的执行时机，有可能让你的程序在启动了很久之后，突然因为在动态引入其他模块的过程中发生SyntaxError等错误而崩溃（如何避免此类问题）。动态引入虽然有这些缺点，但总比那种大幅度修改整个程序结构的办法好。</p>
<h3 id="第89条、重构时考虑通过warnings提醒开发者API已经发生变化"><a href="#第89条、重构时考虑通过warnings提醒开发者API已经发生变化" class="headerlink" title="第89条、重构时考虑通过warnings提醒开发者API已经发生变化"></a>第89条、重构时考虑通过warnings提醒开发者API已经发生变化</h3><p>我们经常需要更新API，以实现早前没有预料到的新需求。如果API很小，而且与上游及下游之间的依赖关系也不复杂，那么修改起来就比较简单。在这种情况下，只需要某位开发者把API本身与调用这些API的代码都改好，一起提交到代码库即可。</p>
<p>代码库变大之后，调用这个API的地方也会变多，而且可能来自好几个项目，所以在修改API的时候，不太容易保证那些地方也能够同步更新。我们必须想办法通知写那些代码的合作者这个API的用法已经变了，让他们尽快重构代码以适配新版的API。</p>
<p>warnings模块让我们以编程的手段提醒其他开发者注意：代码所依赖的底层库已经发生变化，请尽快做出相应修改。warnings模块发出的是警告，而不是那种带有Error字样的异常（exception），异常主要针对计算机而言，目标是让程序能够自动处理相关的错误，而警告则是写给开发者的，目标是与他们沟通，告诉对方应该如何正确地使用这个API。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning.warn(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure>
<p>warnings.warn函数提供了一个名为stacklevel的参数，让我们可以根据栈的深度指出真正触发这条警告的那个位置，而不是调用warnings.warn函数的字面位置。</p>
<p>负责这段代码的开发者，如果已经意识到自己应该按照新的方式来使用你所提供的API，那么他就可以通过warnings模块的simplefilter与filterwarnings函数暂时忽略警告（详细的用法，参见<a href="https://docs.python.org/3/library/warnings）。" target="_blank" rel="noopener">https://docs.python.org/3/library/warnings）。</a></p>
<p>程序部署到生产环境之后，就没有必要让警告变成错误了，因为那样可能导致程序在关键时刻崩溃。比较好的办法是，通过Python内置的logging模块将警告信息重新定向到日志系统。</p>
<p>如果你设计的API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</p>
<h3 id="第90条、考虑通过typing做静态分析，以消除bug"><a href="#第90条、考虑通过typing做静态分析，以消除bug" class="headerlink" title="第90条、考虑通过typing做静态分析，以消除bug"></a>第90条、考虑通过typing做静态分析，以消除bug</h3><p>只有文档可能还不够，有时我们还是会把API用错，导致程序出现bug。所以，最好能有一套机制来验证调用者使用API的方式是否正确，如果我们把自己的API发布出去，那么这套机制还能帮助其他开发者检查他们的代码有没有恰当地使用这套API。许多编程语言通过编译期的类型检查来实现这种验证，这确实能够消除某些bug。</p>
<p>Python以前主要关注的是动态特性，所以没有提供编译期的类型安全机制。但是最近，Python开始引入一套特殊的写法，让我们可以通过内置的typing模块给变量、类中的字段、函数及方法添加类型信息。这些类型提示（type hint）信息可以实现渐进的类型判定机制（gradual typing），让我们在开发项目的过程中，把能够在编译期明确指定类型的地方逐渐确定下来。</p>
<p>给Python程序的代码添加类型信息之后，我们就可以运行静态分析（staticanalysis）工具，分析这些代码里面是否存在极有可能出现bug的地方。Python内置的typing模块本身并不实现类型检查功能，它只是一套可以公开使用的代码库，其中定义了相关的类型（也包括泛型类型），我们可以用这些类型来注解 Python代码，并利用其他工具根据这些类型判断受注解的代码有没有正确地得到使用。</p>
<p>Python解释器有许多种不同的实现方案，例如CPython、PyPy等，与之类似，与typing模块相搭配的Python静态分析工具，也有很多方案。笔者编写本书的时候，比较流行的是mypy（<a href="https://github.com/python/mypy）、pytype（https://github.com/google/pytype）、pyright（https://github.com/microsoft/pyright）与pyre（https://pyre-check.org）。" target="_blank" rel="noopener">https://github.com/python/mypy）、pytype（https://github.com/google/pytype）、pyright（https://github.com/microsoft/pyright）与pyre（https://pyre-check.org）。</a></p>
<p>如使用mypy：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">substract</span><span class="params">(a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">return</span> a - b</span><br></pre></td></tr></table></figure>
<p>Python的动态机制有个好处，就是可以实现泛型，进而把需要操作的数据当成duck type使用。也就是说，只要用户给出支持这种操作的数据即可，不用管这份数据究竟是什么类型，这样我们就能够让函数接受各种各样的数据，而不用针对每一种数据都专门编写对应的版本，这可以避免重复代码并简化测试工作。</p>
<p>我们可以利用typing模块给函数所涉及的泛型做注解，从而通过静态手段把程序运行时可能发生的错误提前探查出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_default</span><span class="params">(value: Optional[int]m</span></span></span><br><span class="line"><span class="function"><span class="params">                  default: int)</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<p>typing模块还提供了许多选项，可以给代码做注解，详情参见<a href="https://docs.python.org/3.8/library/typing。然而特别需要注意的是，异常并不包括在内。Python与Java不同，Java里面有一种异常叫作受检异常（checkedexception），如果API宣称自己可能抛出这种异常，那么使用API的开发者必须明确做出应对。Python在这一方面更像C#，它们都不把异常当作接口定义中的一部分，因此，如果想确保自己的API能够正确地抛出异常，或确保自己在使用别人的API时能够正确地捕获异常，那么必须编写相关的测试。" target="_blank" rel="noopener">https://docs.python.org/3.8/library/typing。然而特别需要注意的是，异常并不包括在内。Python与Java不同，Java里面有一种异常叫作受检异常（checkedexception），如果API宣称自己可能抛出这种异常，那么使用API的开发者必须明确做出应对。Python在这一方面更像C#，它们都不把异常当作接口定义中的一部分，因此，如果想确保自己的API能够正确地抛出异常，或确保自己在使用别人的API时能够正确地捕获异常，那么必须编写相关的测试。</a></p>
<p>使用typing模块的过程中，经常会碰到这样一个问题，那就是我们在编写类型注解的时候，需要用到当前还没有定义出来的类型，这叫作提前引用（forwardreference）。</p>
<p>还有一种更好的办法是，通过<code>from __future__ import annotations</code>来引入类型注解功能，这种办法是从Python 3.7版本开始支持的，到了Python 4，将会成为默认的方式。这样写，会让Python系统在运行程序的时候，完全忽略类型注解里面提到的值，于是就解决了提前引用的问题，而且程序在启动时的性能也会提升。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value: SecondClass)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    </span><br><span class="line">second = SecondClass(<span class="number">5</span>)</span><br><span class="line">first = FirstClass(second)</span><br></pre></td></tr></table></figure>
<p>我们已经了解了类型提示信息的用法及其潜在好处，现在必须提醒大家注意，怎样合理地使用这些注解。下面是几条原则：</p>
<ul>
<li>如果刚开始写代码的时候，就想着如何添加类型注解，那可能会拖慢编程速度。所以我们通常应该先把代码本身写出来，然后编写测试，最后才考虑在必要的地方添加类型信息。类型提示信息最能发挥作用的地方，是在项目与项目衔接处。例如，如果有很多个项目都要使用你的API，那么这种API就很有必要做类型注解，因为这些信息可以跟集成测试（参见第77条）与警告互补，以确保API的调用者不会发生误用，并督促调用者在你更新API之后，及时修改他们的代码中与新版API不符的地方。</li>
<li>如果有些代码比较复杂，或者特别容易出错，那么即便不属于API，也仍然值得添加类型提示信息。但是要注意，没必要给所有的代码都添上类型注解，因为到了一定程度之后，再添加这种信息，就不会给项目带来太大的好处了。</li>
<li>如果有可能的话，应该把静态分析这一环节纳入自动构建流程与测试系统中，以确保提交上去的每份代码都会经受相关的检查。另外，检查类型信息所用的配置方案，应该放在代码库里面维护，以保证其他的合作者使用的也是这套规则。</li>
<li>每添加一批类型注解，就应该把静态分析工具运行一遍，这样可以及时发现问题并加以解决。假如把整个项目全都注解完之后，再实施类型检查，那么类型分析工具就有可能打印出极多的错误信息，让你不知道应该先处理哪一条才好，有时甚至会让你想要放弃类型注解。</li>
</ul>
<p>最后必须注意，还有许多场合是不需要写类型注解的，比如小型程序、临时代码、遗留项目以及原型等。没必要花时间给这些代码添加类型注解，因为这样做好处很少。</p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2024/06/16/html/记录HTML中与性能:渲染有关的几个新属性/" class="prev">Previous Post<span>记录HTML中与性能/渲染有关的几个新属性</span></a></div><div class="post-next"><a href="/2024/05/25/python/【笔记】《编写高质量Python代码的90个有效方法》-52至74/" class="next">Next Post<span>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 52 ～ 74 条读书笔记</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> Recent Posts</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/29/notes/【工具】21st.dev-面向AI友好的组件库及页面模版库/">21st.dev：让AI生成的页面告别"塑料感"的专业解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/25/figma/Figma-AIGC相关记录（持续）/">【笔记】Figma和AIGC（持续）</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/notes/【笔记】State-Of-Ai/">【笔记】State-Of-Ai 报告信息</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/26/notes/【笔记】web黑夜模式适配/">【笔记】web 黑夜模式通用适配方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/15/ai/【笔记】19届阿里D2终端技术大会纪要/">【笔记】19届阿里D2终端技术大会纪要</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> Tags</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebApi/">WebApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpt/">gpt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/">prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prompt/">prompt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwa/">pwa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形/">图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常工作/">日常工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨端/">跨端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> Archive</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2025 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script></body></html>