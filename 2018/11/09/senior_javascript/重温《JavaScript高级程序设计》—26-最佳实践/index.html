<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 重温《JavaScript高级程序设计》—26-最佳实践 | Wayne的博客</title><meta name="description" content="重温《JavaScript高级程序设计》—26-最佳实践 - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><script>(function (w) {w.frontjsConfig={token:"81a82620fb0dca7680f2f06be134fa4f",behaviour:8,FPSThreshold:10};w.frontjsTmpData = {r:[],e:[],l:[]};w.frontjsTmpCollector = function (ev) {(ev.message ? window.frontjsTmpData.e : window.frontjsTmpData.r).push([new Date().getTime(), ev])};w.FrontJS = {addEventListener: function (t, f) {w.frontjsTmpData.l.push([t, f]);return f;},removeEventListener: function (t, f) {for (var i = 0; i < w.frontjsTmpData.l.length; i++) {t === w.frontjsTmpData.l[i][0] && f === w.frontjsTmpData.l[i][1] && w.frontjsTmpData.l.splice(i, 1);}return f;}};w.document.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("load", function () {var n = w.document.createElement("script");n.src = "https://frontjs-static.pgyer.com/dist/current/frontjs.web.min.js"; w.document.body.appendChild(n);}, true);})(window);</script><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">主页</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">归档</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">关于</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">重温《JavaScript高级程序设计》—26-最佳实践</h1><span class="post-date">Nov 9, 2018</span><span class="post-tag"><a href="/tags/js/">js</a><a href="/tags/前端/">前端</a></span><img src="/images/20171105/icon.png" class="bgimage"><div class="post-content"><h5 id="本篇内容"><a href="#本篇内容" class="headerlink" title="本篇内容"></a>本篇内容</h5><ul>
<li>可维护性</li>
<li>性能</li>
<li>部署</li>
</ul>
<hr>
<h2 id="1-可维护性"><a href="#1-可维护性" class="headerlink" title="1 可维护性"></a>1 可维护性</h2><p>在早期的网站中，JavaScript主要是用于小特效或者是表单验证。而今天的Web应用则会有成千上万行JavaScript代码，执行各种复杂的过程。这种演化让开发者必须得考虑到可维护性。除了秉承较传统理念的软件工程师外，还要雇佣JavaScript开发人员为公司创造价值，而他们并非仅仅按时交付产品，同时还要开发智力成果在之后不断地增加价值。<br>编写可维护的代码很重要，因为大部分开发人员都花费大量时间维护他人代码。很难从头开始开发新代码的，很多情况下是以他人的工作成果为基础的。确保自己代码的可维护性，以便其他开发人员在 此基础上更好的开展工作。</p>
<h3 id="1-1-什么是可维护的代码"><a href="#1-1-什么是可维护的代码" class="headerlink" title="1.1 什么是可维护的代码"></a>1.1 什么是可维护的代码</h3><p>可维护的代码有一些特征。一般来说，如果说代码是可维护的，它需要遵循－以下特点。</p>
<ul>
<li><strong>可理解性</strong>：其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。</li>
<li><strong>直观性</strong>：代码中的东西一看就能明白，不管其操作过程多么复杂。</li>
<li><strong>可适应性</strong>：代码以一种数据上的变化不要求完全重写的方法撰写。</li>
<li><strong>可扩展性</strong>：在代码架构上已考虑到在未来允许对核心功能进行扩展。</li>
<li><strong>可调试性</strong>：当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。</li>
</ul>
<h3 id="1-2-代码约定"><a href="#1-2-代码约定" class="headerlink" title="1.2 代码约定"></a>1.2 代码约定</h3><p>一种让代码变得可维护的简单途径是形成一套JavaScript代码的书写约定。绝大多数语言都开发出了各自的代码约定，只要在网上一搜就能找到大量相关文档。专业的组织为开发人员制定了详尽的代码约定试图让代码对任何人都可维护。杰出的开放源代码项目有着严格的代码约定要求，这让社区中的任何人都可以轻松地理解代码是如何组织的。<br>由于JavaScript的可适应性，代码约定对它也很重要。由于和大多数面向对象语言不同，JavaScript并不强制开发人员将所有东西都定义为对象。语言可以支持各种编程风格，从传统面向对象式到声明式到函数式。只要快速浏览一下一些开源JavaScript库，就能发现好几种创建对象、定义方法和管理环境的途径。</p>
<p>以下小节将讨论代码约定的概论。对这些主题的解说非常重要，虽然可能的解说方式会有区别，这取决于个人需求。</p>
<h4 id="1-可读性"><a href="#1-可读性" class="headerlink" title="1.可读性"></a>1.可读性</h4><p>要让代码可维护，首先它必须可读。可读性与代码作为文本文件的格式化方式有关。可读性的大部分内容都是和代码的缩进相关的。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于阅读。通常会使用若干空中备而非制表符来进行<strong>缩进</strong>，这是因为制表符在不同的文本编辑器中显示效果不同。一种不错的、很常见的缩进大小为4个空格，当然你也可以使用其他数量。<br>可读性的另一方面是<strong>注释</strong>。在大多数编程语言中，对每个方法的注释都视为一个可行的实践。因为JavaScript可以在代码的任何地方创建函数，所以这点常常被忽略了。然而正因如此，在JavaScript中为每个函数编写文档就更加重要了。一般而言有如下一些地方需要进行注释。</p>
<ul>
<li><strong>函数和方法</strong>：每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述事先的假设也非常重要．参数代表什么，函数是否有返回值（因为这不能从函数定义中推断出来）。</li>
<li><strong>大段代码</strong>：用于完成单个任务的多行代码应该在前面放－个描述任务的注释。</li>
<li><strong>复杂的算法</strong>：如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的。这不仅仅可以帮助其他浏览你代码的人，也能在下次你自己查阅代码的时候帮助理解。</li>
<li><strong>Hack</strong>：因为存在浏览器差异，JavaScript代码一般会包含一些hack。不要假设其他人在看代码的时候能够理解back所要应付的浏览器问题。如果因为某种浏览器无法使用普通的方法，所以你需要用一些不同的方法，那么诸将这些信息放在注释中。这样可以减少出现这种情况的可能性：有人偶然看到你的hack，然后”修正“了它，最后重新引入了你本来修正了的错误。</li>
</ul>
<p>缩进和注释可以带来更可读的代码、在未来则更容易维护。</p>
<h4 id="2-变量和函数命名"><a href="#2-变量和函数命名" class="headerlink" title="2.变量和函数命名"></a>2.变量和函数命名</h4><p>适当纷变量和函数起名字对于增加代码可理解性和可维护性是非常重要的。 由于很多JavaScript开发人员最初都只是业余爱好者，所以有一种使用无意义名字的倾向，诸如给变量起”foo“、”bar“等名字，给函数器”doSomething“这样的名字。专业JavaScript开发人员必须克服这些恶习以创建可维护的代码。命名的一般规则如下所示。</p>
<ul>
<li><strong>变量名应为名词</strong>，如car或person。</li>
<li><strong>函数名应该以动词开始</strong>，如getName()。<strong>返回布尔类型值的函数一般以is开头</strong>，如<br>isEnable()。</li>
<li><strong>变量和函数都应使用合乎逻辑的名字，不要担心长度</strong>。长度问题可以通过后处理和压缩来缓解。</li>
</ul>
<p>必须避免出现无法表示所包含的数据类型的无用变量名。有了合适的命名，代码阅读起来就像讲述故事一样，更容易理解。</p>
<h4 id="3-变量类型透明"><a href="#3-变量类型透明" class="headerlink" title="3.变量类型透明"></a>3.变量类型透明</h4><p>由于在JavaScript中变量是松散类型的，很容易就忘记变量所应包含的数据类型。合适的命名方式可以一定程度上缓解这个问题，但敢到所有的情况下看，还不够。有三种表示变量数据类型的方式。<br>第一种方式是<strong>初始化</strong>。当定义了一个变量后，它应该被初始化为一个值，来暗示它将来应该如何应用。例如，将来保存布尔类型值的变量应该初始化为true或者false，将来保存数字的变量就应该初 始化为一个数字，如以下例子所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found = <span class="literal">false</span>;	<span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">-1</span>;		<span class="comment">// Number</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">''</span>;		<span class="comment">// String</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>;	<span class="comment">// Object</span></span><br></pre></td></tr></table></figure></p>
<p>初始化为一个特定的数据类型可以很好的指明变量的类型。但缺点是它无法用于函数声明中的函数参数。<br>第二种方法是使用<strong>匈牙利标记法来指定变量类型</strong>。匈牙利标记法在变量名之前加上一个或多个字符来表示数据类型。这个标记法在脚本语言中很流行，曾经很长时间也是JavaScript所推崇的方式。JavaScript中最传统的匈牙利标记法是用单个字符表示基本类型：<strong>”o“代表对象，”s“代表字符串，”i“代表整数、”f“代表浮点数，”b“代表布尔型</strong>。如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFound;	<span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">var</span> iCount;	<span class="comment">// Number(Int)</span></span><br><span class="line"><span class="keyword">var</span> sName;	<span class="comment">// String</span></span><br><span class="line"><span class="keyword">var</span> oPerson;	<span class="comment">// Object</span></span><br></pre></td></tr></table></figure></p>
<p>JavaScript中用匈牙利标记法的好处是函数参数一样可以使用。但它的缺点是让代码某种程度上难以阅读，阻碍了没有用它时代码的直观性和句子式的特质。因此，匈牙利标记法失去了一些开发者的宠爱。</p>
<p>最后一种指定变量类型的方式是<strong>使用类型注释</strong>。类型注释放在变量名右边，，但是在初始化前面。这种方式是在变量旁边放－段指定类型的注释，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found <span class="comment">/* :Boolean */</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> count <span class="comment">/* :Int */</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> name <span class="comment">/* :String */</span> = <span class="string">'Micheal'</span>;</span><br><span class="line"><span class="keyword">var</span> person <span class="comment">/* :Object */</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>类型注得维持了代码的整体可读性，同时注入f类型信息。类型注释的缺点是你不能用多行注释－次注释大块的代码，因为类型注释也是多行注释，两者会冲突，如下例所示所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	var found /* :Boolean */</span> = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">var</span> count <span class="comment">/* :Int */</span> = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">var</span> name <span class="comment">/* :String */</span> = <span class="string">'Micheal'</span>;</span><br><span class="line">	<span class="keyword">var</span> person <span class="comment">/* :Object */</span> = <span class="literal">null</span>;</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p>
<p>这里，试图通过多行注释注释所有变量。类型注释与其相冲突，因为第一次出现的户（第二行）匹配了第一次出现的叫（第3行），这会造成一个语法错误。如果你想注释掉这些使用类型注释的代码行，最好在每一行上使用单行注释（很多编辑器可以帮你完成）。<br>这就是最常见的三种指定变量数据类型的方法。每种都有各自的优势和劣势，要自己在使用之前进行评估。最重要的是要确定哪种最适合你的项目；并一致使用。</p>
<h3 id="1-3-松散耦合"><a href="#1-3-松散耦合" class="headerlink" title="1.3 松散耦合"></a>1.3 松散耦合</h3><p>只要应用的某个部分过分依赖于另一部分，代码就是耦合过紧，难于维护。典型的问题如：对象直接引用另一个对象，并且当修改其中一个的同时需要修改另外一个。紧密耦合的软件难于维护并且需要经常重写。<br>因为Web应用所涉及的技术，有多种情况会使它变得耦合过紧。 必须小心这些情况，并尽可能维护弱耦合的代码。</p>
<h4 id="1-解耦HTML-JavaScript"><a href="#1-解耦HTML-JavaScript" class="headerlink" title="1.解耦HTML/JavaScript"></a>1.解耦HTML/JavaScript</h4><p>一种最常见的耦合类型是HTML/JavaScript耦合。在Web上，HTML和JavaScript各自代表了解决方案中的不同层次：HTML是数据，JavaScript是行为。 因为它们天生就需要交互，所以有多种不同的方法将这两个技术关联起来。但是，有些方法会将HTML和JavaScript过于紧密地耦合在一起。<br>直接写在HTML中的JavaScript，使用包含内联代码的<code>&lt;script&gt;</code>元素或者是使用HTML属性来分配事件处理程序，都是过于紧密的耦合。请看以下代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 紧密耦合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">'Hello'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事件处理的紧密耦合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click"</span> <span class="attr">onclick</span>=<span class="string">"doSomething()"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>虽然这些从技术上来说都是正确的，但是实践中，它们将表示数据的HTML和定义行为的JavaScript紧密耦合在了一起。 理想情况是，HTML和JavaScript应该完全分离，并通过外部文件和使用DOM附加行为来包含JavaScript。<br>当HTML和JavaScript过于紧密的耦合在一起时，出现JavaScript错误时就要先判断错误是出现在HTML部分还是在JavaScript文件中。它还会引入和代码是否可用的相关新问题。在这个例子中，可能在doSomething()函数可用之前，就已经按下了按钮，引发了一个JavaScript错误。因为任何对按钮行为的更改要同时触及HTML和JavaScript，因此影响了可维护性。而这些更改本该只在JavaScript中进行。<br>HTML和JavaScript的紧密耦合也可以在相反的关系上成立：JavaScript包含了HTML。这通常会出现在使用innerHTML来插入－段HTML文本到页面上这种情况中，如下面的例子所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将HTML紧密耦合到JavaScript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertMessage</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">	container.innerHTML = <span class="string">'&lt;div class="msg"&gt;&lt;p class="post"&gt;'</span> + msg + <span class="string">'&lt;/p&gt;&lt;/div&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般来说，你应该避免在JavaScript中创建大量HTML。再一次重申要保持层次的分离，这样可以很容易的确定错误来源。当使用上而这个例子的时候，有一个页面布局的问题，可能和动态创建的HTML没有被正确格式化有关。不过，要定位这个错误可能非常困难，因为你可能一般先看页面的源代码来查找那段烦人的HTML，但是却没能找到，因为它是动态生成的。对数据或者布局的更改也会要求更改JavaScript，这也表明了这两个层次过于紧密地耦合了。<br>HTML呈现应在该尽可能与JavaScript保持分离。当JavaScript用于插入数据时，尽量不要直接插入标记。 一般可以在页面中直接包含并隐藏标记，然后等到整个页面渲染好之后，就可以用JavaScript显示该标记，而非生成它。另一种方法是进行Ajax请求并获取更多主要显示的HTML，这个方法可以让同样的渲染层（PHP、JSP、Ruby等等）来输出标记，而不是直接嵌在JavaScript中。<br>将HTML和JavaScript解耦可以在调试过程中节省时间，更加容易确定错误的来源，也减轻维护的难度：更改行为只需要在JavaScript文件中进行，而更改标记则只要在渲染文件中。</p>
<h4 id="2-解耦CSS-JavaScript"><a href="#2-解耦CSS-JavaScript" class="headerlink" title="2.解耦CSS/JavaScript"></a>2.解耦CSS/JavaScript</h4><p>另一个Web层则是css，它主要负责页面的显示。JavaScript和css也是非常紧密相关的：他们都是HTML之上的层次，因此常常一起使用。但是，和HTML与JavaScript的情况一样，css和JavaScript也可能会过于紧密地耦合在一起。最常见的紧密耦合的例子是使用JavaScript来更改某些样式，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css对JavaScript的紧密耦合</span></span><br><span class="line">element.style.color = <span class="string">'red'</span>;</span><br><span class="line">element.style.backgroundColor = <span class="string">'blue'</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于css负责页面的显示，当显示出现任何问题时都应该只是查看css文件来解决。然而，当使用了JavaScript来更改某些样式的时候，比如颜色，就出现了第二个可能已更改和必须检查的地方。结果是JavaScript也在某种程度上负责了页面的显示，并与css紧密耦合了。如果未来需要更改样式表，css和JavaScript文件可能都需要修改。这就给开发人员造成了维护上的噩梦。所以在这两个层次之间 必须有清晰的划分。<br>现代Web应用常常要使用JavaScript来更改样式，所以虽然不可能完全将css和JavaScript解耦，但是还是能让耦合更松散的。这是通过动态更改样式类而非特定样式来实现的，如下例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css对JavaScript的松散耦合</span></span><br><span class="line">element.className = <span class="string">'edit'</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过只修改某个元素的css类，就可以让大部分样式信息严格保留在css中。JavaScript可以更改样式类，但并不会直接影响到元素的样式。 只要应用了正确的类，那么任何显示问题都可以直接追溯到css而非JavaScript。<br>第二类紧密耦合仅会在IE中出现（但运行于标准模式下的IE8不会出现），它可以在css中通过表达式嵌入JavaScript，如下例所示：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* javascript对css的紧密耦合 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="built_in">expression</span>(document.body.offsetWidth - <span class="number">10</span> + <span class="string">'px'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常要避免使用表达式，因为它们不能跨浏览器兼容，还因为它们所引入的JavaScript和css之间的紧密耦合。如果使用了表达式，那么可能会在css中出现JavaScript错误。由于css表达式而追踪过JavaScript错误的开发人员，会告诉你在他们决定看一下css之前花了多长时间来查找错误。<br>再次提醒，好的层次划分是非常重要的。显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript。在这些层次之间保持松散耦合可以让你的整个应用更加易于维护。</p>
<h4 id="3-解耦应用逻辑-事件处理程序"><a href="#3-解耦应用逻辑-事件处理程序" class="headerlink" title="3.解耦应用逻辑/事件处理程序"></a>3.解耦应用逻辑/事件处理程序</h4><p>每个Web应用一般都有相当多的事件处理－程序，监听着无数不同的事件。然而，很少有能仔细得将应用逻辑从事件处理程序中分离的。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleKeyPress</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (event.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">		<span class="keyword">var</span> value = <span class="number">5</span> * <span class="built_in">parseInt</span>(target.value);</span><br><span class="line">		<span class="keyword">if</span> (value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="built_in">document</span>.getElementById(<span class="string">'error-msg'</span>).style.dispaly = <span class="string">'block'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个事件处理程序除了包含了应用逻辑，还进行了事件的处理。这种方式的问题有其双重性。首先，除了通过事件之外就再没有方法执行应用逻辑，这让调试变得困难。如果没有发生预想的结果怎么办？ 是不是表示事件处理程序没有被调用还是指应用逻辑失败？其次，如果一个后续的事件引发同样的应用逻辑，那就必须复制功能代码或者将代码抽取到一个单独的属数中。无论何种方式，都要作比实际所需更多的改动。<br>较好的方法是将应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中。例如，前面的代码可以被重写为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateValue</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	value = <span class="number">5</span> * <span class="built_in">parseInt</span>(value);</span><br><span class="line">	<span class="keyword">if</span> (value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'error-msg'</span>).style.dispaly = <span class="string">'block'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleKeyPress</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (event.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">		validateValue(target.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改动过的代码合理将应用逻辑从事件处理程序中分离了出来。handleKeyPress()函数确认是按下了Enter键（event.keyCode为13），取得了事件的目标并将value属性传递给validateValue()函数，这个函数包含了应用逻辑。注意validateValue()中没有任何东西会依赖于任何事件处理程序逻辑，它只是接收一个值，并根据该值进行其他处理。<br>从事件处理程序中分离应用逻辑有几个好处。首先，可以让你更容易更改触发特定过程的事件。如果最开始由鼠标点击事件触发过程，但现在按键也要进行同样处理，这种更改就很容易。其次，可以在不附加到事件的情况下测试代码，使其更易创建单元测试或者是自动化应用流程。<br>以下是要牢记的应用和业务逻辑之间松散耦合的几条原则：</p>
<ul>
<li><strong>勿将event对象传给其他方法；只传来自event对象中所需的数据；</strong></li>
<li><strong>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；</strong></li>
<li><strong>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。</strong></li>
</ul>
<p>牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很多可能。</p>
<h3 id="1-4-编程实践"><a href="#1-4-编程实践" class="headerlink" title="1.4 编程实践"></a>1.4 编程实践</h3><p>书写可维护的JavaScript并不仅仅是关于如何格式化代码；它还关系到代码做什么的问题。在企业环境中创建的Web应用往往同时由大量人员一同创作。这种情况下的目标是确保每个人所使用的浏览器环境都有一致和不变的规则。因此，最好坚持以下一些编程实践。</p>
<p>####　1.尊重对象所有权<br>JavaScript的动态性质使得儿乎任何东西在任何时间都可以修改。有人说在JavaScript没有什么神圣的东西，因为无法将某些东西标记为最终或恒定状态。这种状况在ECMAScript5中通过引人防篡改对象得以改变；不过，默认情况下所有对象都是可以修改的。在其他语言中，当没有实际的源代码的时候，对象和类是不可变的。JavaScript可以在任何时候修改任意对象，这样就可以以不可预计的方式覆写默认的行为。因为这门语言没有强行的限制，所以对于开发者来说，这是很重要的，也是必要的。<br>也许在企业环境中最重要的编程实践就是尊重对象所有权，它的意思是你不能修改不属于你的对象。<strong>简单地说，如果你不负责创建或维护某个对象它的对象或者它的方法，那么你就不能对它们进行修改</strong>。更具体地说：</p>
<ul>
<li><strong>不要为实例或原型添加属性</strong>；</li>
<li><strong>不要为实例或原型添加方法</strong>；</li>
<li><strong>不要重定义已存在的方法。</strong></li>
</ul>
<p>问题在于开发人员会假设浏览器环境按照某个特定方式运行，而对于多个人都用到的对象进行改动就会产生错误。如果某人期望叫做stopEvent()的函数能取消某个事件的默认行为，但是你对其进行了更改．然后它完成了本来的任务，后来还追加了另外的事件处理程序，那肯定会出现问题了。其他开发人员会认为函数还是按照原来的方式执行，所以他们的用法会出错并有可能造成危害，因为他们并不知道有副作用。</p>
<p>这些规则不仅适用于自定义类型和对象，对于诸如Object、String、document、window等原生类型和对象也适用。此处潜在的问题可能更加危险，因为浏览器提供者可能会在不做宣布或者是不可预期的情况下更改这些对象。<br>著名的Prototype JavaScript库就出现过这种例子：它为document对象实现了getElementsByClassName()方法，返回一个Array的实例并增加了一个each()方法。JohnResig在他的博客上叙述了产生这个问题的一系列事件。他在帖子中说，他发现当浏览器开始内部实现getElementsByClassName()的时候就出现问题了，这个方法并不返回一个Array而是返回一个并不包含each()方法的NodeList。使用Prototype库的开发人员习惯于写这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'selected'</span>).each(Element.hide);</span><br></pre></td></tr></table></figure></p>
<p>虽然在没有原生实现getElementsByClassName()的浏览器中可以正常运行，但对于支持的了浏览器就会产生错误，因为返回的值不同。你不能预测浏览器提供者在未来会怎样更改原生对象，所以不管用任何方式修改他们，都可能会导致将来你的实现和他们的实现之间的冲突。<br>所以，<strong>最佳的方法便是永远不修改不是由你所有的对象</strong>。所谓拥有对象．就是说这个对象是你创建的，比如你自己创建的自定义类型或对象字面量。而Array、document这些显然不是你的，它们在你的代码执行前就存在了。你依然可以通过以下方式为对象创建新的功能：</p>
<ul>
<li>创建包含所需功能的新对象，并用它与相关对象进行交互；</li>
<li>创建自定义类型，继承需要进行修改的类型。然后可以为自定义类型添加额外功能。<br>现在很多JavaScript库都赞同并遵守这条开发原理，这样即使浏览器频繁更改，库本身也能继续成长和适应。</li>
</ul>
<h4 id="2-避免全局量"><a href="#2-避免全局量" class="headerlink" title="2. 避免全局量"></a>2. 避免全局量</h4><p>与尊重对象所有权密切相关的是尽可能避免全局变量和函数。这也关系到创建一个脚本执行的一致的和可维护的环境。<strong>最多创建一个全局变量，让其他对象和函数存在其中</strong>。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Micheal'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码包含了两个全局量：变量name和函数sayName()。其实可以创建一个包含两者的对象，如下例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	name: <span class="string">'Micheal'</span>,</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段重写的代码引入了一个单一的全局对象MyApplication,name和sayName()都附加到其上。这样做消除了一些存在于前一段代码中的一些问题。首先，变量name覆盖了window.name属性，可能会与其他功能产生冲突；其次，它有助消除功能作用域之间的混淆。调用MyApplication.sayName()在逻辑上暗示了代码的任何问题都可以通过检查定义MyApplication的代码来确定。<br>单一的全局量的延伸便是命名空间的概念，由YUI（Yahoo! User Interface）库普及。命名空间包括创建－个用于放置功能的对象。在YUI的2.x版本中，有若干用于追加功能的命名空间。比如:</p>
<ul>
<li>YAfiOO.util.Dom 一一处理 DOM 的方法；</li>
<li>YAHOO.util.Event 一一与事件交互的方法；</li>
<li>YAHOO.lang 一一用于底层语言特性的方法。</li>
</ul>
<p>对于YUI，单－的全局对象YAHOO作为一个容器，其中定义了其他对象。<strong>用这种方式将功能组合在一起的对象，叫做命名空间</strong>。整个YUI库便是构建在这个概念上的，让它能够在同一个页面上与其他的JavaScript库共存。<br>命名空间很重要的一部分是确定每个人都同意使用的全局对象的名字，并且尽可能唯一，让其他人不太可能也使用这个名字。在大多数情况下，可以是开发代码的公司的名字，例如YAHOO或者Wrox。你可以如下例所示开始创建命名率间来组合功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Wrox = &#123;&#125;;</span><br><span class="line">Wrox.ProJS = &#123;&#125;;</span><br><span class="line">Wrox.ProJS.EventUtil = &#123;&#125;;</span><br><span class="line">Wrox.ProJS.CookieUtil = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，Wrox是全局量，其他命名空间在此之上创建。如果本书所有代码都放在Wrox.ProJS命名空间，那么其他作者也应把自己的代码添加到Wrox对象中。只要所有人都遵循这个规则，那么就不用担心其他人也创建叫做EventUtil或者CookieUtil的对象，因为它会存在于不同的命名空间中。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wrox.ProAjax = &#123;&#125;;</span><br><span class="line">Wrox.ProAjax.EventUtil = &#123;&#125;;</span><br><span class="line">Wrox.ProAjax.CookieUtil = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Wrox.ProJS.EventUtil.addHandler(<span class="comment">/*...*/</span>);</span><br><span class="line">Wrox.ProAjax.EventUtil.addHandler(<span class="comment">/*...*/</span>);</span><br></pre></td></tr></table></figure></p>
<p>虽然命名空间会需要多写一些代码，但是对于可维护的目的而言是值得的。命名空间有助于确保代码可以在同一个页面上与其他代码以无害的方式一起工作。</p>
<h4 id="3-避免与null进行比较"><a href="#3-避免与null进行比较" class="headerlink" title="3.避免与null进行比较"></a>3.避免与null进行比较</h4><p>由于JavaScript不做任何自动的类型检查，所有它就成了开发人员的责任。因此，在JavaScript代码中其实很少进行类型检测。最常见的类型检测就是查看某个值是否为null。但是，直接将值与null比较是使用过度的，并且常常由于不充分的类型检查导致错误。看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;	<span class="comment">// 避免</span></span><br><span class="line">		values.sort(comparator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的目的是根据给定的比较子对一个数组进行排序。 为了函数能正确执行，values参数必需是数组，但这里的if语句仅仅检查该values是否为null。还有其他的值可以通过if语句，包括字符串、数字，它们会导致函数抛出错误。<br>现实中，与null比较很少适合情况而被使用。必须按照所期望的对值进行检查，而非按照不被期望的那些。例如，在前面的范例中，values参数应该是一个数组，那么就要检查它是不是一个数组，而不是检查它是否非null。函数按照下面的方式修改会更加合适：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">		values.sort(comparator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这种验证数组的技术在多框架的网页中不一定正确工作，因为每个框架都有其自己的全局对象，因此，也有自己的Array构造函数。如果你是从一个框架将数组传送到另一个框架，那么就要另外检查是否存在sort()方法。</p>
</blockquote>
<p>如果看到了与null比较的代码，尝试使用以下技术替换：</p>
<ul>
<li><strong>如果值应为一个引用类型，使用instanceof操作符检查其构造函数；</strong></li>
<li><strong>如果值应为一个基本类型，使用typeof检查其类型；</strong></li>
<li><strong>如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上。</strong></li>
</ul>
<p>代码中的null比较越少，就越容易确定代码的目的，并消除不必要的错误。</p>
<h4 id="4-使用常量"><a href="#4-使用常量" class="headerlink" title="4.使用常量"></a>4.使用常量</h4><p>尽管JavaScript没有常量的正式概念，但它还是很有用的。这种将数据从应用逻辑分离出来的思想，可以在不冒引入错误的风险的同时，就改变数据。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!value) &#123;</span><br><span class="line">		alert(<span class="string">'Invalid value!'</span>);</span><br><span class="line">		location.href = <span class="string">'/error.php'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中有两段数据：要显示给用户的信息以及URL。显示在用户界面上的字符串应该以允许进行语言国际化的方式抽取出来。URL也应被抽取出来，因为它们有随着应用成长而改变的倾向。基本上，有着可能由于这样那样原因会变化的这些数据，那么都会需要找到通数并在其中修改代码。而每次修改应用逻辑的代码，都可能会引入错误。<strong>可以通过将数据抽取出来变成单独定义的常最的方式，将应用逻镜与数据修改隔离开来</strong>。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constants = &#123;</span><br><span class="line">	INVALID_VALUE_MSG: <span class="string">'Invalid value!'</span>,</span><br><span class="line">	INVALID_VALUE_URL: <span class="string">'/error.php'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!value) &#123;</span><br><span class="line">		alert(Constants.INVALID_VALUE_MSG);</span><br><span class="line">		location.href = Constants.INVALID_VALUE_URL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这段重写过的代码中，消息和URL都被定义于Constants对象中，然后雨数引用这些值。这些设置允许数据在无须接触使用它的函数的情况下进行变更。Constants对象甚至可以完全在单独的文件中进行定义，同时该文件可以由包含正确值的其他过程根据国际化设置来生成。<br>关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。</p>
<ul>
<li><strong>重复值</strong>：任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了css类名。</li>
<li><strong>用户界面字符串</strong>：任何用于显示给用户的字符事．都应被抽取出来以方便国际化。</li>
<li><strong>URLs</strong>：在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL。</li>
<li><strong>任意可能会更改的值</strong>：每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。</li>
</ul>
<p>对于企业级的JavaScript开发而言，使用常量是非常重要的技巧，因为它能让代码更容易维护，并且在数据更改的同时保护代码。</p>
<h2 id="2-性能"><a href="#2-性能" class="headerlink" title="2 性能"></a>2 性能</h2><p>自从JavaScript诞生以来，用这门语言编写网页的开发人员有了极大的增长。与此同时，JavaScript代码的执行效率也越来越受到关注。因为JavaScript最初是一个解释型语言，执行速度要比编译型语言慢得多。Chrome是第一款内置优化引擎，将JavaScript编译成本地代码的浏览器。此后，主流浏览器纷纷效仿，陆续实现了JavaScript的编译执行。<br>即使到了编译执行JavaScript的新阶段，仍然会存在低效率的代码。不过，还是有一些方式可以改进代码的整体性能的。</p>
<h3 id="2-1-注意作用域"><a href="#2-1-注意作用域" class="headerlink" title="2.1 注意作用域"></a>2.1 注意作用域</h3><p>随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加。<strong>访问全局变量总是要比访问局部变量慢</strong>，因为需要遍历作用域链。只要能减少花费在作用域链上的时间，就能增加脚本的整体性能。</p>
<h4 id="1-避免全局查找"><a href="#1-避免全局查找" class="headerlink" title="1.避免全局查找"></a>1.避免全局查找</h4><p>可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因为要涉及作用域链上的查找。请看以下函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUI</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = imgs.length; i &lt; len; i++) &#123;</span><br><span class="line">		imgs[i].title = <span class="built_in">document</span>.title + <span class="string">' image '</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span><br><span class="line">	msg.innerHTML = <span class="string">'update complete'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数可能看上去完全正常，但是它包含了三个对于全局document对象的引用。如果在页面上有多个图片，那么for循环中的document引用就会被执行多次甚至上百次，每次都会要进行作用域链查找。通过创建一个指向document对象的局部变量，就可以通过限制一次全局查找来改进这个函数的性能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUI</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line">	<span class="keyword">var</span> imgs = doc.getElementById(<span class="string">'img'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = imgs.length; i &lt; len; i++) &#123;</span><br><span class="line">		imgs[i].title = doc.title + <span class="string">' image '</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> msg = doc.getElementById(<span class="string">'msg'</span>);</span><br><span class="line">	msg.innerHTML = <span class="string">'update complete'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，首先将document对象存在本地的doc变量中；然后在余下的代码中替换原来的document。与原来的的版本相比，现在的函数只有一次全局查找，肯定更快。<br><strong>将在一个函数中会用到多次的全局对象存储为局部变量总是没错的</strong>。</p>
<h4 id="2-避免with语旬"><a href="#2-避免with语旬" class="headerlink" title="2.避免with语旬"></a>2.避免with语旬</h4><p><strong>在性能非常重要的地方必须避免使用with语句</strong>。和函数类似，with语句会创建自己的作用域，因此会增加其中执府的代码的作用域链的长度。由于额外的作用域链查找，在with语句中执行的代码 肯定会比外面执行的代码要慢。<br>必须使用with语句的情况很少，因为它主要用于消除额外的字符。在大多数情况下，可以用局部变量完成相同的事情而不引入新的作用域。下面是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBody</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">		alert(tagName);</span><br><span class="line">		innerHTML = <span class="string">'Hello world'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中的with语句让document.body变得更容易使用。其实可以使用局部变量达到相同的效果，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBody</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">	alert(body.tagName);</span><br><span class="line">	body.innerHTML = <span class="string">'Hello world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码稍微长了点，但是阅读起来比with语句版本更好，它确保让你知道tagName和innerHTML是属于哪个对象的。同时，这段代码通过将document.body存储在局部变量中省去了额外的全局查找。</p>
<h3 id="2-2-选择正确方法"><a href="#2-2-选择正确方法" class="headerlink" title="2.2 选择正确方法"></a>2.2 选择正确方法</h3><p>和其他语言一样，性能问题的一部分是利用于解决问题的算法或者方法有关的。老练的开发人员根据经验可以得知哪种方法可能获得更好的性能。 很多应用在其他编程语言中的技术和方法也可以在 JavaScript中使用。</p>
<h4 id="1-避免不必要的属性查找"><a href="#1-避免不必要的属性查找" class="headerlink" title="1.避免不必要的属性查找"></a>1.避免不必要的属性查找</h4><p>在计算机科学中，算法的复杂度是使用O符号来表示的。<strong>最简单、最快捷的算法是常数值即O(1)</strong>。之后，算法变得越来越复杂并花更低时间执行。 下面的表格列出了JavaScript中常见的算法类型。</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td>常数</td>
<td>不管有多少值，执行的时间都是恒定的。一般表示简单值和存储在变量中的值</td>
</tr>
<tr>
<td>O(log n)</td>
<td>对数</td>
<td>总的执行时间和值的数量相关．但是要完成算法并不一定要获取每个值。例如：二分查找</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性</td>
<td>总执行时间和值的数量正比相关。例如：遍历某个数组中的所有元索</td>
</tr>
<tr>
<td>O(n^2)</td>
<td>平方</td>
<td>总执行时间和值的数量有关，每个值至少要获取n次。例如：插入排序</td>
</tr>
</tbody>
</table>
<p>常数值，即O(1)，指代字面值和存储在变量中的值。符号O(1)表示无论有多少个值，需要获取常量值的时间都一样。获取常量值是非常高效的过程。请看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">10</span> + value;</span><br><span class="line">alert(sum);</span><br></pre></td></tr></table></figure></p>
<p>该代码进行了四次常量值查找：数字5，变量value，数字10和变量sum。这段代码的整体复杂度被认为是0(1)。<br>在JavaScript中访问数组元素也是一个0(1)操作，和简单的变量查找效率一样。所以以下代码和前面的例子效率一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">5</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">alert(sum);</span><br></pre></td></tr></table></figure></p>
<p>使用变量和数组要比访问对象上的属性更有效率，后者是一个O(n)操作。对象上的任何属性查找都要比访问变盘或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。请看以下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = &#123;</span><br><span class="line">	first: <span class="number">5</span>,</span><br><span class="line">	second: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sum = values.first + values.second;</span><br><span class="line">alert(sum);</span><br></pre></td></tr></table></figure>
<p>这段代码使用两次属性查找来计算：sum的值。进行一两次属性查找并不会导致显著的性能问题，但是进行成百上千次则肯定会减慢执行速度。<br>注意获取单个值的多重属性查找。例如，请看以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="built_in">window</span>.location.href.substring(<span class="built_in">window</span>.location.href.indexOf(<span class="string">'?'</span>));</span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，有6次属性查找：window.location.href.substring()有3次，window.location.href.indexOf()又有3次。只要数一数代码中的点的数量，就可以确定属性查找的次数了。这段代码由于两次用到了window.location.href，同样的查找进行了两次，因此效率特别不好。<br>一旦多次用到对象属性，应该将其存储在局部变量中。第一次访问该值会是O(n)，然而后续的访问都会是O(1)，就会节省很多。例如，之前的代码可以如下重写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.location.href;</span><br><span class="line"><span class="keyword">var</span> query = url.substring(url.indexOf(<span class="string">'?'</span>));</span><br></pre></td></tr></table></figure></p>
<p>这个版本的代码只有4次属性查找，相对于原始版本节省了33%。在更大的脚本中进行这种优化，倾向于获得更多改进。<br>一般来讲，只要能减少算法的复杂度，就要尽可能减少。尽可能多地使用局部变量将属性查找替换为值资找。进一步讲，如果即可以用数字化的数组位置进行访问，也可以使用命名属性（诸如NodeList对象），那么使用数字位置。</p>
<h4 id="2-优化循环"><a href="#2-优化循环" class="headerlink" title="2.优化循环"></a>2.优化循环</h4><p>循环是编程中最常见的结构，在JavaScript程序中同样随处可见。优化循环是性能优化过程中很重要的一个部分，由于它们会反复运行同一段代码，从而自动地增加执行时间。在其他语言中对于循环优化有大量研究，这些技术也可以应用于JavaScript。一个循环的基本优化步骤如下所示。</p>
<ul>
<li>（1）<strong>减值选代</strong>：大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效。</li>
<li>（2）<strong>简化终止条件</strong>：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说避免属性查找或其他O(n)的操作。</li>
<li>（3）<strong>简化循环体</strong>：循环体是执行最多的，所以要确保其被最大限度地优化。确保没有某些可以被很容易移出循环的密集计算。</li>
<li>（4）<strong>使用后测试循环</strong>：且常用for循环和while循环都是前测试循环。而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</li>
</ul>
<p>用一个例子来描述这种改动。以下是－个基本的for循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">	process(values[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中变量i从0递增到values数组中的元素总数。假设值的处理顺序无关紧要，那么循环可以改为i减值，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = values.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">	process(values[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，变量i每次循环之后都会减1。在这个过程中，将终止条件从value.length的O(n)调用简化成了0的O(1)调用。由于循环体只有一个语句，无法进一步优化。不过循环还能改成后测试循环，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = values.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		process(values[i]);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处主要的优化是将终止条件和自减操作符组合成了单个语句。这时，任何进一步的优化只能process()函数中进行了，因为循环部分已经优化完全了。<br>记住使用“后测试”循环时必须确保要处理的值至少有一个。空数组会导致多余的一次循环而 “前测试” 循环则可以避免。</p>
<h4 id="3-展开循环"><a href="#3-展开循环" class="headerlink" title="3.展开循环"></a>3.展开循环</h4><p>当循环的次数是确定的，消除循环并使用多次函数调用往往更快。请看一下前面的例子。如果数组的长度总是一样的，对每个元素都调用process()可能更优，如以下代码所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process(values[<span class="number">0</span>]);</span><br><span class="line">process(values[<span class="number">1</span>]);</span><br><span class="line">process(values[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></p>
<p>这个例子假设values数组里面只有3个元素，直接对每个元素调用process()。这样展开循环可以消除建立循环和处理终止条件的额外开销，使代码运行得更快。<br>如果循坏中的选代次数不能事先确定，那可以考虑使用一种叫做Duff装置的技术。这个技术是以其创建者Tom Duff命名的，他最早在C语言中使用这项技术。 正是Jeff Greenberg用JavaScript实现了<strong>Duff装置</strong>。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。请看以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterations = <span class="built_in">Math</span>.ceil(values.length / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> startAt = values.length % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> (startAt) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: process(values[i++]);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: process(values[i++]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	startAt = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>Duff装置的实现是通过将values数组中元素个数除以8来计算出循环需要进行多少次选代的。然后使用取整的上限函数确保结果是整数。如果完全根据除8来进行迭代，可能会有一些不能被处理到的元素，这个数量保存在startAt变量中。首次执行该循环时，会检查StartAt变量着有需要多少额外调用。例如，如果数组中有10个值，startAt则等于2，那么最开始的时候process()则只会被调用2次。在接下来的循环中，startAt被重置为0，这样之后的每次循环都会调用8次process()。展开循环可以提升大数据集的处理速度。<br>由Andrew B. King所著的Seed Up Your Site (New Riders,2003)提出了一个更快的Duff装置技术，将do-while循环分成2个单独的循环。以下是例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterations = <span class="built_in">Math</span>.ceil(values.length / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> startAt = values.length % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		process(values[i++]);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--leftover &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">	process(values[i++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在这个实现中，剩余的计算部分不会在实际循环中处理，而是在一个初始化循环中进行除以8的操作。当处理掉了额外的元素．继续执行每次调用8次process()的主循环。这个方法几乎比原始的Duff 装置实现快上40%。<br>针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。它是要花更多的代码来完成同样的任务，如果处理的不是大数据集，一般来说并不值得。</p>
<h4 id="4-避免双重解释"><a href="#4-避免双重解释" class="headerlink" title="4.避免双重解释"></a>4.避免双重解释</h4><p>当JavaScript代码想解析JavaScript的时候就会存在双重解释惩罚。当使用eval()函数或者是Function构造函数以及使用setTimeout()传一个字符串参数时都会发生这种情况。下面有一些例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某些代码求值——避免</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'alert("Hello")'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新函数——避免</span></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert("Hello")'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置超时——避免</span></span><br><span class="line">setTimeout(<span class="string">'alert("Hello")'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>在以上这些例子中，都要解析包含了JavaScript代码的字符串。这个操作是不能在初始的解析过程中完成的，因为代码是包含在字符串中的，也就是说在JavaScript代码运行的同时必须新启动一个解析器来解析新的代码。 实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。 对于这几个例子都有另外的办法。只有极少的情况下eval()是绝对必须的，所以尽可能避免使用。 在这个例子中，代码其实可以直接内嵌在原代码中。对于Function构造函数，完全可以直接写成一般的函数，调用setTimeout()可以传人函数作为第一个参数。 以下是一些例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串。</p>
<h4 id="5-性能的其他注意事项"><a href="#5-性能的其他注意事项" class="headerlink" title="5.性能的其他注意事项"></a>5.性能的其他注意事项</h4><p>当评估脚本性能的时候，还有其他一些可以考虑的东西。下面并非主要的问题， 不过如果使用得当也会有相当大的提升。</p>
<ul>
<li><strong>原生方法较快</strong>：只要有可能，使用原生方法而不是自己用JavaScript重写一个。原生方法是用诸如C/C++之类的编译型语言写出来的，所以要比JavaScript的快很多很多。JavaScript中最容易被忘记的就是可以在Math弃战中找到的复杂的数学运算；这些方法要比任何用JavaScript写的同样方法如正弦、余弦快的多。</li>
<li><strong>Switch语句较快</strong>：如果有一系列复杂的if-else语句，可以转换成单个switch语句则可以得到更快的代码。还可以通过将case语句按照最可能的到最不可能的顺序进行组织，来进一步优化switch语句。</li>
<li><strong>位运算符较快</strong>：当进行数学运算的时候，位运算操作要比任何布尔运算或者算数运算快。选择性地用位运算替换算数运算可以极大提升复杂计算的性能。诸如取模，逻辑与和逻辑或都可以考虑用位运算来替换。</li>
</ul>
<h3 id="2-3-最小化语句数"><a href="#2-3-最小化语句数" class="headerlink" title="2.3 最小化语句数"></a>2.3 最小化语句数</h3><p>JavaScript代码中的语句数量也影响所执行的操作的速度。完成多个操作的单个语句要比完成单个操作的多个语句快。所以，就要找出可以组合在一起的语句，以减少脚本整体的执行时间。这里有几个可以参考的模式。</p>
<h4 id="1-多个变量声明"><a href="#1-多个变量声明" class="headerlink" title="1.多个变量声明"></a>1.多个变量声明</h4><p>有个地方很多开发人员都容易创建很多语句，那就是多个变量的声明。很容易看到代码中由多个var语句来声明多个变量，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浪费</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>在强类型语言中，不同的数据类型的变量必须在不同的语句中声明。然而，在JavaScript中所有的变量都可以使用单个var语句来声明。前面的代码可以如下重写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nice</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">5</span>,</span><br><span class="line">	color = <span class="string">'blue'</span>,</span><br><span class="line">	values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>此处，变量声明只用了一个var语句，之间由逗号隔开。 在大多数情况下这种优化都非常容易做，并且要比单个变量分别声明快很多。</p>
<h4 id="2-插入选代值"><a href="#2-插入选代值" class="headerlink" title="2.插入选代值"></a>2.插入选代值</h4><p>当使用迭代值（也就是在不同的位置进行增加或减少的值）的时候，尽可能合并语句。请看以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = values[i]; </span><br><span class="line">i++;</span><br></pre></td></tr></table></figure></p>
<p>前面这2句话句各只有一个目的：第一个从values数组中获取值，然后存储在name中；第二个给变量i增加1。这两句可以通过迭代值插入第一个语句组合成一个语句，如下所示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = values[i++];</span><br></pre></td></tr></table></figure></p>
<p>这一个语句可以完成和前面两个语句一样的事情。因为自增操作符是后缀操作符，i的值只有在语句其他部分结束之后才会增加。一旦出现类似情况，都要尝试将送代值插入到最后使用它的语句中去。</p>
<h4 id="3-使用数组和对象字面量"><a href="#3-使用数组和对象字面量" class="headerlink" title="3.使用数组和对象字面量"></a>3.使用数组和对象字面量</h4><p>本书中，你可能看过两种创建数组和对象的方法：使用构造函数或者是使用字面量。使用构造函数总是要用到更多的话句来插入元素或者定义属性，而字面量可以将这些操作在一个语句中完成。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> values = [];</span><br><span class="line">values[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">values[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">values[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">values[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'Micheal'</span>;</span><br><span class="line">person.age = <span class="number">25</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中，只创建和初始化了一个数组和一个对象。各用了4个语句：一个调用构造函数，其他3个分配数据。其实可以很容易地转换成使用字面量的形式。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">'Micheal'</span>,</span><br><span class="line">	age: <span class="number">25</span>,</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>重写后的代码只包含两条语句，一条创建和初始化数组，另一条创建和初始化对象。之前用了八条语句的东西现在只用了两条，减少了75%的语句量。在包含成千上万行JavaScript的代码库中，这些优化的价值更大。<br>只要有可能，尽量使用数组和对象的字面量表达方式来消除不必要的语句。</p>
<blockquote>
<p>*IE6及之前使用字面量有微小的性能惩罚</p>
</blockquote>
<h3 id="2-4-优化-DOM-交互"><a href="#2-4-优化-DOM-交互" class="headerlink" title="2.4 优化 DOM 交互"></a>2.4 优化 DOM 交互</h3><p>在JavaScript各个方面中，DOM毫无疑问是是慢的一部分。DOM操作与交互要消费大量时间，因为它们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能要花很久来执行，因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大得提高脚本完成的速度。</p>
<h4 id="1-最小化现场更新"><a href="#1-最小化现场更新" class="headerlink" title="1.最小化现场更新"></a>1.最小化现场更新</h4><p>一旦你需要访问的DOM部分是已经显示的页面的一部分，那么你就是在进行－个<strong>现场更新</strong>。之所以叫现场更新，是因为需要立即（现场）对页面对用户的显示进行更新。每一个更改，不管是插入单个字符，还是移除整个片段，都有一个性能惩罚，因为浏览器要重新计算无数尺寸以进行更新。现场更新进行得越多，代码完成执行所花的时间就越长；完成一个操作所需的现场更新越少，代码就越快。请看以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>),</span><br><span class="line">	item,</span><br><span class="line">	i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">	list.appendChild(item);</span><br><span class="line">	item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码为列表添加了10个项目。添加每个项目时，都有2个现场更新：一个添加<code>&lt;li&gt;</code>元素，另个给它添加文本节点。这样添加10个项目，这个操作总共要完成20个现场更新。<br>要修正这个性能瓶颈，需要减少现场更新的数量。一般有2种方法。第一种是将列表从页面上移除，最后进行更新，最后再将列表插回到同样的位置。这个方法不是非常理想，因为在每次页面更新的时候它会不必要的闪烁。第二个方法是使用文档碎片来构建DOM结构，接着将其添加到List元素中。这个方式避免了现场更新和页面闪烁问题。请看下面内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>),</span><br><span class="line">	fragment = <span class="built_in">document</span>.createDocumentFragment(),</span><br><span class="line">	item,</span><br><span class="line">	i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">	fragment.appendChild(item);</span><br><span class="line">	item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中只有一次现场更新，它发生在所有项目都创建好之后。文档碎片用作一个临时的占位符，放置新创建的项目。然后使用appendChild()将所有项目添加到列表用。记住，当给appendChild()传入文档碎片时，只有碎片中的子节点被添加到目标，碎片本身不会被添加的。<br>一旦需要更新DOM，请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>
<h4 id="2-使用innerHTML"><a href="#2-使用innerHTML" class="headerlink" title="2.使用innerHTML"></a>2.使用innerHTML</h4><p>有两种在页面上创建DOM节点的方法：使用诸如createElement()和appendChild()之类的DOM方法，以及使用innerHTML。对于小的DOM更改而言，两种方法效率都差不多。然而，对于大的DOM更改，使用innerHTML要比使用标准DOM方法创建同样的DOM结构快得多。<br>当把innerHTML设置为某个值时，后台会创建一个HTML解析器，然后使用内部的DOM调用来创建DOM结构，而非基于JavaScript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。前面的例子还可以用innerHTML改写如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>),</span><br><span class="line">	html = <span class="string">''</span>,</span><br><span class="line">	i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	html += <span class="string">'&lt;li&gt;Item '</span> + i + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.innerHTML = html;</span><br></pre></td></tr></table></figure></p>
<p>这段代码构建了一个HTML字符串，然后将其指定到list.innerHTML，便创建了需要的DOM结构。虽然字符串连接上总是有点性能损失，但这种方式还是要比进行多个DOM操作更快。<br>使用innerHTML的关键在于（和其他DOM操作一样）最小化调用它的次数。例如，下面的代码在这个操作中用到innerHTML的次数太多了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>),</span><br><span class="line">	html = <span class="string">''</span>,</span><br><span class="line">	i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	list.innerHTML += <span class="string">'&lt;li&gt;Item '</span> + i + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码的问题在于每次循环都要调用innerHTML，这是极其低效的。调用innerHTML实际上就是一次现场更新，所以也要如此对待。构建好一个字符串然后一次性调用innerHTML，要比调用innerHTML多次快得多。</p>
<h4 id="3-使用事件代理"><a href="#3-使用事件代理" class="headerlink" title="3.使用事件代理"></a>3.使用事件代理</h4><p>大多数Web应用在用户交互上大量用到事件处理程序。页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。<br>任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理。使用这个知识，就可以将事件处理程序附加到更高层的地方负责多个目标的事件处现。如果可能，在文档级别附加事件处理程序，这样可以处理整个页面的事件。</p>
<h4 id="4-注意HTMLCollection"><a href="#4-注意HTMLCollection" class="headerlink" title="4.注意HTMLCollection"></a>4.注意HTMLCollection</h4><p>HTMLCollection对象的陷阱已经在本书中讨论过了，因为它们对于Web应用的性能而言是巨大的损害。记住，任何时候要访问HTMLCollection，不管它是－个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。<br>也许优化HTMLCollection访问最重要的地方就是循环了。前面提到过将长度计算移入for循环的初始化部分。现在看一下这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>),</span><br><span class="line">	i,</span><br><span class="line">	len;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = images.length; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="comment">// deal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的关键在于长度length存入了len变量，而不是每次都去访问HTMLCollection的length属性。当在循环中使用HTMLCollection的时候，下一步应该是获取要使用的项目的引用，如下所示．以便避免在循环体内多次调用HTMLCollection。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>),</span><br><span class="line">	image,</span><br><span class="line">	i,</span><br><span class="line">	len;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = images.length; i &lt; len; i++) &#123;</span><br><span class="line">	image = images[i];</span><br><span class="line">	<span class="comment">// deal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码添加了Image变量，保存了当前的图像。这之后，在循环内就没有理由再访问images的HTMLCollection了。<br>编写JavaScript的时候，一定要知道何时返回HTMLCollection对象，这样你就可以最小化对他们的访问。发生以下情况时会返回HTMLCollection对象：</p>
<ul>
<li><strong>进行了对getElementsByTagName()的调用；</strong></li>
<li><strong>获取了元素的childNodes属性；</strong></li>
<li><strong>获取了元素的attributes属性；</strong></li>
<li><strong>访问了特殊的集合，如document.forms、document.images等。</strong></li>
</ul>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3 部署"></a>3 部署</h2><p>也许所有JavaScript解决方案最重要的部分，便是最后部署到运营中的网站或者是Web应用的过程。在这之前可能你已经做了相当多的工作，为普通的使用进行架构并优化一个解决方案。现在是时候从开发环境中走出来并进入Web阶段了。在此将会和真正的用户交互。然而，在这之前还有一系列需要解决的问题。</p>
<h3 id="3-1-构建过程"><a href="#3-1-构建过程" class="headerlink" title="3.1 构建过程"></a>3.1 构建过程</h3><p>完备JavaScript代码可以用于部署的－件很重要的事情，就是给它开发某些类型的构建过程。软件开发的典型模式是写代码-编译-测试，即首先书写好代码，将其编译通过，然后运行并确保其正常工作。 由于JavaScript并非一个编译型语言，模式变成了写代码－测试，这里你写的代码就是你要在浏览器中测试的代码。这个方法的问题在于它不是最优的，你写的代码不应该原封不动地放入浏览器中，理由如下所示。</p>
<ul>
<li>知识产权问题一一如果把带有完整注释的代码放到线上，那别人就更容易知道你的意图，对它再利用，并且可能找到安全漏洞。</li>
<li>文件大小一一书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。 浏览器并不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。</li>
<li>代码组织一一组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。</li>
</ul>
<p>基于这些原因，最好给JavaScript文件定义一个构建过程。</p>
<p>构建过程始于在源控制中定义用于存储文件的逻辑结构。最好避免使用－个文件存放所有的JavaScript，遵循以下面向对象语言中的典型模式：<strong>将每个对象或自定义类型分别放入其单独的文件中。</strong> 这样可以确保每个文件包含最少量的代码，使其在不引入错误的情况下更容易修改。另外，在使用像CVS或Subversion这类并发源控制系统的时候，这样做也减少了在合并操作中产生冲突的风险。<br>记住将代码分离成多个文件只是为了提高可维护性，并非为了部署。要进行部署的时候，需要将这些源代码合并为一个或几个归并文件。推荐Web应用中尽可能使用最少的JavaScript文件，是因为HTTP请求是Web中的主要性能瓶颈之一。 记住通过<code>&lt;script&gt;</code>标记引用JavaScript文件是一个阻塞操作，当代码下载并运行的时候会停止其他所有的下载。因此，尽量从逻辑上将JavaScript代码分组成部署文件。<br>－旦组织好文件和目录结构，并确定哪些要出现在部署文件中，就可以创建构建系统了。Ant构建工具（<a href="http://antapache.org）是为了自动化Java构建过程而诞生的，不过因为其易用性和应用广泛，而在Web应用开发人员中也颇流行，诸如Julien" target="_blank" rel="noopener">http://antapache.org）是为了自动化Java构建过程而诞生的，不过因为其易用性和应用广泛，而在Web应用开发人员中也颇流行，诸如Julien</a> Lecomte的软件工程师，已经写了教程指导如何使用Ant进行JavaScript和css的构建自动化（Lecomte的文章在<a href="http://www.julienlecomte.net/blog/2007/09/16/）。" target="_blank" rel="noopener">www.julienlecomte.net/blog/2007/09/16/）。</a><br>Ant由于其简便的文件处理能力而非常适合JavaScript编译系统。其使用方法在此不做介绍。</p>
<p>~~~<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack</a></p>
<h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>尽管现在出现了一些可以理解并支持JavaScript的IDE，大多数开发人员还是要在浏览器中运行代码以检查其语法。这种方法有一些问题。首先，验证过程难以自动化或者在不同系统间直接移植。其次，除了语法错误外，很多问题只有在执行代码的时候才会遇到，这给错误留下了空间；有些工具可以帮助确定JavaScript代码中潜在的问题，其中最著名的就是Douglas Crockford的JSLint（<a href="http://www.jslint.com）。" target="_blank" rel="noopener">www.jslint.com）。</a><br>JSLint可以查找JavaScript代码中的语法错误以及常见的编码错误。它可以发掘的一些潜在问题如下：</p>
<ul>
<li>eval()的使用；</li>
<li>未声明变量的使用；</li>
<li>遗漏的分号；</li>
<li>不恰当的换行；</li>
<li>错误的逗号使用；</li>
<li>语句周围遗漏的括号：</li>
<li>switch分支语句中遗漏的break;</li>
<li>重复声明的变量；</li>
<li>with的使用；</li>
<li>错误使用的等号（替代了双等号或三等号）；</li>
<li>无法到达的代码。</li>
</ul>
<p>为了方便访问，它有一个在线版本。不过它也可以使用基于Java的Rhino JavaScript引擎（<a href="http://www.mozilla.org/rhino/）运行于命令行模式下。要在命令行中运行JSLint，首先要下载Rhino，并从www.jslint.com/下载Rhino版本的JSLint。－旦安装完成，便可以使用下面的语法从命令行运行JSLint了：" target="_blank" rel="noopener">www.mozilla.org/rhino/）运行于命令行模式下。要在命令行中运行JSLint，首先要下载Rhino，并从www.jslint.com/下载Rhino版本的JSLint。－旦安装完成，便可以使用下面的语法从命令行运行JSLint了：</a><br>如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rhino<span class="number">-1.6</span>R7.jar jslint.js a.js b.js c.js</span><br></pre></td></tr></table></figure></p>
<p>如果给定文件中有任何语法问题或者是潜在的错误，则会输出有关错误和警告的报告。如果没有问题，代码会直接结束而不显示任何信息。</p>
<p>给开发周期添加代码验证这个环节有助于避免将来可能出现的－些错误。建议开发人员给构建过程加入某种类型的代码验证作为确定潜在问题的一个方法，防患于未然。</p>
<p>jslint、<a href="https://cn.eslint.org/" target="_blank" rel="noopener">eslint</a></p>
<h3 id="3-3-压缩"><a href="#3-3-压缩" class="headerlink" title="3.3 压缩"></a>3.3 压缩</h3><p>当谈及JavaScript文件压缩，其实在讨论两个东西：代码长度和配重（Wire weight）。<strong>代码长度指的是浏览器所需解析的字节数，配重指的是实际从服务器传送到浏览器的字节数</strong>。在Web开发的早期，这两个数字几乎是一样的，因为从服务器端到客户端原封不动地传递了源文件。而在今天的Web上，这两者很少相等，实际上也不应相等。</p>
<h4 id="1-文件压缩"><a href="#1-文件压缩" class="headerlink" title="1.文件压缩"></a>1.文件压缩</h4><p>因为JavaScript并非编译为字节码，而是按照源代码传送的，代码文件通常包含浏览器执行所不需要的额外的信息和格式。注释，额外的空白，以及长长的变量名和函数名虽然提高了可读性，但却是传送给浏览器时不必要的字节。不过，我们可以使用压缩工具减少文件的大小。<br>压缩器一般进行如下一些步骤： </p>
<ul>
<li>删除额外的空白（包括换行）；</li>
<li>删除所有注释；</li>
<li>缩短变量名。</li>
</ul>
<p>JavaScript有不少压缩工具可用（附录D中有一个完整列表），其中最优秀的（有争议的）是YUI压缩器，不过多介绍</p>
<h4 id="2-HTTP压缩"><a href="#2-HTTP压缩" class="headerlink" title="2.HTTP压缩"></a>2.HTTP压缩</h4><p>配置指的是实际从服务器传送到浏览器的字节数。因为现在的服务器和浏览器都有压缩功能，这个字节数不一定和代码长度一样。所有的五大Web浏览器（IE、Firefox、Safari、Chrome和Opera）都支持对所接收的资源进行客户端解压缩。这样服务器端就可以使用服务器端相关功能来压缩JavaScript文件。 一个指定了文件使用了给定格式进行了压缩的HTTP头包含在了服务器响应中。接着浏览器会查看该HTTP头确定文件是否已被压缩，然后使用合适的格式进行解压缩。结果是和原来的代码量相比在网络中传递的字节数量大大减少了。<br><strong>对于ApacheWeb服务器，有两个模块可以进行HTTP压缩：mod_gzip(Apache 1.3.x）和mod_deflate（Apache 2.0.x）。对于mod_gzip，可以给httpd.conf文件或者是.htaccess文件添加以下代码启用对JavaScript的自动压缩：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#告诉mod_zip要包含任何以.js结尾的文件</span><br><span class="line">mod_gzip_item_include  file \.js$</span><br></pre></td></tr></table></figure></p>
<p>该行代码告诉mod_zip要包含来自浏览器请求的任何以.js结尾的文件。假设你所有的JavaScript文件都以.js结尾，就可以压缩所有请求并应用合适的HTTP头以表示内容已被压缩。</p>
<p>对于mod_deflate，可以类似添加一行代码以保证JavaScript文件在被发送之前已被压缩。将以下这一行代码添加到httpd.conf文件，或者是.htaccess文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 告诉mod_deflate要包含所有的JavaScript文件</span><br><span class="line">AddOutputFilterByType DEFLATE application/x-javascript</span><br></pre></td></tr></table></figure></p>
<p>注意这－行代码用到了响应的MIME类型来确定是否对其进行压缩。记住虽然<code>&lt;script&gt;</code>的type属性用的是text/javascript，但是JavaScript文件一般还是用application/x-javascript作为其服务的MIME类型。<br>mod_gzip和mod_deflate都可以节省大约70%的JavaScript文件大小。 这很大程度上是因为JavaScript都是文本文件，因此可以非常有效地进行压缩。减少文件的配重可以减少需要传输到浏览器的时间。记住有一点点细微的代价，因为服务都必须花时间对每个请求压缩文件，当浏览器接收到这些文件后也需要花一些时间解压缩。不过，一般来说，这个代价还是值得的。</p>
<blockquote>
<p>大部分Web服务器，开源的或是商业的，都有一些HTTP压缩功能。请查看服务器的文档说明以确定如何合适地配置压缩。</p>
</blockquote>
<p>温习：</p>
<ul>
<li>可维护的代码的特征，变量、解耦；</li>
<li>js性能优化，查找、执行、DOM；</li>
<li>部署，构建、验证、压缩；</li>
</ul>
<p>（完） </p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2018/11/16/senior_javascript/重温《JavaScript高级程序设计》—27-“新兴”的API/" class="prev">上一篇<span>重温《JavaScript高级程序设计》—27-“新兴”的API</span></a></div><div class="post-next"><a href="/2018/11/03/senior_javascript/重温《JavaScript高级程序设计》—25-离线应用与客户端存储/" class="next">下一篇<span>重温《JavaScript高级程序设计》—25-离线应用与客户端存储</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> 近期文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/02/11/notes/【笔记】2022跨端及小程序的一些文章书籍等整理/">【笔记】2022 跨端及小程序的一些文章书籍等整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/notes/【笔记】StateOfJs2022中的ES语言特性/">【笔记】State Of Js2022中的ES语言特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/02/notes/【笔记】《演进式架构》（三）/">【笔记】《演进式架构》学习笔记（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/17/notes/【笔记】《演进式架构》（二）/">【笔记】《演进式架构》学习笔记（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/10/notes/【笔记】《演进式架构》（一）/">【笔记】《演进式架构》学习笔记（一）</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> 标签</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/">prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serviceWorker/">serviceWorker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形处理/">图形处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨端/">跨端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> 归档</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2023 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script></body></html>