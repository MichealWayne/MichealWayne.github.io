<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 重温《JavaScript高级程序设计》—25-离线应用与客户端存储 | Wayne的博客</title><meta name="description" content="重温《JavaScript高级程序设计》—25-离线应用与客户端存储 - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><script>(function (w) {w.frontjsConfig={token:"81a82620fb0dca7680f2f06be134fa4f",behaviour:8,FPSThreshold:10};w.frontjsTmpData = {r:[],e:[],l:[]};w.frontjsTmpCollector = function (ev) {(ev.message ? window.frontjsTmpData.e : window.frontjsTmpData.r).push([new Date().getTime(), ev])};w.FrontJS = {addEventListener: function (t, f) {w.frontjsTmpData.l.push([t, f]);return f;},removeEventListener: function (t, f) {for (var i = 0; i < w.frontjsTmpData.l.length; i++) {t === w.frontjsTmpData.l[i][0] && f === w.frontjsTmpData.l[i][1] && w.frontjsTmpData.l.splice(i, 1);}return f;}};w.document.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("load", function () {var n = w.document.createElement("script");n.src = "https://frontjs-static.pgyer.com/dist/current/frontjs.web.min.js"; w.document.body.appendChild(n);}, true);})(window);</script><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">Home</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">Archive</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">About</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="search" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">重温《JavaScript高级程序设计》—25-离线应用与客户端存储</h1><span class="post-date">Nov 3, 2018</span><span class="post-tag"><a href="/tags/前端/">前端</a><a href="/tags/js/">js</a></span><img src="/images/20171105/icon.png" class="bgimage"><div class="post-content"><h5 id="本篇内容"><a href="#本篇内容" class="headerlink" title="本篇内容"></a>本篇内容</h5><ul>
<li>离线检测</li>
<li>应用缓存</li>
<li>数据存储</li>
</ul>
<hr>
<p>支持离线Web应用开发是HTML5的另一个重点。所谓离线Web应用，就是在设备不能上网的情况下仍然可以运行的应用。HTML5把离线应用作为重点，主要是基于开发人员的心愿。前端开发人员一直希望Web应用能够与传统的客户端应用同场竞技，起码做到只要设备有电就能使用。<br>开发离线Web应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图像、JavaScript、css等）。只有这样才能正常工作。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。HTML5及其相关的API让开发离线应用成为现实。</p>
<h2 id="1-离线检测"><a href="#1-离线检测" class="headerlink" title="1 离线检测"></a>1 离线检测</h2><p>开发离线应用的第一步是要知道设备是在线还是离线，HTML5为此定义了一个<strong>navigator.onLine</strong>属性，这个属性值为true表示设备能上网，值为false表示设备离线。这个属性的关键是浏览器必须知道设备能否访问网络，从而返回正确的值。实际应用中，navigator.onLine在不同浏览器间还有一些小的差异。</p>
<ul>
<li>IE6+和Safari5+能够正确检测到网络已断开，并将navigator.onLine的值转换为false。</li>
<li>Firefox3+和Opera 10.6+支持navigator.onLine属性，但你必须手工选中菜单项“文件→Web开发人员（设置）→脱机工作“才能让浏览器正常工作。</li>
<li>Chrome 11及之前版本始终将navigator.onLine属性没置为true。这是－个有待修复的bug。</li>
</ul>
<p>由于存在上述兼容性问题，单独使用navigator.onLine属性不能确定网络是否连通。即使如此，在请求发生错误的情况下，检测这个属性仍然是管用的。以下是检测该属性状态的示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.onLine) &#123;</span><br><span class="line">	<span class="comment">// 正常工作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 执行离线状态时的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除navigator.onLine属性之外，为了更好地确定网络是否可用，HTML5还定义了两个事件： <strong>online和offline</strong>。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。<strong>这两个事件在window对象上触发。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'online'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'online'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'offline'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为了检测应用是否离线，在页面加载后，最好先通过navigator.onLine取得初始的状态。然后，就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发时，navigator.onLine属性的值也会改变，不过必须要手工轮询这个属性才能检测到网络状态的变化。<br>支持离线检测的浏览器有IE6+（只支持navigator.onLine属性）、Firefox3, Safari4、Opera10.6、Chrome、iOS3.2版Safari和Android版WebKit。</p>
<h2 id="2-应用缓存"><a href="#2-应用缓存" class="headerlink" title="2 应用缓存"></a>2 应用缓存</h2><p>HTML5的应用缓存（application cache），或者简称为appcache，是专门为开发离线Web应用而设计的。Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。下而是一个简单的描述文件示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#Comment</span><br><span class="line"></span><br><span class="line">file.js</span><br><span class="line">file.css</span><br></pre></td></tr></table></figure></p>
<p>在最简单的情况下，描述文件中列出的都是需要下载的资源，以备离线时使用。</p>
<p>要将描述文件与页面关联起来，可以在<code>&lt;html&gt;</code>中的manifest属性中指定这个文件的路径，例如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"/offline.manifest"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码告诉页面，/offline.manifest中包含着描述文件。这个文件的MIME类型必须是 text/cache-manifest</p>
<blockquote>
<p>描述文件的扩展名以前推荐用manifest，但现在推荐的是appcache。</p>
</blockquote>
<p>虽然应用缓存的意图是确保离线时资源可用，但也有相应的JavaScriptAPI让你知道它都在做什么。这个API的核心是applicationcache对象，这个对象有一个status属性，属性的值是常量，表示应用缓存的如下当前状态。</p>
<ul>
<li>0：无缓存，即没有与页面相关的应用缓存。</li>
<li>1：闲置，即应用缓存未得到更新。</li>
<li>2：检查中，即正在下载描述文件并检查更新。</li>
<li>3：下载中，即应用缓存正在下载描述文件中指定的资源。</li>
<li>4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了。</li>
<li>5：废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存。</li>
</ul>
<p>应用缓存还有很多相关的事件，表示其状态的改变。以下是这些事件。</p>
<ul>
<li>checking：在浏览器为应用缓存资找更新时触发。</li>
<li>error：在检查更新或下载资源期间发生错误时触发。</li>
<li>noupdate ：在检查描述文件发现文件元变化时触发。</li>
<li>downloading：在开始下载应用缓存资源时触发。</li>
<li>progress：在文件下载应用缓存的过程中持续不断地触发。</li>
<li>updateready：在页面新的应用缓存下载完毕且可以通过swapCache()使用时触发。</li>
<li>cached：在应用缓存完整可用时触发。</li>
</ul>
<p>一般来讲，这些事件会随着页面加载按上述顺序依次触发。不过，通过调用<strong>update()</strong>方法也可以手工干预，让应用缓存为检查更新而触发上述事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.update();</span><br></pre></td></tr></table></figure></p>
<p>update()一经调用，应用缓存就会去检查描述文件是否更新（触发checking事件），然后就像页面刚刚加载一样，继续执行后续操作。如果触发了cached事件，就说明应用缓存已经准备就绪，不会再发生其他操作了。如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时你需要调用swapCache()来启用新应用缓存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(applicationCache, <span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	applicationCache.swapCache();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>支持HTML5应用缓存的浏览器有Firefox 3+、Safari 4+、Opera 10.6、Chrome、iOS 3.2+版Safari及Android版WebKit。在Firefox 4及之前版本中调用swapCache()会抛出错误。</p>
<h2 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3 数据存储"></a>3 数据存储</h2><p>随着Web应用程序的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。想法很合乎逻辑，属于某个特定用户的信息应该存在该用户的机器上。无论是登录信息、偏好设定或其他数据，Web应用提供者发现他们在找各种方式将数据存在客户端上。这个问题的第一个方案是以cookie的形式出现的。cookie是原来的网景公司创造的。一份题为“PersistentClient State: HTIP Cookies”的标准中对cookie机制进行了阐述。今天，cookie只是在客户端存储数据的其中一种选项。</p>
<h3 id="3-1-Cookie"><a href="#3-1-Cookie" class="headerlink" title="3.1 Cookie"></a>3.1 Cookie</h3><p>HTTP Cookie，通常直接叫做cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意HTTP请求发送SetCookieHTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p>
<p>这个HTTP响应设置以name为名称、以value为值的一个cookie，名称和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP头将信息发送回服务器，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Cookie: name=value</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p>
<p>发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求。</p>
<h4 id="1-限制"><a href="#1-限制" class="headerlink" title="1. 限制"></a>1. 限制</h4><p>cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。这个限制确保了储存在cookie中的信息只能让批准的接受者访问，而无法被其他域访问。<br>由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。每个域的cookie总数是有限的，不过浏览器之间各有不同。如下所示。</p>
<ul>
<li>IE6以及更低版本限制每个域名最多20个cookie。</li>
<li>IE7和之后版本每个域名最多50个。IE7最初是支持每个域名最大20个cookie，之后被微软的一个补丁所更新。</li>
<li>Firefox限制每个城最多 50 个cookie。</li>
<li>Opera限制每个域最多30个cookie。</li>
<li>Safari和Chrome对于每个域的cookie数量限制没有硬性规定。</li>
</ul>
<p><strong>当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie</strong>。IE和Opera会删除最近最少使用过的（LRU, Least Recently Used）cookie，腾出空间给新设置的cookie。Firefox看上去好像是随机决定要消除哪个cookie，所以考虑cookie限制非常重要，以免出现不可预期的后果。<br>浏览器中对于cookie的尺寸也有限制。大多数浏览报都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie长度限制在4095B（含4095）以内。尺寸限制影响到一个域下所有的cookie，而并非每个cookie单独限制。<br>如果你尝试创建超过最大尺寸限制的cookie，那么该cookie会被悄无声息地丢掉。注意，虽然一个字符通常占用一字节，但是多字节情况则有不同。</p>
<h4 id="2-cookie的构成"><a href="#2-cookie的构成" class="headerlink" title="2. cookie的构成"></a>2. cookie的构成</h4><p>cookie由浏览器保存的以下几块信息构成。</p>
<ul>
<li><strong>名称</strong>：一个唯一确定cookie的名称。cookie名称是不区分大小写的，所以myCookie和MyCookie被认为是同一个cookie。 然而，实践中最好将cookie名称看作是区分大小写的，因为某些服务器会这样处理cookie。cookie的名称必须是经过URL编码的。</li>
<li><strong>值</strong>：储存在cookie中的字符串值。值必须被URL编码。</li>
<li><strong>域</strong>：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域（subdomain,如<a href="http://www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域。" target="_blank" rel="noopener">www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域。</a></li>
<li><strong>路径</strong>：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie只有从<a href="http://www.wrox.com/book中才能访问，那http://www.wrox.com的页面就不会发送cookie信息，即使请求都是来自同一个域的。" target="_blank" rel="noopener">http://www.wrox.com/book中才能访问，那http://www.wrox.com的页面就不会发送cookie信息，即使请求都是来自同一个域的。</a></li>
<li><strong>失效时间</strong>：表示cookie何时应该被删除的时间戳（也就是，何时应该停止向服务帮发送这个cookie）。默认情况下，浏览器会话结束时即将所有cookie删除；不过也可以臼己设置删除时间。这个值是个GMT格式的日期（Wdy,DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie的准确时间。因此，cookie可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则cookie会被立刻删除。</li>
<li><strong>安全标志</strong>：指定后，cookie只有在使用SSL连接的时候才发送到服务器。例如，cookie信息只能发送给<a href="https://www.wrox.com，而http://www.wrox.com的请求则不能发送cookie。" target="_blank" rel="noopener">https://www.wrox.com，而http://www.wrox.com的请求则不能发送cookie。</a></li>
</ul>
<p>每一段信息、都作为Set-Cookie头的一部分．使用分号加空中各分隔每一段，如下例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p>
<p>该头信息指定了一个叫做name的cookie，它会在格林威治时间2007年1月22日7:10:24失效，同时对于<a href="http://www.wrox.com和wrox.com的任何子域（如p2p.wrox.com）都有效。" target="_blank" rel="noopener">www.wrox.com和wrox.com的任何子域（如p2p.wrox.com）都有效。</a></p>
<p><strong>secure标志是cookie中唯一一个非名值对儿的部分，直接包含一个secure单词</strong>。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value; domain=.wrox.com; path=/; secure</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p>
<p>这里，创建了一个对于所有wrox.com的子域和域名下（由path参数指定的）所有页面都有效的cookie。因为设置了secure标志，这个cookie只能通过SSL连接才能传输。<br>尤其要注意，域、路径、失效时间和secure标志都是服务器给浏览器的指示，以指定何时应该发送cookie。这些参数并不会作为发送到服务器的cookie信息的一部分，只有名值对儿才会被发送。</p>
<h4 id="3-JavaScript中的cookie"><a href="#3-JavaScript中的cookie" class="headerlink" title="3. JavaScript中的cookie"></a>3. JavaScript中的cookie</h4><p>在JavaScript中处理cookie有些复杂，因为其众所周知的蹩脚的接口，即BOM的document.cookie属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为。当用来获取属性值时，document.cookie返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由乡间－隔开的名值对儿，如下例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name1=value1;name2=value2;name3=value3;</span><br></pre></td></tr></table></figure></p>
<p><strong>所有名字和值都是经过URL编码的，所以必须使用decodeURIComponent()来解码。</strong><br>当用于设置值的时候，document.cookie属性可以设置为一个新的cookie字符串。这个cookie字符串会被解释并添加到现有的cookie集合中。设置document.cookie并不会覆盖cookie，除非设置的cookie的名称已经存在。设置cookie的格式如下，和Set-Cookie头中使用的格式－祥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value;expires=expiration_time;path=domain_path;domain=domain_name;secure</span><br></pre></td></tr></table></figure></p>
<p>这些参数中，只有cookie的名字和值是必需的。下面是一个简单的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=Micheal'</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码创建了一个叫name的cookie，值为Nicholas。当客户端每次向服务器端发送请求的时候，都会发送这个cookie；当浏览器关闭的时候，它就会被删除。虽然这段代码没问题，但因为这里正好名称和值都无需编码，所以最好每次设置cookie时都像下面这个例子中一样使用encodeURIComponent()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">'Micheal'</span>);</span><br></pre></td></tr></table></figure>
<p>要给被创建的cookie指定额外的信息，只要将参数追加到该字符串，和Set-Cookie头中的格式一样，如下所示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">'Micheal'</span>) + <span class="string">'; domain=.michealwayne.cn; path=/'</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于JavaScript中读写cookie不是非常直观，常常需要写一些函数来简化cookie的功能。基本的cookie操作有三种：读取、写入和删除。它们在cookieUtil对象中如下表示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CookieUtil = &#123;</span><br><span class="line">	<span class="keyword">get</span>: function (name) &#123;</span><br><span class="line">		<span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>,</span><br><span class="line">			cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</span><br><span class="line">			cookieValue = <span class="literal">null</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">			<span class="keyword">if</span> (cookieEnd === <span class="number">-1</span>) cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">			cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> cookieValue;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">set</span>: function (name, value, expires, path, domain, secure) &#123;</span><br><span class="line">		<span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">			cookieText += <span class="string">'; expires='</span> expires.toGMTString();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (path) &#123;</span><br><span class="line">			cookieText += <span class="string">'; path='</span> + path;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (domain) &#123;</span><br><span class="line">			cookieText += <span class="string">'; domain='</span> + domain;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (secure) &#123;</span><br><span class="line">			cookieText += <span class="string">'; secure'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	unset: <span class="function"><span class="keyword">function</span> (<span class="params">name, path, domain, secure</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.set(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>CookieUtil.get()方法根据cookie的名字获取相应的值。它会在document.cookie字符串中查找cookie名加上等于号的位置。如果找到了，那么使用indexOf()查找该位置之后的第一个分号（表示了该cookie的结束位置）。 如果没有找到分号，则表示该cookie是字符串中的最后一个，则余下的字符串都是cookie的值。该值使用decodeURIComponent()进行解码并最后返回。如果没有发现cookie，则返回null。<br>CookieUtil.set()方法在页面上设置一个cookie，接收如下几个参数：cookie的名称，cookie的值，可选的用于指定cookie何时应被删除的Date对象，cookie的可选的URL路径，可选的域，以及可选的表示是否要添加secure标志的布尔值。参数是按照它们的使用频率排列的，只有头两个是必需的。在这个方法中，名称和值都使用encodeURIComponent()进行了URL编码，并检查其他选项。如果expires 参数是Date对象，那么会使用Date对象的toGMTString()方法正确格式化Date对象，并添加到expires选项上。方法的其他部分就是构造cookie字符申并将其设置到document.cookie中。<br>没有删除己有cookie的直接方法。所以，需要使用相同的路径、域和安全选项再次设置cookie，并将失效时间设置为过去的时间。CookieUtil.unset()方法可以处理这种事情。它接收4个参数：要删除的cookie的名称、可选的路径参数、可选的域参数和可选的安全参数。<br>这些参数加上空字符串并设置失效时间为1970年1月1日（初始化为0ms的Date对象的值）．传给CookieUtil.set()。 这样就能确保删除cookie。</p>
<h4 id="4-子cookie"><a href="#4-子cookie" class="headerlink" title="4.子cookie"></a>4.子cookie</h4><p>为了绕开浏览器的单域名下的cookie数限制，一些开发人员使用了一种称为子cookie(subcookie)的概念。 <strong>子cookie是存放在单个cookie中的更小段的数据</strong>。也就是使用cookie值来存储多个名称值对儿。子cookie最常见的的格式如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=name1=value1&amp;name2=value2&amp;name3=value3</span><br></pre></td></tr></table></figure></p>
<p>子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问，而非对每个名称－值对儿使用不同的cookie存储。最后网站或者Web应用程序可以无需达到单域名cookie上限也可以存储更加结构化的数据。<br>为了更好地操作子cookie，必须建立一系列新方法。子cookie的解析和序列化会因子cookie的期望用途而略有不同并更加复杂些。例如，要获得一个子cookie，首先要遵循与获得cookie一样的基本步骤．但是在解码cookie值之前，需要按如下方法找出子cookie的信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SubCookieUtil = &#123;</span><br><span class="line">	<span class="keyword">get</span>: function (name, subName) &#123;</span><br><span class="line">		<span class="keyword">var</span> subCookies = <span class="keyword">this</span>.getAll(name);</span><br><span class="line">		<span class="keyword">if</span> (subCookies) &#123;</span><br><span class="line">			<span class="keyword">return</span> subCookies(subName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	getAll: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>,</span><br><span class="line">			cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</span><br><span class="line">			cookieValue = <span class="literal">null</span>,</span><br><span class="line">			cookieEnd,</span><br><span class="line">			subCookies,</span><br><span class="line">			i,</span><br><span class="line">			parts,</span><br><span class="line">			result = &#123;&#125;;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">			cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">			<span class="keyword">if</span> (cookieEnd &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">				cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">			&#125;</span><br><span class="line">			cookieValue = <span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (cookieValue.length &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">				subCookies = cookieValue.split(<span class="string">'&amp;'</span>);</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>, len = subCookies.length; i &lt; len; i++) &#123;</span><br><span class="line">					parts = subCookies[i].split(<span class="string">'&amp;'</span>);</span><br><span class="line">					result[<span class="built_in">decodeURIComponent</span>(parts[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(parts[<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> result</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取子cookie的方法有两个：get()和getAll()。其中get()获取单个子cookie的值，getAll()在取所有子cookie并将它们放入一个对象中返回，对象的属性为子cookie的名称，对应值为子cookie对应的值。get()方法接收两个参数：cookie的名字和子cookie的名字。它其实就是调用getAll()获取所有的子cookie，然后只返回所需的那一个（如果cookie不存在则返回null）。</p>
<p>SubCookieUtil.getAll()方法和CookieUtil.get()在解析cookie值的方式上非常相似。区别在于cookie的值并非立即解码，而是先根据＆字符将于cookie分割出来放在一个数组中，每一个子cookie再根据等于号分割，这样在parts数组中的前一部分便是子cookie名，后一部分则是子cookie的值。 这两个项目都要使用decodeURIComponent()来解码，然后放入result对象中，最后作为方法的返回值。如果cookie不存在，则返回null。</p>
<p>要设置子cookie，也有两种方法：set()和setAll()。以下代码展示了它们的构造。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SubCookieUtil = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>: function (name, subName)&#123;</span><br><span class="line">        <span class="keyword">var</span> subCookies = <span class="keyword">this</span>.getAll(name);</span><br><span class="line">        <span class="keyword">if</span> (subCookies)&#123;</span><br><span class="line">            <span class="keyword">return</span> subCookies[subName];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getAll: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span>,</span><br><span class="line">            cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</span><br><span class="line">            cookieValue = <span class="literal">null</span>,</span><br><span class="line">            cookieEnd,</span><br><span class="line">            subCookies,</span><br><span class="line">            i,</span><br><span class="line">            parts,</span><br><span class="line">            result = &#123;&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">            cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>, cookieStart)</span><br><span class="line">            <span class="keyword">if</span> (cookieEnd == <span class="number">-1</span>)&#123;</span><br><span class="line">                cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">            &#125;</span><br><span class="line">            cookieValue = <span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cookieValue.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                subCookies = cookieValue.split(<span class="string">"&amp;"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>, len=subCookies.length; i &lt; len; i++)&#123;</span><br><span class="line">                    parts = subCookies[i].split(<span class="string">"="</span>);</span><br><span class="line">                    result[<span class="built_in">decodeURIComponent</span>(parts[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(parts[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span>: function (name, subName, value, expires, path, domain, secure) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> subcookies = <span class="keyword">this</span>.getAll(name) || &#123;&#125;;</span><br><span class="line">        subcookies[subName] = value;</span><br><span class="line">        <span class="keyword">this</span>.setAll(name, subcookies, expires, path, domain, secure);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    setAll: <span class="function"><span class="keyword">function</span>(<span class="params">name, subcookies, expires, path, domain, secure</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span>,</span><br><span class="line">            subcookieParts = <span class="keyword">new</span> <span class="built_in">Array</span>(),</span><br><span class="line">            subName;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (subName <span class="keyword">in</span> subcookies)&#123;</span><br><span class="line">            <span class="keyword">if</span> (subName.length &gt; <span class="number">0</span> &amp;&amp; subcookies.hasOwnProperty(subName))&#123;</span><br><span class="line">                subcookieParts.push(<span class="built_in">encodeURIComponent</span>(subName) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(subcookies[subName]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (subcookieParts.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cookieText += subcookieParts.join(<span class="string">"&amp;"</span>);</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">                cookieText += <span class="string">"; expires="</span> + expires.toGMTString();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (path) &#123;</span><br><span class="line">                cookieText += <span class="string">"; path="</span> + path;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">                cookieText += <span class="string">"; domain="</span> + domain;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">                cookieText += <span class="string">"; secure"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cookieText += <span class="string">"; expires="</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)).toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">document</span>.cookie = cookieText;        </span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    unset: <span class="function"><span class="keyword">function</span> (<span class="params">name, subName, path, domain, secure</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subcookies = <span class="keyword">this</span>.getAll(name);</span><br><span class="line">        <span class="keyword">if</span> (subcookies)&#123;</span><br><span class="line">            <span class="keyword">delete</span> subcookies[subName];</span><br><span class="line">            <span class="keyword">this</span>.setAll(name, subcookies, <span class="literal">null</span>, path, domain, secure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    unsetAll: <span class="function"><span class="keyword">function</span>(<span class="params">name, path, domain, secure</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setAll(name, <span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-关于cookie的思考"><a href="#5-关于cookie的思考" class="headerlink" title="5.关于cookie的思考"></a>5.关于cookie的思考</h4><p>还有一类cookie被称为“HTTP专有cookie”。HTTP专有cookie可以从浏览器或者服务器设置，但是只能从服务器端读取，因为JavaScript无法获取HTTP专有cookie的值。<br>由于所有的cookie都会自浏览器作为请求头发送。所以在cookie中存储大量信息会影响到特定域的请求性能。<strong>cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览椿对cookie进行了大小限制，不过最好还是尽可能在cookie中少存储信息，以避免影响性能。</strong><br>cookie的性质和它的局限使得其并不能作为在储大量信息的理想手段，所以又出现了其他方法。</p>
<blockquote>
<p>一定不要在cookie中存储重要和敏感的数据。cookie数据并非存储在一个安全环境中，其中包含的任何数据都可以被他人访问。所以不要在cookie中存储诸如信用卡号或者个人地址之类的极据。</p>
</blockquote>
<h3 id="3-2-IE用户数据"><a href="#3-2-IE用户数据" class="headerlink" title="* 3.2 IE用户数据"></a>* 3.2 IE用户数据</h3><p>不作介绍</p>
<h3 id="3-3-Web-存储机制"><a href="#3-3-Web-存储机制" class="headerlink" title="3.3 Web 存储机制"></a>3.3 Web 存储机制</h3><p>Web Storage最早是在Web超文本应用技术工作组（WHAT-WG）的Web应用1.0规范中描述的。 这个规范的最初的工作最终成为了HTML5的一部分。WebStorage的目的是克服自cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：</p>
<ul>
<li>提供一种在cookie之外存储会话数据的途径：</li>
<li>提供一种存储大量可以跨会话存在的数据的机制。</li>
</ul>
<p>最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个对象在支持的浏览器中都是以windows对象属性的形式存在的，支持这两个属性的浏览器包括IE8+、Firefox 3.5+、 Chrome4+和 Opera 10.5+。</p>
<h4 id="1-storage类型"><a href="#1-storage类型" class="headerlink" title="1.storage类型"></a>1.storage类型</h4><p>Storage类型提供最大的存储空间（因浏览器而异）来存储名值对儿。Storage的实例与其他对象类似，有如下方法。</p>
<ul>
<li><strong>clear()</strong>: 删除所有值；Firefox中没有实现。</li>
<li><strong>getItem(name)</strong>：根据指定的名字name获取对应的值 。</li>
<li><strong>key(index)</strong>：获得index位置处的值的名字。</li>
<li><strong>removeitem(name)</strong>：删除由name指定的名值对儿。</li>
<li><strong>setitem(name, value)</strong>：为指定的name 设置一个对应的值 。</li>
</ul>
<p>其中，getItem()、removeItem()和setItem()方法可以直接调用，也可通过Storage对象间接调用。因为每个项目都是作为属性存储在该对象上的．所以可以通过点语法或者方括号语法访问属性来读取值，设置也一样，或者通过delete操作符进行删除。不过，我们还建议读者使用方法而不是属性来访问数据，以免某个键会意外重写该对象上已经存在的成员。<br>还可以使用length属性来判断有多少名值对存放在Storage对象中。但无法判断对象中所有数据的大小，不过IE8提供了一个remainingSpace属性，用于获取还可以使用的存储空间的字节数。</p>
<blockquote>
<p>Storage类型只能存储字符串。非字符串的数据在存储之常会被转换成字符串。</p>
</blockquote>
<h4 id="2-sessionStorage对象"><a href="#2-sessionStorage对象" class="headerlink" title="2. sessionStorage对象"></a>2. sessionStorage对象</h4><p><strong>sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭</strong>。这个对象就像会话cookie，也会在浏览器关闭后消失。存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox和WebKit都支待，IE则不行）。<br>因为seesionStorage对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。<br>由于sessionStorage对象其实是Storage的一个实例，所以可以使用setItem()或者直接设置新的属性来存储数据。下面是这两种方法的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法存储数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'Micheal'</span>);</span><br><span class="line"><span class="comment">// 使用属性存储数据</span></span><br><span class="line">sessionStorage.book = <span class="string">'Js'</span>;</span><br></pre></td></tr></table></figure></p>
<p>不同浏览器写入数据方面略有不同。Firefox和WebKit实现了同步写入，所以添加到存储空间中的数据是立刻被提交的。而IE的实现则是异步写入数据，所以在设置数据和将数据实际写入磁盘之间可能有一些延迟。对于少量数据而言，这个差异是可以忽略的。对于大量数据，你会发现IE要比其他浏览器更快地恢复执行，因为它会跳过实际的磁盘写入过程。<br>在IE8中可以强制把数据写入磁盘：在设置新数据之前使用begin()方法，并且在所有设置完成之后调用commit()方法。看以下例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只适用于IE8</span></span><br><span class="line">sessionStorage.begin(); </span><br><span class="line">sessionStorage.name = <span class="string">'Micheal'</span>;</span><br><span class="line">sessionStorage.book = <span class="string">'js'</span>;</span><br><span class="line">sessionStorage.commit();</span><br></pre></td></tr></table></figure></p>
<p>这段代码确保了name和book的值在调用commit()之后立刻被写入磁盘。调用begin()是为了确保在这段代码执行的时候不会发生其他磁盘写入操作。对于少量数据而言，这个过程不是必需的；不过，对于大量数据（如文档之类的）可能就要考虑这种事务形式的方法了。<br>sessionStorage中有数据时，可以使用getItem()或者通过直接访问属性名来获取数据。两种方法的例子如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性读取数据</span></span><br><span class="line"><span class="keyword">var</span> book = sessionStorage.book;</span><br></pre></td></tr></table></figure></p>
<p>还可以通过结合length属性和key()方法来迭代sessionStorage中的值，如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sessionStorage.length; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="keyword">var</span> key = sessionStorage.key(i);</span><br><span class="line">	<span class="keyword">var</span> value = sessionStorage.getItem(key);</span><br><span class="line">	alert(key + <span class="string">'='</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以使用for-in循环来迭代sessionStorage中的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sessionStorage) &#123;</span><br><span class="line">	<span class="keyword">var</span> value = sessionStorage.getItem(key);</span><br><span class="line">	alert(key + <span class="string">'='</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次经过循环的时候，key被设置为sessionStorage中下一个名字，此时不会返回任何内置方法或length属性。<br>要从sessionStorage中删除数据，可以使用delete操作符删除对象属性，也可调用removeItem()方法。以下是这些方法的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用delete（webkit无效）</span></span><br><span class="line"><span class="keyword">delete</span> sessionStorage.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure></p>
<p>sessionStorage对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据，那么globalStorage或者localStorage更为合适。</p>
<h4 id="3-globalStorage对象（兼容目测仅火狐）"><a href="#3-globalStorage对象（兼容目测仅火狐）" class="headerlink" title="*3.globalStorage对象（兼容目测仅火狐）"></a><code>*</code>3.globalStorage对象（兼容目测仅火狐）</h4><p>Firefox 2中实现了globalStorage对象。作为最初的WebStorage规范的一部分，这个对象的目的是跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性米实现，如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">globalStorage[<span class="string">'wrox.com'</span>].name = <span class="string">'Micheal'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">console</span>.log(globalStorage[<span class="string">'wrox.com'</span>].name)</span><br></pre></td></tr></table></figure></p>
<p>在这里，访问的是针对域名wrox.com的存储空间。globalStorage对象不是Storage的实例，而具体的globalStorage[‘wrox.com’]才是。这个存储空间对于wrox.com及其所有子域都是可以访问的。可以像下面这样指定子域名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">globalStorage[<span class="string">'www.wrox.com'</span>].name = <span class="string">'Micheal'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">console</span>.log(globalStorage[<span class="string">'www.wrox.com'</span>].name)</span><br></pre></td></tr></table></figure></p>
<p>某些浏览器允许更加宽泛的访问限制，比如只根据顶级域名进行限制或者允许全局访问，如下面例子所示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">globalStorage[<span class="string">''</span>].name = <span class="string">'Micheal'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据，.net结尾的域名都可访问</span></span><br><span class="line">globalStorage[<span class="string">'net'</span>].name = <span class="string">'Micheal'</span>;</span><br></pre></td></tr></table></figure></p>
<p>虽然这些也支持，但是还是要避免使用这种可宽泛访问的数据存储，以防止出现潜在的安全问题。 考虑到安全问题，这些功能在未来可能会被删除或者是被更严格地限制，所以不应依赖于这类功能。当使用globalStorage的时候－定要指定一个域名。<br>对globalStorage空间的访问，是依据发起请求的页丽的域名、协议和端口来限制的。例如，如果使用HITPS协议在wrox.com中存储了数据，那么通过HTIP访问的wrox.com的页商就不能访问该数据。同样，通过80端口访问的页面则无法与同一个域同样协议但通过8080端口访问的页面共享数据。这类似于Ajax请求的同源策略。</p>
<p>如果不使用removeItem()或者delete删除，或者用户未清除浏览器缓存，存储在 globalStorage属性中的数据会一直保留在磁盘上。这让globalStorage非常适合在客户端存储文皑或者长期保存用户偏好设置。</p>
<h4 id="4-localStorage对象"><a href="#4-localStorage对象" class="headerlink" title="4.localStorage对象"></a>4.localStorage对象</h4><p>localStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则；规则事先就设定好了。<strong>要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host］。</strong><br>由于localStorage是Storage的实例，所以可以像使用sessionStorage一样来使用。下面是一些例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法存储数据</span></span><br><span class="line">localStorage.setItem(<span class="string">'name'</span>, <span class="string">'Micheal'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性存储数据</span></span><br><span class="line">localStorage.book = <span class="string">'js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> name = localStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性读取数据</span></span><br><span class="line"><span class="keyword">var</span> book = localStorage.book;</span><br></pre></td></tr></table></figure></p>
<p>存储在localStorage中的数据和存储在globalStorage中的数据－样，都遵循相同的规则：数据保留到通过JavaScript删除或者是用户消除浏览器缓存。</p>
<p>为了兼容只支持globalStorage的浏览楞，可以使用以下函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocalStorage</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> localStorage === <span class="string">'object'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> localStorage;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> globalStorage === <span class="string">'object'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> globalStorage;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Local storage not available'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-storage事件"><a href="#5-storage事件" class="headerlink" title="5.storage事件"></a>5.storage事件</h4><p>对Storage对象进行任何修改，都会在文档上触发storage事件。<strong>当通过属性或setItem()方法保存数据，使用delete操作符或removeitem()删除数据，或者调用clear()方法时，都会发生该事件。这个事件的event对象有以下属性。</strong></p>
<ul>
<li><strong>domain</strong>：发生变化的存储空间的域名。</li>
<li><strong>key</strong>：设置或者删除的键名。</li>
<li><strong>newValue</strong>：如果是设置值，则是新值；如果是删除键，则是null。</li>
<li><strong>oldValue</strong>：键被更改之前的值。</li>
</ul>
<p>在这四个属性中，IE8和Firefox只实现了domain属性。如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Storage changed for '</span> + event.domain)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>无论对sessionStorage、globalStorage还是localStorage进行操作，都会触发storage事件，但不作区分。</p>
<h4 id="6-限制"><a href="#6-限制" class="headerlink" title="6.限制"></a>6.限制</h4><p>与其他客户端数据存储方案类似，Web Storage同样也有限制。这些限制因浏览器而异。一般来说，对存储空间大小的限制都是以每个来源（协议、域和端口）为单位的。换句话说，每个来源都有固定大小的空间用于保存自己的数据。考虑到这个限制，就要注意分析和控制每个来源中有多少页面需要保存数据。</p>
<ul>
<li><strong>对于localStorage而言，大多数桌面浏览器会设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。而iOS版Safari和Android版WebKit的限制也是2.5MB。</strong><br>– 对sessionStorage的限制也是因浏览器而异。有的浏览器对sessionstorage的大小没有限制，但Chrome、Safari、iOS版Safari和Android版WebKit都有限制，也都是2.5M。IE8+和Opera对sessionStorage的限制是5MB。**</li>
</ul>
<h3 id="3-4-IndexedDB"><a href="#3-4-IndexedDB" class="headerlink" title="3.4 IndexedDB"></a>3.4 IndexedDB</h3><p>Indexed Database API，或者简称为<strong>IndexedDB</strong>，是在浏览器中保存结构化数据的一种数据库。IndexedDB是为了替代目前已被废弃的WebSQL Database API而出现的。IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询及搜索。<br><strong>IndexedDB设计的操作完全是异步进行的</strong>。因此，大多数操作会以请求方式进行，但这些操作会在后期执行，然后如果成功则返回结果，如果失败则返回错误。差不多每一次IndexedDB操作，都需要你注册onerror或onsuccess事件处理程序，以确保适当地处理结果。<br>在得到完整支持的情况下，IndexedDB将是一个作为API宿主的全局对象。由于API仍然可能有变化，浏览器也都使用提供商前缀，因此这个对象在IE10中叫msIndexedDB，在Firefox4中叫mozIndexedDB，在Chrome中叫webkitIndexedDB。为了清楚起见，本节示例中将使用IndexedDB,而实际土每个示例前面都应该加上下面这行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.msIndexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.webkitIndexedDB;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h4><p>IndexedDB就是一个数据库，与MySQL或WebSQL Database等这些你以前可能用过的数据库类似。IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据。一个IndexedDB数据库，就是一组位于相同命名空间下的对象的集合。<br>使用IndexedDB的第一步是打开它，即要打开的数据库名传给indexDB.open()。如果传入的数据库已经存在，就会发送一个打开它的请求；如果传入的数据库还不存在，就会发送一个创建并打开它的请求。总之，调用indexDB.open()会返回一个IDBRequest对象，在这个对象上可以添加onerror和onsuccess事件处理程序。先来看个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request,</span><br><span class="line">	database;</span><br><span class="line"></span><br><span class="line">request = indexedDB.open(<span class="string">'admin'</span>);</span><br><span class="line"></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Something bad happened while trying to open:'</span> + event.target.errorCode);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	database = event.target.result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这两个事件处理程序中，event.target都指向request对象，因此它们可以互换使用。如果响应的是onsuccess事件处理程序，那么event.target.result中将有一个数据库实例对象。（IDBDatabase），这个对象会保存在database变量中。如果发生了错误，那event.target.errorCode中将保存一个错误码，表示问题的性质。一下就是可能的错误码（这个错误码适合所有操作）。</p>
<ul>
<li>IDBDatabaseException.UNKNOW_ERR(1)：意外错误，无法归类。</li>
<li>IDBDatabaseException.NON_TRANSIENT_ERR(2)：操作不合法。</li>
<li>IDBDatabaseException.NO_FOUND_ERR(3)：未发现要操作的数据库。</li>
<li>IDBDatabaseException.CONSTRAINT_ERR(4)：违反了数据库约束。</li>
<li>IDBDatabaseException.DATA_ERR(5)：提供给事务的数据不能满足要求。</li>
<li>IDBDatabaseException.NOT_ALLOWED_ERR(6)：操作不合法。</li>
<li>IDBDatabaseException.TRANSACTION_INACTIVE_ERR(7)：试图重用已完成的事务。</li>
<li>IDBDatabaseException.ABORT_ERR(8)：请求中断，未成功。</li>
<li>IDBDatabaseException.READ_ONLY_ERR(9)：试图在只读模式下写入或修改数据。</li>
<li>IDBDatabaseException.TIMEOUT_ERR(10)：在有效时间内未完成操作。</li>
<li>IDBDatabaseException.QUOTA_ERR(11)：磁盘空间不足。</li>
</ul>
<p>默认情况下，lndexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。为此，可以调用setVersion()方法，传入以字符串形式表示的版本号。同样，调用这个方法也会返回一个请求对象，需要你再指定事件处理程序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (database.version != <span class="string">'1.0'</span>) &#123;</span><br><span class="line">	request = database.setVersion(<span class="string">'1.0'</span>);</span><br><span class="line">	request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'Something bad happened whil trying to set version:'</span> + event.target.errorCode);</span><br><span class="line">	&#125;;</span><br><span class="line">	request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'Database initialization complete. Database name:'</span> + database.name + <span class="string">', Version:'</span> + database.version);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	alert(<span class="string">'Database already initialized.Database name :'</span> + database.name + <span class="string">', Version: '</span> + database.version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子尝试把数据库的版本号设置为1.0。第一行先检测version属性，看是否已经为数据库设置了相应的版本号。如果没有，就调用setVersion()创建修改版本的请求。如果请求成功，显示一条消息，表示版本修改成功。<br>如果数据库的版本号已经被设置为1.0，则显示一条消息，说明数据库已经初始化过了。总之，通过这种模式，就能知道你想使用的数据库是否已经设置了适当的对象存储空间。在整个Web应用中，随着对数据库结构的更新和修改，可能会产生很多个不同版本的数据库。</p>
<h4 id="2-对象存储空间"><a href="#2-对象存储空间" class="headerlink" title="2.对象存储空间"></a>2.对象存储空间</h4><p>在建立了与数据库的连接之后，下一步就是使用对象存储空间飞如果数据库的版本与你传入的版本不匹配，那可能就需要创建一个新的对象存储空间。在创建对象存储空间之前，必须要想清楚你想要 保存什么数据类型。<br>假设你要保存的用户记录自用户名、密码等组成，那么保存一条记录的对象应该类似如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">	usrname: <span class="string">'007'</span>,</span><br><span class="line">	firstName: <span class="string">'James'</span>,</span><br><span class="line">	lastName: <span class="string">'Bond'</span>,</span><br><span class="line">	password: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有了这个对象，很容易想到username属性可以作为这个对象存储空间的键。这个username必须全局唯一，而且大多数时候都要通过这个键采访问数据。这一点非常重要，因为在创建对象存储空间时，必须指定这么一个键。以下是就是为保存上述用户记录而创建对象存储空间的示例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.createObjectStore(<span class="string">'users'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'username'</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中第二个参数中的keyPath属性，就是空间中将要保存的对象的一个属性，而这个属性将作为 存储空间的键来使用。<br>好，现在有了一个对存储空间的引用。接下来可以使用add()或put()方法来向其中添加数据。这两个方法都接收一个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，add()会返回错误，而put()则会重写原有对象。简单地说，可以把add()想象成插入新值，把put()想象成更新原有的值。在初始化对象存储空间时，可以使用类似下面这样的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users中保存着一批用户对象</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">	len = users.length;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">	store.add(users[i++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用add()或put()都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是否成功完成，可以把返回的请求对象保存在－个变量中．然后再指定onerror或onsuccess事件处理程序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users中保存着一批用户对象</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">	request,</span><br><span class="line">	requests = [],</span><br><span class="line">	len = user.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">	request = store.add(users[i++]);</span><br><span class="line">	request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// error</span></span><br><span class="line">	&#125;;</span><br><span class="line">	request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// success</span></span><br><span class="line">	&#125;;</span><br><span class="line">	request.push(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建了对象存储空间并向其中添加了数据之后，就该查询数据了。</p>
<h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><p>跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。在最简单的情况下，可以像下面这样创建事务。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction();</span><br></pre></td></tr></table></figure></p>
<p>如果没有参数，就只能通过事务来读取数据库中保存的对象。是常见的方式是传入要访问的一或多个对象存储空间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">'users'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样就能保证只加载users存储空间中的数据，以便通过事务进行防问。 如柴要访问多个对象存储空间，也可以在第一个参数的位置上传入字符串数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">'users'</span>, <span class="string">'anotherStore]);</span></span><br></pre></td></tr></table></figure></p>
<p>如前所述，这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数，这个参数表示访问模式，用IDBTransaction接口定义的如下常量表示：READ_ONLY(0)表示只读;READ_WRITE(1)表示读写，VERSION_CHANGE(2)表示改变。IE10+和Firefox4+实现的是IDBTransaction，但在Chrome中则叫webkitIDBTransaction，所以使用下面的代码可以统一接口：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBTransaction = <span class="built_in">window</span>.IDBTransaction || <span class="built_in">window</span>.webkitIDBTransaction;</span><br></pre></td></tr></table></figure></p>
<p>有了这行代码，就可以更方便地为transaction()指定第二个参数了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">'user'</span>, IDBTransaction.READ_WRITE);</span><br></pre></td></tr></table></figure></p>
<p>这个事务能够读写users存储空间。<br>取得了事务的索引后，使用objectstore()方法并传入存储空间的名称，就可以访问特定的存储空间。然后，可以像以前一样使用add()和put()方法，使用get()可以取得值，使用delete()可以删除对象，而使用clear()则可以删除所有对象。get()和delete()方法都接收一个对象键作为参数，而所有这5个方法都会返回一个新的请求对象。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = db.transaction(<span class="string">'user'</span>).objectStore(<span class="string">'users'</span>).get(<span class="string">'007'</span>);</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Did not get the object'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = event.target.result;</span><br><span class="line">	alert(result.firstName);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为一个事务可以完成任何多个请求， 所以事务对象本身也有察件处理程序： onerror和oncomplete。这两个事件可以提供事务级的状态信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，通过oncomplete事件的事件对象（event）访问不到get()请求返回的任何数据。必须在相应请求的onsuccess事件处理程序中才能访问到数据。</p>
<h4 id="4-使用游标查询"><a href="#4-使用游标查询" class="headerlink" title="4.使用游标查询"></a>4.使用游标查询</h4><p>使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标就是－指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第…项，在接到查找下一项的指令时，才会指向下一项。<br>在对象存储空间上调用openCursor()方法可以创建游标。与IndexedDB中的其他操作一样，openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理 程序。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	request = store.openCursor();</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在onsuccess事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个对象。在结果集中有下－项时，这个属性中保存一个IDBCursor的实例，在没有下一项时，这个属性 的值为null。IDBCursor的实例有以下几个属性。</p>
<ul>
<li>direction：数值，表示游标移动的方向。默认值为IDBCursor.NEXT(0)，表示下－项。IDBCursor.NEXT_NO_DUPLICATE(1)表示下一个不重复的项，IDBCursor.PREV(2)表示前一项，而IDBCursor.PREV_NO_DUPLICATE表示前一个不重复的项。</li>
<li>key：对象的键。</li>
<li>value：实际的对象。</li>
<li>primaryKey：游标使用的键。可能是对象键，也可能是索引键（稍后讨论索引键）。<br>要检索某一个结果的信息，可以像下面这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(cursor.key, <span class="built_in">JSON</span>.stringify(cursor.value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>请记住，这个例子中的cursor.value是一个对象，这也是为什么在显示它之前先将它转换成JSON字符串的原因。<br>使用游标可以更新个别的记录。调用update()方程可以用指定的对象更新当前游标的value。与其他操作一样，调用update()方法也会创建一个新请求，因此如果你想知道结果，就要为它指定onsuccess和onerror事件处理程序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> cursor = event.target.result,</span><br><span class="line">		value,</span><br><span class="line">		updateRequest;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cursor.key == <span class="string">'foo'</span>) &#123;</span><br><span class="line">			value = cursor.value;</span><br><span class="line">			value.password = <span class="string">'magic!'</span>;</span><br><span class="line">			</span><br><span class="line">			updateRequest = cursor.update(value);</span><br><span class="line">			updateRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="comment">// success</span></span><br><span class="line">			&#125;;</span><br><span class="line">			updateRequest.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="comment">// error</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，如果调用delete()方法，就会删除相应的记录。与update() 一样，调用delete()也返回一个请求。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> cursor = event.target.result,</span><br><span class="line">		value,</span><br><span class="line">		deleteRequest;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cursor.key == <span class="string">'foo'</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			deleteRequest = cursor.delete();</span><br><span class="line">			deleteRequest.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="comment">// success</span></span><br><span class="line">			&#125;;</span><br><span class="line">			deleteRequest.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="comment">// error</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果当前事务没有修改对象存储空间的权限，update()和delete()会抛出错误。<br>默认情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法。</p>
<ul>
<li>continue(key)：移动到结果集中的下一项。参数key是可选的，不指定这个参数，游标移动到下一项；指定这个参数，游标会移动到指定键的位置。</li>
<li>advance(count)：向前移动count指定的项数。</li>
</ul>
<p>这两个方法都会导致游标使用相同的请求，因此相同的onsuccess和onerror事件处理程序也会得到重用。例如，下面的例子遍历了对象存储空间中的所有项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> cursor = event.target.result,</span><br><span class="line">		value,</span><br><span class="line">		deleteRequest;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(cursor.key, <span class="built_in">JSON</span>.stringify(cursor.value));</span><br><span class="line">		cursor.continue();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用continue()会触发另一次请求，进而再次调用onsuccess事件处理程序。在没有更多项可以迭代时，将最后一次调用onsuccess事件处理程序，此时event.target.result的值为null。</p>
<h4 id="5-键范围"><a href="#5-键范围" class="headerlink" title="5.键范围"></a>5.键范围</h4><p>使用游标总让人觉得不那么理想，因为通过游标查找数据的方式太有限了。键范围（ key range ）为使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。支持标准 IDBKeyRange类型的浏览器有IE10+和Firefox 4+,Chrome中的名字叫webkitIDBKeyRange。与使用IndexedDB中的其他类型一样，你最好先声明一个本地的类型，同时要考虑到不同浏览器中的差异。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBKeyRange = <span class="built_in">window</span>.IDBKeyRange || <span class="built_in">window</span>.webkitIDBKeyRange;</span><br></pre></td></tr></table></figure></p>
<p>有四种定义键范围的方式。第一种是使用only()方法，传入你想要取得的对象的键。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> onlyRange = IDBKeyRange.only(<span class="string">'007'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个班圈可以保证只取得键为”007”的对象。使用这个范围创建的游标与直接访问存储空间并调用get(‘007’)差不多。</p>
<p>第二种定义键范围的方式是指定结果集的下界。下界表示游标开始的位置。例如，以下键范围可以保证游标从键为’007’的对象开始，然后继续向前移动，直至最后一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowerRange = IDBKeyRange.lowerBound(<span class="string">'007'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果你想忽略键为”007”的对象，从它的下一个对象开始，那么可以传入第二个参数true：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowerRange = IDBKeyRange.lowerBound(<span class="string">'007'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>第三种定义键范围的方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用upperRange()方法。下面这个键范围可以保证游标从头开始，到取得键为’ace’的对象终止。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> upperRange = IDBKeyRange.upperRange(<span class="string">'ace'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果你不想包含键为指定值的对象，同样，传入第二个参数 true:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> upperRange = IDBKeyRange.upperRange(<span class="string">'ace'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>第四种定义键范围的方式——没错，就是同时指定上、下界，使用bound()方法。这个方法可以接收4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过 上界的布尔值。以下是几个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boundRange = IDBKeyRange.bound(<span class="string">'007'</span>, <span class="string">'ace'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundRange = IDBKeyRange.bound(<span class="string">'007'</span>, <span class="string">'ace'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundRange = IDBKeyRange.bound(<span class="string">'007'</span>, <span class="string">'ace'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>无论如何，在定义键施围之后，把它传给openCursor()方法，就能得到一个符合相应约束条件的游标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	range = IDBKeyRange.bound(<span class="string">'007'</span>, <span class="string">'ace'</span>),</span><br><span class="line">	request = store.openCursor(range);</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(cursor.key, <span class="built_in">JSON</span>.stringify(cursor.value));</span><br><span class="line">		cursor.continue();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子输出的对象的键为”007”到”ace”，比上一节最后那个例子输出的值少一些。</p>
<h4 id="6-设定游标方向"><a href="#6-设定游标方向" class="headerlink" title="6.设定游标方向"></a>6.设定游标方向</h4><p>实际上，openCursor()可以接收两个参数。第一个参数就是刚刚看到的IDBKeyRange的实例，第二个是表示方向的数值常量。作为第二个参数的常量是前面讲查询时介绍的IDBCursor中的常量。Firefox4+和Chrome的实现又有不同，因此第一步还是在本地消除差异：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBCursor = <span class="built_in">window</span>.IDBCursor || <span class="built_in">window</span>.webkitIDBCursor;</span><br></pre></td></tr></table></figure></p>
<p>正常情况下，游标都是从存储空间的第一项开始，调用 continue()或advance ()前进到最后－项。游标的默认方向值是IDBCursor.NEXT。如果对象存储空间中有重复的项，而你想让游标跳过那些重复的项，可以为openCursor传入IDBCursor.NEXT_NO_DUPLICATE作为第二个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	request = store.openCursor(<span class="literal">null</span>, IDBCursor.NEXT_NO_DUPLICATE);</span><br></pre></td></tr></table></figure></p>
<p>注意，openCursor()的第一个参数是null，表示使用默认的键范围，即包含所有对象。这个游标可以从存储空间中的第一个对象开始，逐个选代到最后一个对象——但会跳过重复的对象。<br>当然，也可以创建一个游标，让它在对象存储空间中向后移动，即从最后一个对象开始，逐个迭代．直至第一个对象。此时，要传入的常量是IDBCursor.PREV和IDBCursor.PREV_NO_DUPLICATE。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	request = store.openCursor(<span class="literal">null</span>, IDBCursor.PREV);</span><br></pre></td></tr></table></figure></p>
<p>使用IDBCursor.PREV或IDBCursor.PREV_NO_DUPLICATE打开游标时，每次调用continue()或advance()，都会在存储空间中向后而不是向前移动游标。</p>
<h4 id="7-索引"><a href="#7-索引" class="headerlink" title="7.索引"></a>7.索引</h4><p>对于某些数据，可能需要为一个对象存储空间指定多个键。比如，若要通过用户ID和用户名两种方式来保存用户资料，就需要通过这两个键来存取记录。为此，可以考虑将用户ID作为主键，然后为用户名创建索引。<br>要创建索引，首先引用对象存储空间，然后调用createIndex()方法，如下所示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store/createIndex(<span class="string">'username'</span>, <span class="string">'username'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>createIndex()的第－个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一个包含unique属性的选项（options）对象。这个选项通常都必须指定，因为它表示键在所有记录中是否唯一。因为username有可能重复，所以这个索引不是唯一的。<br>createIndex()的返回值是IDBIndex的实例。在对象存储空间上调用index()方法也能返回同一个实例。例如，要使用一个已经存在的名为”username“的索引，可以像下面这样取得该索引。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store.index(<span class="string">'username'</span>)</span><br></pre></td></tr></table></figure></p>
<p>索引其实与对象存储空间很相似。在索引上调用opencursor()方法也可以创建新的游标，除了将来会把索引键而非主键保存在event.result.key属性中之外，这个游标与在对象存储空间上调用openCursor()返回的游标完全一样。来看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store.index(<span class="string">'username'</span>),</span><br><span class="line">	request = index.openCursor();</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在索引上也能创建一个特殊的只返回每条记录主键的游标，那就要调用openKeyCursor()方法。这个方法接收的参数与openCursor()相同。 而最大的不同在于这种情况下event.result.key中仍然保存着索引键，而event.result.value中保存的则是主键，而不再是整个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store.index(<span class="string">'username'</span>),</span><br><span class="line">	request = index.openCursor();</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">	<span class="comment">// event.result.key中保存索引键，而event.result.value中保存主键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样，使用get()方法能够从索引中取得一个对象，只要传入相应的索引键即可；当然，这个方法也将返回一个请求。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store.index(<span class="string">'username'</span>),</span><br><span class="line">	request = index.get(<span class="string">'007'</span>);</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">	<span class="comment">// event.result.key中保存索引键，而event.result.value中保存主键</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>要根据给定的索引键取得主键，可以使用getKey()方法。这个方法也会创建－个新的请求。但event.result.value等于主键的值，而不是包含整个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	index = store.index(<span class="string">'username'</span>),</span><br><span class="line">	request = index.getKey(<span class="string">'007'</span>);</span><br><span class="line">	</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">	<span class="comment">// event.result.key中保存索引键，而event.result.value中保存主键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子的onsuccess事件处理程序中，event.result.value中保存的是用户ID。<br>任何时候，通过IDBIndex对象的下列属性都可以取得有关索引的相关信息。</p>
<ul>
<li>name：索引的名字</li>
<li>keyPath：传入createIndex()中的属性路径</li>
<li>objectStore：索引的对象存储空间</li>
<li>unique：表示索引键是否唯一的布尔值</li>
</ul>
<p>另外，通过对象存储对象的indexName属性可以访问到为该空间简历的所有索引。通过以下代码就可以知道根据存储的对象简历了哪些索引。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>),</span><br><span class="line">	indexNames = store.indexName,</span><br><span class="line">	index,</span><br><span class="line">	i = <span class="number">0</span>,</span><br><span class="line">	len = indexNames.length;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">	index = store.index(indexNames[i++]);</span><br><span class="line">	<span class="built_in">console</span>.log(index.name, index.keyPath, index.unique);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码遍历了每个索引，在控制台中输出了它们的信息。<br>在对象存储空间上调用deleteIndex()方法并传入索引的名字可以删除索引。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>);</span><br><span class="line">store.deleteIndex(<span class="string">'username'</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。</p>
<h4 id="8-并发问题"><a href="#8-并发问题" class="headerlink" title="8.并发问题"></a>8.并发问题</h4><p>虽然网页中的lndexedDB提供的是异步API，但仍然存在并发操作的问题。如果浏览器的两个不同的标签页打开了同一个页面，那么一个页面试图更新另一个页面尚未准备就绪的数据库的问题就有可能发生。把数据库设置为新版本有可能导致这个问题。因此，只有当浏览器中仅有一个标签页使用数据库的情况下，调用setVersion()才能完成操作。<br>刚打开数据库时，要记着指定onversionchange事件处理程序。当同一个来源的另一个标签页调用setVersion()时，就会执行这个回调函数。处理这个事件的段佳方式是立即关闭数据库，从而保证版本更新顺利完成。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request,</span><br><span class="line">	database;</span><br><span class="line">	</span><br><span class="line">request = indexedDB.open(<span class="string">'admin'</span>);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	database = event.target.result;</span><br><span class="line">	</span><br><span class="line">	database.onversionchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		database.close();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每次成功打开数据库，都应该指定onversionchange事件处理程序。<br>调用setVersion()时，指定请求的onblocked事件处理程序也很重要。在你想要更新数据库的版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，最好先通知用户关闭其他标簇页，然后再重新调用setVersion()。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = database.setVersion(<span class="string">'2.0'</span>);</span><br><span class="line">request.onblocked = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">'Please colse all other tabs and try again.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请记住，其他标签页中的onversionchange事件处理程序也会执行。<br>通过指定这些事件处理程序，就能确保你的Web应用妥善地处理好IndexedDB的并发问题。</p>
<h4 id="9-限制"><a href="#9-限制" class="headerlink" title="9.限制"></a>9.限制</h4><p>对lndexedDB的限制很多都与对WebStorage的类似。首先，lndexedDB数据库只能由同源（相同协议、域名和端口）页面操作，因此不能跨域共享信息。换句话说，WWW.wrox.com与p2p.wrox.com 的数据库是完全独立的。<br>其次，每个来源的数据库占用的磁盘空间也有限制。Firefox4+目前的上限是每个源50MB，而Chrome的限制是5MB。移动设备上的Firefox最多允许保存5MB，如果超过了这个配额，将会请求用户的许可。<br>Firefox还有另外一个限制，即不允许本地文件访问IndexedDB。Chrome没有这个限制。如果你在本地运行本书的示例，请使用Chrome。</p>
<p>温习：</p>
<ul>
<li>navigator.onLine及online、offline事件</li>
<li>manifest离线应用，及update()、swapCache()</li>
<li>Cookie及子Cookie的增删查，限制</li>
<li>sessionStorage、globalStorage(*)、localStorage；</li>
<li>IndexedDB操作</li>
</ul>
<p>（完） </p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2018/11/09/senior_javascript/重温《JavaScript高级程序设计》—26-最佳实践/" class="prev">Previous Post<span>重温《JavaScript高级程序设计》—26-最佳实践</span></a></div><div class="post-next"><a href="/2018/10/31/notes/【笔记】《浏览器的工作原理：新式网络浏览器幕后揭秘》/" class="next">Next Post<span>【笔记】《浏览器的工作原理：新式网络浏览器幕后揭秘》</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> Recent Posts</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/11/04/ai/【笔记】《Career Essentials in Generative AI by Microsoft and LinkedIn》课程笔记/">【笔记】《Career Essentials in Generative AI by Microsoft and LinkedIn》课程笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/15/code/如何优化代码中的if判断/">前端代码优化:从系统区分处理的业务场景看如何优化代码中的if判断</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/24/notes/【笔记】ES6随手记（持续）/">【笔记】ES6随手记（持续）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/19/webapi/【笔记】unload事件将被正式废弃/">【笔记】unload 事件将被正式废弃</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/02/notes/ES Stage:TS 5.2中的新特性useing关键字/">【js】ES Stage/TS 5.2中的新特性useing关键字</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> Tags</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebApi/">WebApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpt/">gpt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prompt/">prompt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwa/">pwa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形/">图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常工作/">日常工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨端/">跨端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> Archive</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2023 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script></body></html>