<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【笔记】ReactJS随手记（持续） | Wayne的博客</title><meta name="description" content="【笔记】ReactJS随手记（持续） - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><script>(function (w) {w.frontjsConfig={token:"81a82620fb0dca7680f2f06be134fa4f",behaviour:8,FPSThreshold:10};w.frontjsTmpData = {r:[],e:[],l:[]};w.frontjsTmpCollector = function (ev) {(ev.message ? window.frontjsTmpData.e : window.frontjsTmpData.r).push([new Date().getTime(), ev])};w.FrontJS = {addEventListener: function (t, f) {w.frontjsTmpData.l.push([t, f]);return f;},removeEventListener: function (t, f) {for (var i = 0; i < w.frontjsTmpData.l.length; i++) {t === w.frontjsTmpData.l[i][0] && f === w.frontjsTmpData.l[i][1] && w.frontjsTmpData.l.splice(i, 1);}return f;}};w.document.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("load", function () {var n = w.document.createElement("script");n.src = "https://frontjs-static.pgyer.com/dist/current/frontjs.web.min.js"; w.document.body.appendChild(n);}, true);})(window);</script><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">Home</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">Archive</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">About</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="search" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">【笔记】ReactJS随手记（持续）</h1><span class="post-date">Jul 6, 2018</span><span class="post-tag"><a href="/tags/笔记/">笔记</a><a href="/tags/js/">js</a><a href="/tags/react/">react</a></span><img src="/images/icons/react.png" class="bgimage"><div class="post-content"><h1 id="ReactJS-随手记（持续）"><a href="#ReactJS-随手记（持续）" class="headerlink" title="ReactJS 随手记（持续）"></a>ReactJS 随手记（持续）</h1><ul>
<li>start date: 2018-05-27 22:00:45</li>
</ul>
<blockquote>
<p>React 是一个轻量库，它只关注 MVC 的试图部分，它遵循从上到下的单向数据流。</p>
</blockquote>
<h2 id="1-setState-运作机制及优化"><a href="#1-setState-运作机制及优化" class="headerlink" title="1 setState()运作机制及优化"></a>1 <code>setState()</code>运作机制及优化</h2><p>ReactJS 中数据到 UI 的映射就是靠<code>state</code>。React 通过管理状态实现对组件的管理，通过 this.state()方法更新 state。当 this.setState()被调用的时候，React 会重新调用 render 方法来重新渲染 UI。</p>
<h4 id="1-1-setState-用法"><a href="#1-1-setState-用法" class="headerlink" title="1.1 setState 用法"></a>1.1 setState 用法</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(updater, [callback])</span><br></pre></td></tr></table></figure>
<p>它能接收两个参数，其中第一个参数 updater 可以为对象或者为函数 ((prevState, props) =&gt; stateChange)，第二个参数为回调函数</p>
<h4 id="1-2-setState-异步更新"><a href="#1-2-setState-异步更新" class="headerlink" title="1.2 setState 异步更新"></a>1.2 setState 异步更新</h4><p>setState 通过一个队列机制实现 state 的更新。当执行 setState 时，会把需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state，利用这个队列机制可以高效的批量的更新 state。</p>
<p><img src="/images/react/p-setstate1.png" alt="p-setstate1.png"></p>
<p>对 setState 的认知：</p>
<ul>
<li>1.setState 不会立刻改变 React 组件中 state 的值.</li>
<li>2.setState 通过触发一次组件的更新来引发重绘.</li>
<li>3.多次 setState 函数调用产生的效果会合并。</li>
</ul>
<p>重绘指的就是引起 React 的更新生命周期函数 4 个函数：</p>
<ul>
<li>shouldComponentUpdate（被调用时 this.state 没有更新；如果返回了 false，生命周期被中断，虽然不调用之后的函数了，但是 state 仍然会被更新）</li>
<li>componentWillUpdate（被调用时 this.state 没有更新）</li>
<li>render（被调用时 this.state 得到更新），此过程执行最耗性能</li>
<li>componentDidUpdate</li>
</ul>
<p>目前 React 会将 setState 的效果放在队列中，积攒着一次引发更新过程，为的就是把 Virtual DOM 和 DOM 树操作降到最小，用于提高性能。</p>
<blockquote>
<p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外（addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval）的 setState 调用会同步执行 this.state。</p>
</blockquote>
<p>看一道题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val); <span class="comment">// 第 1 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val); <span class="comment">// 第 2 次 log</span></span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val); <span class="comment">// 第 3 次 log</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val); <span class="comment">// 第 4 次 log</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：<br><code>0、0、2、3</code>。原因：接下来就可以理解了，因为在 componentDidMount 中调用 setState 时，batchingStrategy 的 isBatchingUpdates 已经被设置为 true 了，所以两次 setState 的结果并没有立即生效，而是被放进了 dirtyComponents 中。这也解释了两次打印 this.state.val 都是 0 的原因，因为新的 state 还没被应用到组件中。</p>
<p>在看 setTimeOut 中的两次 setState，因为没有前置的 batchedUpdate 调用，所以 batchingStrategy 的 isBatchingUpdates 标志位是 false，也就导致了新的 state 马上生效，没有走到 dirtyComponents 分支。也就是说，setTimeOut 中的第一次执行，setState 时，this.state.val 为 1，而 setState 完成后打印时 this.state.val 变成了 2。第二次的 setState 同理。</p>
<h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><ul>
<li>减少调用 setState 的次数，比如可以合并调用；</li>
<li>利用<a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">shouldComponentUpdate 方法</a></li>
<li>数组声明使用 const</li>
</ul>
<h2 id="2-diff-算法"><a href="#2-diff-算法" class="headerlink" title="2.diff 算法"></a>2.diff 算法</h2><p>diff 算法用于计算出两个 virtual dom 的差异，<strong>是 react 中开销最大的地方</strong>。</p>
<p>传统 diff 算法通过循环递归对比差异，算法复杂度为<code>O(n3)</code>。<br>react diff 算法制定了三条策略，将算法复杂度从 <code>O(n3)</code>降低到<code>O(n)</code>。</p>
<ul>
<li>WebUI 中 DOM 节点跨节点的操作特别少，可以忽略不计。</li>
<li>拥有相同类的组件会拥有相似的 DOM 结构。拥有不同类的组件会生成不同的 DOM 结构。</li>
<li>同一层级的子节点，可以根据唯一的 ID(key)来区分。</li>
</ul>
<p>针对这三个策略，react diff 实施的具体策略是:</p>
<ul>
<li>diff 对树进行分层比较，只对比两棵树同级别的节点。跨层级移动节点，将会导致节点删除，重新插入，无法复用。</li>
<li>diff 对组件进行类比较，类相同的递归 diff 子节点，不同的直接销毁重建。diff 对同一层级的子节点进行处理时，会根据 key 进行简要的复用。两棵树中存在相同 key 的节点时，只会移动节点。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>减少 diff 算法触发次数，即减少 update 流程的次数。正常进入 update 流程有三种方式：<ul>
<li>setState：常见的业务场景即处理接口回调时，无论数据处理多么复杂，保证最后只调用一次 setState。</li>
<li>父组件 render：父组件的 render 必然会触发子组件进入 update 阶段，此时最常用的优化方案即为 shouldComponentUpdate 方法。最常见的方式为进行 this.props 和 this.state 的浅比较来判断组件是否需要更新。或者直接使用 PureComponent。</li>
<li>forceUpdate：只能弃用</li>
</ul>
</li>
<li>正确使用 diff 算法：<ul>
<li>不使用跨层级移动节点的操作。</li>
<li>对于条件渲染多个节点时，尽量采用隐藏等方式切换节点，而不是替换节点。</li>
<li>尽量避免将后面的子节点移动到前面的操作，当节点数量较多时，会产生一定的性能问题。</li>
</ul>
</li>
</ul>
<h2 id="3-PureComponent"><a href="#3-PureComponent" class="headerlink" title="3.PureComponent"></a>3.PureComponent</h2><p>React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
<p>若是数组和对象等引用类型，则要引用不同，才会渲染。但是如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为你知道的，进行浅比较也是需要时间</p>
<p>如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用 React.PureComponent 可提高性能。</p>
<p>PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件</p>
<blockquote>
<p>不要在 PureComponent 中使用 shouldComponentUpdate，因为根本没有必要，也会触发警告<code>Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</code></p>
</blockquote>
<p>继承 PureComponent 时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论你怎么点击按钮，ListOfWords渲染的结果始终没变化，原因就是WordAdder的word的引用地址始终是同一个。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListOfWords</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.words.join(',')&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordAdder</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      words: [<span class="string">'marklar'</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// This section is bad style and causes a bug</span></span><br><span class="line">    <span class="keyword">const</span> words = <span class="keyword">this</span>.state.words;</span><br><span class="line">    words.push(<span class="string">'marklar'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">words</span>: words &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ListOfWords words=&#123;this.state.words&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-React-memo"><a href="#3-1-React-memo" class="headerlink" title="3.1 React.memo"></a>3.1 React.memo</h3><blockquote>
<p>React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件。它和 PureComponent 在数据对比上唯一的区别就在于 ×× 只进行了 props 的浅比较 ××。</p>
</blockquote>
<p>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>
<p>React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。</p>
<p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure>
<h2 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4.生命周期"></a>4.生命周期</h2><p><img src="/images/react/p-lifecircle.png" alt="p-lifecircle.png"></p>
<h2 id="5-super"><a href="#5-super" class="headerlink" title="5.super()"></a>5.<code>super()</code></h2><h3 id="5-1-super-的作用"><a href="#5-1-super-的作用" class="headerlink" title="5.1 super()的作用"></a>5.1 <code>super()</code>的作用</h3><p>ES6 语法中，super 指代父类的构造函数，在你调用 super() 之前，你无法在构造函数中使用 this，JS 不允许这么做。</p>
<p>如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolitePerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetColleagues(); <span class="comment">//这是不允许的</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greetColleagues() &#123;</span><br><span class="line">    alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">    alert(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', nice to meet you!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果允许的话，在 super() 之前执行了一个 greetColleagues 函数，greetColleagues 函数里用到了 this.name，这时还没执行  super(name)，greetColleagues 函数里就获取不到 super 传入的 name 了，此时的 this.name 是 undefined。</p>
<h3 id="5-2-super-里为什么要传-props？"><a href="#5-2-super-里为什么要传-props？" class="headerlink" title="5.2 super() 里为什么要传 props？"></a>5.2 super() 里为什么要传 props？</h3><p>执行 super(props) 可以使基类 React.Component 初始化 this.props。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 内部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们不传 props，只执行 super()，或者没有设置 constructor 的情况下，依然可以在组件内使用 this.props，为什么呢？</p>
<p>其实 React 在组件实例化的时候，马上又给实例设置了一遍 props：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 内部</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> YourComponent(props);</span><br><span class="line">instance.props = props;</span><br></pre></td></tr></table></figure>
<p>那是否意味着我们可以只写 super() 而不用 super(props) 呢？</p>
<p>不是的。虽然 React 会在组件实例化的时候设置一遍 props，但在 super 调用一直到构造函数结束之前，this.props 依然是未定义的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 😬 我们忘了传入 props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// 😬 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这时在构造函数中调用了函数，函数中有 this.props.xxx 这种写法，直接就报错了。</p>
<p>而用 super(props)，则不会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// ✅ 我们传了 props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-受控组件和非受控组件"><a href="#6-受控组件和非受控组件" class="headerlink" title="6 受控组件和非受控组件"></a>6 受控组件和非受控组件</h2><h3 id="6-1-受控组件"><a href="#6-1-受控组件" class="headerlink" title="6.1 受控组件"></a>6.1 受控组件</h3><p>受控组件是在 React 中处理输入表单的一种技术。表单元素通常维护它们自己的状态，而 react 则在组件的状态属性中维护状态。我们可以将两者结合起来控制输入表单，这称为受控组件。因此，<strong>在受控组件表单中，数据由 React 组件处理。</strong></p>
<p>如当用户在 todo 项中输入名称时，调用一个 js 函数 handleChange 捕获每一个输入的数据并将其放入状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: event.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-非受控组件"><a href="#6-2-非受控组件" class="headerlink" title="6.2 非受控组件"></a>6.2 非受控组件</h3><p>在大多数情况下都建议使用受控组件，有一种称为非受控组件的方法可以通过使用<code>Ref</code>来处理表单数据。在非受控组件中，<code>Ref</code>用于直接从 DOM 访问表单值，而不是事件处理程序。</p>
<p>如，我们使用<code>React.createRef()</code>定义<code>Ref</code>并传递该输入表单并直接从<code>handleSubmit</code>方法中的 DOM 访问表单值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.input = React.createRef();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.input.current.value); <span class="comment">// 一个对节点的引用可以通过ref的current属性得到；</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.input&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-展示-UI-组件和容器组件"><a href="#7-展示-UI-组件和容器组件" class="headerlink" title="7. 展示(UI)组件和容器组件"></a>7. 展示(UI)组件和容器组件</h2><blockquote>
<p>为了解决 React 只有 V 层的这个问题，更好地区分我们的代码逻辑，展示组件与容器组件这一对概念就被引入了。</p>
</blockquote>
<table>
<thead>
<tr>
<th>说明/组件</th>
<th>展示组件</th>
<th>容器组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用</td>
<td>描述如何展现（骨架、样式）</td>
<td>描述如何运行（数据获取、状态更新）</td>
</tr>
<tr>
<td>直接使用 store</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>数据来源</td>
<td>props</td>
<td>监听 store state</td>
</tr>
<tr>
<td>数据修改</td>
<td>从 props 调用回调函数</td>
<td>向 store 派发 actions</td>
</tr>
</tbody>
</table>
<h3 id="7-1-展示组件（persentational-components）"><a href="#7-1-展示组件（persentational-components）" class="headerlink" title="7.1 展示组件（persentational components）"></a>7.1 展示组件（persentational components）</h3><ul>
<li>负责展示 UI，也就是组件如何渲染，具有很强的内聚性。</li>
<li>只关心得到数据后(props)如何渲染</li>
<li>*大多数情况可以通过函数定义组件声明</li>
</ul>
<h3 id="7-2-容器组件（container-components）"><a href="#7-2-容器组件（container-components）" class="headerlink" title="7.2 容器组件（container components）"></a>7.2 容器组件（container components）</h3><ul>
<li>负责应用逻辑处理，如<ul>
<li>拥有自身的 state，发送网络请求，处理返回数据，将处理过的数据传递给展示组件，或与 redux 等其他数据处理模块协作</li>
<li>也提供修改数据源的方法，通过展示组件的 props 传递给展示组件</li>
<li>当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化</li>
</ul>
</li>
</ul>
<h3 id="7-3-优点和注意事项"><a href="#7-3-优点和注意事项" class="headerlink" title="7.3 优点和注意事项"></a>7.3 优点和注意事项</h3><p>优点：</p>
<ul>
<li>解耦了界面和数据的逻辑</li>
<li>更好的可复用性，比如同一个回复列表展示组件可以套用不同数据源的容器组件<br>利于团队协作，一个人负责界面结构，一个人负责数据交互</li>
</ul>
<p>注意</p>
<ul>
<li>展示组件和容器组件是根据组件的意图划分组件，展示组件通常通过无状态组件实现，容器组件通过有状态组件实现</li>
<li>无状态和有状态组件时根据组件内部是否使用 state 划分组件</li>
</ul>
<h2 id="8-Fragments"><a href="#8-Fragments" class="headerlink" title="8.Fragments"></a>8.Fragments</h2><p>在 React 中，我们需要有一个父元素，同时从组件返回 React 元素，有时在 DOM 中添加额外的节点会很烦人。这时候就可以使用 Fragments，我们不需要再 DOM 中添加额外的节点，只需要用<code>React.Fragment</code>或直接简写为<code>&lt;&gt;</code>来包裹内容就行。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// origin</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Component A /&gt;</span><br><span class="line">    &lt;Component B /&gt;</span><br><span class="line">    &lt;Component C /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ use fragments</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">  &lt;React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Component A /</span>&gt;</span><br><span class="line">    &lt;Component B /&gt;</span><br><span class="line">    &lt;Component C /&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ or</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">  &lt;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Component A /</span>&gt;</span><br><span class="line">    &lt;Component B /&gt;</span><br><span class="line">    &lt;Component C /&gt;</span><br><span class="line">  &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<h3 id="如何添加-key-属性"><a href="#如何添加-key-属性" class="headerlink" title="如何添加 key 属性"></a>如何添加 key 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">list.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">  &lt;React.Fragment key=&#123;item&#125;&gt;</span><br><span class="line">    &lt;Component A /&gt;</span><br><span class="line">    &lt;Component B /&gt;</span><br><span class="line">    &lt;Component C /&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure>
<h2 id="9-传送门Portals"><a href="#9-传送门Portals" class="headerlink" title="9.传送门Portals"></a>9.传送门<a href="https://zh-hans.reactjs.org/docs/portals.html" target="_blank" rel="noopener">Portals</a></h2><p>默认情况下，所有子组件都在 UI 上呈现，具体取决于组件层次结构。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>
<p>如，有个父组件 parent 在 DOM 层次结构中有子组件 children，我们可以将子组件 children 移出 parent 组件并将其附加 id 为其他的 DOM 节点下，如 id 为 someid 的节点。<br>首先，获取 id 为 someid，我们在 constructor 中创建一个元素 div，将 child 附加到 componentDidMount 中的 someRoot。<br>然后我们在<code>React.createPortal(this.props.children, domnode)</code>方法的帮助下将子节点传递给该特定 DOM 节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someRoot = <span class="built_in">document</span>.querySelector(<span class="string">'#someid'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    someRoot.appendChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    someRoot.removeChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(<span class="keyword">this</span>.props.children, <span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-React16-的兼容"><a href="#10-React16-的兼容" class="headerlink" title="10.React16 的兼容"></a>10.React16 的兼容</h2><p>React 16 依赖集合类型 Map 和 Set 。如果你要支持无法原生提供这些能力（例如 IE &lt; 11）或实现不规范（例如 IE 11）的旧浏览器与设备，考虑在你的应用库中包含一个全局的 polyfill ，例如 core-js 或 babel-polyfill 。<br>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/map'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/set'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="11-拆分组件的原则"><a href="#11-拆分组件的原则" class="headerlink" title="11.拆分组件的原则"></a>11.拆分组件的原则</h2><p>满足高内聚（High Cohesion）和低耦合（Low Coupling）的原则。</p>
<ul>
<li>高内聚：把逻辑紧密相关的内容放在一个组件中。如 jsx 将 js 和 html 甚至 css 聚合在一起，天生具有高内聚的特点；</li>
<li>低耦合：不同组件之间的依赖关系要尽量弱化，每个组件要尽量独立以保持整个系统的低耦合度。</li>
</ul>
<h2 id="12-生命周期"><a href="#12-生命周期" class="headerlink" title="12.生命周期"></a>12.生命周期</h2><h3 id="12-1-getInitialState-和-getDefaultProps"><a href="#12-1-getInitialState-和-getDefaultProps" class="headerlink" title="12.1 * getInitialState 和 getDefaultProps"></a>12.1 * getInitialState 和 getDefaultProps</h3><p>getInitialState()函数的返回值会用来初始化组件的 this.state，getDefaultProps()函数的返回值可以作为 props 的初始值。这两个函数只在 React.createClass 方法创造的组件类才会用到（ES6 定义的 React 组件中根本用不到）。</p>
<p>如以下两个定义结果相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getInitialState和getDefaultProps</span></span><br><span class="line"><span class="keyword">const</span> Sample = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      sampleProp: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Sample.defaultProps = &#123;</span><br><span class="line">  sampleProp: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>*当然，包括官方也不推荐使用 React.createClass，所以基本不会用这两个函数</p>
<h3 id="12-2-componentWillMount-和-componentDidMount"><a href="#12-2-componentWillMount-和-componentDidMount" class="headerlink" title="12.2 componentWillMount 和 componentDidMount"></a>12.2 componentWillMount 和 componentDidMount</h3><blockquote>
<p>componentWillMount 可能将在 17 版本移除。原因有两点：1.服务端渲染: 在服务端渲染的情景下, componentWillMount 执行完立马执行 render 会导致 componentWillMount 里面执行的方法(获取数据, 订阅事件) 并不一定执行完；2.Concurrent Render: 在 fiber 架构下, render 前的钩子会被多次调用, 在 componentWillMount 里执行订阅事件就会产生内存泄漏。这样的话我们需要迁移思路, 将以前写在 componentWillMount 的获取数据、时间订阅的方法写进 componentDidMount 中;</p>
</blockquote>
<p>众所周知，componentWillMount 会在调用 render 函数之前被调用，componentDidMount 会在调用 render 之后调用。</p>
<p>通常我们不用定义 componentWillMount 函数，这个时候没有任何渲染出来的结构，即使调用 this.setState 修改状态也不会引发重新绘制。所有可以在 componentWillMount 中做的事情都可以提前到 constructor 中间去做。</p>
<p>render 函数被调用完之后，componentDidMount 函数并不会被立即调用，componentDidMount 被调用的时候，render 函数返回的东西已经引发了渲染，组件已经被“装载”到了 DOM 树上。需要注意的是，render 函数本身并不往 DOM 树上渲染或者装载内容，它只是返回一个 JSX 表示的对象，然后由 React 库来根据返回对象决定如何渲染。而 React 肯定要把所有组件返回的结果综合起来，才能知道该如何产生对应的 DOM 修改。所以多个组件渲染的情况下，React 只有调用多个组件的 render 函数之后才会依次调用各个组件的 componentDidMount 函数作为装载过程的收尾。这点与 componentWillMount 不一样。</p>
<p>componentWillMount 和 componentDidMount 这对兄弟节点还有个区别：componentWillMount 可以在服务端被调用，也可以在浏览器中被调用；而 componentDidMount 只能在浏览器中被调用，服务端不会被调用。因为服务端渲染并不会产生 DOM 树，通过 React 组件产生的只是一个纯粹的字符串而已。也因如此，componentDidMount 给了开发者一个很好的位置去做只有浏览器端才能做的逻辑，比如调用 ajax。</p>
<h3 id="12-3-componentWillReceiveProps-nextProps"><a href="#12-3-componentWillReceiveProps-nextProps" class="headerlink" title="12.3 componentWillReceiveProps(nextProps)"></a>12.3 componentWillReceiveProps(nextProps)</h3><p>本以为这个函数只有当组件的 props 发生改变时才会被调用，其实是不正确的。只要父组件的 render 函数被调用，在 render 函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的 props 有没有改变都会触发该函数。</p>
<h3 id="12-4-shouldComponentUpdate"><a href="#12-4-shouldComponentUpdate" class="headerlink" title="12.4 shouldComponentUpdate"></a>12.4 shouldComponentUpdate</h3><p>render 和 shouldComponentUpdate 是 React 生命周期函数中唯二两个要求有返回结果的函数。render 函数的返回结果将用于构造 DOM 对象，而 shouldComponentUpdate 函数返回一个布尔值，告诉 React 库这个组件在这次更新过程中是否要继续，这个作用可见上文。</p>
<h2 id="13-Hooks-16-7"><a href="#13-Hooks-16-7" class="headerlink" title="13 Hooks(16.7)"></a>13 Hooks(16.7)</h2><p>在 React 16.7 之前, React 有两种形式的组件, 有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件, 让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程，React 团队希望组件不要变成复杂的容器，最好只是数据流的管道，开发者根据需要组合管道即可。</p>
<h3 id="类组件的缺点"><a href="#类组件的缺点" class="headerlink" title="类组件的缺点"></a>类组件的缺点</h3><ul>
<li>明显的就是代码会很重，编程模式复杂</li>
<li>大型组件很难拆分和重构，也很难测试</li>
<li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑</li>
</ul>
<h3 id="Hook-的含义"><a href="#Hook-的含义" class="headerlink" title="Hook 的含义"></a>Hook 的含义</h3><p>钩子，React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码“钩”进来。</p>
<h4 id="钩子使用"><a href="#钩子使用" class="headerlink" title="钩子使用"></a>钩子使用</h4><p>React 约定钩子一律使用 use 前缀命名，即你要使用 xxx 功能，钩子就命名为 usexxx。Hooks 涉及到最核心的 2 个 api, <code>useState</code>和<code>useEffect</code>。</p>
<h3 id="useState：状态钩子。"><a href="#useState：状态钩子。" class="headerlink" title="useState：状态钩子。"></a>useState：状态钩子。</h3><p>返回状态和一个更新状态的函数。<br>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>原理：闭包+单向循环链表。</p>
<h3 id="useEffect-fn-relyon-：副作用钩子。"><a href="#useEffect-fn-relyon-：副作用钩子。" class="headerlink" title="useEffect(fn, relyon)：副作用钩子。"></a>useEffect(fn, relyon)：副作用钩子。</h3><p>在每次 render 后都会执行这个钩子。可以将它当成是 componentDidMount、componentDidUpdate、componentWillUnmount 的合集。因此使用 useEffect 比之前优越的地方在于: - 可以避免在 componentDidMount、componentDidUpdate 书写重复的代码; - 可以将关联逻辑写进一个 useEffect(在以前得写进不同生命周期里);</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, setVal] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;, [val]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;val&#125;<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useLayoutEffect-fn-relyon"><a href="#useLayoutEffect-fn-relyon" class="headerlink" title="useLayoutEffect(fn, relyon)"></a>useLayoutEffect(fn, relyon)</h4><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<p>简单来说 useLayoutEffect 会更快执行，因此仅在某些特殊情况下（比如 DOM 操作）用 useLayoutEffect， 其他像异步请求的用 useEffect。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.title += <span class="string">'!!!'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>hello<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。<strong>返回的 ref 对象在组件的整个生命周期内保持不变</strong>。</p>
<p>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p>
<h4 id="保存-DOM"><a href="#保存-DOM" class="headerlink" title="保存 DOM"></a>保存 DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> divRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    handleDiv(divRef.current); <span class="comment">// div</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;divRef&#125;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="保存事件程序"><a href="#保存事件程序" class="headerlink" title="保存事件程序"></a>保存事件程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eventRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    eventRef.current = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> handleEvent(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(eventRef.current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;start&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClear&#125;&gt;clear&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="存储以前的值"><a href="#存储以前的值" class="headerlink" title="存储以前的值"></a>存储以前的值</h4><p>useState()/useEffect()经常遇到因闭包导致的取值问题，这时候就需要通过 useRef()来解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'ajanuw'</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    t.current = name;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> prevName = t.current;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;h2&gt;&#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;prevName&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="useImperativeHandle-ref-createHandle-deps"><a href="#useImperativeHandle-ref-createHandle-deps" class="headerlink" title="useImperativeHandle(ref, createHandle, [deps])"></a>useImperativeHandle(ref, createHandle, [deps])</h4><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback()"></a>useCallback()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>
<p>返回一个 memoized 回调<strong>函数</strong>。</p>
<p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo()"></a>useMemo()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>返回一个 memoized <strong>值</strong>。</p>
<p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p>
<p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p>
<p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。</p>
<p>除此之外还有两个不常用的钩子：</p>
<ul>
<li><strong>useContext：共享状态钩子</strong>。在组件之间共享状态时使用。</li>
<li><strong>useReducer：action 钩子</strong>。Redux 等数据 action。</li>
</ul>
<h3 id="hooks-的优缺点"><a href="#hooks-的优缺点" class="headerlink" title="hooks 的优缺点"></a>hooks 的优缺点</h3><p>知乎——<a href="https://zhuanlan.zhihu.com/p/88593858" target="_blank" rel="noopener">《谈谈 react hooks 的优缺点》</a></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>1.<strong>更容易复用代码</strong>：可以通过自定义 hooks 来复用状态，从而解决了类组件有时候难以复用逻辑的问题</li>
<li>2.<strong>清爽的代码风格</strong>：函数式编程风格，函数式组件、状态保存在运行环境、每个功能都包裹在函数中，整体风格更清爽优雅。</li>
<li>3.<strong>代码量更少</strong>：不像 class 组件需要通过 this，props 更简洁。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1.<strong>状态不同步</strong>：函数独立运行导致的独立作用域，函数的变量也是保存在运行时的作用域里面，当我们有异步操作的时候，经常会碰到异步回调的变量引用是之前的；如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onAlertButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'count: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onAlertButtonClick&#125;&gt;click&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.<strong>响应式的 useEffect</strong>：改变写法习惯，需要掌握 useEffect 的触发时机，对比 componentDidmount 和 componentDidUpdate，useEffect 带来的心智负担更大；</li>
</ul>
<h4 id="避免常见问题"><a href="#避免常见问题" class="headerlink" title="避免常见问题"></a>避免常见问题</h4><ul>
<li>1.不要再 useEffect 里写太多依赖项，划分这些依赖项成多个单一功能的 useEffect，“单一职责模式”；</li>
<li>2.注意闭包和作用域可能存在的风险。如遇到状态不同步的问题，可以考虑使用 useRef 或手动传递参数到函数。如</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// showCount的count值来自父级作用域</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(xxx);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// showCount的count来自参数</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(xxx);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCount</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.使用<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a>并重视其警告；</li>
<li>4.复杂业务用 Component 代替 hooks。</li>
</ul>
<h2 id="14-单元测试"><a href="#14-单元测试" class="headerlink" title="14 单元测试"></a>14 单元测试</h2><p>单测引导：<a href="https://testing-library.com/docs/dom-testing-library/intro" target="_blank" rel="noopener">testing-library&gt;&gt;</a></p>
<h3 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h3><table>
<thead>
<tr>
<th>架构层级</th>
<th>测试内容</th>
<th>测试策略</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>action(creator)层</td>
<td>是否正确创建 action 对象</td>
<td>一般不需要测试，视信心而定</td>
<td>这个层级架构上非常简单，设施搭好后一般不会出错</td>
</tr>
<tr>
<td>reducer 层</td>
<td>是否正确完成计算</td>
<td>有逻辑的 reducer，要求 100%覆盖率</td>
<td>这个层级输入输出明确，又包含业务计算，非常适合单元测试</td>
</tr>
<tr>
<td>selector 层</td>
<td>是否正确完成计算</td>
<td>有逻辑的 selector，要求 100%覆盖率</td>
<td>这个层级输入输出明确，又包含业务计算，非常适合单元测试</td>
</tr>
<tr>
<td>saga 层</td>
<td>是否获取了正确的参数</td>
<td>这 5 个业务点建议 100%覆盖</td>
<td>这个层级主要包含前述 5 大方面的业务逻辑，进行测试很有重构价值</td>
</tr>
<tr>
<td>–</td>
<td>是否正确地调用了 API</td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>是否使用了正确的返回值存取回 redux 中</td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>业务分支逻辑</td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>异常逻辑</td>
<td></td>
</tr>
<tr>
<td>component 层</td>
<td>组件分支渲染逻辑</td>
<td>要求 100%覆盖率</td>
<td>这个层级最为复杂，以“代价最低，收益最高”的指导原则进行</td>
</tr>
<tr>
<td>–</td>
<td>交互事件是否以正确的参数被调用</td>
<td>要求 100%覆盖率</td>
</tr>
<tr>
<td>–</td>
<td>redux connect 过的组件</td>
<td>不用测</td>
</tr>
<tr>
<td>UI 层</td>
<td>组件是否渲染了正确的样式</td>
<td>可以不测或快照</td>
<td>这个层级测试成本较高、难度较大</td>
</tr>
<tr>
<td>utils 层</td>
<td>各种帮助函数</td>
<td>没有副作用的必须 100%覆盖率</td>
</tr>
</tbody>
</table>
<h3 id="action-测试"><a href="#action-测试" class="headerlink" title="action 测试"></a>action 测试</h3><p>这一层获益于架构的简单性，甚至都可以不用测试。当然，如果有些经常出错的 action，可以针对性地对这些 action creator 补充测试。其测试方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> saveUserComments = <span class="function"><span class="params">comments</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'saveUserComments'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    comments,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo use action</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'should dispatch saveUserComments action with fetched user comments'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> comments = [];</span><br><span class="line">  <span class="keyword">const</span> expected = &#123;</span><br><span class="line">    type: <span class="string">'saveUserComments'</span>,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      comments: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> result = actions.saveUserComments(comments);</span><br><span class="line">  expect(result).toEqual(expected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="reducer-测试"><a href="#reducer-测试" class="headerlink" title="reducer 测试"></a>reducer 测试</h3><p>reducer 大概有两种：</p>
<ul>
<li>一种比较简单，仅一一保存对应的数据切片；</li>
<li>一种复杂一些，里面具有一些计算逻辑。<br>对于第一种 reducer，写起来非常简单，简单到甚至可以不需要用测试去覆盖，其正确性基本由简单的架构和逻辑去保证。下面是对一个简单 reducer 做测试的例子：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo reducer</span></span><br><span class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">'seamless-immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = Immutable.from(&#123;</span><br><span class="line">  isLoadingProducts: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createReducer(<span class="function"><span class="params">on</span> =&gt;</span> &#123;</span><br><span class="line">  on(actions.isLoadingProducts, (state, action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> state.merge(&#123;</span><br><span class="line">      isLoadingProducts: action.payload.isLoadingProducts,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, initialState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo use reducer</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'should save loading start indicator when action isLoadingProducts is dispatched given isLoadingProducts is true'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> state = &#123; <span class="attr">isLoadingProducts</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">isLoadingProducts</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> result = reducers(state, actions.isLoadingProducts(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">  expect(result).toEqual(expected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>reducer 作为纯函数，非常适合做单元测试，加之一般在 reducer 中做重逻辑处理，此处做单元测试保护的价值很大。请留意，上面所说的单元测试，是不是符合我们描述的单元测试基本原则：</p>
<ul>
<li>只关注输入输出，不关注内部实现：在输入不变时，仅可能因为“合并去重”的业务操作不符预期时才会挂测试</li>
<li>表达力极强：测试描述已经写得清楚“当使用新获取到的留言数据分发 action saveUserComments 时，应该与已有留言合并并去除重复的部分”；此外，测试数据只准备了足够体现“合并”这个操作的两条 id 的数据，而没有放很多的数据，形成杂音；</li>
<li>不包含逻辑：测试代码不包含准备数据、调用、断言外的任何逻辑</li>
<li>运行速度快：没有任何依赖</li>
</ul>
<h3 id="selector-测试"><a href="#selector-测试" class="headerlink" title="selector 测试"></a>selector 测试</h3><p>selector 同样是重逻辑的地方，可以认为是 reducer 到组件的延伸。它也是一个纯函数，测起来与 reducer 一样方便、价值不菲，也是应该重点照顾的部分。况且，稍微大型一点的项目，应该说必然会用到 selector。原因我讲在这里。下面看一个 selector 的测试用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo selector</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for performant access/filtering in React component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> labelArrayToObjectSelector = createSelector(</span><br><span class="line">  [<span class="function">(<span class="params">store, ownProps</span>) =&gt;</span> store.products[ownProps.id].labels],</span><br><span class="line">  labels =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> labels.reduce(</span><br><span class="line">      (result, &#123; code, active &#125;) =&gt; (&#123;</span><br><span class="line">        ...result,</span><br><span class="line">        [code]: active,</span><br><span class="line">      &#125;),</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo use selector</span></span><br><span class="line"><span class="keyword">import</span> &#123; labelArrayToObjectSelector &#125; <span class="keyword">from</span> <span class="string">'./selector'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'should transform label array to object'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    products: &#123;</span><br><span class="line">      <span class="number">10085</span>: &#123;</span><br><span class="line">        labels: [</span><br><span class="line">          &#123; <span class="attr">code</span>: <span class="string">'canvas'</span>, <span class="attr">name</span>: <span class="string">'帆布鞋'</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">code</span>: <span class="string">'casual'</span>, <span class="attr">name</span>: <span class="string">'休闲鞋'</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">code</span>: <span class="string">'oxford'</span>, <span class="attr">name</span>: <span class="string">'牛津鞋'</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">code</span>: <span class="string">'bullock'</span>, <span class="attr">name</span>: <span class="string">'布洛克'</span>, <span class="attr">active</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">code</span>: <span class="string">'ankle'</span>, <span class="attr">name</span>: <span class="string">'高帮鞋'</span>, <span class="attr">active</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> expectedActiveness = &#123;</span><br><span class="line">    canvas: <span class="literal">false</span>,</span><br><span class="line">    casual: <span class="literal">false</span>,</span><br><span class="line">    oxford: <span class="literal">false</span>,</span><br><span class="line">    bullock: <span class="literal">true</span>,</span><br><span class="line">    ankle: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> productLabels = labelArrayToObjectSelector(store, &#123; <span class="attr">id</span>: <span class="number">10085</span> &#125;);</span><br><span class="line">  expect(productLabels).toEqual(expectedActiveness);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="saga-测试"><a href="#saga-测试" class="headerlink" title="saga 测试"></a>saga 测试</h3><p>saga 是负责调用 API、处理副作用的一层。在实际的项目上副作用还有其他的中间层进行处理，比如 redux-thunk、redux-promise 等，本质是一样的，只不过 saga 在测试性上要好一些。这一层副作用怎么测试呢？首先为了保证单元测试的速度和稳定性，像 API 调用这种不确定性的依赖我们一定是要 mock 掉的。经过仔细总结，我认为这一层主要的测试内容有五点：</p>
<ul>
<li>是否使用正确的参数（通常是从 action payload 或 redux 中来），调用了正确的 API</li>
<li>对于 mock 的 API 返回，是否保存了正确的数据（通常是通过 action 保存到 redux 中去）</li>
<li>主要的业务逻辑（比如仅当用户满足某些权限时才调用 API 等分支逻辑）</li>
<li>异常逻辑（比如找不到用户等异常逻辑）</li>
<li>其他副作用是否发生（比如有时有需要 Emit 的事件、需要保存到 IndexDB 中去的数据等）</li>
</ul>
<p>我们认为真正能够保障质量、重构和开发者体验的 saga 测试应该是这样：</p>
<ul>
<li>不依赖实现次序；</li>
<li>允许仅对真正关心的、有价值的业务进行测试；</li>
<li>支持不改动业务行为的重构；</li>
</ul>
<p>官方提供了这么一个跑测试的工具，刚好可以用来完美满足我们的需求：runSaga。我们可以用它将 saga 全部执行一遍，搜集所有发布出去的 action，由开发者自由断言其感兴趣的 action！基于这个发现，我们推出了我们的第二版 saga 测试方案：runSaga + 自定义拓展 jest 的 expect 断言。最终，使用这个工具写出来的 saga 测试，几近完美：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put, call &#125; <span class="keyword">from</span> <span class="string">'saga-effects'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Api &#125; <span class="keyword">from</span> <span class="string">'src/utils/axios'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; testSaga &#125; <span class="keyword">from</span> <span class="string">'../../../testing-utils'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onEnterProductDetailPage &#125; <span class="keyword">from</span> <span class="string">'./saga'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> product = <span class="function"><span class="params">productId</span> =&gt;</span> (&#123; productId &#125;);</span><br><span class="line">test(<span class="string">`</span></span><br><span class="line"><span class="string">    should only save the three recommended products and show ads</span></span><br><span class="line"><span class="string">    when user enters the product detail page</span></span><br><span class="line"><span class="string">    given the user is not a VIP</span></span><br><span class="line"><span class="string">    `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> action = &#123; <span class="attr">payload</span>: &#123; <span class="attr">userId</span>: <span class="number">233</span> &#125; &#125;;</span><br><span class="line">  <span class="keyword">const</span> store = &#123; <span class="attr">credentials</span>: &#123; <span class="attr">vipList</span>: [<span class="number">2333</span>] &#125; &#125;;</span><br><span class="line">  <span class="keyword">const</span> recommendedProducts = [product(<span class="number">1</span>), product(<span class="number">2</span>), product(<span class="number">3</span>), product(<span class="number">4</span>)];</span><br><span class="line">  <span class="keyword">const</span> firstThreeRecommendations = [product(<span class="number">1</span>), product(<span class="number">2</span>), product(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">  Api.get = jest.fn().mockImplementations(<span class="function"><span class="params">()</span> =&gt;</span> recommendedProducts);</span><br><span class="line">  <span class="keyword">await</span> testSaga(onEnterProductDetailPage, action, store);</span><br><span class="line">  expect(Api.get).toHaveBeenCalledWith(<span class="string">'products/recommended'</span>);</span><br><span class="line">  expect(actions.importantActionToSaveRecommendedProducts).toHaveBeenDispatchedWith(</span><br><span class="line">    firstThreeRecommendations</span><br><span class="line">  );</span><br><span class="line">  expect(actions.importantActionToFetchAds).toHaveBeenDispatched();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="component-测试"><a href="#component-测试" class="headerlink" title="component 测试"></a>component 测试</h3><p>组件测试其实是实践最多、测试实践看法和分歧也最多的地方。React 组件是一个高度自治的单元，从分类上来看，它大概有这么几类：</p>
<ul>
<li>展示型业务组件</li>
<li>容器型业务组件</li>
<li>通用 UI 组件</li>
<li>功能型组件</li>
</ul>
<p>先把这个分类放在这里，待会回过头来谈。对于 React 组件测什么不测什么，我有一些思考，也有一些判断标准：除去功能型组件，其他类型的组件一般是以渲染出一个语法树为终点的，它描述了页面的 UI 内容、结构、样式和一些逻辑 component(props) =&gt; UI。内容、结构和样式，比起测试，直接在页面上调试反馈效果更好。测也不是不行，但都难免有不稳定的成本在；逻辑这块，有一测的价值，但需要控制好依赖。综合上面提到的测试原则进行考虑，建议是：两测两不测。</p>
<ul>
<li>组件分支渲染逻辑必须测</li>
<li>事件调用和参数传递一般要测</li>
<li>连接 redux 的高阶组件不测</li>
<li>渲染出来的 UI 不在单元测试层级测</li>
</ul>
<p>组件类型/测试内容 | 分支渲染逻辑 | 事件调用 | @connect | 纯 UI<br>展示型组件 | yes | yes | - | no<br>容器型组件 | yes | yes | no | no<br>通用 UI 组件 | yes | yes | - | no<br>功能型组件 | yes | yes | no | no</p>
<h4 id="业务型组件——分支渲染"><a href="#业务型组件——分支渲染" class="headerlink" title="业务型组件——分支渲染"></a>业务型组件——分支渲染</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CommentsSection = <span class="function">(<span class="params">&#123; comments &#125;</span>) =&gt;</span> (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &#123;comments.length &gt; <span class="number">0</span> &amp;&amp; (</span><br><span class="line">	&lt;h2&gt;Comments&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp"> )&#125;</span></span><br><span class="line"><span class="regexp"> &#123;comments.map((comment) =&gt; (</span></span><br><span class="line"><span class="regexp">	&lt;Comment content=&#123;comment&#125; key=&#123;comment.id&#125; /</span>&gt;</span><br><span class="line"> )&#125;</span><br><span class="line"> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p>对应的测试如下，测试的是不同的分支渲染逻辑：没有评论时，则不渲染 Comments header。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommentsSection &#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Comment &#125; <span class="keyword">from</span> <span class="string">'./Comment'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'should not render a header and any comment sections when there is no comments'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> component = shallow(<span class="xml"><span class="tag">&lt;<span class="name">CommentsSection</span> <span class="attr">comments</span>=<span class="string">&#123;[]&#125;</span> /&gt;</span></span>);</span><br><span class="line">  <span class="keyword">const</span> header = component.find(<span class="string">'h2'</span>);</span><br><span class="line">  <span class="keyword">const</span> comments = component.find(Comment);</span><br><span class="line">  expect(header).toHaveLength(<span class="number">0</span>);</span><br><span class="line">  expect(comments).toHaveLength(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'should render a comments section and a header when there are comments'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> contents = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="string">'男***8'</span>, <span class="attr">comment</span>: <span class="string">'价廉物美，相信奥康旗舰店'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">author</span>: <span class="string">'雨***成'</span>, <span class="attr">comment</span>: <span class="string">'所以一双合脚的鞋子...'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> component = shallow(<span class="xml"><span class="tag">&lt;<span class="name">CommentsSection</span> <span class="attr">comments</span>=<span class="string">&#123;contents&#125;</span> /&gt;</span></span>);</span><br><span class="line">  <span class="keyword">const</span> header = component.find(<span class="string">'h2'</span>);</span><br><span class="line">  <span class="keyword">const</span> comments = component.find(Comment);</span><br><span class="line">  expect(header.html()).toBe(<span class="string">'Comments'</span>);</span><br><span class="line">  expect(comments).toHaveLength(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="业务型组件-–-事件调用"><a href="#业务型组件-–-事件调用" class="headerlink" title="业务型组件 – 事件调用"></a>业务型组件 – 事件调用</h4><p>测试事件的一个场景如下：当某条产品被点击时，应该将产品相关的信息发送给埋点系统进行埋点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ProductItem = <span class="function">(<span class="params">&#123; id, productName, introduction, trackPressEvent &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;TouchableWithoutFeedback onPress=&#123;() =&gt; trackPressEvent(id, productName)&#125;&gt;</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Title name=&#123;productName&#125; /&gt;</span><br><span class="line">      &lt;Introduction introduction=&#123;introduction&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>TouchableWithoutFeedback&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ProductItem &#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line">test(<span class="string">`</span></span><br><span class="line"><span class="string">    should send product id and name to analytics system </span></span><br><span class="line"><span class="string">    when user press the product item</span></span><br><span class="line"><span class="string">    `</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> trackPressEvent = jest.fn();</span><br><span class="line">  <span class="keyword">const</span> component = shallow(</span><br><span class="line">    &lt;productitem</span><br><span class="line">      id=&#123;<span class="number">100832</span>&#125;</span><br><span class="line">      introduction=<span class="string">"iMac Pro - Power to the pro."</span></span><br><span class="line">      trackPressEvent=&#123;trackPressEvent&#125;</span><br><span class="line">    &gt;&lt;<span class="regexp">/productitem&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  component.find(TouchableWithoutFeedback).simulate('press');</span></span><br><span class="line"><span class="regexp">  expect(trackPressEvent).toHaveBeenCalledWith(100832, 'iMac Pro - Power to the pro.');</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<h4 id="功能型组件-–-children-型高阶组件"><a href="#功能型组件-–-children-型高阶组件" class="headerlink" title="功能型组件 – children 型高阶组件"></a>功能型组件 – children 型高阶组件</h4><p>功能型组件，指的是跟业务无关的另一类组件：它是功能型的，更像是底层支撑着业务组件运作的基础组件，比如路由组件、分页组件等。这些组件一般偏重逻辑多一点，关心 UI 少一些。其本质测法跟业务组件是一致的：不关心 UI 具体渲染，只测分支渲染和事件调用。但由于它偏功能型的特性，使得它在设计上常会出现一些业务型组件不常出现的设计模式，如高阶组件、以函数为子组件等。下面分别针对这几种进行分述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FeatureToggle = <span class="function">(<span class="params">&#123; features, featureName, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!features[featureName]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function"><span class="params">store</span> =&gt;</span> (&#123; <span class="attr">features</span>: store.global.features &#125;))(FeatureToggle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> FeatureToggles <span class="keyword">from</span> <span class="string">'./featureToggleStatus'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FeatureToggle &#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"><span class="keyword">const</span> DummyComponent = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>;</span><br><span class="line">test(<span class="string">'should not render children component when remote toggle does not exist'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> component = shallow(</span><br><span class="line">    &lt;FeatureToggle features=&#123;&#123;&#125;&#125; featureName=<span class="string">"promotion618"</span>&gt;</span><br><span class="line">      &lt;DummyComponent /&gt;</span><br><span class="line">    &lt;<span class="regexp">/FeatureToggle&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  expect(component.find(DummyComponent)).toHaveLength(0);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">test('should render children component when remote toggle is present and is on', () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const features = &#123;</span></span><br><span class="line"><span class="regexp">    promotion618: FeatureToggles.on,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">  const component = shallow(</span></span><br><span class="line"><span class="regexp">    &lt;FeatureToggle features=&#123;features&#125; featureName="promotion618"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;DummyComponent /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/FeatureToggle&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  expect(component.find(DummyComponent)).toHaveLength(1);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">test('should not render children component when remote toggle is present but is off', () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const features = &#123;</span></span><br><span class="line"><span class="regexp">    promotion618: FeatureToggles.off,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">  const component = shallow(</span></span><br><span class="line"><span class="regexp">    &lt;FeatureToggle features=&#123;features&#125; featureName="promotion618"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;DummyComponent /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/FeatureToggle&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  expect(component.find(DummyComponent)).toHaveLength(0);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<h4 id="utils-测试"><a href="#utils-测试" class="headerlink" title="utils 测试"></a>utils 测试</h4><p>每个项目都会有 utils。一般来说，我们期望 util 都是纯函数，即是不依赖外部状态、不改变参数值、不维护内部状态的函数。这样的函数测试效率也非常高。测试原则跟前面所说的也并没什么不同，不再赘述。不过值得一提的是，因为 util 函数多是数据驱动，一个输入对应一个输出，并且不需要准备任何依赖，这使得它多了一种测试的选择，也即是参数化测试的方式。参数化测试可以提升数据准备效率，同时依然能保持详细的用例信息、错误提示等优点。jest 从 23 后就内置了对参数化测试的支持，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test.each([</span><br><span class="line">  [[<span class="string">'0'</span>, <span class="string">'99'</span>], <span class="number">0.99</span>, <span class="string">'(整数部分为0时也应返回)'</span>],</span><br><span class="line">  [[<span class="string">'5'</span>, <span class="string">'00'</span>], <span class="number">5</span>, <span class="string">'(小数部分不足时应该补0)'</span>],</span><br><span class="line">  [[<span class="string">'5'</span>, <span class="string">'10'</span>], <span class="number">5.1</span>, <span class="string">'(小数部分不足时应该补0)'</span>],</span><br><span class="line">  [[<span class="string">'4'</span>, <span class="string">'38'</span>], <span class="number">4.38</span>, <span class="string">'(小数部分不足时应该补0)'</span>],</span><br><span class="line">  [[<span class="string">'4'</span>, <span class="string">'99'</span>], <span class="number">4.994</span>, <span class="string">'(超过默认2位的小数的直接截断，不四舍五入)'</span>],</span><br><span class="line">  [[<span class="string">'4'</span>, <span class="string">'99'</span>], <span class="number">4.995</span>, <span class="string">'(超过默认2位的小数的直接截断，不四舍五入)'</span>],</span><br><span class="line">  [[<span class="string">'4'</span>, <span class="string">'99'</span>], <span class="number">4.996</span>, <span class="string">'(超过默认2位的小数的直接截断，不四舍五入)'</span>],</span><br><span class="line">  [[<span class="string">'-0'</span>, <span class="string">'50'</span>], <span class="number">-0.5</span>, <span class="string">'(整数部分为负数时应该保留负号)'</span>],</span><br><span class="line">])(<span class="string">'should return %s when number is %s (%s)'</span>, (expected, input, description) =&gt; &#123;</span><br><span class="line">  expect(truncateAndPadTrailingZeros(input)).toEqual(expected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2018/07/12/tools/【工具】颜色英文名称/" class="prev">Previous Post<span>【工具】web颜色英文名称.md</span></a></div><div class="post-next"><a href="/2018/06/15/ux_way/《UX设计之道》—10.设计原则/" class="next">Next Post<span>《UX设计之道》—10.设计原则</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> Recent Posts</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/06/16/html/记录HTML中与性能:渲染有关的几个新属性/">记录HTML中与性能/渲染有关的几个新属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/02/python/【笔记】《编写高质量Python代码的90个有效方法》-75至90/">【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/25/python/【笔记】《编写高质量Python代码的90个有效方法》-52至74/">【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 52 ～ 74 条读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/14/python/【笔记】《编写高质量Python代码的90个有效方法》-31至51/">【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 31 ～ 51 条读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/17/python/【笔记】《编写高质量Python代码的90个有效方法》-1至30/">【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 1 ～ 30 条读书笔记</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> Tags</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebApi/">WebApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpt/">gpt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/">prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prompt/">prompt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwa/">pwa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形/">图形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常工作/">日常工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨端/">跨端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> Archive</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2024 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script></body></html>