<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wayne的博客</title>
  
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.michealwayne.cn/"/>
  <updated>2022-12-13T08:11:10.676Z</updated>
  <id>http://blog.michealwayne.cn/</id>
  
  <author>
    <name>Micheal Wayne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【笔记】《演进式架构》学习笔记（一）</title>
    <link href="http://blog.michealwayne.cn/2022/12/10/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2022/12/10/notes/【笔记】《演进式架构》（一）/</id>
    <published>2022-12-10T02:58:49.000Z</published>
    <updated>2022-12-13T08:11:10.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《演进式架构》学习笔记（一）"><a href="#《演进式架构》学习笔记（一）" class="headerlink" title="《演进式架构》学习笔记（一）"></a>《演进式架构》学习笔记（一）</h1><p>（此书写得有点杂，但部分内容还可以，以此几篇记录下笔记。）</p><h2 id="一、软件架构"><a href="#一、软件架构" class="headerlink" title="一、软件架构"></a>一、软件架构</h2><p>为了给出解决方案，架构师工作的第一步是<strong>理解业务需求</strong>，也即领域需求。这些需求是使用软件来解决问题的动机，但终究只是架构师在构建架构时需要考虑的因素之一。架构师还必须考虑其他很多因素，其中一些比较明确（比如清楚地写在性能服务水平协议里），还有一些则隐含在商业活动中不言自明（比如公司正着手并购重组，软件架构显然也要有变动）。</p><p>所以对于软件架构师来说，架构水平体现了他们在权衡业务需求和其他重要因素后找到最佳方案的能力。</p><p><img src="/images/notes/20221210/p-1.png" alt="p-1.png"></p><p>在构建软件时，架构师必须明确哪些特征最重要。然而，许多因素是互相矛盾的。</p><p><img src="/images/notes/20221210/p-2.png" alt="p-2.png"></p><p>在为架构设计做必要分析的同时，又要处理好各个因素之间不可避免的冲突，架构师在权衡每个架构设计方案的利弊时，常常需要做出非常艰难的折中。</p><h3 id="演进式架构"><a href="#演进式架构" class="headerlink" title="演进式架构"></a>演进式架构</h3><p>无论我们怎么努力，软件依然变得越来越难以改变。由于各种原因，软件的组成部分不容易变更，而且随着时间推移变得愈发脆弱和难以操作。</p><h4 id="一切都在变化，如何才能长期规划"><a href="#一切都在变化，如何才能长期规划" class="headerlink" title="一切都在变化，如何才能长期规划"></a>一切都在变化，如何才能长期规划</h4><p>软件开发体系由所有的工具、框架、库以及最佳实践（软件开发领域的技术积累）构成。软件开发体系实现了平衡，开发人员能够理解这个体系并为其添砖加瓦。然而，这种平衡是动态的，随着新事物不断出现，平衡不断被打破和重建。</p><p>在软件开发体系中，每一项创新或新实践都可能打破现状，迫使系统重新建立平衡。</p><p>无论是在软件开发的哪个方面，比如编程平台、编程语言、运维环境、持久化技术等，我们都知道改变会持续发生。虽然无法预测技术或领域格局何时会改变，或哪些变化会持续下去，但我们清楚改变是不可避免的。</p><p>如果易于改变是架构的基本原则，那么变更将不再困难。反过来，使架构具备演进能力会导致一组全新的行为出现，进而再次打破整个体系的平衡。</p><h4 id="完成架构构建后，如何防止它逐渐退化"><a href="#完成架构构建后，如何防止它逐渐退化" class="headerlink" title="完成架构构建后，如何防止它逐渐退化"></a>完成架构构建后，如何防止它逐渐退化</h4><p>有一种不幸的退化叫作架构比特衰减，架构师选择特定的架构模式来满足业务需求及让系统具备某些能力，但这些特征常常意外地随着时间推移而退化。</p><p>定义了那些重要的架构特征后，架构师如何保护这些特征不磨损呢？答案是<strong>添加演进能力</strong>。作为新的架构特征，使其在系统演进时保护其他特征。<br>演进能力是一种元特征和保护其他所有架构特征的架构封装器。</p><p>持续架构指构建架构的过程没有最终状态，它会随着软件开发体系的不断变化而演进，并保护重要的架构特征。我们不会尝试定义整个软件架<br>构，因为已经存在很多定义了。我们通过引入时间和变化作为头等架构元素来扩展当前的定义。</p><p>我们对演进式架构的定义如下：<strong>演进式架构支持跨多个维度的引导性增量变更。</strong></p><h3 id="增量变更"><a href="#增量变更" class="headerlink" title="增量变更"></a>增量变更</h3><p>增量变更描述了软件架构的两个方面：如何增量地构建软件和如何部署软件。</p><p>在开发阶段，允许小的增量变更的架构更易于演进，因为对于开发者来说，变更范围相对更小。对部署而言，增量变更指业务功能的模块化和解耦水平，以及它们是如何映射到架构中去的。</p><p>增量变更的成功需要一些持续交付实践的配合。并不是任何情况都需要所有这些实践，但通常它们会一起发生。</p><h3 id="引导性变更"><a href="#引导性变更" class="headerlink" title="引导性变更"></a>引导性变更</h3><p>一旦架构师选择了重要的架构特征，他们会把变更引导进入架构，以保护这些重要特征。为此，我们借用演化计算中的一个概念：<strong>适应度函数</strong>。该函数是一种目标函数，用于计算潜在的解决方案与既定目标的差距。在演化计算中，适应度函数决定一个算法是否在持续提升。换句话说，随着每个算法变体的产生，基于设计者对算法“适应度”的定义，适应度函数决定每个变体的“适应程度”。</p><p>对于演进式架构，随着架构的演进，我们有着类似的需求。我们需要评估机制，来评估变化对架构重要特征的影响，并防止这些特征随着时间的推移而退化。适应度函数的隐喻涵盖多种机制，包括度量、测试和其他检验工具。我们采用这些机制来确保架构不会以不良方式变更。当架构师确定了需要保护的架构特征时，他们会定义一个或多个适应度函数来提供保护。<br>以往，架构往往要划出一部分作为管理活动，最近架构师才接受了通过架构实现变更的思想。架构适应度函数允许在组织需求和业务功能的上下文中制定决策，并为明晰且可测试的决策奠定了基础。演进式架构并不是毫无约束或不负责任的软件开发方式。相反，它可以在高速变迁的业务、严谨的系统需求和架构特征间找到平衡。适应度函数驱动架构设计决策，并引导架构变更适应业务和技术环境的变化。</p><h3 id="多个架构维度"><a href="#多个架构维度" class="headerlink" title="多个架构维度"></a>多个架构维度</h3><p>为了构建可以不断演进的软件系统，架构师不能只考虑技术架构。</p><p>每个项目都有许多维度，架构师在考虑架构演进时必须要想到。下面是一些影响现代软件架构演进能力的常见维度。</p><p><img src="/images/notes/20221210/p-3.png" alt="p-3.png"></p><p>以上每个视角构成一个架构维度——为了支持特定视角而有意进行的划分。</p><p>从实用角度来看，不论如何对关注点进行分类，架构师都需要保证这些维度不磨损。不同的项目有不同的关注点，这导致每个项目都有特定的维度。对于新项目，以上任何技术都能提供有用的见解，但是对于现有的项目，我们必须处理眼前的实际情况。</p><p>按照架构的维度思考，通过评估重要维度对变化的响应，架构师可以分析不同架构的演进能力。随着系统与互相冲突的问题（伸缩性、安全性、分布式、事务性等）关联得越来越紧密，架构师必须跟踪更多的维度。只有结合所有这些重要维度，思考系统将如何演进，才能构建出可以不断演进的系统。</p><p>项目的整个架构范围由软件需求和其他维度构成。当架构和整个体系随着时间的推移一起演进时，我们可以使用适应度函数来保护架构特征，如</p><p><img src="/images/notes/20221210/p-4.png" alt="p-4.png"></p><p>在图 1-3 中，架构师确定了可审计性、数据、安全性、性能、合法性和伸缩性是该应用的关键架构特征。随着业务需求不断变化，每个架构特征都通过适应度函数来保护其完整性。<br>我们强调架构整体的重要性，但也应意识到，技术架构模式及相关议题也是架构演进的很大一部分，比如耦合和内聚。</p><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><p>康威描述道，在设计的最初阶段，人们首先需要高瞻远瞩地思考如何将职责划分为不同的模式。团队分解问题的方式会左右他们之后的选择，这便是康威定律。</p><blockquote><p>在设计系统时，组织所交付的方案结构将不可避免地与其沟通结构一致。 —— 梅尔文 • 康威</p></blockquote><p>正如康威所描述的，当技术人员将问题分解成更小的块，使其更易于委派时，就会产生协调问题。很多组织为了解决协调问题，会设置正式的沟通结构或是建立森严的等级制度，但这样的解决方案往往是僵化的。</p><p>在很多组织中，团队是根据职能来划分的。比如分为前端开发、后端开发、数据库开发。在这样的组织中，管理层从人力资源的角度简单地按照职能划分团队，没有充分考虑工程效率。虽然每个团队都有其擅长的领域（比如构建一个视图，增加一个后端 API 或服务，或者开发一个新的存储机制），但是当需要发布新的业务功能或特性时，三个团队都要参与其中。各个团队通常都会针对眼前的任务优化效率，而不是针对那些更抽象的战略业务目标（特别是有工期压力时）。这会导致各团队往往专注于交付各自的组件，而不关注端到端的特性价值，导致这些组件可能无法高效协作。<br>在这样的团队编制下，由于每个团队都在不同的时间忙于自己的组件，因此那些依赖所有团队的特性需要花费更长的时间。例如，修改目录页这样常见的业务变更涉及 UI、业务规则和数据库模式的变更。如果每个团队都各自为战，那么他们必须协调时间表，这将增加实现该特性所需的时间。</p><p>康威在论文里提到：“每当新的团队组建，其他团队的职责范围会缩小，能够有效执行的可选设计方案也会随之变少。”换句话说，<strong>人们很难改变其职责范围外的事情</strong>。软件架构师需要时刻关注团队的分工模式，从而使架构目标和团队结构保持一致。</p><p>很多构建架构（如微服务）的公司围绕服务边界构建团队，而不是按孤立的技术架构来划分。称之为“康威逆定律”。以这种方式组织团队是理想的，因为团队结构会影响软件开发的很多维度，并且会反映问题的大小和范围。<br><strong>构建与目标系统架构相仿的团队结构，这样项目会更容易实现</strong>。</p><h3 id="为何演进"><a href="#为何演进" class="headerlink" title="为何演进"></a>为何演进</h3><p>在演进式架构的定义中，引导的含义反映了我们想实现的架构，即我们的最终目标。</p><p>为了构建能实实在在演进的架构，架构师必须支持真正的变化，而不是权宜之计的考虑。</p><h2 id="二、适应度函数"><a href="#二、适应度函数" class="headerlink" title="二、适应度函数"></a>二、适应度函数</h2><p>架构的适应度函数的定义如下：架构的适应度函数为某些架构特征提供了客观的完整性评估。</p><p>适应度函数能够保护系统所需的各种架构特征。由于业务驱动、技术能力及其他诸多不同因素，系统和组织对架构的具体需求会有很大区别。有些系统要求很高的安全性，有些要求可观的吞吐量或低延迟，还有一些要求更好的故障恢复能力。这些对系统的考量形成了架构师所关心的架构特征。从概念上来讲，适应度函数体现了系统架构特征的保护机制。</p><p>我们也可以将全系统适应度函数看作适应度函数的集合，其中每个适应度函数对应架构的一个或多个维度。当适应度函数所对应的维度间存在冲突时，使用全系统适应度函数有助于我们做出必要的权衡。类似的问题在处理多功能优化时很常见，想同时优化所有值是不可能的，因此我们必须做出选择。处理架构适应度函数时也一样，架构师熟知的经典案例是：由于加密的开销巨大，性能和安全性可能冲突，因此架构师必须做出艰难的权衡。架构师在调和对立力量时，很多时候为权衡犯难，比如在伸缩性和性能之间做出权衡。然而，对架构师而言，比较这些不同的特征是永恒的难题，因为它们从根本上是不同的（就好像苹果和橙子那样），并且所有利益相关者都认为自己所关心的特征最为重要。全系统适应度函数允许架构师通过统一的机制思考不同的问题，捕捉和保留重要的架构特征。图 2-1 展示了较小的适应度函数和它们所构成的全系统适应度函数之间的关系。</p><p><img src="/images/notes/20221210/p-5.png" alt="p-5.png"></p><p>全系统适应度函数对于架构演进至关重要，它为架构师提供了比较和评估不同架构特征的基础。与对待那些更具针对性的适应度函数不同，架构师很可能不会评估全系统适应度函数，尽管它为日后确定架构决策的优先级提供了指导。</p><blockquote><p>系统绝不是其组成部分的总和，而是各部分相互作用的产物。 ——Russel Ackoff 博士</p></blockquote><h3 id="什么是适应度函数"><a href="#什么是适应度函数" class="headerlink" title="什么是适应度函数"></a>什么是适应度函数</h3><p>数学上，函数从有效输入值集合中获得输入，将其转换为有效输出值集合中的唯一元素。在软件中，我们也普遍使用“函数”来指代可实现的东西。</p><p>正如敏捷软件开发中的验收标准，适应度函数可能无法通过软件的方式实现（比如出于监管原因必须手动完成的某个过程），于是架构师还必须定义手动的适应度函数来指导系统演进。虽然我们倾向于实施自动化检查，但是有些项目无法自动化所有适应度函数。</p><p>也可以通过适应度函数保持代码规范。圈复杂度是常用的代码衡量指标，用来衡量函数或方法的复杂度。架构师可以设置一个阈值上限，然后在持续集成中运行单元测试来保护它，最后使用工具评估该衡量指标。在前面的例子里，架构师决定何时运行适应度函数来评估性能。对于代码规范而言，开发人员希望出现不规范的代码时构建立即停止，从而能积极地解决问题。</p><p>尽管很有必要，但是由于复杂性及其他约束，开发人员有时无法完整地执行所有适应度函数，比如对产生硬故障的数据库进行故障转移的时候。虽然自恢复的过程或许（也应该）是全自动的，但手动触发测试会更好。另外，尽管我们鼓励使用自动化脚本，但是手动确定测试成功与否或许更高效。</p><p>最终，所谓“适应度函数引导演进式架构”，指的是通过单独的适应度函数评估单个架构选择，同时通过全系统适应度函数确定变更的影响。适应度函数共同指出架构中对我们重要的部分，使我们能够在软件开发过程中做出各种关键又令人烦恼的权衡。</p><p>适应度函数将许多已有的概念统一为一个整体机制，让架构师可以统一思考许多现有的（往往是临时的）“非功能性需求”测试。收集重要的架构阈值和需求作为适应度函数，使得以前模糊又主观的评价标准变得更加具体。我们利用了大量现有机制来构建适应度函数，包括传统的测试、监控等工具。当然，并非所有测试都是适应度函数，只有当测试有助于验证架构问题的完整性时，它才是适应度函数。</p><h3 id="适应度函数分类"><a href="#适应度函数分类" class="headerlink" title="适应度函数分类"></a>适应度函数分类</h3><p>适应度函数有很多不同的分类方式，可以依据其范围、运行频率、动态性及其他因素对其进行分类，必要时还可以对不同分类进行组合。</p><h4 id="原子适应度函数与整体适应度函数"><a href="#原子适应度函数与整体适应度函数" class="headerlink" title="　原子适应度函数与整体适应度函数"></a>　原子适应度函数与整体适应度函数</h4><p>原子适应度函数针对单一的上下文执行，用来校验架构的某一维度，比如某个用来验证模块间耦合的单元测试。<br>对于某些架构特征，开发人员不能只是孤立地测试各个架构维度。整体适应度函数在共享的上下文中运行，综合检验架构的多个维度，比如安全性和伸缩性。开发人员设计整体适应度函数来保证原子级特性能够正常地协同工作。</p><p>显然，我们无法测试架构特征的所有组合，所以架构师需要使用整体适用度函数有选择性地测试那些重要的交互。在做出选择和确定优先级的过程中，架构师和开发人员会评估通过适应度函数实现特定测试场景的难度，从而评估该特征的价值。通常，架构关注点之间的交互决定架构的质量，而这正是整体适应度函数要解决的问题。</p><h4 id="触发式适应度函数与持续式适应度函数"><a href="#触发式适应度函数与持续式适应度函数" class="headerlink" title="触发式适应度函数与持续式适应度函数"></a>触发式适应度函数与持续式适应度函数</h4><p>适应度函数间的另一个区别是执行频率。触发式适应度函数基于特定的事件执行，比如开发人员执行单元测试、部署流水线执行单元测试或质量保障人员执行探索性测试。触发式测试包含了传统测试，比如单元测试、功能性测试、行为驱动开发（BDD），还涉及其他测试开发人员。</p><p>持续式测试不是按计划执行，而是持续不断地验证架构的某些方面，比如事务处理速度。监控驱动开发（MDD）是另一种日益普及的测试技术。它通过监控生产环境来评估技术和业务的健康程度，而不是仅仅依赖测试。这些持续式适应度函数比标准的触发式测试更为动态。</p><h4 id="静态适应度函数与动态适应度函数"><a href="#静态适应度函数与动态适应度函数" class="headerlink" title="静态适应度函数与动态适应度函数"></a>静态适应度函数与动态适应度函数</h4><p>静态适应度函数的结果是固定的，比如单元测试的二进制结果——成功或失败。该类型囊括了预定义期望值的适应度函数，比如二进制、数字区间、集合包含等。这类适应度函数通常会用到各种衡量指标。例如，架构师会为代码中的方法定义可接受的平均圈复杂度，并通过嵌在部署流水线的度量工具对其进行检查。<br>动态适应度函数依赖基于额外上下文变化的因素。某些值会视具体情况而定，比如在大规模运行的情况下，大多数架构师会采用较低的性能指标。例如，某公司可能基于伸缩性将性能指标设置为特定范围内的浮动值——在较大的规模下允许较低的性能。</p><h4 id="自动适应度函数与手动适应度函数"><a href="#自动适应度函数与手动适应度函数" class="headerlink" title="　自动适应度函数与手动适应度函数"></a>　自动适应度函数与手动适应度函数</h4><p>显然，架构师喜欢自动化，自动化也是增量变更的一部分。</p><p>然而，尽管我们希望软件开发中的每个部分都实现自动化，但某些部分却抗拒自动化。有时，系统的某些关键维度就无法自动化，例如对合法性的要求。在为某些问题域构建应用时，出于法律原因，开发人员必须手动认证来进行变更，这样的操作无法自动完成。类似地，某些团队可能希望项目变得更具演进性，但缺乏合适的工程实践。例如，在某些特定的项目上，大部分的质量保障工作仍然是手动的，并且这种情况在短期内不会改变。在以<br>上两种（及其他）情况下，我们需要人为操作验证的手动适应度函数。<br>由此可见，虽然尽可能地消除手动步骤可以提高效率，但许多项目仍依赖必要的手动过程。我们需要为这些特征定义适应度函数，在部署流水线时添加手动阶段对其进行验证。</p><h4 id="临时适应度函数"><a href="#临时适应度函数" class="headerlink" title="　临时适应度函数"></a>　临时适应度函数</h4><p>虽然大多数适应度函数在变更发生时被触发，但架构师可能想通过时间组件评估适应度。例如，当项目使用了某个加密库时，架构师或许想创建一个临时适应度函数，在该加密库发生重大更新时发出提醒。升级前破坏（break upon upgrade）测试是这类适应度函数的另一种常见用法。例如，在某些平台的项目（比如 Ruby on Rails）中，一些开发人员不想等到下个版本发布时才能使用那些吸引人的新特性，于是他们将这些新特性直接移植到当前版本。但是移植过来的特性往往与实际发布的版本不兼容，因此开发人员通过升级前破坏测试来封装移植特性，迫使升级时重新对其进行评估。</p><h4 id="预设式高于应急式"><a href="#预设式高于应急式" class="headerlink" title="预设式高于应急式"></a>预设式高于应急式</h4><p>虽然在项目初期，架构师会定义大多数适应度函数，因为它们阐明了架构的特征，但有些适应度函数在系统开发阶段才显现。架构师无法在开始时就知晓架构的所有重要部分。</p><h4 id="针对特定领域的适应度函数"><a href="#针对特定领域的适应度函数" class="headerlink" title="　针对特定领域的适应度函数"></a>　针对特定领域的适应度函数</h4><p>某些架构有着特定的关注点，比如特殊的安全或监管需求。</p><h3 id="尽早确定适应度函数"><a href="#尽早确定适应度函数" class="headerlink" title="尽早确定适应度函数"></a>尽早确定适应度函数</h3><p>团队应该尽早确定适应度函数，将其作为初步理解全局架构关注点的一部分。团队还应该尽早确定系统适应度函数，来帮助他们确定想实现的变更。比较实现不同架构特征（及其适应度函数）的价值和难度，有助于更早地设置高风险工作的优先级，从而做出能够应对变化的设计。</p><p>没能确定适应度函数的团队将面临如下风险：</p><ul><li>做出错误的设计选型，最终导致软件构建失败。</li><li>做出的设计选型在时间和成本上出现不必要的浪费。</li><li>系统无法轻松应对日后的环境变化。</li></ul><p>对于任何软件系统，团队都应该尽早确定最重要的适应度函数及其优先次序。这有助于架构师将大型系统拆解成更小的系统，使每个系统对应较少的适应度函数。</p><p>适应度函数可以简单分为三类。</p><p><img src="/images/notes/20221210/p-6.png" alt="p-6.png"></p><p>将适应度函数的执行结果可视化至明显的公共区域，能使开发人员记得在日常编码中考虑它们，保持关键部分和相关适应度函数的活力。</p><p>对适应度函数进行分类有助于确定设计决策的优先级。如果一个设计决策对某个关键适应度函数有特定影响，那么应该花费更多时间和精力进行探针试验（时间可控的试验性编码工作）来校验设计的架构。有些团队采取基于集合的开发方式，它是精益和敏捷流程中的开发实践，用于同时设计多个解决方案。它以构建多套方案为代价来换取未来决策的可选方案。</p><h3 id="审查适应度函数"><a href="#审查适应度函数" class="headerlink" title="审查适应度函数"></a>审查适应度函数</h3><p>适应度函数审查以会议的形式进行，会上主要业务和技术利益相关者会一起讨论如何修改适应度函数以满足设计目标。例如，当市场份额或用户数量显著增长时，或者引入新的功能或业务能力时，又或者大规模检修现有系统时，都必须审查适应度函数。</p><p>适应度函数审查大致涉及如下几点：</p><ul><li>审查已有的适应度函数。</li><li>审查当前适应度函数的相关性。</li><li>确定每个适应度函数的规模或大小的变化。</li><li>确定是否有更好的方法测量或测试系统的适应度函数。</li><li>发现系统可能需要支持的新的适应度函数。</li></ul><p>我们希望架构在引导下演进，所以我们在架构的不同方面设置约束来防止架构朝着错误的方向演进。</p><h2 id="实施增量变更"><a href="#实施增量变更" class="headerlink" title="实施增量变更"></a>实施增量变更</h2><blockquote><p>演进式架构支持跨维度进行引导式增量变更。</p></blockquote><p>演进式架构的定义暗含了增量变更，这意味着这种架构更容易实现小的增量变更。<br>论增量变更的两个方面：首先是开发方面，涵盖如何构建软件；然后是运维方面，涵盖如何部署软件。</p><h3 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h3><p>在持续交付及其工程实践的推动下，近年来很多能在架构级别提供灵活性的构件成为了主流。</p><p>软件架构师必须决定系统的构成方式，他们通常绘制不同规格的图表来完成此项工作。架构师常错误地将架构视为一个待解的方程。随着时间推移，业务和技术的不断变化要求架构师采用四维视图描绘架构，这使得演进成为重中之重。</p><p>软件中的一切都是动态的。</p><p>为了在现实世界中生存，现代架构必须是可部署和可变的。<br>只有成功完成了架构设计、实现、升级和无法避免的变更后，甚至当架构能够经受由前期未知的未知因素引起的反常事件带来的考验时，架构师才能评价架构的长期有效性。</p><h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><p>可测试性（架构特征是否能够通过自动化测试验证其正确性）是软件架构中一个被经常忽略的特性。但由于缺乏工具的支持，通常很难测试架构的各个部分。<br>但是，架构的某些方面确实可以轻松测试。<br>任何人都可以管理适应度函数，并且不同的团队和角色可以共同承担该职责。</p><p>一旦架构师确定了适应度函数，就应该确保及时地对其进行评估。自动化是持续评估的关键。部署流水线是进行此类评估的常用工具。使用部署流水线，架构师可以决定执行适应度函数的类别、时间和频率。</p><h4 id="部署流水线"><a href="#部署流水线" class="headerlink" title="部署流水线"></a>部署流水线</h4><p>持续交付描述了部署流水线机制。和持续集成服务器类似，部署流水线在“监听”到变化后执行一系列验证步骤，每一步都更加复杂。</p><p>部署流水线还提供了执行架构适应度函数的理想方式——它适用于任何验证标准，在多个阶段包含不同抽象程度和复杂程度的测试，并在系统发生任何变更时执行这些测试。</p><p>在部署流水线中执行适应度函数时，不同类型的适应度函数通常会发生交叉。</p><p><img src="/images/notes/20221210/p-7.png" alt="p-7.png"></p><p><img src="/images/notes/20221210/p-8.png" alt="p-8.png"></p><h4 id="目标冲突"><a href="#目标冲突" class="headerlink" title="目标冲突"></a>目标冲突</h4><p>敏捷软件开发流程告诉我们：开发人员越早发现问题，那么解决问题的成本将越低。考虑所有架构维度的一个副作用是早期针对不同维度的目标会互相冲突。例如开发人员所在的组织后续想追求最激进的变更频率来支持新功能。代码的快速变更意味着数据库结构的快速变更，但 DBA 更关心稳定性，因为他们构建的是数据仓库。这两个演进目标在技术架构和数据架构间相互冲突。</p><p>显然，考虑到影响根本业务的诸多因素，团队必须做出一些妥协。使用架构维度识别部分架构关注点（并通过适应度函数对其进行评估），让我们能对不同的关注点进行“苹果和苹果”（同类事物）的比较，使优先级更加明确。<br><strong>目标冲突无法避免</strong>。但是，尽早发现和量化这些冲突可以使架构师做出更明智的决定，制定出更清晰的目标和原则。</p><h3 id="假设驱动开发和数据驱动开发"><a href="#假设驱动开发和数据驱动开发" class="headerlink" title="假设驱动开发和数据驱动开发"></a>假设驱动开发和数据驱动开发</h3><p>数据驱动开发的例子——使用数据来驱动变更，并集中精力于技术变更。另一个类似的方法是假设驱动开发，该方法更关注业务<br>问题而非技术问题。</p><p>在《精益企业》这本书中，Barry O’Reilly 介绍了假设驱动开发的现代化过程。在这个过程中，团队应该利用科学手段，而不是收集正式的需求然后花费时间和资源将功能构建到系统中。一旦团队创建出应用的最小可行产品（无论是新产品还是维护现有产品），他们便能在构思新功能时建立假设，而不是需求。假设驱动开发的假设是根据假设来检验的，什么试验可以确定结果以及用什么验证假设意味着应用开发的走向。</p><p>驱动敏捷软件方法论的引擎是内置的<strong>反馈环</strong>，如测试、持续集成和迭代等。然而包含应用程序最终用户的反馈环已经脱离了团队的控制。使用假设驱动开发，我们能以一种前所未有的方式将最终用户纳入构建流程，从他们的行为中学习并构建出对其真正有价值的系统。</p><p>为了产生可观的结果，试验应该进行足够长的时间。通常最好找到某种可衡量的方式来确定更好的结果，而不是通过弹出窗口等形式的调查来打扰客户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《演进式架构》学习笔记（一）&quot;&gt;&lt;a href=&quot;#《演进式架构》学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;《演进式架构》学习笔记（一）&quot;&gt;&lt;/a&gt;《演进式架构》学习笔记（一）&lt;/h1&gt;&lt;p&gt;（此书写得有点杂，但部分内容还可以，以此几篇
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TypeScript的图灵完备性</title>
    <link href="http://blog.michealwayne.cn/2022/11/19/typescript/%E6%B5%85%E8%B0%88TypeScript%E7%9A%84%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%80%A7/"/>
    <id>http://blog.michealwayne.cn/2022/11/19/typescript/浅谈TypeScript的图灵完备性/</id>
    <published>2022-11-19T11:34:23.000Z</published>
    <updated>2022-11-22T05:53:20.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈-TypeScript-的图灵完备性"><a href="#浅谈-TypeScript-的图灵完备性" class="headerlink" title="浅谈 TypeScript 的图灵完备性"></a>浅谈 TypeScript 的图灵完备性</h1><h2 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h2><p>先从定义出发：（<a href="https://zh.m.wikipedia.org/zh/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7" target="_blank" rel="noopener">WikiPedia-图灵完备</a>）在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。这意味着这个系统也可以识别其他数据处理规则集，图灵完备性被用作表达这种数据处理规则集的一种属性。如今，几乎所有编程语言都是具有图灵完备性的。</p><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p><img src="/images/20221119/p-1.png" alt="p-1"></p><p>图灵机是一个虚拟的机器，由<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">艾伦·麦席森·图灵</a>1936 年提出来的，尽管这个机器很简单，但它可以模拟计算机的任何算法，无论这个算法有多复杂。</p><p>在 1928 年第八届国际数学家大会上，德国数学家<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%8D%AB%C2%B7%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener">希尔伯特（David Hilbert，1862 - 1943）</a>提出了关于数学的三个精辟问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First, was mathematics complete ...（数学是完备的吗？）</span><br><span class="line">Second, was mathematics consistent ...（数学是一致的吗？）</span><br><span class="line">And thirdly, was mathematics decidable ?（数学是可判定的吗？）</span><br></pre></td></tr></table></figure><p>希尔伯特的第三个问题又被称为判定性问题（<a href="https://en.wikipedia.org/wiki/Entscheidungsproblem" target="_blank" rel="noopener">Entscheidungsproblem</a>）。为了证否这个命题，1936 年，图灵发表了一篇论文，题为《论可计算数，及其在判定性问题上的应用》（<a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/plms/s2-42.1.230" target="_blank" rel="noopener">On Computable Numbers, with an Application to the Entscheidungsproblem</a>）。在这篇论文里，图灵提出了一种假设的计算装置，他称之为 A-Machine（Automatic Machine，自动机器），这就是图灵机（Turing Machine）。</p><p>关于图灵机具体运作及 Brainfuck 语言本文不做整理，可以看<a href="https://zh.m.wikipedia.org/zh-hans/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="noopener">WikiPedia-图灵机介绍</a>，<a href="https://zh.m.wikipedia.org/zh-hans/Brainfuck" target="_blank" rel="noopener">WikiPedia-Brainfuck</a></p><h4 id="可计算函数"><a href="#可计算函数" class="headerlink" title="*可计算函数"></a>*可计算函数</h4><blockquote><p>A function is effectively calculable if its values can be found by some purely mechanical process.</p></blockquote><p>如果一个函数的值可以通过某种纯机械的过程找到，那么这个函数就可以有效地计算出来。</p><p>在作为特定计算模型的图灵机上产生的可计算函数，就被称为图灵可计算函数。</p><h4 id="图灵等价"><a href="#图灵等价" class="headerlink" title="图灵等价"></a>图灵等价</h4><p>还有一个相关概念是<strong>图灵等价</strong> – 如果 <code>P</code> 可以模拟 <code>Q</code> 并且 <code>Q</code> 可以模拟 <code>P</code>，则两台计算机 <code>P</code> 和 <code>Q</code> 称为等效计算机。 <a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98" target="_blank" rel="noopener">邱奇－图灵论题</a>认为任何可以通过算法计算其值的函数都可以由图灵机计算，因此，如果任何真实世界的计算机都可以模拟图灵机，则其对图灵机是图灵等价的。 通用图灵机可用于模拟任何图灵机，且可以扩展现实世界计算机的计算方面。</p><p>如果某物是图灵完备的，则它可以用于模拟某些图灵完备的系统。</p><h3 id="图灵完备的意义"><a href="#图灵完备的意义" class="headerlink" title="图灵完备的意义"></a>图灵完备的意义</h3><p>数学家们早已经提出了邱奇-图灵论题以概括图灵机的计算能力，<strong>任何可计算过程都可以用图灵机来模拟</strong>。这是一个论题而非定理，因为它实际上是对可计算过程的定义，而非证明。但迄今为止，人们尚未发现一个可以视为计算的过程是图灵机不能模拟的。</p><p>图灵完备性也可以用来描述计算机语言的计算能力，如果一门语言图灵完备，这就意味着这门语言可以做到能够用图灵机能做到的所有事情，可以解决所有的可计算问题。</p><h3 id="图灵完备语言"><a href="#图灵完备语言" class="headerlink" title="图灵完备语言"></a>图灵完备语言</h3><p>具有图灵完备性的计算机语言，就被称为图灵完备语言。绝大多数的编程语言，都是图灵完备语言。</p><p>它意味着任何实现以下八条指令的机器都是一台计算机（因此可以执行任何种类的计算）。</p><ul><li><code>.</code> <code>,</code>: 输入或输出一个指令</li><li><code>+</code> <code>-</code>: 加或减内存中的值</li><li><code>&gt;</code> <code>&lt;</code>: 将当前的指针向左或向右移动。</li><li><code>[</code> <code>]</code>: 执行循环</li></ul><p>如果某种语言可以执行以上八种指令，就可以称为是图灵完备的。</p><p>证明我们可以（用这个程序语言）模拟一个图灵机是一个证明语言图灵完备性的好方法，但这不是唯一的方法，另一种方法是证明你的语言能够描述所有的<a href="https://en.wikipedia.org/wiki/General_recursive_function" target="_blank" rel="noopener">μ-recursive functions</a>。</p><p>广泛使用的所有通用语言：</p><ul><li>过程式语言，如 FORTRAN、Pascal 等。</li><li>面向对象语言，如 Java、Python、JavaScript 等。</li><li>多范式语言，如 Ada、C++ 等。</li></ul><p>使用不太常见范式的大多数语言：</p><ul><li>函数式语言，如 Haskell、Mercury 等。</li><li>逻辑式语言，如 Logtalk、Prolog 等。</li><li>声明式语言，如 SQL、XSLT 等。</li><li>深奥的语言（Esoteric Programming Language），一种奇特的数学娱乐形式，程序员用极其困难但数学上图灵等价的语言来实现基本的编程结构。</li></ul><h3 id="非图灵完备语言"><a href="#非图灵完备语言" class="headerlink" title="非图灵完备语言"></a>非图灵完备语言</h3><p>并非所有的计算机语言都是图灵完备的，例如标记语言，或者更恰当地称为“容器语言”或“数据描述语言”，就不是图灵完备的。</p><p>非图灵完备语言（Non-Turing-Complete Language），包括 HTML、JSON、XML、YAML 等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>进行程序计算的一定是图灵完备的，图灵完备的不一定能进行程序计算。</p><h2 id="TypeScript-的图灵完备性"><a href="#TypeScript-的图灵完备性" class="headerlink" title="TypeScript 的图灵完备性"></a>TypeScript 的图灵完备性</h2><p>Typescript 空间分为类型空间和值空间。两个空间不互通，因此值不能当成类型，类型不能当成值，并且值和类型不能做运算等。因此我们需要分别考虑类型空间和值空间的图灵完备性：</p><h3 id="类型系统的图灵完备"><a href="#类型系统的图灵完备" class="headerlink" title="类型系统的图灵完备"></a>类型系统的图灵完备</h3><p>早在 2017 年，TypeScript 的 github 上就有人提出 ts2.2 类型系统是图灵完备的，楼主也给出了<a href="https://gist.github.com/hediet/63f4844acf5ac330804801084f87a6d4" target="_blank" rel="noopener">相关证明</a>，此 issue 也引发了大量讨论（<a href="https://github.com/Microsoft/TypeScript/issues/14833" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/14833</a>）。</p><p><img src="/images/20221119/p-2.png" alt="p-2"></p><p>我们知道，TypeScript 类型系统是“独立”于值系统的存在，我们可以通过映射类型、递归类型定义、索引访问成员类型以及可以创建任意数量的类型，来实现图灵完备。</p><p>如下，当 <code>TrueExpr</code>、<code>FalseExpr</code> 和 <code>Test</code> 定义为适合的类型，如下的实现将具备图灵完备性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc&lt;TArg&gt; = &#123;</span><br><span class="line">  <span class="literal">true</span>: TrueExpr&lt;MyFunction, TArg&gt;;</span><br><span class="line">  <span class="literal">false</span>: FalseExpr&lt;MyFunc, TArg&gt;;</span><br><span class="line">&#125;[Test&lt;MyFunc, TArg&gt;];</span><br></pre></td></tr></table></figure><p>TypeScript 包含了一套完整的类型层面编程能力，就像我们可以用 JavaScript、C++、Go 等编程语言解决各种实际问题一样，TypeScript 可以解决各种类型问题，因为本质上它们的内核都和图灵机等价。</p><p>由此 ts 开发者可以自由发挥类型作用，比如开发判定素数的类型 <code>IsPrime&lt;T&gt;</code> 、将合集类型转换为元组的类型 <code>UnionToTuple&lt;T&gt;</code>、根据条件获取子集类型的类型 <code>ConditionalSubset&lt;T&gt;</code> 等等、即 ts 类型编程。</p><p>比如<code>IsPrime</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params"><span class="built_in">number</span>: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isPrime = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">number</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    isPrime = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">number</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">Math</span>.sqrt(<span class="built_in">number</span>); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">number</span> % i == <span class="number">0</span>) &#123;</span><br><span class="line">        isPrime = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isPrime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型编程的花式操作"><a href="#类型编程的花式操作" class="headerlink" title="类型编程的花式操作"></a>类型编程的花式操作</h3><h4 id="用-ts-类型系统写象棋"><a href="#用-ts-类型系统写象棋" class="headerlink" title="用 ts 类型系统写象棋"></a>用 ts 类型系统写象棋</h4><p><img src="/images/20221119/p-3.png" alt="p-3"></p><p>效果体验：<a href="https://tsplay.dev/Nd4n0N" target="_blank" rel="noopener">https://tsplay.dev/Nd4n0N</a></p><p>具体实现可见：<a href="https://zhuanlan.zhihu.com/p/426966480" target="_blank" rel="noopener">《用 TypeScript 类型运算实现一个中国象棋程序》</a></p><h4 id="用-ts-类型系统写一个-Lisp-解释器"><a href="#用-ts-类型系统写一个-Lisp-解释器" class="headerlink" title="用 ts 类型系统写一个 Lisp 解释器"></a>用 ts 类型系统写一个 Lisp 解释器</h4><p>在 ts 写象棋的引领下，ts 花式操作越来越多，像扫雷等等，甚至有人用于写解释器。</p><p>见：<a href="https://zhuanlan.zhihu.com/p/427309936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/427309936</a></p><h3 id="type-challenges"><a href="#type-challenges" class="headerlink" title="type-challenges"></a>type-challenges</h3><p><img src="/images/20221119/p-4.png" alt="p-4"></p><p>要写出象棋这种花式操作、或者本质来说学好 ts 类型知识，我们需要大量的实践和理解，在这<a href="https://github.com/type-challenges/type-challenges" target="_blank" rel="noopener">type-challenges</a>就是一个很好的实践类学习项目，此项目通过刷题让你更好的了解 TS 的类型系统，编写你自己的类型工具。</p><h3 id="ts-值空间"><a href="#ts-值空间" class="headerlink" title="ts 值空间"></a>ts 值空间</h3><p>相比类型系统，ts 的值空间图灵完备验证就很容易，即 JavaScript 的图灵完备性验证。</p><p>正因为 js 具备图灵完备性，因此像微信无法从根本上禁止小程序代码的热更，因为我们可以根据宿主语言（js）实现任何其他图灵完备的编程语言。比如 用 js 实现 js 解释器、Python 解释器、PHP 解释器等等，甚至你还可以设计一个自己的比如本文的字节码虚拟机。</p><blockquote><p>对微信小程序禁止 eval 热更的讨论感兴趣可以看官方社区——<a href="https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801" target="_blank" rel="noopener">关于禁止小程序 JavaScript 解释器使用规范要求</a></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>ts 类型系统具备图灵完备，虽然用 ts 类型系统写复杂逻辑没有太大意义，但我们也能看到 ts 能做的事越来越多、对于 ts 开发者的使用也越来越灵活方便。</p><p>最后，致敬<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">艾伦·麦席森·图灵（Alan Mathison Turing，1912.6.23 - 1954.6.7）</a>，英国数学家、逻辑学家、密码学家和英国首位计算机科学家，被誉为计算机科学和人工智能之父。</p><p><img src="/images/20221119/p-5.png" alt="p-5"></p><p>思考一下，现在的 CSS 是图灵完备的语言吗？</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://zh.m.wikipedia.org/zh-cn/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-cn/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7</a></li><li><a href="https://github.com/Microsoft/TypeScript/issues/14833" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/14833</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDAzNzY0MQ==&amp;mid=2247486711&amp;idx=3&amp;sn=45297f05551962f12863e34a0b1822ad&amp;chksm=fd39c711ca4e4e07258fc1109dd3f916ba5bc5cac7566de76c4244c184ad1e484b1e608bf3d0&amp;token=1222177772&amp;lang=zh_CN#rd" target="_blank" rel="noopener">《用 TypeScript 实现汉诺塔》</a></li><li><a href="https://zhuanlan.zhihu.com/p/426966480" target="_blank" rel="noopener">《用 TypeScript 类型运算实现一个中国象棋程序》</a></li><li><a href="https://zhuanlan.zhihu.com/p/427309936" target="_blank" rel="noopener">《TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器》</a></li><li><a href="https://juejin.cn/post/6927088564194770951" target="_blank" rel="noopener">《【🤦‍♂️ 工作无用】证明 JS 和 TS 类型编程是图灵完备的》</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5</a></li><li><a href="https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈-TypeScript-的图灵完备性&quot;&gt;&lt;a href=&quot;#浅谈-TypeScript-的图灵完备性&quot; class=&quot;headerlink&quot; title=&quot;浅谈 TypeScript 的图灵完备性&quot;&gt;&lt;/a&gt;浅谈 TypeScript 的图灵完备性&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://blog.michealwayne.cn/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编三——架构原则，技艺、艺术与美</title>
    <link href="http://blog.michealwayne.cn/2022/10/23/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%B8%89/"/>
    <id>http://blog.michealwayne.cn/2022/10/23/notes/【笔记】《我的架构思想：基本模型、理论与原则》编三/</id>
    <published>2022-10-23T09:23:16.000Z</published>
    <updated>2022-10-25T03:32:32.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美"><a href="#《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美"></a>《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美</h1><h2 id="架构原则"><a href="#架构原则" class="headerlink" title="架构原则"></a>架构原则</h2><h3 id="架构第一原则：架构面向问题，但满足需求"><a href="#架构第一原则：架构面向问题，但满足需求" class="headerlink" title="架构第一原则：架构面向问题，但满足需求"></a>架构第一原则：架构面向问题，但满足需求</h3><h4 id="“我们已接受的许多东西是有着商业背景的”"><a href="#“我们已接受的许多东西是有着商业背景的”" class="headerlink" title="“我们已接受的许多东西是有着商业背景的”"></a>“我们已接受的许多东西是有着商业背景的”</h4><h4 id="“面向需求通常是不考虑系统的背景的”"><a href="#“面向需求通常是不考虑系统的背景的”" class="headerlink" title="“面向需求通常是不考虑系统的背景的”"></a>“面向需求通常是不考虑系统的背景的”</h4><p>从提供方来考虑的方案，通常是面向“同类系统的同类需求”的。这种需求上的相似性才决定了方案的价值。它并不考虑确定系统的背景，因为背景的不同正好削弱了方案的价值。然而，我们事实上是无法脱离背景来讨论系统问题的。</p><h4 id="“面向问题首先是客户视角的变化”"><a href="#“面向问题首先是客户视角的变化”" class="headerlink" title="“面向问题首先是客户视角的变化”"></a>“面向问题首先是客户视角的变化”</h4><p>“面向需求”本身是没什么错的，因为我们的软件开发活动最终总是要解决用户的实际需求。但需求的“持续可变”是所有问题浮在冰海上的表象，正是它们随海水的、风力的变化而变化着，才导致我们“面向需求”去求解时疲于奔命。这其中，一个重要的问题在于：客户是很难从系统角度上识别问题的，并且当他们站在“客户与供应商”的层面上思考时，他们也完全不必要对可能的系统问题作出解释。</p><p>只有当二者站到“共同解决问题”的角度上来看，才是共赢的，进而问题本身就变成了焦点：<strong>需求可以通过对问题的阶段性关注、梳理来明确；需求的变化可以通过架构的确定性来消化</strong>。</p><p>对于“供应商/开发方”来说，面向问题会是一个主动发起合作，进而争取普遍合作的开端。</p><h4 id="“面向问题与开发实作并无冲突”"><a href="#“面向问题与开发实作并无冲突”" class="headerlink" title="“面向问题与开发实作并无冲突”"></a>“面向问题与开发实作并无冲突”</h4><p>但是“面向问题”这一概念对于开发人员同样显得空乏。因为问题的关键求解在于架构，而不在于具体实作阶段的某一个技术行为。</p><p>开发人员可以在任意时候、任意位置，就地实现数据库或数据结构。但是，这必将给架构角色带来层次规划上的灾难。因为如果推进这一方法，则在“第二阶段”来考虑数据建模时，系统架构将无法进行调整以容纳、应用新的数据模型。</p><p>因此，架构在第一阶段既不能“放任”开发人员的数据规划行为，也没有足够的信息与时间来进行数据建模。但这一矛盾的实质并不在于“谁做数据建模”，而在于“何时定义其细节”。而使架构角色在这里陷入了两难困境的原因则在于，他对自身的职责仍然缺乏必要的了解。回顾此前我们在架构过程中提及的两项架构责任：</p><ul><li>其一，架构对实施的约束；</li><li>其二，架构的阶段抽象在实现域与交付域的映射。</li></ul><p>由此看来，架构应当在第一阶段中与开发人员约定（注意做这些约定，其本质上也是数据建模活动）：</p><ul><li>开发人员的数据规划行为必须限于当前应用中的数据层；</li><li>必须通过一个界面交付到应用层，避免直接访问；</li><li>若该数据规划涉及多个应用，则必须由架构角色来确认规划的有效性；</li><li>数据层的交付界面必须不涉及特定数据层实现方案的细节”</li></ul><p>架构的约束既体现为对问题的把握，也体现为面向问题的、阶段性的隔离。它对整个系统工程构成影响的方式既包括一系列架构图例，也包括上述的一些实施规则，最后——也最为重要的是，还包括架构师对问题的分解。</p><h4 id="“面向问题是架构活动的必须”"><a href="#“面向问题是架构活动的必须”" class="headerlink" title="“面向问题是架构活动的必须”"></a>“面向问题是架构活动的必须”</h4><p>软件架构活动的来处并不在于“变化的需求”，<strong>只有将架构所解决的本质对象定义为“问题”，架构本身才有长期与持续性的需求</strong>；架构本身的复杂性与规模才有出处；架构应对于“持续可变的需求”才能寻得方法。</p><p>总的来说，需求可能一样，但问题却未必相同；需求可能被满足，但问题未必会因满足需求而消失；需求可能是破碎的，但问题却恒久而弥新。因此，<strong>架构的思维对象必须直接指向问题</strong>。唯只如此，架构活动的本质，才在于面向问题的求解；而其结果，才会是一个长期的、有效的、可持续推进的架构，而非应对一时之所需的技法。</p><h3 id="架构第二原则：架构基于概念抽象，而非想象"><a href="#架构第二原则：架构基于概念抽象，而非想象" class="headerlink" title="架构第二原则：架构基于概念抽象，而非想象"></a>架构第二原则：架构基于概念抽象，而非想象</h3><h4 id="“1-形式化方法”"><a href="#“1-形式化方法”" class="headerlink" title="“1. 形式化方法”"></a>“1. 形式化方法”</h4><p>作为第一原则，“架构面向问题”是无助于讨论“架构是什么”这一设问的。架构作为一个确定的工作产物，它必须有对其形态的确切说明，否则我们无法以之作为后续实施的依据。</p><p>举例来说，若“架构师所想”是架构，那么架构的本意是无形的，它在被叙述的一刹那便已走了模样；若“架构师所言”是架构，那么架构最终必以录音为载体，并且后续的分析也将基于对录音的讨论。类似的，我们讨论架构的形态，是要讨论架构本身可否用作持续依赖（我的意思是实施）和持续讨论（我的意思是不同阶段的架构），并更具体地阐明“依赖与讨论”的可行方法。</p><p>不幸的是，总体来说，在这个问题上我们的可选答案并不多。就目前对思维表达方法的研究来看，我们只有<strong>意象化</strong>和<strong>形式化</strong>两条路可走。意象化包含联想与想象，例如说作者 A 在纸上画下一个圆，观者 B 可以自由地认为那是一张面饼，或者是昨晚所见的月亮。至于这一意象是否确实是 A 所绘的这个圆的本意，是不要紧的。如果非得说这一意象有传递的效果，那么我们可以强调 A 绘制的圆表达了“完整”，而 B 所见的面饼与月亮总的来说在形态上也是完整而无有或缺的。</p><p>从非形式化到形式化，一路走来，我们唯一可选的是“<strong>更加明确的形式化</strong>”。这是表达架构——这一思维活动的结果的最终方法。</p><h4 id="“2-形式化的基础是抽象”"><a href="#“2-形式化的基础是抽象”" class="headerlink" title="“2. 形式化的基础是抽象”"></a>“2. 形式化的基础是抽象”</h4><p>形式化方法本质上只是“在我们现在、在对思维的表达方式过于粗略的前提下的、不得已而为之的”一种方法。</p><p>其一，在表达之前的思维活动中，究竟形成了什么；其二，在表达之后的验证活动中，我们可选择何种方法。</p><p>确定的形式必然包括<strong>抽象</strong>、<strong>概念</strong>以及<strong>基于此的确定表达法</strong>。否则它必将无法作为我们表达确定思维的基础构件——与此相对应的，意象适合表达的是非确定的思维。<br>抽象是不具体的，但抽象的表达是确定的；具象是确实的，但基于具象的表达却是不确定的。如上二者互成矛盾，但是却构成我们思维与表达的全部极限。作为架构的目的——产生确定的系统——的所需，我们只能选择抽象。而所谓形式化，只是“思维的抽象表达”的一种方法。</p><h4 id="“3-形式化的表达必须以语法和语义为基础，而忽略语用”"><a href="#“3-形式化的表达必须以语法和语义为基础，而忽略语用”" class="headerlink" title="“3. 形式化的表达必须以语法和语义为基础，而忽略语用”"></a>“3. 形式化的表达必须以语法和语义为基础，而忽略语用”</h4><p>架构存在的基本价值在于交流，如果不需要交流，那么这个开发活动中就自然不需要一个“具形的、存在的架构”。</p><p>总的来说，交流有两个基本的要素，其一是交流的主客体，其二是交流的对象。</p><p>任何有语法与语义并以语法为交流形式，以语义为交流对象的，都可以称为（广义上的）语言。</p><p>我们尽可以有任意多种形式，也包括这一形式的要件（我是指概念、抽象与表达法），但如果要表达架构师的思维，那么它还必须以语义为交流的对象。这是“架构师应以形式化语言为交流工具”的一个推理过程，在“形式化”上，它是指语言工具的基础要件；在“语言”上，它是强调语言的语义特性。</p><p>忽略语用”仍然是考虑“架构的目的——产生确定的系统”的所需，而进行的一个选择。</p><p>架构师所表达的系统是不确定的，在交流客体的感受上会变成“架构师主观而随意地阐述着系统。</p><h3 id="架构第三原则：架构-范围-联接件。"><a href="#架构第三原则：架构-范围-联接件。" class="headerlink" title="架构第三原则：架构=范围+联接件。"></a>架构第三原则：架构=范围+联接件。</h3><h4 id="“1-基本前设”"><a href="#“1-基本前设”" class="headerlink" title="“1. 基本前设”"></a>“1. 基本前设”</h4><p>(本原则是对第二原则的补充，讨论架构作为工作产物时的内容。)</p><p>架构的目标究竟是什么？我们当然知道其目标是系统——无论是大的、复杂的体系，还是一个小的、有含义的组成，又或是我们要考虑其系统性的任何东西。然而这一概念下的系统，其内涵是丰富以至于无可穷尽的。架构作为一个事实工具或对于这一系统的事实影射，只能表达其中的部分而决非全集。因此，我们所谓“架构的目标是什么”，其答案必将指向系统，也必然是系统特定的一面两面或数个方面。</p><h4 id="“2-范围与联接件之于系统的意义”"><a href="#“2-范围与联接件之于系统的意义”" class="headerlink" title="“2. 范围与联接件之于系统的意义”"></a>“2. 范围与联接件之于系统的意义”</h4><p>决策层在系统的方向问题上赋予架构师的职责是“目标的映射”。这包括两方面的含义，其一，不一定是确实的目标，例如某个产品或产品的某个版本；其二，是对目标的约束，而非说明其实施的细节。范围与联接件是架构师的两个工具，与其说它们是对规模与复杂性的求解，不如说它们事实上就是架构师对“系统的方向问题”的两个求解。</p><p>所谓方向与目标有一些基本性质，包括：其一，<strong>系统的方向可能是确实的，也可能是阶段性变化的</strong>；其二，<strong>阶段目标清晰而明确，但方向却可能存有模糊性</strong>；其三，<strong>方向必是一个面的问题，而目标方才是点的问题</strong>。</p><p>我们在层次架构中通过“逐层清晰”来解构系统复杂性一样，这一手法通常用来确保系统长期的不变性——复杂性通常是由<strong>可变性</strong>引起的。</p><p>架构在应对系统方向下的规模问题时，采用的方法通常有两个：其一是<strong>对“系统组成”的明确约定</strong>，例如模块图或（细化的）层次架构图；其二是<strong>对系统构件的明确概念</strong>。后者——构建明确概念是架构抽象中最困难而又最重要的工作之一。</p><p>系统总在变大，在它的形态与内涵两个方面都必将存在失控的风险。这两个风险是骈生的。此外，风险与机会也是骈生的，所以架构不仅能够反映系统的“范围与联接件”，也可以反映系统的“转折点”。只是后者常常仅被视作风险而遭到严防死守罢了。</p><h3 id="架构第四原则：过程之于结果，并没有必然性。"><a href="#架构第四原则：过程之于结果，并没有必然性。" class="headerlink" title="架构第四原则：过程之于结果，并没有必然性。"></a>架构第四原则：过程之于结果，并没有必然性。</h3><h4 id="“1-基本前设”-1"><a href="#“1-基本前设”-1" class="headerlink" title="“1. 基本前设”"></a>“1. 基本前设”</h4><p>所谓工程，是一个实作问题，简而言之，工程讨论的就是如何把东西做出来。在这个问题上，架构工程与软件工程类似，也是可以追溯到“<strong>过程、方法、工具</strong>”三个要素的。其中，架构第二原则主要讨论的是方法论问题，间或讨论到与方法论适配的工具问题；架构第三原则可以视为对工程产物的补充。</p><p>形成论与组成论是两个过程观点，前者是过程论的动态模型，后者则是静态模型。将架构结果作为工程产物时，静态模型强调架构的构件之间的结构关系，以及通过这些结构关系来维护“架构目标的系统性”的方法；动态模型则强调架构是一个与时间相关的产生过程 13，在时间轴以及组织性上，架构团队以及系统的参与者都是变化的，（整体来看，）其结果在形态上也是变化的。在后者——形成论的视角下，架构结果是可以通过阶段进化来获得的，而至于这一产生过程是否是一次性的或迭代数次的，则是过程实施中的选择。</p><h4 id="“2-有关过程正确与结果正确的讨论”"><a href="#“2-有关过程正确与结果正确的讨论”" class="headerlink" title="“2. 有关过程正确与结果正确的讨论”"></a>“2. 有关过程正确与结果正确的讨论”</h4><p>“正确的步骤会产生正确的结果”是丰田模式的核心原则的重要组成部分。</p><p>生产过程中如果包含大量的修正过程，则其效率会变得相当低下。这是因为修正过程将使生产过程的周期变长且导致产品品质下降，这些都可以理解为是由过程的不确定性导致。因此，总的来说，尽量摒除生产过程中的修正是得到“正确的步骤”的必经之路。为了这一目标，传统的生产型企业都会有所谓的“产品研制”阶段，在这个阶段中允许大量的修正，并最终交付一个可投入生产的“正确的步骤”。“生产”作为一种工程手段，大抵上是从一个“正确的步骤”的交付开始的。</p><p>形成论下的架构产出是过程记录而非指导性规范，但这是出于“能力上无法做到规格化”，还是出于“架构的某些特殊性质决定了它无法被规格化”，是我仍存疑的；其二，软件系统产品通常是一次性产生的，因此它是否需要一个生产过程并将架构作为生产阶段来理解，是我存疑的；其三，即使上述两点均成立，即我们确需“基于架构的生产过程，且架构规格可作为指导性规范”，我对其可实施性（综合考虑实施成本与团队成本）也是存疑的。<br>但是形成论的“映射与约束”性质必将由组成论来实现。因此结合组成论与形成论，可以在一定程度上解决上面的问题。</p><p>我们尚未能找到过程正确性之于结果的必然关系，因此<strong>“正确形成+正确组成”并不等于正确的架构</strong>。</p><h3 id="架构第五原则：系统的本质，即是架构的本质。"><a href="#架构第五原则：系统的本质，即是架构的本质。" class="headerlink" title="架构第五原则：系统的本质，即是架构的本质。"></a>架构第五原则：系统的本质，即是架构的本质。</h3><h4 id="“1-普遍性架构原则的提出”"><a href="#“1-普遍性架构原则的提出”" class="headerlink" title="“1. 普遍性架构原则的提出”"></a>“1. 普遍性架构原则的提出”</h4><p>架构是面向问题的求解”也只是一个结果，而非完整的、准确的、概念上的架构的本义。</p><p>我们必须重新定义我们所讨论的架构、系统以及二者的关系，这是上述架构第一和第二原则作为普遍性架构原则的必要前提。</p><h4 id="“2-系统性”"><a href="#“2-系统性”" class="headerlink" title="“2. 系统性”"></a>“2. 系统性”</h4><p>总的来说，形成论与组成论是“（面向实作问题的）过程论”下的视角。我们不能因“过程是这样需要的”，而反过来指称“一个系统的本质为何”。本质是不应随应用的需求而变化的，否则其必然是一个“可用的观察”，而非本质本身。</p><p>我们之所以将某个领域集或其他类似的“组成/构成/集/……”称为系统，必是因为它们之间存在某种系统性，以维持它们的内部关系与外部表现。</p><p>这种系统性是系统存在的唯一依据、核心矛盾与主体价值。既如此，这种系统性也必是架构——系统所有的可能映像——的基本事实、本质问题与形成驱动。</p><p>唯有将系统的本质与架构的本质都设定为对“系统何以为系统”的拷问，才能抹去二者因概念抽象而导致的差异。唯只如此，它们才能在“问题与解”上真实地一致，才能在“过程与方法”上无视于系统与架构的先后问题。</p><h4 id="“3-本质”"><a href="#“3-本质”" class="headerlink" title="“3. 本质”"></a>“3. 本质”</h4><p>“在本质上相同的抽象系统，其系统解集的抽象也是本质上相同的。”</p><p>综观我们的知识构成，我们所见并能自由论及的一切系统，都是事实系统的抽象系统，我们只是在多个抽象系统中维持着本质上的相同。<br>系统的本质即是架构的本质。我们必将二者的本质指向同一，其复杂性，亦即结构的本质，方可同一；其方向性，亦即目标的本质，方可同一；其系统性，亦即问题的本质，方可同一。</p><h2 id="技艺、艺术与美"><a href="#技艺、艺术与美" class="headerlink" title="技艺、艺术与美"></a>技艺、艺术与美</h2><h3 id="架构可以“学而时习”的部分"><a href="#架构可以“学而时习”的部分" class="headerlink" title="架构可以“学而时习”的部分"></a>架构可以“学而时习”的部分</h3><p>就传授来说，授业者可以分解步骤、讲述原理并总结经验与诀窍；求学者可以亦步亦趋地跟随，先得其形实，再究其质底。就实作而言，实作者可以在技术的实践活动中有所变化，若这种变化是有了质的区别，我们就称之为“新技术”了。<strong>但即使新旧技术存在质的区别，其目的却没有变化：实现相同的目标，或解决一样的问题。</strong></p><p>架构的确首先是一种实作的技术。这是毋庸置疑的，因为的确是在工程实践过程中产生了架构这一角色并承载了属于它的需求。这也是架构过程的“形成论与组成论”两个观点的真正出处。对于一个既存的架构，实作者认为它是源自于一个形成的过程，所以得到前一种观点，即架构的出处在于这些阶段的组合；而当实作者认为架构表达的是系统映像的具体内容时，便会得到后一种观点，即架构的落足在于这些内容的组成。<br>无论是前者亦或后者，都是将架构作为一个死物，并试图通过模仿来复制一个新的架构。</p><h3 id="死过程与活灵魂"><a href="#死过程与活灵魂" class="headerlink" title="死过程与活灵魂"></a>死过程与活灵魂</h3><p>即使你做出来的同样是一个三层（或 N 层）架构，如果你是通过系统分析、思考、权衡而得到这一架构决策的，那么它仍具有独特而丰富的架构思想；但如果只是因为与当前系统的背景类似，而使得你选择了这种架构形式，那么这只是一个工程师的技术选型，而非架构师的架构过程。</p><p>架构思想是认识系统的方法与结果：从方法上来说，思想决定了如何认识系统；从结果上来说，思想表现为对系统的认识。</p><p>“窠臼是思想的表达，形式是架构的道具。”</p><h3 id="美"><a href="#美" class="headerlink" title="美"></a>美</h3><p>关于技术、技艺与艺术，有三种美。其重点各有不同。</p><ul><li>首先，技术的美在于可行。</li><li>其次，技艺的美在于超越。</li><li>第三，艺术的美在于如一。</li></ul><p>若架构师确有思想，但无法表达出来或他的表达与思想并不一致，那么是不美的；若架构师拿出了一个“看似完美”的作品，却没有任何有意义的思想，那么也是不美的。若架构是一门艺术，则架构艺术的美，必以追求思想、形式、技艺完美如一为最终标准。</p><h3 id="架构的美"><a href="#架构的美" class="headerlink" title="架构的美"></a>架构的美</h3><p>美的学问究其根底是讨论三类东西：美，美的对象，以及美的感受与意识。</p><p>从架构对于工程的意义、对于系统的意义以及对于一个实施团队的意义来说，无限制的、漫无目的地追求美是一种浪费。</p><p>架构的美的对象定位于“时间与空间”两个维度。在时间维度上，我希望一个架构的美在于能以其持续性来保障系统的实施；在空间维度上，我希望一个架构的美在于能以其结构性来保障系统的成本。无论是软件产品还是硬件产品，对于这样一个系统，若既是可实施的又是成本可控的，或称为规模与复杂性可控的，那么该系统是否能最终完成便只需由必要性来决定了。</p><p>当我们回到美的对象，亦即时间与空间下的架构，亦即探求其持续与结构上的美的问题时，我想尽我所能使用的词汇，尽我所能表达的认识，尽我所愿意接受的、对美的架构的最终审美标准来说</p><p>“架构的美在于不朽”</p><h3 id="舞者"><a href="#舞者" class="headerlink" title="舞者"></a>舞者</h3><p>通常，面对一个系统，一开始就讨论高并发、大流量、大数据以及大规模运算的架构师，是入门零段的。他还不懂得忽略与聚焦。</p><p>通常，面对一个系统的组成，大谈平衡与模型的架构师，是入门一段的。他还不懂得平衡只是技法，系统是没有平衡的，系统是在动态中不平衡地发展的；系统是一个时间轴上的东西，而非一个瞬间的衡态，例如模型。</p><p>通常，脱离了平衡的味趣，奔逐于系统的关键，寻求种种方案并努力实施的，是架构师的初段。这并没有不好，这些架构推进并演义了整个行业的瑰丽，如同那珠宝闪烁，成就了前台的舞者。</p><p>通常，诠释着舞蹈之绝美的有两种人，一种是会审美的看客，一种是会创造美的编舞。他们都将自我之见作用于美的一片一片，如同架构师通过时间与空间的拼接来完成系统的全体。美与不美都任由评说，而又各有评说的标准。无论是作为看客还是编舞，这样的架构师已得架构之纲法精要。</p><p>通常，把舞蹈表现得完美无缺的，是一个舞者。那个舞者就是那段舞，当他表演的时候，编舞认为这段舞蹈是为舞者而生，而自己只是那个接生者；看客认为自己是舞者；舞者却从不承认这是表演。这样的架构师，他的架构对象和自己已成一体，但我很难找到一个人来诠释这一角色，因为他必已完美地谢幕。</p><p>其作品也必为不朽。</p><h2 id="附"><a href="#附" class="headerlink" title="*附"></a>*附</h2><p>《大道至简》这本书通过“工程层状模型”（EHM），从“实现者”这一角色出发，并论及 “团队”和“经营”角色。但是——如同上面的问题一样，EHM 模型将这些角色析别出来的时候，也少了一半的观察。</p><p><img src="/images/20220912/p-31.png" alt="p-31"></p><p>在使用“在哪里？是谁？在做什么？”这一工具来仔细分析这两类角色时，我们会发现他们所在的领域也是有区别的：实现角色是在技术领域，团队角色则是在工程领域。技术领域关注的是实现的细节，即通过何种方法能将目标有效地实现出来，因而会追求这一实现过程的最优解；工程领域关注的是团队及其所应对目标的规模，在大多数的情况下，这一角色期望控制这一规模以使“目标、资源与质量”可按某种预期、整体地得到保障。有趣的是，从技术领域来说，一旦更细节的或者更宏大的实现成为可能，那么他们将毫不犹豫地将这种“可能”升级为“必须”，并为之充满激情；而这一切，往往又是以牺牲规模为代价的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编二—
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</title>
    <link href="http://blog.michealwayne.cn/2022/10/04/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%BA%8C/"/>
    <id>http://blog.michealwayne.cn/2022/10/04/notes/【笔记】《我的架构思想：基本模型、理论与原则》编二/</id>
    <published>2022-10-04T02:01:23.000Z</published>
    <updated>2022-10-04T01:50:39.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果"><a href="#《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果"></a>《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</h1><h2 id="架构师的能力结构"><a href="#架构师的能力结构" class="headerlink" title="架构师的能力结构"></a>架构师的能力结构</h2><h3 id="组织视角下的架构师角色"><a href="#组织视角下的架构师角色" class="headerlink" title="组织视角下的架构师角色"></a>组织视角下的架构师角色</h3><p>架构作为一个实施对象，是有明确的实作和理论上的好坏的，并且它必将作用于一个以现实系统为对象或需求的架构目标。而架构师是以组织整体及其决策过程为背景的、实施活动中的角色之一，因而首先是以<strong>组织行为</strong>为核心的，其次才是将“架构”作为目标的优劣判别。</p><p>因此决策过程具有两个方向上的问题，其一是以<strong>架构目标</strong>为对象的，其二是以<strong>组织行为</strong>为对象的。因为架构目标的特点不同，所以这两个方向并非恒等。</p><p>如果架构可以由“一个人”来做，那么由架构意图驱动的架构决策过程将会相当完美。而这个“架构师个体”也必因上述的原因，只需要在架构与其相关领域中有丰富的经验与技术能力即可完成这一过程。事实上，这是软件产品开发中的常态：一名架构师决定整个的系统分析、架构与设计过程，并负责在这一软件的后续产品阶段中对这些原始决策加以修正</p><p>这时，架构师的个体能力往往决定了一个产品实施过程的推进。这一模式可以应用于大多数的软件产品开发过程中。</p><h3 id="架构师的能力模型"><a href="#架构师的能力模型" class="headerlink" title="架构师的能力模型"></a>架构师的能力模型</h3><p>作为一个“规模”的用词，系统是一个“领域集”；即使将这一领域聚焦到“数据+算法”这样的软件开发本质工作中，（在大型系统中）也被具体分成多个领域了。一旦在系统中出现跨领域和领域细分，也或者说这样的背景就是我们将“系统”作为一个规模设定的本质，那么架构也就通常是一个人无法完成的了。</p><p>因此，在这个系统的解决方案——某个具体的项目中，团队中需要一个架构团队来处理架构方面的具体实作：<strong>实施与推进</strong>。</p><p><img src="/images/20220912/p-8.png" alt="p-8.png"></p><ul><li><strong>领悟</strong>，主要包括架构思维的三个核心能力：“概念抽象能力、概念表达能力和基于概念的逻辑表达能力。”</li><li><strong>领域</strong>，是架构师在目标系统中的背景知识。架构师需要相当的背景知识，才“能够”对目标系统进行恰当的概念抽象，也才“能够”准确把握系统的内在动律与整体动向。</li><li><strong>领袖</strong>，是架构师在领域内和团队内的影响力。领袖能力与领导能力略有区别。后者（即领导能力）主要是在组织视角下对管理者（manager）这样的角色，在其职能、责权与实施能力上的说明；尤其重要的是，就组织的必要性来说，是希望限制领导角色的影响力范围的，跨责权范围的影响力是对领导职权的一个质问。而前者，这里讨论的领袖并非是一个组织角色，而是指架构角色所形成的、超出组织结构的影响力，其主要表达为方向、决策和对团队向心力的把握。</li></ul><p>这一模型由<strong>思维</strong>、<strong>知识</strong>、<strong>行动</strong>三个方向的能力构成。总的来说，个人能力的不同取向决定了他在组织中的职业倾向，而架构师所需的是在三者中相对平衡的一种整体能力。</p><p><img src="/images/20220912/p-9.png" alt="p-9.png"></p><p>当从领域专家这一方向上衡量时，在领域方面的背景知识（一定程度上）反映了他可以应对的架构的规模——之所以选择从领域方面进行考察，是因为“领域”是在架构师团队中进行分工的一般标准</p><p><img src="/images/20220912/p-10.png" alt="p-10.png"></p><p>三个方向上的能力在整体上是平衡的，如果架构师偏向于强化领悟能力而弱化其他，则由于在领域能力上的缺失，其架构思维趋向于理想化，偏于学术；又由于领袖能力的缺失，导致他在决策过程中丧失发言权，或有言无行，疏于实作。类似的，片面强调领域能力，则与工程师无异；片面强调领袖能力，则必将碌碌而难有所为。</p><p><img src="/images/20220912/p-11.png" alt="p-11.png"></p><p>当“架构”被作为计算机系统的一个领域时，该领域也必然具有自己特定的知识，也必然具有自身的系统性需求。因此，“架构整体”作为一个系统性的目标，仍然是存在自身在“目标、规模与实现”三方面的需求，仍然需要架构角色。</p><h3 id="架构决策"><a href="#架构决策" class="headerlink" title="架构决策"></a>架构决策</h3><p>“架构整体”的决策涉及团队管理中的几个问题：</p><ul><li>对架构师团队与技术团队的评估；</li><li>适时地中止讨论并形成架构决议；</li><li>对实施过程有效跟踪并适时发起调整过程。</li></ul><p>参考格拉斯问题解决模型，整个架构推进过程还涉及两个时间方面的决策：</p><ul><li>何时能确定架构解决了系统的核心问题并可以进入实施推进环节；</li><li>一旦实施中发生变更，确定该变更应当在何时予以满足。</li></ul><p><img src="/images/20220912/p-12.png" alt="p-12.png"></p><p>该模型应用于一个开发实施场景中的具体架构决策过程</p><p><img src="/images/20220912/p-13.png" alt="p-13.png"></p><p>这一复杂的决策过程是由多个架构师角色参与的，但其决策者必是其中“以架构整体为目标”的架构师。</p><h3 id="有价值的决策是对意图的响应"><a href="#有价值的决策是对意图的响应" class="headerlink" title="有价值的决策是对意图的响应"></a>有价值的决策是对意图的响应</h3><p>所讨论的系统的规模已经扩展到多个领域，因此需要由架构师团队来处理它的架构需求。进而地，多个领域之间的——系统本身的——问题作为一个独立领域仍然有自身的架构需求，因此我们提出了系统架构师或平台架构师等规模来应对之，并（根据其领袖能力、可能性地）赋予其一定的组织责权，例如“首席架构师”或“主架构师”。</p><p>这一架构角色面对的并非上述系统各个独立领域内部的问题，而是“架构整体”的问题。</p><p>架构有两个效果方面的考量，即它对<strong>时间需求</strong>与<strong>空间需求</strong>的响应与收益。</p><ul><li>其一，若架构不谈时间需求与空间需求，而只谈目标需求，那么“架构整体”就必将等效于“各种架构的全集”。然而，若这个全集的元素之间没有关系，也就无法构成整体，进而“全集”这一观念构成了对架构整体性的破坏。</li><li>其二，如前所论，架构是可以通过解决问题来实现需求的，而非单纯对需求的响应。若架构本身只谈上述全集的“目标需求”，那么也就无法触及其背后的“问题”；而时间需求与空间需求背后的问题是清晰的，即系统的规模与复杂性。</li><li>其三，架构本身的价值在于：在保持方向的同时控制成本。而架构在时间需求与空间需求上的考量，构成了“架构全集”到“架构整体”的价值提升。它使得架构可以通过在时间与空间上的分解——一般表达为架构阶段（以及对应的实施阶段）的迭代——来解决架构规模问题与复杂性问题，进而达到成本控制。</li></ul><p>团队模式下的决策与个体决策有很大的不同。团队决策考虑的对象有两点，</p><ul><li>其一是对架构整体的把握，</li><li>其二是对团队整体的把握。对前者的思考，仍然可以归于架构意图，是由领悟能力驱动的；而后者则可以视为对架构意图的效果的保障，是由领袖能力所驱动的。</li></ul><h2 id="系统架构与决策"><a href="#系统架构与决策" class="headerlink" title="系统架构与决策"></a>系统架构与决策</h2><h3 id="系统架构的提出"><a href="#系统架构的提出" class="headerlink" title="系统架构的提出"></a>系统架构的提出</h3><p>针对系统架构的架构意图，我们仍然可以提出如下设问：</p><ul><li>其一般过程是什么？</li><li>其可能的演化方向是什么？</li><li>该系统对于客户战略作何种响应？</li><li>什么是系统的本质问题？</li><li>能不能不做？</li></ul><h3 id="形成论：参考模型-M0-以及可参照的示例"><a href="#形成论：参考模型-M0-以及可参照的示例" class="headerlink" title="形成论：参考模型 M0 以及可参照的示例"></a>形成论：参考模型 M0 以及可参照的示例</h3><p>任何系统架构必存在其<strong>外部实现</strong>与<strong>内部实现</strong>的过程。所谓外部实现，即是指架构师团队用以形成与演化架构的过程，所谓内部实现，即是架构以及其部件的内部关系得以构建与维护的过程</p><p><img src="/images/20220912/p-14.png" alt="p-14.png"></p><p>这张图已经表达了一般过程中的限制条件与流转关系，但仍然需要强调两点：其一，在“实现架构”与“开发架构”中，分别只列举出了其中最重要的两个组成部分，这并非其全部；其二，在“实现架构”中只列出了运行架构与集成架构，其原因是它们对部署与开发的约束作用最为明显。</p><p>一个架构的有效性、正确性应当表达为：</p><ul><li>如何确保宏观规划层对需求映射层的约束，以及确保功能架构对开发架构的约束；</li><li>如何确保在将能力架构映射为实现架构时不丢失功能设计；</li><li>如何确保开发实现的结果能够被应用于预设的交付环境。</li></ul><h3 id="参考模型-M0：细解各部分的形成过程与关系"><a href="#参考模型-M0：细解各部分的形成过程与关系" class="headerlink" title="参考模型 M0：细解各部分的形成过程与关系"></a>参考模型 M0：细解各部分的形成过程与关系</h3><p><img src="/images/20220912/p-15.png" alt="p-15.png"></p><p>框架是一种动态的运行架构（dynamic view of process architecture）。运行架构被框架层和服务层分为了动态与静态两个部分，这取决于你以何种视角来观察这些部件。</p><p><img src="/images/20220912/p-16.png" alt="p-16.png"></p><h3 id="“通过什么来影响什么”作为一般过程是可行的，但不完备"><a href="#“通过什么来影响什么”作为一般过程是可行的，但不完备" class="headerlink" title="“通过什么来影响什么”作为一般过程是可行的，但不完备"></a>“通过什么来影响什么”作为一般过程是可行的，但不完备</h3><p><img src="/images/20220912/p-17.png" alt="p-17.png"></p><ul><li>功能架构：它是实现架构中的组成部分，把由能力架构映射而来的能力分割为基本独立的功能块，基本映射了用户的原始需求，并约束了开发架构中的功能模块。</li><li>运行架构（静态部分）：将这些功能包装并发布成服务，用以约束开发架构中的包的组织与接口的设计。</li><li>运行架构（动态部分）：选择或实现可运行框架来驱动服务与功能，基本约束了开发架构中可选的第三方应用服务器，以及应当自主开发的、系统中的关键联接件，如事务服务框架等。</li><li>集成架构：以产品来封装和交付可运行框架，基本约束了部署架构可用的部件，以及部件之间的组合、依赖等关系。</li></ul><p>系统架构的一般过程：</p><p><img src="/images/20220912/p-18.png" alt="p-18.png"></p><h3 id="平台与框架的极致是“做到看不见”"><a href="#平台与框架的极致是“做到看不见”" class="headerlink" title="平台与框架的极致是“做到看不见”"></a>平台与框架的极致是“做到看不见”</h3><p>一个架构总是对它的构成部件在边界与联接件两个方面的设定。所谓设定，即是明确边界的范围，或明确联接的方法。然而，架构的主体——系统本身，却是动态地基于现实系统而演进的。</p><p>就“系统架构”这个领域出现的本质来看，它就应当具有两点特性：</p><ul><li>它能反映系统长期演化中的不变性，以在演化过程中持续用于对系统的讨论；</li><li>它不能是系统阶段实现的负担。</li></ul><p>显然，系统架构的作用与其方向上构成了一对矛盾。但是在我们的实践中，这个矛盾是有解的，亦即所谓<strong>平台（platform）</strong>与<strong>框架</strong>（framework）。</p><p>这两个解，也是对系统架构中的“体系架构”的两个抽象。首先，架构的支撑性应当以数据为核心，也就是说，平台通常是围绕数据的位置、功用、生存周期或其分布特性来规划的，例如常提到的三层结构在本质上就有平台化的倾向，因为它明确了交互数据、应用数据与系统数据在三个层次上的位置，以及相互间的产生、转化过程。其次，架构的调度性应当以逻辑为核心，也就是说，框架应当追寻架构对象——系统——的一般过程，并将它实现为架构的核心调度逻辑。</p><p>若系统架构以平台为方向，则应当力求“<strong>大到看不见</strong>”；若系统架构以框架为方向，则应当力求“<strong>小到看不见</strong>”。所谓“看不见”，就是指该架构的存在不应当对系统的其他部件（例如对应于不同的领域的子系统）的实现构成影响。</p><p>无论是做平台，还是做框架，最终的目标都是让系统<strong>基于它或使用它，而又无视它</strong>。</p><h3 id="层次结构是架构的一种平台化表现方法，而非架构本身"><a href="#层次结构是架构的一种平台化表现方法，而非架构本身" class="headerlink" title="层次结构是架构的一种平台化表现方法，而非架构本身"></a>层次结构是架构的一种平台化表现方法，而非架构本身</h3><p>平台是用于<strong>整合资源</strong>的，这是由平台本身“面向数据”这一特性而决定的。平台的核心在于支撑，这意味着平台（或平台中的层次）对数据的持有是独占的——在同一平台中对数据的理解是一致的。如果不具有这种特性，那么应当增加一层数据抽象，并在该层次上再构建新的平台。</p><p>三层或更多层，并不是平台化。层次是平台化的一种表现方法，而非平台——作为架构意图的本身，也并不是平台在应对战略问题中的核心关注点。</p><h3 id="形成论的另一种求解：架构规划"><a href="#形成论的另一种求解：架构规划" class="headerlink" title="形成论的另一种求解：架构规划"></a>形成论的另一种求解：架构规划</h3><p>“系统”的本质是领域集。若以现实系统为各个领域的目标，那么系统只需实现目标需求即可，亦即本质问题将是“能或不能实现”的问题。但是这将会得到一个“死的”系统：从系统被完成的第一时间开始它就不再增删任何东西；也没有任何对外的接口，因为它不面向新的领域。这样的系统并非不存在，事实上它大量存在着，并且是“高可靠系统”的主要开发方式。这样的系统的一个主要特点是它在架构上的确定性，与之对应而又匹配的，则是其领域集中的运作模式也相对确定。但我们是在讨论复合领域集的问题。尤其其关键核心在于：由领域集构成的业务模式（犹如产业链等）是可能变化的，甚至是变化频繁的。</p><p>当我们将当前系统的目标与上述规划对应时，就很容易锁定我们“应有的”架构意图，并且能够通过阶段规划，来促使当前的架构意图契合业务方向对架构的要求。</p><p>“从架构的体系性上来考虑，即使在最初阶段的架构中，也不能缺少对后续架构阶段的设定。这至少包括两个方面：其一，后续架构阶段的启动条件；其二，后续架构过程“在当前架构中的”入手点。”</p><p>架构意图在各个阶段的不同变化，意味着我们可以用“有规划的变化”来讨论整体的架构意图。</p><h2 id="架构的表达与逻辑"><a href="#架构的表达与逻辑" class="headerlink" title="架构的表达与逻辑"></a>架构的表达与逻辑</h2><h3 id="从暗示、隐喻，到抽象概念的表达"><a href="#从暗示、隐喻，到抽象概念的表达" class="headerlink" title="从暗示、隐喻，到抽象概念的表达"></a>从暗示、隐喻，到抽象概念的表达</h3><p>架构过程中存在大量的背景知识和推定事实，并且信息表现得可能会模糊而含混。这是因为架构过程本身就是对目标系统中一些不太明晰的概念（边界、联接关系等）渐次清晰的过程，所以架构过程中的模糊信息是必然存在的，否则根本不必去架构它。</p><p>但是这并不妨碍我们要求对架构的表达必须清晰准确。因为实施过程必将依赖架构的结果，亦即是架构的最终表达与决策。架构表达是在架构过程的阶段性成果的基础上所进行的、尽可能准确而清晰的叙述。如果它不能尽量准确地反映架构过程的阶段性成果，那么它也就不能作为下一个阶段（无论是实施还是新的架构迭代）的有效依据。换言之，如果对架构结果的表达是模糊的，则该结果是无意义的。</p><h3 id="理解线与线框"><a href="#理解线与线框" class="headerlink" title="理解线与线框"></a>理解线与线框</h3><p>在架构图中出现了一条线，通常都意味着它将一个整体划分成了两个部分。习惯性地，我们用纵向的线来表明领域的划分，而用横向的线来表明层次的划分</p><p><img src="/images/20220912/p-19.png" alt="p-19.png"></p><h3 id="对系统或其构件的不变性的表达：平台、框架与库"><a href="#对系统或其构件的不变性的表达：平台、框架与库" class="headerlink" title="对系统或其构件的不变性的表达：平台、框架与库"></a>对系统或其构件的不变性的表达：平台、框架与库</h3><p>用一个方框来表示领域，并且把一个方框分成两个（或多个）以表明领域之间没有关系或仅有殊少关系，</p><p><img src="/images/20220912/p-20.png" alt="p-20.png"></p><p>如何降低或至少不增加系统整体的复杂性来说，一种可选的分类依据是：如何隔离变化。</p><p>系统的复杂性有很大一部分是由其可变性导致的 4。但既有其可变处，也必有其不变处。以上述三种结构的表达方式来看：</p><ul><li>如果一个系统的公共部分是不变的，那么它适合用层次结构来表示；</li><li>如果一个系统的总量是不变的，那么它适合用并列结构来表示；</li><li>如果一个系统的核心是不变的，那么它适合用嵌套结构来表示。</li></ul><p>以层次结构来论，如果我们能从系统中捕捉到那些不变的公共部分，我们就可以将它表达在底层，反之将“目前看起来可变”的部分表达在上层。如此，在一系列的架构活动结束之后，我们总是能保证系统的基底部分是无需变化的，亦即它是稳定的；相对于系统整体来说，它带来的复杂度应是衡为“1”的；它决定了系统整体的性状是不变的。</p><p>就“系统架构”的整体表达来看，层次结构适宜构建平台（platform）的过程，其基础领域倾向于不变；并列结构适宜构建库（library）的过程 7，其领域总量倾向于不变；嵌套结构适宜构建框架（framework）的过程，其核心领域（或核心过程）是倾向于不变的。</p><h3 id="系统总量不变，其本质是复杂性的不变"><a href="#系统总量不变，其本质是复杂性的不变" class="headerlink" title="系统总量不变，其本质是复杂性的不变"></a>系统总量不变，其本质是复杂性的不变</h3><p>多个方框放在一起的时候，它们（所表达的领域）之间是没有关系或仅有殊少关系的。其中，当使用并列结构时，它通常表明系统总量不变——系统的复杂性不因为拆分而增加。这事实上也约束了并列结构之间是不应有相互关系的。</p><p>当并列结构之间不存在关系并且它所表明的系统总量不变时，并列（的所有域）是可以被视为一个整体的。</p><p><img src="/images/20220912/p-21.png" alt="p-21.png"></p><p>嵌套结构所谓的“核心”，是指所有除核心之外的其他领域必然与该核心发生关系，亦即它必然可以表达为图 32 所示形式的结构。</p><p><img src="/images/20220912/p-22.png" alt="p-22.png"></p><p><img src="/images/20220912/p-23.png" alt="p-23.png"></p><p>就系统架构整体来说，我们必须关注三点：</p><ul><li>其一，应通过层次系统来隔离可变性，并尽量增大其中不变的部分；</li><li>其二，可变部分影响系统的形态，但不影响系统的性状（亦即是指系统的边界与联接件）；</li><li>其三，如何理解“不变部分的关系”决定了系统的性状，也决定了“不变部分的复杂度是 1”的单位大小。</li></ul><h3 id="化繁为简：控制架构的复杂性"><a href="#化繁为简：控制架构的复杂性" class="headerlink" title="化繁为简：控制架构的复杂性"></a>化繁为简：控制架构的复杂性</h3><p>若 A 需要 B 的数据资源，我们称为数据依赖；若 A 需要 B 的计算资源，我们称为逻辑依赖；若将 A 和 B 都视为逻辑（亦即是可计算的资源），并讨论二者之间的关系，那么我们就会看到（逻辑或数据的）时序依赖。</p><p><img src="/images/20220912/p-24.png" alt="p-24.png"></p><p><img src="/images/20220912/p-25.png" alt="p-25.png"></p><p>即 A 和 B 间存在相互的数据时序依赖关系。若 A 和 B 是各自依赖了不同的数据而导致这种关系，则可以将 A 中的数据抽离至 B，如：</p><p><img src="/images/20220912/p-26.png" alt="p-26.png"></p><p>如果 A 和 B 间存在相互的逻辑时序依赖关系，那么我们总是可以通过添加一层数据抽象，来将向上的逻辑时序依赖变成“数据的”时序依赖，如：</p><p><img src="/images/20220912/p-27.png" alt="p-27.png"></p><h3 id="系统确定性是界面原则的核心"><a href="#系统确定性是界面原则的核心" class="headerlink" title="系统确定性是界面原则的核心"></a>系统确定性是界面原则的核心</h3><p>通过讨论领域间的组成与关系，我们可以尽量将系统的可变性隔离在较晚实现的域中。因此，这意味着先期建设的系统总是不变的、稳定的、可重用的。这是组成论视角对系统架构的主要贡献。但从系统演进的趋势来说，任何系统的组成部分都必然面临我们持续开发行为将会带来的影响。</p><p>而界面（interface）——就提出这一概念的本意来说——就是通过对系统确定性加以规格化，从而来避免上述影响，如果一个界面（以及其规格细节）是确切而有效的，那么它应当完全满足如下条件：</p><ul><li>准确——合适的知识与表达，至少能让交流双方通过某种形式沟通；</li><li>有用——完全明白的意图，至少与系统架构的意图不违背；</li><li>可见——执行的效果显而易见，至少在领域或层次上的数据与逻辑流向明确；</li><li>可能——应当存在实现的手段，至少可以立即着手开始尝试。”</li></ul><p>在架构的表达上，由于纵向分开的并列部分之间是没有关系的，因此它们之间也就没有规格化的需求。而横向的层次之间，仅有向下依赖是确定的，因此界面必是由下层来规格化的。这应当包括（上层所需的）数据规格与（调用的）逻辑规格两个部分。</p><p>三类界面原则的示例：Erlang 的一些实践性原则：</p><p><img src="/images/20220912/p-28.png" alt="p-28.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编二——架构是
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编一——你所关注的系统</title>
    <link href="http://blog.michealwayne.cn/2022/09/12/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%B8%80/"/>
    <id>http://blog.michealwayne.cn/2022/09/12/notes/【笔记】《我的架构思想：基本模型、理论与原则》编一/</id>
    <published>2022-09-12T06:19:10.000Z</published>
    <updated>2022-10-04T01:40:42.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编一——你所关注的系统"><a href="#《我的架构思想：基本模型、理论与原则》编一——你所关注的系统" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编一——你所关注的系统"></a>《我的架构思想：基本模型、理论与原则》编一——你所关注的系统</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="认知层次"><a href="#认知层次" class="headerlink" title="认知层次"></a>认知层次</h3><p><img src="/images/20220912/p-1.png" alt="p-1"></p><ul><li><p><code>L0</code>：机器学习的兴起，最直接的原因是大数据的出现。在大数据出现之前，大量的业务决策过程是所谓“拍脑袋”式的，也就是依靠经验和直觉。虽然数据很早就进入了商业管理的领域，但是时至今日，即使在全球领先的五百强企业当中，很多关键的决策，也只是把数据统计出来，变成图表，然后由“有经验”的管理人员根据数据来“拍脑袋”。</p></li><li><p><code>L1</code>：当前的机器学习工程师，未必需要深入理解机器学习的数学原理，只要根据一套完善的“套路”，配合类似 R 语言或者 Python 的 scikit-learn、TensorFlow 等工具，就可以开发出一个回归或者分类模型，帮助商业人士决策。</p></li></ul><p>而 L1 认知层次的局限性在于，一旦这个“套路”失效，只停留在这个认知层次的工程师，会束手无策，因为他们并不知道自己使用的方法和套路是怎么来的，自然也无法变通和调试。</p><ul><li><code>L2</code>：也就是通过理解“套路”和模型背后的原理，特别是数学原理，进入到方法论的层次。到了这个层次，你才能够在实践中知其然且知其所以然，恢恢乎游刃有余，才能称得上是“高手”</li></ul><p>L3：能站在上帝视角来审视自己的学科本身，考虑这门学问的根本问题和长远命运。<br>L2 的局限性，就在于他们对于自己的这一套做法，还缺乏“反躬自省”的审视。”其有效性的边界在哪里？对什么样的问题可能会失效？</p><blockquote><p>“台湾的高焕堂先生曾说架构的要旨是“以序容易”，我解释成“用规则来包容变化”，高老师说很合他的本意。这里的“易”，指的就是变化。既是变化，那当然是艰难而复杂的了。然而我们通常说一件事易做或另一件事不易做，这里的“易”却都是指简单的意思。所以“易”既是无穷的复杂，也是至极的简单，关键在于如何“容”它。”“知音变而得律，有容则易。”</p></blockquote><p>程序是可被组织的元素，这事实上是对程序的<strong>可结构化</strong>特性的一个阐释，貌似是说着相同的话。然而如果程序是可被组织的，那么“结构化”其实就只是组织的手法之一。这意味着后者——结构化——只是“程序是什么”的一个解，而绝非唯一解。这就是架构视角的独特处。当它找到一种新的抽象来定义事物时，旧的事物哪怕没有形式与内容上的变化，却在思维框架中有了新的位置、新的理解，以及新的矛盾与冲突。而所谓问题，就来自这些外在视角的变化和内在冲突的产生。<strong>架构的目标最终就是直指这些问题，而非解决一个切实的需求，例如写一个程序。</strong></p><p>架构本质上是一个<strong>映像</strong>。洞见映像背后的事实，就如同从镜子去观照现实，知道镜子是一层，知道镜子中的映像是第二层，知道镜子映像所现的实体是第三层。而至第四层时，还要看得到那实体周围的背景，这是实体之为实体所必须的依托，如绿叶之于红花。再深入到第五层，你得知道背景之外不可见的那些影影绰绰的事实，它们是环境中的残片和推想，它们不可确知而又影响着你在镜子中看见的那个主体。再至第六层……</p><p>如此层层渐近，才是真正的“镜之用在鉴”，才是“鉴”这一行为的本意。然而一旦你触及到“鉴作为行为的事实存在”，那么你就看到了镜子一侧的自我，进而看到自我之见，看到由自我、镜鉴和自我之见等等所构成的整个系统，这个系统被称为“观察”。当然，在这整个“被称之观察系统”的系统之外，还要有光。否则一切所谓事实都将湮灭，即便存在，亦无可证实，无可证伪。</p><h3 id="架构师的思维"><a href="#架构师的思维" class="headerlink" title="架构师的思维"></a>架构师的思维</h3><p>“着眼于<strong>高远</strong>”，便是架构师的基本修养，而几乎所有的架构思维，都从这修养中来。就架构来说，“高”就是指空间上的可拓展性，即系统的复杂性是否可以通过组成部件的增减来解决；“远”就是指时间上的可持续性，即系统的规模是否可以划分为多个时间阶段来实施。以软件架构为例，在讨论系统——这一架构目标的属性时，架构师可能关注的话题包括性能、可用性、可靠性等十余种，我们可以通过高、远两个维度的思考将它们大致地分类：</p><p><img src="/images/20220912/p-2.png" alt="p-2"></p><p>架构师在思维过程中使用的工具</p><p><img src="/images/20220912/p-3.png" alt="p-3"></p><blockquote><p>“系统，是对架构师所面对对象的基本抽象。架构师对系统的认识过程、方法与结果，决定了他如何理性地架构之。”</p></blockquote><p>认识系统不是架构系统。认识系统将致力于将系统中的核心概念抽象出来，将核心逻辑梳理出来，将核心问题（关系、依赖与冲突）揭示出来。但是架构系统的目的正好在于通过对概念与逻辑的映射来消弥这些核心问题，使核心问题对其外在（例如用户可见的产品）不构成明显的影响。</p><p><strong>架构是一个过程。</strong>既然是过程，必然有起始与终的。</p><h2 id="1-了解系统的过程"><a href="#1-了解系统的过程" class="headerlink" title="1.了解系统的过程"></a>1.了解系统的过程</h2><h3 id="感受一个系统的事实"><a href="#感受一个系统的事实" class="headerlink" title="感受一个系统的事实"></a>感受一个系统的事实</h3><p>如同新闻，以体察之，感同身受</p><h3 id="系统是一种认知，而非分析的结果"><a href="#系统是一种认知，而非分析的结果" class="headerlink" title="系统是一种认知，而非分析的结果"></a>系统是一种认知，而非分析的结果</h3><p>我们作为“计算机专业人士”的日子太久了，我们对太多的事物有了理性的认识，而缺乏感性的认识。正因为我们忘却了这种“感同身受”地了解事物的方式，所以我们对这些事物的认识流于浅表，流于那些有数字个数、形体大小、边界棱角或者演进逻辑的判断推理当中。我们忘了一个“系统”是可以去知道、了解、感知，进而感受的。</p><p>我们把对系统的观见与解说当成一种理论，这种理论称为“需求分析”。而我们在一定程度上忘记了，我们所谓之“系统”，并不仅仅是模块的组成，更是一种外界——之于这个系统——的认知。</p><h3 id="认知理论中的知识：知得与识得"><a href="#认知理论中的知识：知得与识得" class="headerlink" title="认知理论中的知识：知得与识得"></a>认知理论中的知识：知得与识得</h3><p>我们获取知识有两种手段，是所谓“知得”与“识得”。</p><p>当我们知道张三，却不知道它的形貌时，是知得，大多数图书馆知识是知得的；当我们亲触这个事物 3，却不知道它是什么时，是识得，大多数野外考察知识是识得的。</p><p><img src="/images/20220912/p-4.png" alt="p-4"></p><p>从动词角度上来说，认识是识得的具体方法之一。认，是指记认；识，是指辨识。</p><p>作为实践者，我们大多数时候是在讨论“某种记认的方法”，而未能追究：在认知理论上，这种记认的可靠性及其依赖的条件。而忽略这一点，就会产生一些似是而非的方法，例如失效的刻舟求剑。但是，失效并不是无法容忍的，例如 HASH 应用中存在的命中率问题。所以记认并不是准确无误的方法，实践中只是在寻求这种方法的背景限制并进一步控制误差而已。</p><p>辨识的一个基本含义在于分辨出差异。如果找不到差异，那么所有的事物也就混沌一物，无从辨识，也无从获得它的知识了。具体来说，辨识也可以分成两种方法：其一是识别，其二是分别。</p><p>识别依赖于我们对事实的直观了解，在一定程度上是与我们的感觉器官相关的，例如听见的、看见的或者闻见的等。然而识别是不可靠的。它首先取决于生理机能本身的可靠性。其次它还取决于既识的持续可靠性。“基于识别所构建的既有知识”为既识，称基于既识而识别为持续性。例如，某人此前听过猿啼（并确认正确），当他再听到某种啼声时，识别为“这是猿啼”。但后者并不一定是持续正确的。</p><p>分别则相对复杂一些，它建立于一个观察的角度、切面，或者依赖于某种参照。通常，“数”这一抽象，是我们能加以分别所依赖的核心概念。例如，核桃的个体与群体，以及火车的速度，都是我们对观察对象先进行数值化，再加以比较，最后得到的知识。</p><p>分别是可靠的吗？答案仍然是否定的，千人千面是一种理想状态，现实往往是一人千面。</p><p>分别的问题在于比较所需的角度与背景不同，以及不同人对于抽象概念的理解有异——如你所见的，基于“数的值”的分别往往准确一些，是因为人们对于“数”这一抽象有着大抵相同的理解。</p><h3 id="尝试一个“建立知识”的过程"><a href="#尝试一个“建立知识”的过程" class="headerlink" title="尝试一个“建立知识”的过程"></a>尝试一个“建立知识”的过程</h3><p>我们从一个系统中获得的知识因人、因方法而不同；既便是相同的方法，由于其实施者的不同以及方法（本质中存在的）误差，也会不同。这就是作为架构师，任何两个人都不可能得到相同的架构结果的根本原因。所有的最终架构都是在实施过程中的调和，以及某些决策者、决策机构的“决定”。</p><h3 id="建立知识以陈述现实系统”是不足以架构系统的"><a href="#建立知识以陈述现实系统”是不足以架构系统的" class="headerlink" title="建立知识以陈述现实系统”是不足以架构系统的"></a>建立知识以陈述现实系统”是不足以架构系统的</h3><p>归纳（概念）、梳理（关系）、推演（逻辑）这些架构活动所需要的，都是较高层次上的思维方法。</p><p>现实中，基于所面对的计算机系统，我们大多数的系统抽象与建模过程中都会用到“分别”这一认知方法。比如说，我们将已知需求规划为条目，然后分门别类，进而整理出子系统、模块、服务，以及规划出服务器、集群等的方案。对系统中的组成、要件、关系等加以分别，是上述这些活动的基点。</p><h2 id="2-知识的构建"><a href="#2-知识的构建" class="headerlink" title="2.知识的构建"></a>2.知识的构建</h2><h3 id="观察者的背景差异带来了更多不同的正确映像"><a href="#观察者的背景差异带来了更多不同的正确映像" class="headerlink" title="观察者的背景差异带来了更多不同的正确映像"></a>观察者的背景差异带来了更多不同的正确映像</h3><p>识别与分别对于了解事物的内在特性来说，都只是辅助手段。而这就是能够建立一个系统的物理模型（组成/结构模型），而难于建立它的逻辑模型的根本原因。</p><p>事实上，我们在架构活动中进行的归纳（概念）、梳理（关系）、推演（逻辑），这些活动的核心基础在于图中的“知得”而非“识得”。</p><p><img src="/images/20220912/p-5.png" alt="p-5"></p><p>其一，我们是否有能力得到一个物理模型；其二，我们得到上述物理模型的过程是否仅仅依赖“识得”。然而，这两个问题的答案都是否定的。首先，我们可能得到很多种物理模型，这些模型映射了现实系统的不同视角。真正的原因是：你难于一以贯之地采用特定视角去观察现实系统，并且你所了解的系统也会动态地以种种角度呈现给你。</p><p>现实中的系统总是自洽的——系统中的角色总是在制造冲突的同时消弭着冲突，这就是所谓的生态，亦或“它们”之所以表现为一个（活着的、动态的）系统的内在能量。</p><p>但计算机系统只能描述其中的一部分（事实上这也意味着计算机系统只能解决动态的现实系统中的部分问题），这一部分必须首先成为“我们”——作为观察者的认识，而后才会表达为软硬件系统中的“可计算的”映像。最终，我们事实是通过对“映像”的运算，来还原现实系统中的某些侧面，以达到我们的目的——替代之、推演之，并作为其他可计算系统的组成部分。</p><p>所以事实上我们可能得到多个物理模型，它们在表面上看起来都是现实系统的“正确映像”，但其内在是各自不同的。</p><h3 id="这种差异表现了不同的“架构意图"><a href="#这种差异表现了不同的“架构意图" class="headerlink" title="这种差异表现了不同的“架构意图"></a>这种差异表现了不同的“架构意图</h3><p>当我们试图去表达现实系统的“一个映像”时，我们总是存有特定的意图。这种“架构上的意图”决定了我们的观察视角，也决定了我们之后表达的结果。</p><h3 id="抽象概念与模型是展示架构意图的方式之一"><a href="#抽象概念与模型是展示架构意图的方式之一" class="headerlink" title="抽象概念与模型是展示架构意图的方式之一"></a>抽象概念与模型是展示架构意图的方式之一</h3><p>如果这是某一个特定类型的办公室成员使用的系统，那么它适宜实现为一个工作系统，用来重现某种特定工作的规则与流程；如果这是一个混合的、由不同成员及其工作需求交织而成的系统，那么这个系统（的本身）必然需要某种东西来使自身规则化。</p><p>也就是说，“管理”不是现实系统的意图，而是映射这一系统到计算环境时的一个需求。我们必须确定：如果这一需求来自于现实系统，那么它是原始需求；如果它来自于上述的这个软件系统本身，那么它首先是设计者的意图，其次才是对现实系统的反映。</p><p>这是一个典型的因果问题：究竟是现实产生了意图，还是先有了意图再去参考现实。我们强调这一细节的原因于：如果是前者，那么控制这一意图（以这里的例子来说，是指“管理”这一行为）的意义在于“控制原始需求”；如果是后者，那么控制它的意义在于“控制设计欲望”。</p><p>一旦我们确认这只是一个意图，并且这一意图的核心仅仅是“规则化”那些需求与需求的用户对象，我们就需要更深层次地设定“被规则化的”这个系统（本身）。它将会是：</p><ul><li>与现实系统看起来类似的</li><li>具有同等的组织容量的</li><li>基本符合现实系统的运作逻辑的<br>一个软件系统。</li></ul><p><img src="/images/20220912/p-6.png" alt="p-6"></p><p>现实系统中，并没有任何需求方来提出这些设定，例如经营角色会说“我们需要一个饼状图”，营销角色会说“我们每周至少发布一次营销活动”，但是他们都不会说“你的系统中需要这样有着管理层次关系的两个角色”。</p><h3 id="系统的识得，是在架构意图的逐步清晰中渐行渐显的"><a href="#系统的识得，是在架构意图的逐步清晰中渐行渐显的" class="headerlink" title="系统的识得，是在架构意图的逐步清晰中渐行渐显的"></a>系统的识得，是在架构意图的逐步清晰中渐行渐显的</h3><p>意图，是“识得”的核心，即“你想要什么”决定了系统如何构画，而不仅仅是对现实系统的复制。</p><p>意图是架构真正的灵魂。架构活动只是将这种意图表达在架构产出中，并阐述这一意图的合理性；如何得到或形成意图才是架构的精髓，其本质是通过抽象过程，对既有系统的再认识与再创造。简单地说，如果架构师没有意图，那么系统只是目标系统的某一时间上的静态映像 5；而架构师如果有意图，那么系统也就有了灵魂，就能跟随目标系统的实际需求的发展而演化，或至少为这种演化留备了可能。</p><p>这存在两个条件：其一，它首先必须是能够被规则化的，这是主要条件；其二，作为附加收益，规则化也可以为其他系统构件带来便利。对这两个条件的思考是架构过程中的一种权衡，即从“想要什么”到“能要什么”的一个过渡。这个过程中，“控制架构欲望”是一种关键素质。而这一素质的源起与核心，是架构师对自身职责的不断的、反复地省思，即“想要什么”应当能决定一个系统在时间与空间两个方面的特性，而不是（仅仅）出于客户需求或自我喜好。</p><p>组织机构表达的“人与人的授权”7 以及“被授权者是可以行使系统行为的角色”这两点是可以被规则化的。这很明显。但是它能带来哪些便利呢？表 2 是一个简要的考察。</p><p><img src="/images/20220912/p-7.png" alt="p-7"></p><p>在这些考量中最重要的是“概念完整性”，它决定了整个系统的核心逻辑，以及描述架构、功能与内部关系的一般方法。如果一个架构设定没有概念完整性方面的必要，通常它的价值收益就会偏小、偏局部，或者可备选。</p><p>最后需要补充的是：这样完备地考察通常是不必要的。这是因为，其一，很少有类似授权这样的架构意图，是能够影响到系统全局并在各考察点上都有相对平衡的重要性的；其二，架构意图通常是反向论证的，即“它不与哪些考察点冲突”；其三，核心架构意图通常是明显的、一贯的以及关键的，因此它的影响面也就巨大，这意味着多个这样的意图并存时将是轻重缓急的问题，而并不是是非取舍问题；其四，如上的轻重缓急是一时的选择，可能会随着所架构的系统——或者说项目——的推进而有变化，这既说明了多种意图的必然性，也说明了多种意图间冲突的根源，亦即是需求的内容与焦点会随时间与空间变化。</p><p>最关键的架构意图是架构师对上述第四个因素的推定，而并非依赖当前的、静止的需求。这种推定的合理性是建立在一个非常完整、缜密、基于抽象概念的逻辑推理基础上的，其背景多数已经超出了“软件系统”本身。</p><h3 id="知得，始于抽象概念的构建之后"><a href="#知得，始于抽象概念的构建之后" class="headerlink" title="知得，始于抽象概念的构建之后"></a>知得，始于抽象概念的构建之后</h3><p>“知得”是一个由抽象概念开始的思考过程。在我们的架构活动中，我强调这是一个由“架构意图”驱动的抽象活动。但这并非惟只的方向，并且可能是一个本末倒置的方向。这里需要强调两点，一是我们并没有完整地讨论“架构意图”的由来 9，二是“本末倒置”并非是一件坏事。</p><p>从经典的架构与设计的法则来看，是“需求决定架构及设计”，这种需求通常是以现实系统为核心的。这很合理，毕竟从上述的分析来看，现实系统才是系统的本体，系统只是现实系统的一个侧相，而“架构意图”只不过是由架构师对系统之所用的理解。我们一旦强调由所用来推动架构过程，而忽略了本体的真实与侧相的含义，那么往往就会被指为本末倒置。</p><p>我们可以找到这样两个不同的架构：它映射同一系统，由不同的架构师来实现。当我们对这样两个架构作分析时，一定可以找到一些相同的部分。这些内容大体来自于由需求驱动的架构方法，它们是架构师对需求的正确描述、复制与映射。如果这些描述、复制与映射中存在了差异，在这两个或更多的架构师之间是可以调和的，因为这仅仅是对一些真实可见、可以反复而又唯只陈述的需求的不同看法，它可以论证、分解、削弱或搁置，无论如何，它们不会成为两个架构中最核心与典型的差别。</p><p>我们也必然会找到一些不同的部分。（除了上述的差别之外，）不同的部分必然来自于架构意图的差别，是明显的主观认识，带有很强的目的性。</p><h3 id="“识别架构意图”的核心理论与方法"><a href="#“识别架构意图”的核心理论与方法" class="headerlink" title="“识别架构意图”的核心理论与方法"></a>“识别架构意图”的核心理论与方法</h3><p>架构意图需承架构的定义而来，它首先必是“经营角色对方向的设定”在系统上的体现。若架构意图不体现方向，则它将只是局部的、边角的一些架构决策或意图。架构师的核心价值，在于通过架构意图来将“方向设定”映射为“规模与细节”。其中，“规模”表现为架构的边界/范围，“细节”表现为架构部件的联接关系/联接件。</p><p>对于架构意图的识别，有三个入手的角度。这三个角度仍是“规模与细节”相关的，其一，是系统的脉络；其二，是系统的组织；其三，是系统组织间的关系。如果一个意图表现了架构师对系统上述三个方面的理解，则该意图应当视为架构意图。</p><p>架构意图中最重要的是系统的脉络，其整体动向是本质性的需求，其内在动律是上述需求的表现与表达方式 23。总体来说，任何一个架构意图的形成都是对三个“入手角度”整体的反复考量进而形成的一个最终认识，而决非其单一方面的阐述。</p><h2 id="3-最初的事实"><a href="#3-最初的事实" class="headerlink" title="3.最初的事实"></a>3.最初的事实</h2><h3 id="真相是相，而不是真"><a href="#真相是相，而不是真" class="headerlink" title="真相是相，而不是真"></a>真相是相，而不是真</h3><p>所谓“事实”的形成，与事实本身看起来没什么关系，而仅仅在于观察者的主观判断。这看起来相当地可笑：“科学”总是依赖客观事实，但我们对客观事实的认识本身就是发自主观的——从思维的角度上来讲，如果“毫无主观判断”，那么我们也就连任何概念都无法形成。</p><p>真正完整而科学的思维方法是将“概念、论证、应用”三者合而为一的：单独地提出概念确实是主观的，科学之谓科学，在于通过后面的两种行为使概念符合逻辑论证与现实实证。</p><p>质疑那些主观判断，是系统架构思维中的第一步。</p><h3 id="如何推翻那些最初设定的“事实”？"><a href="#如何推翻那些最初设定的“事实”？" class="headerlink" title="如何推翻那些最初设定的“事实”？"></a>如何推翻那些最初设定的“事实”？</h3><p>我们谈到过系统的脉络在架构意图中最为重要，它包括两个部分，即内在动律与整体动向。通常，前者是无可争辩的事实，后者则是主观判断或客户战略。</p><p>架构不是为客户设定战略，而是服从客户设定的战略。如果客户没有形成战略，那么架构也就只能依据内在动律来主观判断整体动向。如前所论，这种主观判断是依赖对系统的分析而非对战略的假定的，并且也主要用于描述系统的发展方向，而非系统的客户——企业或领域的发展方向。</p><p>所以在架构意图上中对整体动向的考虑主要是三点：依赖、复杂性与持续价值。这三方面的问题都可以从战略设定中去寻求最终答案；如果战略不清晰，则也可以从上述的一般过程中去得到一些（阶段性的、可维护系统自身的发展所需的）设定。</p><p>与其他工程活动一样，架构工作也是渐进的，并不是一开始就准确无误。因而架构思维中需要不断反思与回顾，而架构活动也将是持续与迭代的。</p><h3 id="仰首者瞻，凝神者瞩"><a href="#仰首者瞻，凝神者瞩" class="headerlink" title="仰首者瞻，凝神者瞩"></a>仰首者瞻，凝神者瞩</h3><p>战略与方向，是存在本质性的不同的。方向只表达动向，而战略其实是已经决策的动作，或对其行动步骤的规划 7。对于架构师来说，无法决定的其实是客户的战略决策，但对于客户的方向是可以有自己的判断的。</p><h3 id="找到问题也就等于找到了解"><a href="#找到问题也就等于找到了解" class="headerlink" title="找到问题也就等于找到了解"></a>找到问题也就等于找到了解</h3><p>在既不存在所谓事实（因而也难有可信的主观判断），又没有所谓战略时，我们是可以藉由前瞻方向来形成架构意图的。而另一方面，我们也可以尝试回溯问题。</p><p>我们的软件开发活动向来是从对需求的分析开始的，经过设计、开发等过程，最后交付和维护。这一过程是如此的自然，因而我们将它从历史的开发活动中“识别”出来之后，立即被看成是软件工程作为一个成熟概念的标志。</p><p>什么是问题？问题有两个形态：其一，若系统存在某种“一般过程”，则阻碍这个一般过程的，必然是核心问题；其二，若系统存在一个确定的观察者，则所谓问题，就是这个观察者的期望与现实之间的差异。换作精炼一点的描述：<br>“所谓问题，要么是系统与其要素之间的矛盾，要么是观察与其预期之间的矛盾。”</p><p>我们在系统中引入了一般过程与观察者，前者是“导致问题”的内因，后者则是其外因。系统的不变性，一般来说是由前者决定的，所谓平衡，即是在这个一般过程的要素之间的、时间与空间上的权衡；系统的变化往往是后者导致的，亦即观察者——例如经营角色或主管——对于系统的期望缺乏一贯性。</p><h3 id="反思那些事实与问题"><a href="#反思那些事实与问题" class="headerlink" title="反思那些事实与问题"></a>反思那些事实与问题</h3><p>在此前的讨论中，除了对基本的事实与真相的识别之外，大概涉及三种思维方法：设定、试探和归纳。而本质上来说，这三种思维的过程也是模型与概念抽取的过程。由此所得的，是一个可以用来作为基础并进一步讨论的现实系统的映像：软件系统的架构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot;&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Browserslist 信息和使用整理</title>
    <link href="http://blog.michealwayne.cn/2022/08/20/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Browserslist%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.michealwayne.cn/2022/08/20/notes/【笔记】Browserslist和使用/</id>
    <published>2022-08-20T02:58:29.000Z</published>
    <updated>2022-08-23T09:13:54.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Browserslist-信息和使用整理"><a href="#Browserslist-信息和使用整理" class="headerlink" title="Browserslist 信息和使用整理"></a>Browserslist 信息和使用整理</h1><blockquote><p>Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-preset-env.用在不同的前端开发工具之间，分享指定的目标 Browser。像是 Autoprefixer，Stylelint，和 babel-preset-env。</p></blockquote><p>主页：<a href="https://github.com/ai/browserslist" target="_blank" rel="noopener">https://github.com/ai/browserslist</a>、<a href="https://browsersl.ist/" target="_blank" rel="noopener">https://browsersl.ist/</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Browserslist 是一个根据目标浏览器（target browser）检查支持浏览器版本的 js 库。它是现代前端工程化不可或缺的工具，无论是处理 js 的 babel 还是处理 css 的 postcss，凡是与垫片相关的，他们背后都有 browserslist 的身影。比如：</p><ul><li><code>babel</code>，在 <code>@babel/preset-env</code> 中使用 <code>core-js</code> 作为垫片</li><li><code>postcss</code> 使用 <code>autoprefixer</code> 作为垫片</li></ul><p>在前端工程化实践中，当我们确认了浏览器版本号，那么它的垫片体积就会确认。</p><ul><li>由于低浏览器版本的存在，垫片是必不可少的</li><li>垫片越少，打包体积越小</li><li>随着时间的推移，浏览器版本越新，垫片越少</li></ul><h2 id="Browserslist-原理"><a href="#Browserslist-原理" class="headerlink" title="Browserslist 原理"></a>Browserslist 原理</h2><p><code>browserslist</code> 根据正则解析查询语句，对浏览器版本数据库 <a href="https://github.com/browserslist/caniuse-lite" target="_blank" rel="noopener"><code>caniuse-lite</code></a> 进行查询，返回所得的浏览器版本列表。</p><p><img src="/images/browserslist/p-browserslist-ori.png" alt="p-browserslist-ori.png"></p><blockquote><p>*caniuse-lite 这个库也由 browserslist 团队进行维护，它是基于 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a> 的数据库进行的数据整合。caniuse-lite 库是 CanIUse (这个网站用来查询浏览器兼容性)的数据库的小版本，只有一些必需数据，这些数据存放在 caniuse-lite/data 中</p></blockquote><p>因为 <code>browserslist</code> 并不维护数据库，因此它会经常提醒你去更新 <code>caniuse-lite</code> 这个库，由于 <code>lock</code> 文件的存在，因此需要使用以下命令手动更新数据库（我们需要定期更新）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist@latest --update-db</span><br></pre></td></tr></table></figure><p>该命令将会对 <code>caniuse-lite</code> 进行升级，并体现在 <code>lock</code> 文件中。此更新将为 Autoprefixer 或 Babel 等 polyfill 工具带来有关新浏览器的数据，并减少已经不必要的 polyfill。</p><p>需要定期更新主要有如下三个原因：</p><ul><li>在查询中使用最新的浏览器版本和统计信息：例如 <code>last 2 versions or &gt;1%</code> ，如果在 2 年前创建了项目但是没有更新依赖项，那么返回结果是 2 年前的浏览器</li><li>实际的浏览器数据将导致使用更少的 polyfill。它将减少 JS 和 CSS 文件的大小并提高网站性能。</li><li><code>caniuse-lite</code> 重复数据删除：在不同工具中同步版本。</li></ul><h4 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h4><p>如果您选择的前端工具包括对 browserslist 的支持，它将在以下位置查找指定浏览器版本的查询，从第一个到最后一个，browerslist 将使用如下配置文件限定的的浏览器和 node 版本范围：</p><ul><li>工具 options，例如 Autoprefixer 工具配置中的 browsers 属性。</li><li><code>BROWERSLIST</code> 环境变量。</li><li>当前目录或者上级目录的 <code>browserslist</code> 配置文件。</li><li>当前目录或者上级目录的 <code>.browserslistrc</code> 配置文件。</li><li>当前目录或者上级目录的 <code>package.json</code> 配置文件里面的 <code>browserslist</code> 配置项（推荐）。</li></ul><p>如果上述的配置文件缺失或者其他因素导致未能生成有效的配置，browserslist 将使用<code>default</code>配置<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>。</p><h2 id="Browserslist-使用者"><a href="#Browserslist-使用者" class="headerlink" title="Browserslist 使用者"></a>Browserslist 使用者</h2><p>目前主要前端工程工具都或多或少用到了 browserslist，如：</p><p><img src="/images/browserslist/p-users.jpg" alt="p-users.jpg"></p><ul><li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a>：Autoprefixer browserslist 从 package.json. 您无需执行任何其他操作——Autoprefixer 会自动查找并加载配置。</li><li><p><a href="https://github.com/babel/babel-preset-env" target="_blank" rel="noopener">babel-preset-env</a>是“JavaScript 的自动前缀”。如果它已经知道所有目标浏览器都支持它，它就不会编译 ES2015+ 语法。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel&quot;: &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;browsers&quot;: &quot;last 2 version&quot;,</span><br><span class="line">          &quot;node&quot;: 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;loose&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/amilajack/eslint-plugin-compat" target="_blank" rel="noopener">eslint-plugin-compat</a>：是 ESLint 的一个插件，当并非所有目标浏览器都支持您的 JavaScript 代码时，它会向您发出警告。它支持开箱即用的 Browserslist 配置；它获取目标浏览器版本列表并检查您的代码是否使用所有指定浏览器支持的 JavaScript API。</p></li><li><a href="https://github.com/ismay/stylelint-no-unsupported-browser-features" target="_blank" rel="noopener">stylelint-no-unsupported-browser-features</a> 的工作方式类似于 eslint-plugin-compat— 但适用于 CSS。Stylelint 是一个出色且最流行的 CSS linter。这个 Stylelint 插件确保所有目标浏览器都支持所有使用的 CSS 属性。它还支持开箱即用的 Browserslist 配置。</li><li><a href="https://github.com/jonathantneal/postcss-normalize" target="_blank" rel="noopener">postcss-normalize</a> 仅包含<a href="https://github.com/jonathantneal/normalize.css" target="_blank" rel="noopener">normalize.css</a>的必要部分 ，基于您支持的浏览器列表。</li></ul><h2 id="使用-常用配置"><a href="#使用-常用配置" class="headerlink" title="使用/常用配置"></a>使用/常用配置</h2><h3 id="根据用户份额"><a href="#根据用户份额" class="headerlink" title="根据用户份额:"></a>根据用户份额:</h3><ul><li><code>&gt; 5%</code>: 在全球用户份额大于 5% 的浏览器</li><li><code>&gt; 5% in CN</code>: 在中国用户份额大于 5% 的浏览器</li></ul><h3 id="根据最新浏览器版本"><a href="#根据最新浏览器版本" class="headerlink" title="根据最新浏览器版本"></a>根据最新浏览器版本</h3><ul><li><code>last 2 versions</code>: 所有浏览器的最新两个版本</li><li><code>last 2 Chrome versions</code>: Chrome 浏览器的最新两个版本</li></ul><h3 id="不再维护的浏览器"><a href="#不再维护的浏览器" class="headerlink" title="不再维护的浏览器"></a>不再维护的浏览器</h3><p><code>dead</code>: 官方不在维护已过两年，比如 IE10</p><h3 id="官方提供的查询"><a href="#官方提供的查询" class="headerlink" title="*官方提供的查询"></a>*官方提供的查询</h3><p>你可以用如下查询条件来限定浏览器和 node 的版本范围（大小写不敏感）：</p><ul><li><code>&gt; 5%</code>: 基于全球使用率统计而选择的浏览器版本范围。&gt;=,&lt;,&lt;=同样适用。</li><li><code>&gt; 5% in US</code> : 同上，只是使用地区变为美国。支持两个字母的国家码来指定地区。</li><li><code>&gt; 5% in alt-AS</code> : 同上，只是使用地区变为亚洲所有国家。这里列举了所有的地区码。</li><li><code>&gt; 5% in my stats</code> : 使用定制的浏览器统计数据。</li><li><code>cover 99.5%</code> : 使用率总和为 99.5%的浏览器版本，前提是浏览器提供了使用覆盖率。</li><li><code>cover 99.5% in US</code> : 同上，只是限制了地域，支持两个字母的国家码。</li><li><code>cover 99.5% in my stats</code> :使用定制的浏览器统计数据。</li><li><code>maintained node versions</code> :所有还被 node 基金会维护的 node 版本。</li><li><code>node 10 and node 10.4</code> : 最新的 node 10.x.x 或者 10.4.x 版本。</li><li><code>current node</code> :当前被 browserslist 使用的 node 版本。</li><li><code>extends browserslist-config-mycompany</code> :来自 browserslist-config-mycompany 包的查询设置</li><li><code>ie 6-8</code> : 选择一个浏览器的版本范围。</li><li><code>Firefox &gt; 20</code> : 版本高于 20 的所有火狐浏览器版本。&gt;=,&lt;,&lt;=同样适用。</li><li><code>ios 7</code> :ios 7 自带的浏览器。</li><li><code>Firefox ESR</code> :最新的火狐 ESR（长期支持版） 版本的浏览器。</li><li><code>unreleased versions or unreleased Chrome versions</code> : alpha 和 beta 版本。</li><li><code>last 2 major versions or last 2 ios major versions</code> :最近的两个发行版，包括所有的次版本号和补丁版本号变更的浏览器版本。</li><li><code>since 2015 or last 2 years</code> :自某个时间以来更新的版本（也可以写的更具体 since 2015-03 或者 since 2015-03-10）</li><li><code>dead</code> :通过 <code>last 2 versions</code> 筛选的浏览器版本中，全球使用率低于 0.5% 并且官方声明不在维护或者事实上已经两年没有再更新的版本。</li><li><code>last 2 versions</code>: 每个浏览器最近的两个版本。</li><li><code>last 2 Chrome versions</code>: chrome 浏览器最近的两个版本。</li><li><code>defaults</code>: <strong>默认配置<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code></strong>。</li><li><code>not ie &lt;= 8</code>: 浏览器范围的取反。</li></ul><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>直接在工程目录下运行 <code>npx browserslist</code> 来查看你配置的筛选条件筛选出的浏览器版本范围。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>browserslist 会处理浏览器的每个版本，所以应该避免配置这样的查询条件 <code>Firefox &gt; 0</code>.</p><p>多个查询条件组和在一起之后，其之间的的覆盖是以 <code>OR</code> 的方式，而是不是 <code>AND</code>,也就是说只要浏览器版本符合筛选条件里面的一种即可。</p><p>所有的查询条件均基于 <code>caniuse</code> 的支持列表。例如：<code>last 3 ios versions</code> 可能会返回 <code>8.4</code>, <code>9.2</code>, <code>9.3</code>(混合了主版本和次版本)，然而 <code>last 3 Chrome versions</code> 可能返回 <code>50</code>, <code>49</code>, <code>48</code>（只有主版本）。</p><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>可通过 and、or、not 关键字进行组合查询。</p><table><thead><tr><th>组合器类型</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>and</code></td><td>为交集，每个条件相交的结果</td><td><code>Chrome 58-65 and supports es6-module</code>：查找 Chrome 58 到 65 并且支持 es6-module 的版本。</td></tr><tr><td><code>or</code></td><td>为并集，每个条件合并的结果。也可以用逗号代替 or</td><td><code>Chrome &gt; 94 or Edge &gt; 94</code>或<code>Chrome &gt; 94,Edge &gt; 94</code>：查找 Chrome 与 Edge 大于 94 的版本。</td></tr><tr><td><code>not</code></td><td>为非，取反</td><td><code>&gt; .5% and not last 2 versions</code>或<code>&gt; .5% or not last 2 versions</code>或<code>&gt; .5%, not last 2 versions</code>：使用率大于 0.5% 的版本中排除不是最后两个版本。</td></tr></tbody></table><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="1-package-json"><a href="#1-package-json" class="headerlink" title="1.package.json"></a>1.package.json</h4><p>如果你想减少工程根目录下的配置文件的数量，可以在 package.json 中设置 browserslist 配置项，如下所示:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^6.5.4"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"browserslist"</span>: [<span class="string">"last 1 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><p>browserslist 配置文件应该被命名为 <code>.browserslistrc</code> 或者 <code>browserslist</code> 每条查询条件独占一行。 注释用 # 开头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Browsers that we support</span><br><span class="line"></span><br><span class="line">last 1 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10 # sorry</span><br></pre></td></tr></table></figure><p>browserslist 将检查 path 路径上每一级目录下面是否有配置文件. 所以，如果工具要处理的文件路径是这样的 <code>app/styles/main.css</code>, 那么你可以将配置文件放置在根目录, <code>app/</code> 或者 <code>app/styles</code>。</p><p>也可以在 <code>BROWSERSLIST_CONFIG</code> 环境变量中直接指定配置文件的路径 。</p><h4 id="3-Shareable-Configs"><a href="#3-Shareable-Configs" class="headerlink" title="3.Shareable Configs"></a>3.Shareable Configs</h4><p>可以使用如下写法，从另外一个输出 browserslist 配置的包导入配置数据:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">  <span class="string">"extends browserslist-config-mycompany"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>为了安全起见，额外的配置包只支持前缀 <code>browserslist-config-</code> 的包命名. npm 包作用域也同样支持 <code>@scope/browserslist-config</code>,例如： <code>@scope/browserslist-config</code> or <code>@scope/browserslist-config-mycompany</code>.</p><p>当写一个 shared config package 时，必须导出一个数组。如 <code>browserslist-config-mycompany/index.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [<span class="string">'last 1 version'</span>, <span class="string">'&gt; 1%'</span>, <span class="string">'ie 10'</span>];</span><br></pre></td></tr></table></figure><h4 id="4-环境的差异化配置"><a href="#4-环境的差异化配置" class="headerlink" title="4.环境的差异化配置"></a>4.环境的差异化配置</h4><p>你可以为不同的环境配置不同的浏览器查询条件。 browserslist 将依赖 <code>BROWSERSLIST_ENV</code> 或者 <code>NODE_ENV</code> 查询浏览器版本范围 . 如果两个环境变量都没有配置正确的查询条件，那么优先从 <code>production</code> 对应的配置项加载查询条件，如果再不行就应用默认配置。</p><p>如在<code>package.json</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": &#123;</span><br><span class="line">  "production": [</span><br><span class="line">    "&gt; 1%",</span><br><span class="line">    <span class="string">"ie 10"</span></span><br><span class="line">  ],</span><br><span class="line">  "development": [</span><br><span class="line">    "last 1 chrome version",</span><br><span class="line">    <span class="string">"last 1 firefox version"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或在<code>.browserslistrc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[production staging]</span><br><span class="line">&gt; 1%</span><br><span class="line">ie 10</span><br><span class="line"></span><br><span class="line">[development]</span><br><span class="line">last 1 chrome version</span><br><span class="line">last 1 firefox version</span><br></pre></td></tr></table></figure><h4 id="5-使用自定义数据"><a href="#5-使用自定义数据" class="headerlink" title="5.使用自定义数据"></a>5.使用自定义数据</h4><p>这需要 <a href="https://analytics.google.com/analytics/web/provision/#/provision" target="_blank" rel="noopener">Google Analytics</a>，然后可以通过数据生成<code>browserslist-stats.json</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist-ga</span><br></pre></td></tr></table></figure><p>你也可以通过其它方式得到统计，但是最终数据生成的内容格式应保持如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ie"</span>: &#123;</span><br><span class="line">    <span class="attr">"6"</span>: <span class="number">0.01</span>,</span><br><span class="line">    <span class="attr">"7"</span>: <span class="number">0.4</span>,</span><br><span class="line">    <span class="attr">"8"</span>: <span class="number">1.5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"chrome"</span>: &#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;,</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js-api"><a href="#js-api" class="headerlink" title="js api"></a>js api</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browserslist = <span class="built_in">require</span>(<span class="string">'browserslist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your CSS/JS build tool code</span></span><br><span class="line"><span class="keyword">const</span> process = <span class="function"><span class="keyword">function</span> (<span class="params">source, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> browsers = browserslist(opts.browsers, &#123;</span><br><span class="line">    stats: opts.stats,</span><br><span class="line">    path: opts.file,</span><br><span class="line">    env: opts.env,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Your code to add features for selected browsers</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查询可以是字符串 <code>&quot;&gt; 1%, IE 10&quot;</code> 或数组 <code>[&#39;&gt; 1%&#39;, &#39;IE 10&#39;]</code>。</p><p>如果缺少查询，browserslist 将查找配置文件。您可以提供一个路径选项（可以是一个文件）来查找相对于它的配置文件。</p><p>Options:</p><ul><li><code>path</code>: 文件或目录路径来查找配置文件。默认为<code>.</code></li><li><code>env</code>: 从配置中使用什么环境部分。默认为 <code>production</code></li><li><code>stats</code>: 自定义使用统计数据</li><li><code>config</code>: 如果要手动设置，则配置路径</li><li><code>ignoreUnknownVersions</code>: 不要直接查询（例如 <code>12</code>）。默认为 <code>false</code></li><li><code>dangerousExtend</code>: 禁用扩展查询的安全检查。默认为 <code>false</code></li></ul><p>对于非 js 环境和调试目的，可以使用 cli 工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist <span class="string">"&gt; 1%, IE 10"</span></span><br></pre></td></tr></table></figure><h3 id="覆盖率查询"><a href="#覆盖率查询" class="headerlink" title="覆盖率查询"></a>覆盖率查询</h3><p>可以通过 js API 获得所选浏览器的总用户覆盖率：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browserslist.coverage(browserslist(<span class="string">'&gt; 1%'</span>));</span><br><span class="line"><span class="comment">//=&gt; 81.4</span></span><br></pre></td></tr></table></figure><p>或者通过 cli：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist --coverage=US <span class="string">"&gt; 1% in US"</span></span><br></pre></td></tr></table></figure><h3 id="在线覆盖情况查询"><a href="#在线覆盖情况查询" class="headerlink" title="在线覆盖情况查询"></a>在线覆盖情况查询</h3><p>地址：<a href="https://browsersl.ist/" target="_blank" rel="noopener">https://browsersl.ist/</a>、<a href="https://browserslist.dev/" target="_blank" rel="noopener">https://browserslist.dev/</a></p><p>效果：</p><p><img src="/images/browserslist/p-browserslist-dev.jpg" alt="p-browserslist-dev.jpg"></p><p><img src="/images/browserslist/p-browserslist-ist.jpg" alt="p-browserslist-ist.jpg"></p><h2 id="衍生工具"><a href="#衍生工具" class="headerlink" title="衍生工具"></a>衍生工具</h2><p>browerslist 衍生的工具，具体可见<a href="https://github.com/browserslist/browserslist#tools" target="_blank" rel="noopener">browserslist tools</a></p><ul><li><a href="https://github.com/browserslist/browserslist-ga" target="_blank" rel="noopener">browserslist-ga</a>或<a href="https://github.com/browserslist/browserslist-ga-export" target="_blank" rel="noopener">browserslist-ga-export</a>： 该工具能生成访问你运营的网站的浏览器的版本分布数据，以便用于类似&gt; 0.5% in my stats 查询条件, 前提是你运营的网站部署有 Google Analytics。</li><li><a href="https://github.com/browserslist/browserslist-useragent-regexp" target="_blank" rel="noopener">browserslist-useragent</a> ： 检验 某浏览器的 user-agent 字符串是否匹配 browserslist 给出的浏览器范围。</li><li><a href="https://github.com/browserslist/browserslist-useragent-ruby" target="_blank" rel="noopener">browserslist-useragent-ruby</a> ： 功能同上，ruby 库。</li><li>caniuse-api： 返回支持指定特性的浏览器版本范围</li><li>npx browserslist ：在前端工程目录下运行上面命令，输出当前工程的目标浏览器列表。</li></ul><h2 id="Browserslist-2"><a href="#Browserslist-2" class="headerlink" title="Browserslist 2"></a>Browserslist 2</h2><h3 id="last-n-versions-为更好的网络而改变"><a href="#last-n-versions-为更好的网络而改变" class="headerlink" title="last n versions 为更好的网络而改变"></a><code>last n versions</code> 为更好的网络而改变</h3><p>从一开始，Autoprefixer 就 <code>last 2 versions</code> 选择了最后的 2 个浏览器版本，但不是从所有浏览器中挑选出来，只是最流行的那些。事实证明，这是一个错误。</p><p>现实世界中没有“主流”浏览器。例如，中国在线市场巨大，在中国有很多流行的本地浏览器。我们不能仅仅忽略本地浏览器——每个人都应该可以访问网络。</p><p>事实上，Autoprefixer 本身的创建是为了阻止浏览器的差异化（例如<code>-webkit-</code>对移动浏览器使用 <code>-only</code> 前缀）。</p><p>这就是为什么 Autoprefixer 7 和 Browserslist 2 <code>last 2 version</code> 会选择 所有浏览器的 2 个最新版本。</p><p>不用担心大小，<code>——gzip</code> 可以很好地压缩前缀，因此您很可能不会看到任何大小差异。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Browserslist 在托管过程中缓存它从 <code>package.json</code> 和 <code>browserslist</code> 文件中读取的配置，以及有关文件存在的知识。</p><p>要清除这些缓存，请使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist.clearCaches();</span><br></pre></td></tr></table></figure><p>要完全禁用缓存，请设置 <code>BROWSERSLIST_DISABLE_CACHE</code> 环境变量。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>不推荐用 <code>last 2 Chrome versions</code> 或 <code>not dead</code> 的查询条件来锁定特别具体的浏览器品牌和版本。市面上有各种各样的浏览器，同时浏览器的版本碎片化也很严重，如果你在开发一款通用的 webapp，那就应该考虑浏览器多样性导致的兼容问题。（<code>not dead</code>在国内外的差异见下图）</p><p><code>not dead</code> 国内覆盖率只有 73%</p><p><img src="/images/browserslist/p-browserslist-ist-notdead1.jpg" alt="p-browserslist-ist-notdead1.jpg"></p><p><code>not dead</code> 全球有 86.4%<br><img src="/images/browserslist/p-browserslist-ist-notdead2.jpg" alt="p-browserslist-ist-notdead2.jpg"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://github.com/ai/browserslist" target="_blank" rel="noopener">https://github.com/ai/browserslist</a></li><li><a href="https://evilmartians.com/chronicles/autoprefixer-7-browserslist-2-released" target="_blank" rel="noopener">https://evilmartians.com/chronicles/autoprefixer-7-browserslist-2-released</a></li><li><a href="https://css-tricks.com/browserlist-good-idea/" target="_blank" rel="noopener">https://css-tricks.com/browserlist-good-idea/</a></li><li><a href="http://browserl.ist/" target="_blank" rel="noopener">http://browserl.ist/</a></li><li><a href="https://browserslist.dev/" target="_blank" rel="noopener">https://browserslist.dev/</a></li><li><a href="https://github.com/browserslist/update-db#readme" target="_blank" rel="noopener">https://github.com/browserslist/update-db#readme</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Browserslist-信息和使用整理&quot;&gt;&lt;a href=&quot;#Browserslist-信息和使用整理&quot; class=&quot;headerlink&quot; title=&quot;Browserslist 信息和使用整理&quot;&gt;&lt;/a&gt;Browserslist 信息和使用整理&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浏览器" scheme="http://blog.michealwayne.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】越来越快的jsRuntime——Bun</title>
    <link href="http://blog.michealwayne.cn/2022/07/17/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%BF%AB%E7%9A%84jsRuntime%E2%80%94%E2%80%94Bun/"/>
    <id>http://blog.michealwayne.cn/2022/07/17/notes/【笔记】越来越快的jsRuntime——Bun/</id>
    <published>2022-07-17T08:17:10.000Z</published>
    <updated>2022-07-19T02:30:18.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="越来越快的-jsRuntime——Bun"><a href="#越来越快的-jsRuntime——Bun" class="headerlink" title="越来越快的 jsRuntime——Bun"></a>越来越快的 jsRuntime——Bun</h1><p>在 2020 年起，大家都在谈论 js 的未来发展，其中本人印象最为深刻的就是<a href="https://www.swyx.io/js-third-age/" target="_blank" rel="noopener">“js 三时代”</a>一论。大致表达意思是只每隔 10 年，js 就会发生一次变化，而我们正处于 js 第三个时代——整合工具层时期。在 js runtime 这块比较典型的就是<a href="https://github.com/denoland/deno" target="_blank" rel="noopener">Deno</a>，它试图将执行测试、格式化、linting 和捆绑等任务的常用工具合并到一个二进制文件中，使用 TypeScript，甚至包括一个标准库。<a href="https://github.com/rome" target="_blank" rel="noopener">Rome</a>采取了不同的策略，将所有这些层折叠在 Node.js 之上。</p><p>js 第三时代工具的特点：</p><ul><li>更快</li><li>ESM 优先</li><li>折叠层（一个工具做好很多事情，而不是很多工具做好一件事）</li><li>Typesafe-er（以强类型语言为核心构建，并以零配置支持用户代码中的 TS）</li><li>Secure-er（来自依赖攻击，或宽松的权限）</li><li>多语种</li><li>Neo-Isomorphic（JS 应该首先在构建时或服务器端运行，然后再到达客户端）</li></ul><p><img src="/images/bun/p-1.png" alt="p-1.png"></p><p>所有这些的结果是更好的开发人员体验（更快地构建，标准化行业工具）和用户体验（更小的 bundle 包、更快的功能交付）。它是 js 从站点脚本语言到完整应用平台的最终蜕变。</p><p>而本文介绍的也是第三阶段演进中近期快速发展的整合 Runtime ——<a href="https://github.com/oven-sh/bun" target="_blank" rel="noopener">Bun</a>。</p><blockquote><p>Bun——Incredibly fast JavaScript runtime, bundler, transpiler and package manager – all in one. 官网：<a href="https://bun.sh/" target="_blank" rel="noopener">https://bun.sh/</a>；Bun Github：<a href="https://github.com/oven-sh/bun" target="_blank" rel="noopener">https://github.com/oven-sh/bun</a></p></blockquote><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Bun 是采用 Zig 语言编写的高性能“全家桶” js runtime，官方称其为“all-in-one JavaScript runtime”，它原生（作者自己手撸）实现了数百个 Node.js 和 Web API，包括约 90% 的 node API 函数、fs、path、Buffer 等，并且 Bun 也可以直接运行 TypeScript 文件。</p><blockquote><p>作者 <a href="https://twitter.com/jarredsumner" target="_blank" rel="noopener">Jarred Sumner</a>，据说因为肝代码而天天都吃包子，所以取名叫 Bun。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>支持系统：macOS x64、Silicon、Linux x64、Windows Subsystem for Linux（WSL）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://bun.sh/install | bash</span><br></pre></td></tr></table></figure><p>（目前最新版本 v0.1.4 beta）</p><blockquote><p>注意 Windows 系统不能像装 Nodejs 一样直接程序安装，Windows 的安装使用可以参照<a href="https://juejin.cn/post/7119006461576871973" target="_blank" rel="noopener">https://juejin.cn/post/7119006461576871973</a></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装后可以写一个 demo（如官方 http server demo）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  fetch(request) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'Welcome to Bun!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun run http.js</span><br></pre></td></tr></table></figure><p>然后可以通过 <code>http://localhost:3000</code> 进行访问。</p><h4 id="TypeScript-使用"><a href="#TypeScript-使用" class="headerlink" title="TypeScript 使用"></a>TypeScript 使用</h4><p>在 Bun 中，天然支持运行运行 TypeScript，无需配置，无需额外安装；<br>如果你导入一个<code>.ts</code>或<code>.tsx</code>文件，Bun 会将它转换成 js。注意 Bun 还会编译<code>node_modules</code>中的<code>.ts</code>或<code>.tsx</code>文件；这是由 Bun 内置了 TypeScript 转译器，且速度很快。</p><p>如果你想在全局使用对应的 API，安装 <a href="https://github.com/oven-sh/bun/blob/main/types/bun/bun.d.ts" target="_blank" rel="noopener">bun-typs</a> 到你的项目即可：</p><p>1.安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun add -d bun-types</span><br></pre></td></tr></table></figure><p>2.在<code>tsconfig.json</code>中使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"types"</span>: [<span class="string">"bun-types"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Bun 目前处于初创和快速迭代器，使用建议看 github（<a href="https://github.com/oven-sh/bun#using-bunjs---a-new-javascript-runtime-environment" target="_blank" rel="noopener">https://github.com/oven-sh/bun#using-bunjs—a-new-javascript-runtime-environment</a>）</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>bun run</code>：执行 js/ts 脚本，可以执行 package.json 中的 “scripts” 脚本，而且官方说比 npm run 快 30 倍；</li><li><code>bun install</code>：安装模块。官方说 bun install 使用最快的系统调用来复制文件，官方说比 yarn 快 20 倍；<ul><li><code>bun remove</code>：删除一个模块；</li><li><code>bun add</code>：增加安装一个模块；</li><li><code>bun create</code>：创建一个模板项目，如<code>bun create react ./bun-react-demo</code>创建一个名为 bun-react-demo 的 react 项目</li></ul></li><li><code>bun wiptest</code>：进行测试，一个类似于 Jest 的测试运行器，用于内置到 bun 的 JavaScript 和 TypeScript 项目。</li><li><code>bun upgrade</code>：升级 bun。</li></ul><h3 id="配置文件bunfig-toml"><a href="#配置文件bunfig-toml" class="headerlink" title="配置文件bunfig.toml"></a>配置文件<code>bunfig.toml</code></h3><p><code>bunfig.toml</code> 是 bun 的配置文件。</p><p>通过配置文件我们可以在 <code>bunfig.toml</code> 加载配置，而不是每次都将参数传递给命令行。在解析命令行参数之前加载配置文件，这意味着命令行参数可以覆盖这个配置。</p><p>如官方案例（<a href="https://github.com/oven-sh/bun#bunfigtoml）：" target="_blank" rel="noopener">https://github.com/oven-sh/bun#bunfigtoml）：</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Set a default framework to use</span><br><span class="line"># By default, bun will look for an npm package like `bun-framework-$&#123;framework&#125;`, followed by `$&#123;framework&#125;`</span><br><span class="line">framework = "next"</span><br><span class="line">logLevel = "debug"</span><br><span class="line"></span><br><span class="line"># publicDir = "public"</span><br><span class="line"># external = ["jquery"]</span><br><span class="line"></span><br><span class="line">[macros]</span><br><span class="line"># Remap any import like this:</span><br><span class="line">#     import &#123;graphql&#125; from 'react-relay';</span><br><span class="line"># To:</span><br><span class="line">#     import &#123;graphql&#125; from 'macro:bun-macro-relay';</span><br><span class="line">react-relay = &#123; "graphql" = "bun-macro-relay" &#125;</span><br><span class="line"></span><br><span class="line">[bundle]</span><br><span class="line">saveTo = "node_modules.bun"</span><br><span class="line"># Don't need this if `framework` is set, but showing it here as an example anyway</span><br><span class="line">entryPoints = ["./app/index.ts"]</span><br><span class="line"></span><br><span class="line">[bundle.packages]</span><br><span class="line"># If you're bundling packages that do not actually live in a `node_modules` folder or do not have the full package name in the file path, you can pass this to bundle them anyway</span><br><span class="line">"@bigapp/design-system" = true</span><br><span class="line"></span><br><span class="line">[dev]</span><br><span class="line"># Change the default port from 3000 to 5000</span><br><span class="line"># Also inherited by Bun.serve</span><br><span class="line">port = 5000</span><br><span class="line"></span><br><span class="line">[define]</span><br><span class="line"># Replace any usage of "process.env.bagel" with the string `lox`.</span><br><span class="line"># The values are parsed as JSON, except single-quoted strings are supported and `'undefined'` becomes `undefined` in JS.</span><br><span class="line"># This will probably change in a future release to be just regular TOML instead. It is a holdover from the CLI argument parsing.</span><br><span class="line">"process.env.bagel" = "'lox'"</span><br><span class="line"></span><br><span class="line">[loaders]</span><br><span class="line"># When loading a .bagel file, run the JS parser</span><br><span class="line">".bagel" = "js"</span><br><span class="line"></span><br><span class="line">[debug]</span><br><span class="line"># When navigating to a blob: or src: link, open the file in your editor</span><br><span class="line"># If not, it tries $EDITOR or $VISUAL</span><br><span class="line"># If that still fails, it will try Visual Studio Code, then Sublime Text, then a few others</span><br><span class="line"># This is used by Bun.openInEditor()</span><br><span class="line">editor = "code"</span><br><span class="line"></span><br><span class="line"># List of editors:</span><br><span class="line"># - "subl", "sublime"</span><br><span class="line"># - "vscode", "code"</span><br><span class="line"># - "textmate", "mate"</span><br><span class="line"># - "idea"</span><br><span class="line"># - "webstorm"</span><br><span class="line"># - "nvim", "neovim"</span><br><span class="line"># - "vim","vi"</span><br><span class="line"># - "emacs"</span><br><span class="line"># - "atom"</span><br><span class="line"># If you pass it a file path, it will open with the file path instead</span><br><span class="line"># It will recognize non-GUI editors, but I don't think it will work yet</span><br></pre></td></tr></table></figure><p>属性解释：</p><ul><li><code>framework</code> ：指定默认使用的 framework 版本，bun 将根据 <code>bun-framework-${framework}</code> 格式找寻找 npm 包；</li><li><code>logLevel</code> ：指定 log 级别（可用值 error 、 warn 、 info 和 debug ）；</li><li><code>publicDir</code> ：指定 public 目录；</li><li><code>external</code> ：指定外部扩展，作用等同于 Webpack 的 externals；</li><li><code>macros</code> ：宏定义，用于替换 import 路径，比如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'react-relay'</span>; 将被转换为 <span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">"macro:bun-macro-relay/bun-macro-relay.tsx"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>dev.port</code> ：指定服务的监听端口（默认 3000 ）；</li><li><code>define</code> ：作用等同于 Webpack 的 DefinePlugin；</li><li><code>loaders</code> ：指定各类文件的解析器；</li></ul><h3 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h3><ul><li>Web API 支持：对  fetch、WebSocket、 ReadableStream  等  API  都提供了内置支持；</li><li>Node.js 模块：Bun  实现了  Node.js  的模块解析算法，，以便我们可以在 Bun 中使用 npm 包，同时支持  ESM  和  CommonJS，但  Bun  内部使用  ESM；</li><li>Bun.js  实现了大部分  Node-API (N-API)，大部分  Node.js  原生模块及全局变量（比如 Buffer 和 process）都可以正常工作；</li><li>自动加载环境变量  .env  文件，不需要再  require(“dotenv”).load()；</li><li>附带一个内置的快速  SQLite3 户端  bun:sqlite；</li><li>内置 JavaScript、TypeScript、JSX 等（见下表）各种转译器；</li></ul><table><thead><tr><th>Input</th><th>Loader</th><th>Output</th></tr></thead><tbody><tr><td><code>.js</code></td><td>JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.jsx</code></td><td>JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.ts</code></td><td>TypeScript + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.tsx</code></td><td>TypeScript + JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.mjs</code></td><td>JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.cjs</code></td><td>JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.mts</code></td><td>TypeScript</td><td><code>.js</code></td></tr><tr><td><code>.cts</code></td><td>TypeScript</td><td><code>.js</code></td></tr><tr><td><code>.toml</code></td><td>TOML</td><td><code>.js</code></td></tr><tr><td><code>.css</code></td><td>CSS</td><td><code>.css</code></td></tr><tr><td><code>.env</code></td><td>Env</td><td><code>N/A</code></td></tr><tr><td><code>.*</code></td><td>file</td><td><code>string</code></td></tr></tbody></table><p>Bun 对 Node.js 生态实现了良好兼容：</p><ul><li>内置了 fetch、WebSocket、ReadableStream 等 Web API；</li><li>实现了 Node.js 核心模块（比如 fs、path、Buffer 等）及全局变量（比如 process）；</li><li>实现了 Node.js 的模块解析算法，以便我们可以在 Bun 中使用 npm 包；</li><li>支持 ESM 和 CommonJS（Bun 内部默认使用 ESM）。</li></ul><h2 id="有多快"><a href="#有多快" class="headerlink" title="有多快"></a>有多快</h2><p>Bun 的主要优势就是快，那么它快在哪里？</p><h3 id="官方对比数据"><a href="#官方对比数据" class="headerlink" title="官方对比数据"></a>官方对比数据</h3><p>首先是 React 的服务器端渲染速度（每秒的 HTTP 请求数）：</p><p><img src="/images/bun/p-compare-1.png" alt="p-compare-1.png"></p><p>加载一个大型数据表：每秒平均查询次数：</p><p><img src="/images/bun/p-compare-2.png" alt="p-compare-2.png"></p><p>FFI：每秒操作数：</p><p><img src="/images/bun/p-compare-3.png" alt="p-compare-3.png"></p><p>按作者推特上的测试：</p><p><img src="/images/bun/p-bun-fast.png" alt="p-bun-fast.png"></p><p>还有一篇文章中的多项测试（要翻墙）：<br><a href="https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9" target="_blank" rel="noopener">https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9</a></p><p>与 npm 对比：<br><img src="/images/bun/p-bun-npm.png" alt="p-bun-npm.png"></p><p>与 babel 对比：<br><img src="/images/bun/p-bun-babel.png" alt="p-bun-babel.png"></p><p>与 webpack 对比：<br><img src="/images/bun/p-bun-webpack.png" alt="p-bun-webpack.png"></p><p>与 vite、swc 对比：<br><img src="/images/bun/p-bun-vite.png" alt="p-bun-vite.png"></p><p>我们可以用 bun 的一些 demo 自行验证：<a href="https://github.com/oven-sh/bun/tree/main/examples" target="_blank" rel="noopener">https://github.com/oven-sh/bun/tree/main/examples</a></p><p>按官方的对比数据，Bun 可以说在性能方面是碾压 Node.js 和 Deno。</p><h3 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h3><h4 id="1-js-引擎差异"><a href="#1-js-引擎差异" class="headerlink" title="1.js 引擎差异"></a>1.js 引擎差异</h4><p>不同于 Node.js 和 Deno，Bun 并没有基于 V8 引擎，而是使用了轻量级的 <a href="https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore" target="_blank" rel="noopener">JavaScriptCore</a> 引擎，jsCore 一般用于移动端，它的执行速度往往要比 V8 等更传统引擎要快。</p><p>Bun 中一些 Web API 直接用了 Safari 的实现，如 Headers 和 URL，<a href="https://github.com/oven-sh/bun/blob/HEAD/src/bun.js/bindings/webcore/JSFetchHeaders.cpp" target="_blank" rel="noopener">https://github.com/oven-sh/bun/blob/HEAD/src/bun.js/bindings/webcore/JSFetchHeaders.cpp</a>。</p><h4 id="2-开发语言差异"><a href="#2-开发语言差异" class="headerlink" title="2.开发语言差异"></a>2.开发语言差异</h4><p>Bun.js 使用的是新兴的系统编程语言 <a href="https://ziglang.org/" target="_blank" rel="noopener">ZIG</a> 编写的，ZIG 一般用于嵌入式和系统级编程，使用 ZIG 主要通过手动内存管理对内存进行更细粒度的控制、无隐藏的控制流来提升程序的性能。</p><blockquote><p>Zig 是一门系统级编程语言，专为稳定性、可维护性和性能而设计，是追求替代 C 语言在系统编程上的最佳地位。</p></blockquote><p><img src="/images/bun/p-bun-language.png" alt="p-bun-language.png"></p><p>其中 C++的代码大部分是 web API 的实现（Safari）</p><h4 id="3-独立实现工具"><a href="#3-独立实现工具" class="headerlink" title="3.独立实现工具"></a>3.独立实现工具</h4><p>在前两点的前提下，作者重新实现了诸如 JSX/TypeScript 转编器、npm 客户端、SQLite 客户端、HTTP 客户端、WebSocket 客户端等类库。</p><h2 id="使用评估"><a href="#使用评估" class="headerlink" title="使用评估"></a>使用评估</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能。主要亮点、核心竞争力。至少短期 Node/Deno 是难以超越 Bun；</li><li>效率。集成各类工具，能大幅提高开发效率，这也是 js 第三阶段产物的典型特征。</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>是起步项目，目前存在内存泄露等问题，连作者也不建议在生产使用；</li><li>是个人项目，目前仍有 200+个 issue 待解决</li><li>部分 npm 包不兼容</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>版本较新，最新版本才 v0.1.4；</li><li>star 快速上升，目前 26.2k（至 2022.07.17）。油管上也有多了许多讲解视频；</li><li>社区维护：<a href="https://bun.sh/discord" target="_blank" rel="noopener">https://bun.sh/discord</a><br><img src="/images/bun/p-bun-discord.jpg" alt="p-bun-discord.jpg"></li><li>里程碑：<a href="https://github.com/oven-sh/bun/issues/159" target="_blank" rel="noopener">https://github.com/oven-sh/bun/issues/159</a></li></ul><p>综上，Bun 是一个有前景的项目，高效的性能能拓宽 js 的应用边界，但是目前项目仍处理起步阶段，整体并不成熟。因此我们目前不能在业务生产中直接使用 Bun，但我们可以尝试试用 Bun 并对 Bun 保持高度关注。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li>《The Third Age of JavaScript》<a href="https://www.swyx.io/js-third-age/" target="_blank" rel="noopener">https://www.swyx.io/js-third-age/</a></li><li>《Windows 下安装 Bun》<a href="https://juejin.cn/post/7119006461576871973" target="_blank" rel="noopener">https://juejin.cn/post/7119006461576871973</a></li><li>《Is Bun the Next Big Thing After Webpack?》<a href="https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9" target="_blank" rel="noopener">https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;越来越快的-jsRuntime——Bun&quot;&gt;&lt;a href=&quot;#越来越快的-jsRuntime——Bun&quot; class=&quot;headerlink&quot; title=&quot;越来越快的 jsRuntime——Bun&quot;&gt;&lt;/a&gt;越来越快的 jsRuntime——Bun&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Bun" scheme="http://blog.michealwayne.cn/tags/Bun/"/>
    
  </entry>
  
  <entry>
    <title>【整理】编码命名规范建议</title>
    <link href="http://blog.michealwayne.cn/2022/06/12/notes/%E3%80%90%E6%95%B4%E7%90%86%E3%80%91%E7%BC%96%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/"/>
    <id>http://blog.michealwayne.cn/2022/06/12/notes/【整理】编码命名规范建议/</id>
    <published>2022-06-12T12:41:10.000Z</published>
    <updated>2022-06-27T11:00:39.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码命名规范建议"><a href="#编码命名规范建议" class="headerlink" title="编码命名规范建议"></a>编码命名规范建议</h1><h2 id="编程中命名习惯的改进"><a href="#编程中命名习惯的改进" class="headerlink" title="编程中命名习惯的改进"></a>编程中命名习惯的改进</h2><blockquote><p> 当我们看到一段代码时，最先注意到的，不是代码有几层循环，用了什么模式，而是变量与注释，因为它们是代码里最接近自然语言的东西。</p></blockquote><p>写代码前先决定名字。</p><h3 id="命名的指导方针"><a href="#命名的指导方针" class="headerlink" title="命名的指导方针"></a>命名的指导方针</h3><ul><li>名字中要尽量多包含信息。</li><li>名字不能有歧义。</li><li>名字说明的是效果和目的，而不是手段。</li><li>可以通过先写测试程序后写处理的方式检查一下自己取的名字是否合适。</li><li>名字要能念出来。</li><li>名字要能搜索出来。</li></ul><p>有一种叫做<strong>“名字可逆性”</strong>的命名思路，主张名字必须能还原其所指内容的说明文本。要想满足这一条件，就需要进行环回检测。先通过内容的说明文本来想名字，再通过名字倒推出说明文本。按照说明文本、名字、说明文本的顺序绕一圈回来后，如果说明文本一致，那这个名字就是好名字，如果不一致就需要我们注意了。</p><blockquote><p>*心理映射：读代码的人看到某元素名字后需要先在心里把它转换成自己知道的东西，这个过程就是心理映射，我们应该极力避免这种情况发生。</p></blockquote><h3 id="命名的基本原则"><a href="#命名的基本原则" class="headerlink" title="命名的基本原则"></a>命名的基本原则</h3><ul><li><p>全部采用易懂的英文来命名，可以辅以下划线和数字。</p></li><li><p>名称长度尽量不要超过16个字符（有些常量名称可能长度会比较长）。</p></li><li><p>不要采用无意义的名字</p></li><li><p>每个单词之间应该有合适的分割，可以采用大小写间隔，也可以采用下划线。</p></li><li><p>除了常量以外，都应该是大小写混合的形式，即使是FTP，也要写成Ftp。</p></li><li><p>遵循编程语言的标准，比如 Python 遵循 <a href="https://pep8.org/" target="_blank" rel="noopener">PEP8</a> 编码风格。</p></li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><h5 id="1-snake-case"><a href="#1-snake-case" class="headerlink" title="1.snake-case"></a>1.snake-case</h5><p>蛇形命名法, 规定复合词或短语中的各个单词之间用下划线（<code>_</code>）分隔并且没有空格。复合词中的每一个单词的首字母通常都是小写的，并且复合词的第一个字母既可以是大写的又可以是小写的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: lisp_case、kebab_case、SCREAMING_SNAKE_CASE</span><br></pre></td></tr></table></figure><h5 id="2-camel-case"><a href="#2-camel-case" class="headerlink" title="2.camel-case"></a>2.camel-case</h5><p>驼峰命名法，其中又可分：</p><p> <strong>lower-case </strong>：小驼峰命名法，第一个单词的首字母小写；第二个单词开始每个单词的的首字母大写。方法名、参数名、成员变量、局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: firstName、lastName</span><br></pre></td></tr></table></figure><p><strong>upper-case / pascal-case</strong>：大驼峰命名法，每一个单词的首字母都大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: FirstName、LastName、CamelCase</span><br></pre></td></tr></table></figure><h5 id="3-kebab-case"><a href="#3-kebab-case" class="headerlink" title="3.kebab-case"></a>3.kebab-case</h5><p>短横线命名法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: v-bind</span><br></pre></td></tr></table></figure><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><h4 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h4><ul><li><ol><li>尽量不要使用拼音，杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou 反例：validateCanShu</li></ol></li><li><ol start="2"><li>命名过程中尽量不要出现特殊的字符，常量除外。</li></ol></li><li><ol start="3"><li>尽量不要和全局变量或者框架中已存在的类重名，也不能使用编程语言中的关键字命名。</li></ol></li><li><ol start="4"><li>妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。如类名采用 User4RedisDO，方法名 getUserInfoFromRedis，convertJson2Map等。</li></ol></li><li><ol start="5"><li>避免误导。要注意使用小写字母i和大写字母O作为变量名，看起来像“壹”和“零”。</li></ol></li><li><ol start="6"><li>使用可搜索的名称。单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来</li></ol></li><li><ol start="7"><li>言到意到，意到言到，别扮”可爱“，别用双关语。</li></ol></li></ul><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。</p><p>为变量命名要结合代码情境和上下文，变量命名时，<strong>尽量简短且能清楚的表达变量的作用</strong>，命名体现具体的业务含义即可。</p><p>通用格式：</p><ul><li><p>变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法，lower-case），如 computedValues，index。</p></li><li><p>变量名<strong>不应以下划线或美元符号开头</strong>，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo（简单的Java对象，实际就是普通JavaBeans）中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。</p></li><li><p>变量名描述性要强，但不宜过长，尽量<strong>不要超过4个</strong>单词。</p></li><li><p>在同一段代码内，不要出现多个相似的变量名。</p></li></ul><p>其他：</p><ul><li>变量越多，就越难全部跟踪它们的动向</li><li>变量的作用域越大，就需要跟踪它的动向越久</li><li>变量改变得越频繁，就越难以跟踪它的当前值。</li></ul><h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><p>通用格式：</p><ul><li><p>常量要采用全部大写的形式进行命名，如果有多个单词，用下划线进行分割。</p></li><li><p>常量的命名不要采用序号式命名。</p></li><li><p>常量应该通过其开头词进行分组。</p></li></ul><p>其他：</p><ul><li><p>常量一般都有自己的业务含义，<strong>不要害怕长度过长而进行省略或者缩写</strong>。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。</p></li><li><p>虽然很多常量名字本身已经很清楚感觉不需要注释，但是可以通过加注释得以改进，比如定义这个常量时的想法。</p></li></ul><h3 id="相似的命名"><a href="#相似的命名" class="headerlink" title="相似的命名"></a>相似的命名</h3><ul><li>*Form（获取页面输入）、持久化（想数据库存取数据）、View（想页面显示数据）的重复：难免会产生这三层需要采用同一个名称的情况，最佳方法就是将三者合一，通过Annotation来完成各自不同用途的格式定义，从而减少命名重复的困扰。</li><li>层1、层2……层n的无形层的重复：可以采用<code>～Form</code>、<code>～Wapper</code>、<code>～Layer</code>分别对不同的包装容器进行命名来规避这个问题。</li><li>类和内容的重复：一般来说，容器和内容之间都会有不同的名词，例如房子和家具、菜篮子和蔬菜、问卷和问题。</li><li>整体和部分：可以通过增加前缀来区分部分和整体，例如matched、filtered、grouped、wrapper。</li><li>类型转换：可以通过连续调用来略过类型转换时的中间变量。</li></ul><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><h3 id="1-从阅读者角度，一些常见的编码问题"><a href="#1-从阅读者角度，一些常见的编码问题" class="headerlink" title="1.从阅读者角度，一些常见的编码问题"></a>1.从阅读者角度，一些常见的编码问题</h3><ul><li>一直滚动鼠标滚轮——方法过长</li><li>总是全局搜索——方法过长</li><li>反复地查看方法实现——命名无法反映其真实含义</li><li>不停地查看调用方法实现——调用层数太多</li><li>反复查看全局常量的值——常量定义方式无法反映其实质</li><li>画流程图——嵌套太深。</li></ul><p>在阅读上的问题分为以下5类：</p><ul><li>命名类问题</li><li>注释类问题</li><li>结构类问题</li><li>架构类问题</li><li>风格类问题</li></ul><p>其中与命名相关的问题：</p><h4 id="命名类问题"><a href="#命名类问题" class="headerlink" title="命名类问题"></a>命名类问题</h4><p>代码能够用尽可能短的命名来表征尽可能多的含义。</p><ul><li>1.缺乏统一性：类/接口/方法/变量命名都应该遵守一定的规则。</li><li>2.没有考虑调用时的情形</li><li>3.本地语言命名：除非专有名词，否则还是要用英语。</li><li>4.命名用词不当：所使用的英文有误、可能引起误解。如：<ul><li>research不能表示重新检索，想要表示重新检索应该用searchAgain；</li><li>limit表示极限而不是限制，restriction或者constraint才表示限制；</li><li>fasten表示固定而不是加速，accelerate才表示加速。</li></ul></li><li>5.超长的命名：超长的命名回花费较多时间阅读，也不容易记忆。例如internationalization这个词汇已经被缩略为i18n，以方便书写和记忆。<ul><li>是否需要使用缩略词，取决于<strong>团队的新成员是否能理解这个名字的含义</strong>。</li></ul></li><li>6.命名含义模糊</li><li>7.命名和行为不一致：承诺多做得少；承诺少做得多；言行不一。</li><li>8.否定式命名：否定式命名往往会引起阅读成本。</li><li>9.无意义命名：temp、result、retVal这些不表征具体的含义，包含的信息量少。</li><li>10.序号式命名：序号并不能表明其真实含义，例如layer0、layer1.</li><li>11.工程名为类名前缀：把工程名作为类和接口的前缀是一种画蛇添足的行为，会降低阅读的速度。</li><li>12.超短命名：a、b、c这种也无法获取有用信息，但注意循环体中约定俗成的i、j、k是无妨的。</li><li>13.匈牙利命名法：匈牙利命名法可以帮助读者了解数据的类型方面，但在例如面向对象的编程风格中代，编写的代码难以形成统一易懂的缩写。应当把类和函数做得足够小，消除对成员前缀的需要</li></ul><h4 id="注释类问题"><a href="#注释类问题" class="headerlink" title="注释类问题"></a>注释类问题</h4><p>当代码通过其名称和符号无法很直观地表达其含义时，需要注释来帮助说明代码的作用。</p><ul><li>1.复制名称的注释：这种注释无法起到帮助作用。</li></ul><h4 id="风格类问题"><a href="#风格类问题" class="headerlink" title="风格类问题"></a>风格类问题</h4><ul><li>1.冗余的常量定义：<ul><li>有些可在原输入基础上补充而无需采用长常量列表的场景。不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。合适的做法比如缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。</li><li>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。<br>2） 应用内共享常量：放置在一方库中，通常是子模块中的constant目录下。</li></ul></li><li>2.变量意思不稳定：有歧义。</li><li>3.返回值意思不稳定</li><li>4.无用的方法或变量：特别是类中无用的public方法难以被发现。</li></ul><h3 id="问题产生的部分原因"><a href="#问题产生的部分原因" class="headerlink" title="问题产生的部分原因"></a>问题产生的部分原因</h3><h3 id="编程习惯不佳"><a href="#编程习惯不佳" class="headerlink" title="编程习惯不佳"></a>编程习惯不佳</h3><ul><li>命名习惯不好：is等作用域开头等，变量名称和方法名称容易无法区分。</li><li>没有管理好代码的责任：UI和数据和逻辑。</li><li>不考虑调用时的样子：调用时可能难以理解，要认真设计调用、比如接口。</li><li>不考虑命名的一致性：比如remove/delete。</li><li>方法命名必须以动词开头：方法命名必须为动词，或者动词+名词的形式，因为方法必须是动作。但不绝对，比如List.size()、find.all()，这样更易读。</li></ul><h3 id="英语能力不足"><a href="#英语能力不足" class="headerlink" title="英语能力不足"></a>英语能力不足</h3><ul><li><p>词性不对：对于集合性质的变量命名可以考虑采用其复数形式（有时也会降低阅读成本，这时可以换为在末尾加List、Map），例如可以用books而不是bookList。对于将动作变为变量的情况，应该将动作从动词改为动名词。例如可以用action而不是act。对于只有开关两种状态的属性来说，可以采用形容词。而对于多种取值的属性来说，则应该采用对应的名词。</p></li><li><p>词汇不对：应该用更为准确的词汇，例如表示缩短，makeShorter不如shorten更贴切；表示认证，doLogin不如authenticate更准确。对于一些计算机专业术语也是有一定规定的，例如对于栈Stack，它的行为应该是Push和Pop，而不是Pull。对于一些行业，也有其特定的术语，例如余额应该是balance而不是leftMoney。如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称。</p><ul><li><p>比如有这么个函数为<code>getPage(url)</code>，我们虽然可以知道是获取一个页面，但是如果用<code>fetchPage</code>或者<code>downloadPage</code>进行更具体的动作区分命名会更好。</p></li><li><p>再比如有个函数为<code>getSize()</code>，更为形象化的话可以命名为<code>getHeight()</code>、<code>getNodeNum()</code>、<code>getArrLength()</code></p></li><li><p>再比如有个函数为<code>stopAnimation()</code>，我们不知道它将是终止动画还是中止动画，我们可以命名为<code>killAnimation()</code>、<code>pauseAnimation()</code>。</p></li><li><p>下面是一些例子，这些单词可以使命名更有表现力且适合语境</p><p>| 单词  | 更多选择                                           |<br>| —- | ———————————————— |<br>| send  | deliver、dispatch、announce、distribute、route     |<br>| find  | search、extract、locate、recover                   |<br>| start | launch、create、begin、open                        |<br>| make  | create、set up、build、generate、compose、add、new |</p></li></ul></li><li><p>时态不对：采用动词原型命名的状态值往往会让读者猜测：到底是已经发生了这件事情，还是正在进行这件事情呢？例如register、attend、test、pass、failed，而如果能够结合时态命名则状态的含义就更容易理解了，例如：registered、atteneded、tested、evaluated。</p></li><li><p>语法没有加善利用：由于受到一些限制和束缚，没有把介词和连词在方法的命名中，代码读起来就不够顺畅，如果把这些词汇放在代码中，代码就会变得更加易读了。例如判断cell是否在最后一排：cell.isAtLastColumn() / gird.isAtLastColumn(cell)。</p></li></ul><h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><h3 id="词性"><a href="#词性" class="headerlink" title="词性"></a>词性</h3><ul><li>名词：表示属性的常用词性。</li><li>动词：一般用来表示方法（处理），方法的名称中一般都应该包含一个动词，其构成形式上一个动词或者动词+名词形式的词组</li><li>动名词：动作可以作为属性出现，但是应该以动名词的形式表现。例如action、configuration。动作行为也可以作为类或者接口出现，但是最好以动名词或者名词的形式出现，例如class Activity，class Service。</li><li>形容词：形容词作为属性表示某种状态，例如visible；用来表示某个状态的属性如果是形容词，一般是布尔型的，而其对应的判定方法则是is，如isVisible，其setter的形式是setVisible。形容词也可以有多种取值范围，例如可见性除了显示、隐藏之外还增加了正在消失。对于这种情况，需要改用名词来使其多种取值范围得以体现，例如visibility。</li><li>代词：代词可以用来指代其他事物，所以具有不必关心被指代事物的类型的特点。this（关键词，不能够使用）、what（当类中需要包含一个可能和自己重名的对象时）、other（当需要做对比时）、还有that、when、where、who、which、me、you、him、self。</li><li>介词、连词等：介词、连词等让代码读起来更顺畅。by（表示根据后面的条件执行前面的动作，如getLicenseById）、for（表示执行前面的动作是为了后面的目的，如waitForIdle）、at（表示根据后面的条件执行前面的动作，如removeAt）、and（表示两个条件都需要成立才能够执行前面的动作，如saveAndExit）、or（表示两个条件只需要其中一个条件成立即可执行前面的动作，如isNullOrEmpty）、另外还有with、after、before、through、as也都可以使用。另外介词、连词也可以作为方法的开头。</li></ul><h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><p>动词的时态有很多种，但编程中只要使用其中3种即可：</p><ul><li>一般现在时：表示状态类动作；</li><li>完成时：表示动作已经完成；</li><li>进行时：表示动作正在进行。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>宾语从句，如assertThat(num).isEqualTo(6)，读起来更像一句话而不需要更多思考；</li><li>过去时：如viewDidLoad表示视图加载完成；</li><li>一般将来时：如sendDelayed(3) -&gt; updateUiAfter(3)</li></ul><h3 id="否定词"><a href="#否定词" class="headerlink" title="否定词"></a>否定词</h3><ul><li>Exception与Error等的命名：异常或者错误本身就表示系统发生错误了，所以异常和错误都可以采用否定式命名以明确表示它原来的意思。如：<ul><li>InconvertibleException表示不能转换；</li><li>FileNotExistException表示文件不存在。</li></ul></li><li>错误常量：当处理发生错误时，有时需要使用错误值进行处理。错误号需要定义为常量，常量的命名可以采用否定式命名，如INVAILD_CODE</li><li>特殊类：如输入键盘。</li></ul><h3 id="成对词"><a href="#成对词" class="headerlink" title="成对词"></a>成对词</h3><p>固定方式出现的成对词能直接想到另一个方法的名称。常用成对词：</p><ul><li>get获取/set设置</li><li>max最大/min最小</li><li>start启动/stop停止</li><li>begin开始/end结束</li><li>backup备份/restore恢复</li><li>bind 绑定/  separate 分离</li><li>copy 复制/  paste 粘贴</li><li>clean 清理/  clear 清除</li><li>source来源/destination目的地</li><li>from来/to去</li><li>previous上一个/current当前/next下一个</li><li>create创建/destroy移除</li><li>plus加/minus减</li><li>positive积极的/negative消极的</li><li>connect 连接/  disconnect 断开（或close）</li><li>download 下载/  upload 上传</li><li>add增加/remove删除</li><li>add数字加/sub数字减</li><li>add 加入/  append 添加</li><li>increase 增加/  decrease 减少</li><li>enable启动/disable废弃</li><li>encode 编码/  decode 解码</li><li>encrypt 加密/  decrypt 解密</li><li>compress 压缩/  decompress 解压缩</li><li>parse 解析/  emit 生成</li><li>pause暂停/resume恢复</li><li>open打开/close关闭</li><li>initialize初始/finalize最后</li><li>request请求/respond响应</li><li>success成功/failed失败</li><li>top顶部/bottom底部</li><li>include包含/exclude排除</li><li>input 输入/  output 输出</li><li>import导入/export导出</li><li>width宽度/height高度</li><li>read读取/write写入</li><li>load载入/save保存</li><li>split 分割 /merge 合并</li><li>inject 注入 /extract 提取</li><li>attach 附着/  detach 脱离</li><li>view 查看/  browse 浏览</li><li>edit 编辑/  modify 修改</li><li>select 选取/  mark 标记</li><li>undo 撤销/  redo 重做</li><li>insert 插入/  delete 移除</li><li>index 索引/  sort 排序</li><li>play 播放/  pause 暂停</li><li>launch 启动/  run 运行</li><li>compile 编译/  execute 执行</li><li>build 构建/  publish 发布</li><li>pack 打包/  unpack 解包</li><li>send 发送/  receive 接收</li><li>refresh 刷新/  synchronize 同步</li><li>update 更新/  revert 复原</li><li>lock 锁定/  unlock 解锁</li><li>check out 签出/  check in 签入</li><li>push 推/  pull 拉</li><li>expand 展开/  collapse 折叠</li><li>begin 起始/  end 结束</li><li>start 开始/  finish 完成</li><li>enter 进入/  exit 退出</li></ul><h3 id="近义词"><a href="#近义词" class="headerlink" title="近义词"></a>近义词</h3><p>近义词如果使用不对，会造成理解上的偏差，如：</p><ul><li>invalidate 使无效 / refresh 刷新 / update 更新</li><li>draw 绘制 / render 渲染 / display 展示/show 显示</li><li>perform 执行 / process 处理 / do做 / run运行 / execute 实施 / invoke 调用</li><li>picture 图片 / image 图像 / bitmap 位图 / icon 图标 / thumbnail 缩略图</li><li>size 尺寸 / length 长度</li><li>refuse 拒绝 / decline 拒绝、下降 / reject 拒绝、否决</li><li>revoke 撤销 / cancel 取消</li><li>obsolete 废弃 /  depreciate 废旧 </li><li>collect 收集 / aggregate 聚集</li><li>abort 放弃 /  quit 离开</li><li>submit 提交 /  commit 交付</li><li>find 查找 /  search 搜索</li><li>observe 观察 /  listen 监听</li><li>debug 调试 /  trace 跟踪</li></ul><p>一个系统中最好不要出现各种同义词。</p><h3 id="前缀、扩展名"><a href="#前缀、扩展名" class="headerlink" title="前缀、扩展名"></a>前缀、扩展名</h3><ul><li><code>prev/curr/next</code> 表示顺序</li><li><code>on~</code>表示响应某个行为</li><li><code>is~</code>（表示“是”）/ <code>has~</code>（表示“有”）/<code>need~</code>（表示“需要”）/<code>can~</code>（表示“可以”）/<code>allow~</code>（表示“允许”）表示判定：注意这些词不应该用在域变量上，只能用在方法上。</li><li><code>do~</code>（表示执行某个操作）/<code>process~</code>/<code>run~</code>/<code>execute~</code>/<code>invoke~</code>/<code>perform~</code>都表示执行</li><li><code>~Wrapper</code>表示包装器：往往被包装的对象是成组的</li><li>设计模式名字作为结尾：<code>~State</code>表示状态模式、<code>~Proxy</code>表示代理模式</li><li><code>~Listener</code>表示事件接收器</li><li><code>get~</code>、<code>set~</code>表示获取和设置值：注意 boolean 类型的 getter 是用 <code>is~</code> 开头的</li><li><code>to~</code> 表示转换</li></ul><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>可以帮助缩短命名长度、但是滥用缩写会导致意思不明确。</p><ul><li>average -&gt; avg</li><li>administrator -&gt; admin</li><li>argument -&gt; arg</li><li>application -&gt; app</li><li>asynchronous -&gt; async(注意关键字)</li><li>address -&gt; add</li><li>bitmap -&gt; bmp</li><li>button -&gt; btn</li><li>calculate -&gt; calc</li><li>column -&gt; col</li><li>connection -&gt; conn</li><li>configuration -&gt; conf</li><li>command -&gt; cmd</li><li>control -&gt; ctl</li><li>copy -&gt; cpy</li><li>decrease -&gt; dec</li><li>delete -&gt; del</li><li>default -&gt; def</li><li>dictionary -&gt; dict</li><li>document -&gt; doc</li><li>environment -&gt; env</li><li>event -&gt; evt</li><li>error -&gt; err</li><li>execute -&gt; exec</li><li>horizontal -&gt; horz</li><li>information -&gt; info</li><li>message -&gt; msg</li><li>memory -&gt; mem</li><li>manager -&gt; mgr</li><li>maximum -&gt; max</li><li>minimum -&gt; min</li><li>table -&gt; tbl</li><li>version -&gt; ver</li><li>object -&gt; obj</li><li>picture -&gt; pic</li><li>position -&gt; pos</li><li>reference -&gt; ref</li><li>subtract -&gt; sub</li><li>synchronization -&gt; sync</li><li>temporary -&gt; temp</li><li>variable -&gt; var(注意关键字)</li><li>vertical -&gt; vert</li><li>initialize -&gt; init</li><li>temporary -&gt; temp/tmp</li><li>length -&gt; len</li><li>panel -&gt; pnl</li><li>frame -&gt; frm</li></ul><p>缩写如果全部都是大写字母，那么作为变量时也应该写为大小写混合。除了DO / BO / DTO / VO / AO / PO，如UserDO</p><h3 id="正确用词"><a href="#正确用词" class="headerlink" title="正确用词"></a>正确用词</h3><ul><li>拼写正确</li><li>正确用词：如hasPermission比isAllowed更易读，如<ul><li>花费的时间不是usedTime，而是elapsedTime</li><li>缩短不是makeShorter，而是shorten</li><li>加快不是fasten，而是accelerate</li><li>限制不是limit，而是constraint或restriction</li><li>成熟不是aged而是sophisticated</li><li>上下不是upDown而是vertical</li><li>错误级别不是faultLevel而是severity</li></ul></li><li>准确的用词：yyyyMMddhhmmss -&gt; timestamp</li><li>明确的用词：如fire可以表示点燃也可以表示开除</li><li>精确的用词：子啊列表当中会涉及各种顶点、节点、缝隙、元素之间的关系，需要有一套整体的命名规则，来为各个元素定义清楚其用词。</li></ul><h2 id="注释方面的改进"><a href="#注释方面的改进" class="headerlink" title="*注释方面的改进"></a>*注释方面的改进</h2><p>注释作为代码之外的说明性文字，应该尽量提供那些读者无法从代码里读出来的信息，描述代码为什么要这么做，而不是简单复述代码本身。若编程语言足够有表达力，就不需要注释。注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。</p><blockquote><p>注释总是一种失败，不准确的注释要比没注释坏得多。</p></blockquote><p>除了描述“为什么”的解释性注释外，还有一种注释：指引性注释，这种注释不直接复述代码，而是简明扼要地概括代码功能，起到“代码导读”的作用。</p><p>注释jsdoc/javadoc标签：</p><ul><li><code>@see</code>：表示参照代码，子类或实现类通过次连到声明类</li><li><code>@link</code>：表示连接，通过这个连接可以连到另外一个类的说明中去</li><li><code>@code</code>：表示应用一个值</li><li><code>@param</code>：表示参数</li><li><code>@return</code>：表示返回值</li><li><code>@throw</code>：表示方法抛出的异常</li><li><code>@author</code>：表示作者</li><li><code>@version</code>：表示版本</li><li><code>@since</code>：表示自哪个版本开始使用该方法</li><li><code>@example</code>：表示演示使用方式</li></ul><h3 id="TODO、FIXME和XXX"><a href="#TODO、FIXME和XXX" class="headerlink" title="TODO、FIXME和XXX"></a>TODO、FIXME和XXX</h3><ul><li>FIXME：表示这段代码没有正确处理，需要修改</li><li>TODO：表示这段代码尚未完成，需要实现</li><li>XXX：表示这段代码目前可以完成工作，但是还需要改进。</li><li>HACK：表示对一个问题不得不采用的比较粗糙的解决方案</li></ul><h3 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h3><ul><li>类的功能说明</li><li>类的主要方法介绍</li><li>类的方法常用调用方式</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>建议行尾不要加入注释，因为不利于行长的控制。</p><p>版权说明</p><ul><li>开放源代码：<a href="https://choosealicense.com/" target="_blank" rel="noopener">开源协议</a>通常有MIT、BSD、Apache2.0、GPL3.0、LGPL</li><li>封闭源代码：<a href="https://www.copyright.gov/what-is-copyright/" target="_blank" rel="noopener">Copyright</a>（C）</li></ul><p>换行</p><ul><li>Annotation之后要换行；</li><li>每行处理（分号）之后要换行；</li><li>每个花括号开头后面要换行；</li><li>每个花括号结尾后面要换行；</li><li>每行处理之后要换行；</li><li>不在同一行上声明超过两个变量；</li><li>每个变量、常量定义要换行。</li></ul><p>无效代码</p><ul><li>对于不再需要的代码，我们应该直接把它们删掉，而不是注释。</li></ul><p>空行</p><ul><li>适当地在代码中插入空行，把代码按不同的逻辑块分隔开，这样能有效提升代码的可读性。</li></ul><h2 id="测试代码的自表达改进"><a href="#测试代码的自表达改进" class="headerlink" title="测试代码的自表达改进"></a>测试代码的自表达改进</h2><p>自动测试的结构采用的都是三步结构：</p><ul><li>given 前提的数据</li><li>when 进行的操作</li><li>then 期望的结果</li><li>fixture 测试夹具前提的数据</li><li>behavior 行为进行的操作</li><li>expectation 期望值期望的结果</li></ul><h2 id="前端命名"><a href="#前端命名" class="headerlink" title="前端命名"></a>前端命名</h2><h3 id="html-文件的命名"><a href="#html-文件的命名" class="headerlink" title="html 文件的命名"></a>html 文件的命名</h3><p>格式：<strong>统一用小写的英文字母，</strong>单词间用连字符 “<code>-</code>”  连接，kebab-case (短横线分隔命名)</p><p>原则： </p><ul><li><p>可移植性。Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。</p></li><li><p>易读性。小写文件名通常比大写文件名更易读。</p></li><li><p>易用性：某些系统会生成一些预置的用户目录，采用首字母大写的目录名，用户的文件都采用小写文件名，就很方便与上面这些目录或文件相区分。</p></li><li><p>便捷性：文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用-i参数了。</p></li></ul><p>常用命名：</p><ul><li><p>首页/主页面：<code>index.html</code></p></li><li><p>子页面：</p><ul><li>首页：<code>home.html</code></li><li>我的：<code>mine.html</code></li><li>关于我们：<code>about.html</code></li><li>信息反馈：<code>feedback.html</code></li><li>产品：<code>produot.html</code></li><li>购物：<code>shop.html</code></li><li>计数器: <code>count.html</code></li><li>购买：<code>buy.html</code></li></ul></li><li><p>一级页面：</p><ul><li>登录：<code>login.html</code></li><li>注册：<code>resign.html</code></li></ul></li></ul><h3 id="Image图片的命名规则"><a href="#Image图片的命名规则" class="headerlink" title="Image图片的命名规则"></a>Image图片的命名规则</h3><ul><li>*可以考虑带上前缀：<code>i-</code>表示logo类图标、<code>p-</code>表示普通图片</li><li><p>图片的后缀：<code>xxx.png</code>、<code>xxx.jpg</code>、<code>xxx.gif</code>、<code>xxx.bmp</code>、<code>xxx.webp</code></p></li><li><p>图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质。例如：产品 <code>product</code>  产品下的  -&gt; 电视 / 手机：  <code>product_tv product_phone</code></p></li></ul><p>例如：广告、标志、菜单、按钮等等。</p><ul><li>放置在页面顶部的<strong>广告</strong>：<code>banner</code></li><li>企业商标/标志性的图：<code>logo</code></li><li>在页面上某个文字连续出现，性质相同的链接栏目图片： <code>menu</code></li><li>装饰用的照片： <code>pic</code></li><li>标题的图片：<code>title</code></li></ul><h3 id="文件夹命名-存放规则"><a href="#文件夹命名-存放规则" class="headerlink" title="文件夹命名/存放规则"></a>文件夹命名/存放规则</h3><ul><li><p>frontend、www  或者  web  存放前端代码文件</p></li><li><ul><li>bulid  存放构建等脚本文件</li><li>css  存放  xxx.css文件</li><li>src  存放源码文件</li><li>views 或者 pages  存放  xxx.html  或者  xxx.vue</li><li>components 存放组件文件</li><li>assets  存放所有[资源文件]</li></ul></li><li><ul><li><ul><li>images/imgs  存放图片文件</li><li>library/lib  存放[第三方库]文件</li><li>media  存放媒体文件</li></ul></li></ul></li><li><p>backend、serve  存放服务端代码文件</p></li><li><ul><li>api  存放[接口文件]</li><li>modules  存放[数据库操作]文件</li></ul></li></ul><h3 id="css-书写规范"><a href="#css-书写规范" class="headerlink" title="css 书写规范"></a>css 书写规范</h3><blockquote><p>可见MooCSS 命名规则：<a href="http://blog.michealwayne.cn/Moo-CSS/docs/nameRule/">http://blog.michealwayne.cn/Moo-CSS/docs/nameRule/</a></p></blockquote><ol><li>禁止 class 和 id 重名</li><li>书写顺序, 建议遵循 布局定位属性–&gt;自身属性–&gt;文本属性–&gt;其他属性</li></ol><ul><li><ul><li>布局定位属性 ：Margin\padding\float\clear\position （ 相 应 的top,right,bottom,left）\display\visibility\overflow 等</li><li>自身属性 ：Width\height\background\ border</li><li>文本属性 ：font\color\text-align\text-decoration\text-indent\ white-space\othertext\content 等</li><li>其他属性 ：list-style(列表样式)\vertical-align\cursor\z-index(层叠顺序)\zoom 等</li></ul></li></ul><h4 id="css-命名基本单词规范"><a href="#css-命名基本单词规范" class="headerlink" title="css 命名基本单词规范"></a>css 命名基本单词规范</h4><p>1.页面结构 </p><ul><li>容器：container/wrap </li><li>整体宽度：wrapper </li><li>页头：header </li><li>内容：content </li><li>侧栏：sidebar </li><li>栏目：column </li><li>中间内容：center</li></ul><p>2.导航 </p><ul><li>导航：nav </li><li>主导航：mainNav  main_nav</li><li>子导航：subNav        sub_nav </li><li>顶导航：topNav        top_nav </li><li>边导航：sideBar        side_bar </li><li>左导航：leftSideBar      left_side_bar </li><li>右导航：righSideBar      righ_side_bar </li><li>边导航图标：sidebarIcon    side_bar_icon </li><li>菜单：menu </li><li>子菜单：subMenu        sub_menu </li><li>标题：title</li></ul><p>3.功能 </p><ul><li>标志：logo </li><li>登陆：login </li><li>登录条：loginbar </li><li>注册：regsiter </li><li>产品：products </li><li>产品价格：products_prices </li><li>产品评论：products_review </li><li>编辑评论：editor_review </li><li>最新评论：news_release </li><li>广告/标语：banner </li><li>摘要:summary </li><li>生产商：publisher </li><li>缩略图：screenshot </li><li>常见问题：faqs </li><li>关键词：keyword </li><li>博客：blog </li><li>论坛：forum </li><li>搜索：search </li><li>搜索输入框：search_input </li><li>搜索输出：search_output </li><li>搜索结果：search_results </li><li>加入我们：joinus </li><li>状态：status </li><li>按钮：btn </li><li>滚动：scroll</li></ul><p>4.视图： view</p><p>5.滚动</p><ul><li>视图：scroll-view </li><li>标签页：tab </li><li>文章列表：list </li><li>提示信息：msg/message </li><li>当前的: current </li><li>小技巧：tips </li><li>皮肤：skin </li><li>充值：pay </li><li>活动：activities </li><li>推广：promotion </li><li>公告：announcement </li><li>排行：ranking </li><li>公司简介：company_profile </li><li>公司设备：equipment </li><li>公司荣誉：glories </li><li>企业文化：culture </li><li>企业规模：scale </li><li>营销网络：sales_network</li><li>组织机构：organization </li><li>技术力量：technology </li><li>分支机构：branches </li><li>经营理念：operation_principle </li><li>经理致辞：manager_oration </li><li>发展历程：development_history </li><li>工程案例：engineering_projects </li><li>分类浏览：browse_by_category </li><li>应用领域：application_fields </li><li>人力资源：human_resource_hr </li><li>领导致辞： leader_oration </li><li>客户留言：customer_message </li><li>客户服务：customer_service </li><li>您的要求：your_requirements </li><li>销售信息：sales_information </li><li>招商：enterprise_establishing </li><li>教育培训：education_training </li><li>合作加盟：joinIn_cooperation </li><li>产品描述：products_description </li><li>业务范围：business_scope </li><li>产品销售：sales_sales </li><li>联系我们：contact_us </li><li>信息发布：information </li><li>返回首页：homepage </li><li>产品定购：order </li><li>电子商务：e_business </li><li>版权所有：copy _right </li><li>友情连结：hot_link </li><li>行业新闻：trade_news </li><li>行业动态：trends </li><li>邮编：postal_code_zipcode </li><li>新闻动态：news_trends </li><li>公司名称：company_name </li><li>销售热线：sales_hotline </li><li>联系人：contact_person </li><li>建设中：in_construction </li><li>证书：certificate </li><li>地址：address </li><li>电话：tel </li><li>传真：fax </li><li>产品名称：product_name </li><li>产品说明：description </li><li>价格：price </li><li>品牌：brand </li><li>规格：specification </li><li>尺寸：size </li><li>生产厂家：manufacuturer </li><li>型号：model </li><li>产品标号：item_no </li><li>技术指标：technique_data </li><li>产品描述：description </li><li>产地：production_place </li><li>用途：application </li><li>论坛：forum </li><li>在线订购：on_line_order </li><li>招标：bidInviting </li><li>综述：general </li><li>业绩：achievements </li><li>大事：great_event </li><li>动态：trends </li><li>服务：service </li><li>投资：investment </li><li>行业：industry </li><li>规划：programming </li><li>环境：environment </li><li>发送：delivery </li><li>提交：submit </li><li>重写：reset </li><li>社区：community </li><li>业务：business </li><li>在线调查：online_inquiry </li><li>下载中心：download </li><li>意见反馈：feedback </li><li>常见问题：faq </li><li>中心概况：general_profile </li><li>游乐园：amusement_park </li><li>专题报道：special_report </li><li>图标: icon </li><li>注释：note </li><li>指南：guild </li><li>服务：service </li><li>热点：hot </li><li>新闻：news </li><li>下载：download </li><li>投票：vote </li><li>商标：label/branding </li><li>当前位置：breadcrumb/loc </li><li>购物车：shop </li><li>标签：tag </li><li>信誉：siteinfo_credits </li><li>网站信息：siteinfo </li><li>法律声明：siteinfo_legal </li><li>合作伙伴：partner </li><li>友情链接：friendlink </li><li>版权：copyright</li></ul><h2 id="class命名规范"><a href="#class命名规范" class="headerlink" title="class命名规范"></a>class命名规范</h2><p>分类式命名法（在前端组件优化下尤为重要）</p><ul><li>布局（grid）（<code>.g-</code>）:将页面分割为几大块，通常有头部，主体，主栏，侧栏，尾部等。</li><li>模块（module）（<code>.m-</code>）:通常是一个语义化可以重复使用的较大整体，比如导航，登录，注册等。</li><li>元件（unit）（<code>.u-</code>）:通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中，例如按钮，输入框。</li><li>功能（function）（<code>.f-</code>）:为了方便一些重用样式的使用，我们将这些使用频繁的样式剥离出来，按照需求使用，通常这些选择器具有固定样式表现，比如清除浮动等（不可滥用）。</li><li>状态（<code>.z-</code>）:为状态样式加入前缀，统一标识，方便识别，它只能组合使用或作为后代出现。</li><li>javascript（<code>.j-</code>）:j-被专用与JS获取节点，请勿使用j-定义样式。</li><li>class名称中只能出现小写字母和破折号”-“。破折号应当用于相关class的命名（类似于空间命名）例如: .btn和.btn-xxx。</li><li>避免过度任意的简写。例如: <code>.btn</code>代表 button，但是<code>.s</code>不能代表任何意思。</li><li>class名称应当尽可能短，并且意义明确。</li><li>使用有意义的名称，使用有组织或目的地明确的名称，不要使用表现形式的名称。</li><li>基于最近的父class或基本（base）class作为新class的前缀。例如：父class为.btn则子class为.btn-xxx。</li><li>使用j-*class来标识行为（与样式相对），并且不要将这些class包含到css文件中。</li></ul><h2 id="服务端nodejs-java命名规则"><a href="#服务端nodejs-java命名规则" class="headerlink" title="服务端nodejs/java命名规则"></a>服务端nodejs/java命名规则</h2><table><thead><tr><th>类型(名)</th><th>约束</th><th>例</th></tr></thead><tbody><tr><td>项目</td><td>全部小写 多个单词用中划线分隔‘-’</td><td>spring-cloud</td></tr><tr><td>包</td><td>全部小写</td><td>com.alibaba.fastjson</td></tr><tr><td>类</td><td>单词首字母大写</td><td>Feature, FieldDeserializer</td></tr><tr><td>变量</td><td>首字母小写 多个单词组成时， 除首个单词 其他单词首字母都要大写</td><td>password,  userName</td></tr><tr><td>常量</td><td>全部大写，多个单词，用’_’分隔</td><td>CACHEEXPIREDTIME</td></tr><tr><td>方法</td><td>同变量</td><td>read(),  getById(Long id)</td></tr></tbody></table><h3 id="包的命名"><a href="#包的命名" class="headerlink" title="*包的命名"></a>*包的命名</h3><p>格式：<code>组织类型+组织名称+项目名称+功能名称</code> / <code>【前缀】 【发起者名】【项目名】【模块名】</code>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块，包名中不要有大写字母和下划线，最好也不要有数字。</p><p>包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p><table><thead><tr><th>前缀</th><th>例</th><th>含义</th></tr></thead><tbody><tr><td>indi 或 onem</td><td>indi.发起者名.项目名.模块名.……</td><td>个体项目 个人发起，但非自己独自完成 可公开或私有项目， copyright主要属于发起者。</td></tr><tr><td>pers</td><td>pers.个人名.项目名.模块名.……</td><td>个人项目 指个人发起，独自完成， 可分享的项目 copyright主要属于个人</td></tr><tr><td>priv</td><td>priv.个人名.项目名.模块名.……</td><td>私有项目，指个人发起，独自完成 非公开的私人使用的项目， copyright属于个人。</td></tr><tr><td>team</td><td>team.团队名.项目名.模块名.……</td><td>团队项目，指由团队发起 并由该团队开发的项目 copyright属于该团队所有</td></tr><tr><td>顶级域名</td><td>com.公司名.项目名.模块名.……</td><td>公司项目 copyright由项目发起的公司所有</td></tr></tbody></table><h3 id="接口的名称"><a href="#接口的名称" class="headerlink" title="接口的名称"></a>接口的名称</h3><p>不要以<code>I</code>为开头。</p><p>如果以<code>~able</code>结尾表示具备某种能力，例如Cloneable和Runnable。</p><h3 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h3><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。</p><p>对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过通常认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准，如阿里巴巴中<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是组织统一就好。</p><p>不要以Base作为开头或者结尾，基类选用的词汇应该是具有通用意义的名称，例如Model、View、Control等。</p><p>子类的命名如果继承父类的名称则会好懂，例如SoftKeyboard extends AbstractKeyboard。</p><p>抽象类前面可以增加Abstract开头，这是当有一个Concrete类存在，而无法直接使用名称为抽象类命名时使用的。例如AbstractInputMethodService。</p><p>兄弟类之间要有明显的区别式赐予，如SoftKeyboard、HardKeyboard。</p><table><thead><tr><th>属性(类)</th><th>约束</th><th>例</th></tr></thead><tbody><tr><td>抽象</td><td>Abstract  或 Base 开头</td><td>BaseUserService</td></tr><tr><td>枚举</td><td>Enum 作为后缀</td><td>OSTypeEnum</td></tr><tr><td>工具</td><td>Utils作为后缀</td><td>StringUtils</td></tr><tr><td>异常</td><td>Exception结尾</td><td>RuntimeException</td></tr><tr><td>接口实现</td><td>接口名+ Impl</td><td>UserServiceImpl</td></tr><tr><td>领域模型相</td><td>/DO/DTO/VO/DAO</td><td>正例：UserDAO 反例：UserDao</td></tr><tr><td>设计模式相关</td><td>Builder，Factory等</td><td>当使用到设计模式时 要使用对应的设计模式作为后缀 如ThreadFactory</td></tr><tr><td>处理特定功能</td><td>Handler，Predicate Validator</td><td>表示处理器，校验器，断言 这些类工厂还有配套的方法名 如handle，predicate，validate</td></tr><tr><td>测试</td><td>Test后缀</td><td>UserServiceTest 表示用来测试UserService类的</td></tr><tr><td>MVC分层</td><td>Controller，Service ServiceImpl，DAO 后缀</td><td>UserManageController UserManageDAO</td></tr></tbody></table><h3 id="注解的命名（装饰器）"><a href="#注解的命名（装饰器）" class="headerlink" title="注解的命名（装饰器）"></a>注解的命名（装饰器）</h3><p>要考虑被使用时的样子</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，但并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p><ol><li>Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清楚，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。</li><li>Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</li><li>Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</li></ol><h4 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h4><p>注解大体上可以分为两种，一种是jsdoc/javadoc注解，另一种是简单注解。参与同一项目开发的同学，尽量设置成相同的注解模板。</p><h3 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h3><p>要考虑到声明和调用时的情形。</p><h3 id="方法的命名"><a href="#方法的命名" class="headerlink" title="方法的命名"></a>方法的命名</h3><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p><ul><li>动词+名词式命名的基本原则：要选择合适的动词，动词是方法的灵魂；其次要列明动作的对象，至于动作的修饰符（副词）或者对象的修饰语（定语），放到参数列表里就好了。</li><li>方法名称和返回值之间的关系：如果返回值有可能是个列表，那么方法所带有的名词最好就是复数形式；如果返回值是布尔型的，那么就要用is/can/need/has/contains等开头；如果返回值是确定类型的，那么该类型的名字有可能需要出现在方法名称里；如果返回值是个不确定类型的，那么Object或者父类名称是一个代替；如果是个Getter，那么get对象的名称就是其名词部分。</li><li>考虑被调用时的样子</li><li>“执行”动词的使用：doLogin意味着authenticate，doRegister意味着createUser，doEdit就是Save。</li><li>介词的使用：by、with、and、after等</li><li>其他：命名不要有下划线，不要有临时字符。</li></ul><h4 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h4><p>注：<code>pre-</code> prefix前缀，<code>suf-</code> suffix后缀，<code>alo-</code>alone 单独使用</p><table><thead><tr><th>位置</th><th>单词</th><th>意义</th></tr></thead><tbody><tr><td>pre</td><td>is</td><td>对象是否符合期待的状态</td></tr><tr><td>pre</td><td>can</td><td>对象<strong>能否执行</strong>所期待的动作</td></tr><tr><td>pre</td><td>should</td><td>调用方执行某个命令或方法是好还是不好、应不应该， 或者说推荐还是不推荐</td></tr><tr><td>pre</td><td>has</td><td>对象<strong>是否持有</strong>所期待的数据和属性</td></tr><tr><td>pre</td><td>needs</td><td>调用方<strong>是否需要</strong>执行某个命令或方法</td></tr></tbody></table><h4 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>ensure</td><td>检查是否为期待的状态不是则抛出异常或返回error code</td><td>ensureCapacity</td></tr><tr><td>validate</td><td>检查是否为正确的状态不是则抛出异常或返回error code</td><td>validateInputs</td></tr></tbody></table><h4 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>suf</td><td>IfNeeded</td><td>需要的时候执行不需要则什么都不做</td><td>drawIfNeeded</td></tr><tr><td>pre</td><td>might</td><td>同上</td><td>mightCreate</td></tr><tr><td>pre</td><td>try</td><td>尝试执行失败时抛出异常或是返回errorcode</td><td>tryCreate</td></tr><tr><td>suf</td><td>OrDefault</td><td>尝试执行失败时返回默认值</td><td>getOrDefault</td></tr><tr><td>suf</td><td>OrElse</td><td>尝试执行失败时返回实际参数中指定的值</td><td>getOrElse</td></tr><tr><td>pre</td><td>force</td><td>强制尝试执行error抛出异常或是返回值</td><td>forceCreate, forceStop</td></tr></tbody></table><h4 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>pre</td><td>blocking</td><td>线程阻塞方法</td><td>blockingGetUser</td></tr><tr><td>suf</td><td>InBackground</td><td>执行在后台线程</td><td>doInBackground</td></tr><tr><td>suf</td><td>Async</td><td>异步方法</td><td>sendAsync</td></tr><tr><td>suf</td><td>Sync</td><td>同步方法</td><td>sendSync</td></tr><tr><td>pre / alo</td><td>schedule</td><td>Job和Tas k放入队列</td><td>schedule,  scheduleJob</td></tr><tr><td>pre / alo</td><td>post</td><td>同上</td><td>postJob</td></tr><tr><td>pre / alo</td><td>execute</td><td>执行异步 或同步方法</td><td>execute, executeTask</td></tr><tr><td>pre / alo</td><td>start</td><td>同上</td><td>start, startJob</td></tr><tr><td>pre / alo</td><td>cancel</td><td>停止异步方法</td><td>cance, cancelJob</td></tr><tr><td>pre / alo</td><td>stop</td><td>同上</td><td>stop,stopJob</td></tr></tbody></table><h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>pre</td><td>on</td><td>事件发生时执行</td><td>onCompleted</td></tr><tr><td>pre</td><td>before</td><td>事件发生前执行</td><td>beforeUpdate</td></tr><tr><td>pre</td><td>pre</td><td>同上</td><td>preUpdate</td></tr><tr><td>pre</td><td>will</td><td>同上</td><td>willUpdate</td></tr><tr><td>pre</td><td>after</td><td>事件发生后执行</td><td>afterUpdate</td></tr><tr><td>pre</td><td>post</td><td>同上</td><td>postUpdate</td></tr><tr><td>pre</td><td>did</td><td>同上</td><td>didUpdate</td></tr><tr><td>pre</td><td>should</td><td>确认事件是否可以执行</td><td>shouldUpdate</td></tr></tbody></table><h4 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>initialize</td><td>初始化或延迟初始化使用</td><td>initialize</td></tr><tr><td>pause</td><td>暂停</td><td>onPause , pause</td></tr><tr><td>stop</td><td>停止</td><td>onStop, stop</td></tr><tr><td>abandon</td><td>销毁的替代</td><td>abandon</td></tr><tr><td>destroy</td><td>同上</td><td>destroy</td></tr><tr><td>dispose</td><td>同上</td><td>dispose</td></tr></tbody></table><h4 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>contains</td><td>是包含指定对象相同的对象</td><td>contains</td></tr><tr><td>add</td><td>添加</td><td>addJob</td></tr><tr><td>append</td><td>添加</td><td>appendJob</td></tr><tr><td>insert</td><td>插入到下标n</td><td>insertJob</td></tr><tr><td>put</td><td>添加与key对应的元素</td><td>putJob</td></tr><tr><td>remove</td><td>移除元素</td><td>removeJob</td></tr><tr><td>enqueue</td><td>添加到队列的最末位</td><td>enqueueJob</td></tr><tr><td>dequeue</td><td>从队列中头部取出并移除</td><td>dequeueJob</td></tr><tr><td>push</td><td>添加到栈头</td><td>pushJob</td></tr><tr><td>pop</td><td>从栈头取出并移除</td><td>popJob</td></tr><tr><td>peek</td><td>从栈头取出但不移除</td><td>peekJob</td></tr><tr><td>find</td><td>寻找符合条件的某物</td><td>findById</td></tr></tbody></table><h4 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>create</td><td>新创建</td><td>createAccount</td></tr><tr><td>new</td><td>新创建</td><td>newAccount</td></tr><tr><td>from</td><td>从既有的某物新建或是从其他的数据新建</td><td>fromConfig</td></tr><tr><td>to</td><td>转换</td><td>toString</td></tr><tr><td>update</td><td>更新既有某物</td><td>updateAccount</td></tr><tr><td>load</td><td>读取</td><td>loadAccount</td></tr><tr><td>fetch</td><td>远程读取</td><td>fetchAccount</td></tr><tr><td>delete</td><td>删除</td><td>deleteAccount</td></tr><tr><td>remove</td><td>删除</td><td>removeAccount</td></tr><tr><td>save</td><td>保存</td><td>saveAccount</td></tr><tr><td>store</td><td>保存</td><td>storeAccount</td></tr><tr><td>commit</td><td>保存</td><td>commitChange</td></tr><tr><td>apply</td><td>保存或应用</td><td>applyChange</td></tr><tr><td>clear</td><td>清除或是恢复到初始状态</td><td>clearAll</td></tr><tr><td>reset</td><td>清除或是恢复到初始状态</td><td>resetAll</td></tr></tbody></table><p>函数的第一规则是要短小，第二条规则是还要更短小</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>一个命名插件：</p><ul><li>在线：<a href="https://unbug.github.io/codelf/，不过不稳定，中文版用了有道翻译api有次数限制" target="_blank" rel="noopener">https://unbug.github.io/codelf/，不过不稳定，中文版用了有道翻译api有次数限制</a></li></ul><p><a href="https://github.com/unbug/codelf" target="_blank" rel="noopener">https://github.com/unbug/codelf</a></p><p><img src="https://user-images.githubusercontent.com/799578/51435509-a2595d00-1cb3-11e9-8f4e-85ecbc3a2325.png" alt="codeif"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li>《Python工匠》案例技巧与工程实践</li><li>《编写可读代码的艺术》</li><li>《会说话的代码》</li><li>《代码整洁之道》</li><li>《编程的原则》</li><li><a href="https://www.yuque.com/iv8gga/qgf69v/296ea151c0a1d5bd475f8b3c5ed1a0f4" target="_blank" rel="noopener">https://www.yuque.com/iv8gga/qgf69v/296ea151c0a1d5bd475f8b3c5ed1a0f4</a></li><li><a href="https://juejin.cn/post/6995342820512890893" target="_blank" rel="noopener">https://juejin.cn/post/6995342820512890893</a></li><li><a href="https://jimmysong.io/eng-practices/docs/review/reviewer/looking-for/#%E5%91%BD%E5%90%8D" target="_blank" rel="noopener">https://jimmysong.io/eng-practices/docs/review/reviewer/looking-for/#%E5%91%BD%E5%90%8D</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编码命名规范建议&quot;&gt;&lt;a href=&quot;#编码命名规范建议&quot; class=&quot;headerlink&quot; title=&quot;编码命名规范建议&quot;&gt;&lt;/a&gt;编码命名规范建议&lt;/h1&gt;&lt;h2 id=&quot;编程中命名习惯的改进&quot;&gt;&lt;a href=&quot;#编程中命名习惯的改进&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编码" scheme="http://blog.michealwayne.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《这样编码才规范 128个编码好习惯》</title>
    <link href="http://blog.michealwayne.cn/2022/05/08/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%BF%99%E6%A0%B7%E7%BC%96%E7%A0%81%E6%89%8D%E8%A7%84%E8%8C%83%20128%E4%B8%AA%E7%BC%96%E7%A0%81%E5%A5%BD%E4%B9%A0%E6%83%AF%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2022/05/08/notes/【笔记】《这样编码才规范 128个编码好习惯》/</id>
    <published>2022-05-08T12:41:10.000Z</published>
    <updated>2022-05-17T05:34:12.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《这样编码才规范-128个编码好习惯》"><a href="#《这样编码才规范-128个编码好习惯》" class="headerlink" title="《这样编码才规范 128个编码好习惯》"></a>《这样编码才规范 128个编码好习惯》</h1><p>此书从早好几年前开始阅读，一直断断续续至今才看完。整本书个人感觉总体一般（实际可用性不高），但帮助本人重新思考了一下当前代码规范或软件工程需要注意的点。<br>个人觉得前1～2章可读，从软件工程角度强调编码规范的注意事项，第3章开始是具体的格式、api规范，很多规范不适用于当前主流，也可以通过工具解决，比如格式化可以用prettier。</p><h2 id="1-基础知识概述"><a href="#1-基础知识概述" class="headerlink" title="1.基础知识概述"></a>1.基础知识概述</h2><h3 id="1-1-编码风格"><a href="#1-1-编码风格" class="headerlink" title="1.1 编码风格"></a>1.1 编码风格</h3><p>代码编写过程：</p><ul><li>1.认清问题</li><li>2.寻求解决问题的算法</li><li>3.用流程图或伪代码描述算法</li><li>4.用编程语言编写原始代码，此步骤也称为编码（coding）。编写代码的过程中需要处理以下几个部分，<ul><li>逻辑的表述方式</li><li>算法的表述方式</li><li>声明语句（statement）的布局方式</li><li>表达式（expression）的表述方式</li></ul></li><li>5.编译源代码并生成目标代码</li><li>6.进行单元测试并修正错误</li></ul><blockquote><p>编码和编程的含义几乎相同，但编程是指开发应用程序的逻辑层面的工作，编码可以理解为根据程序的逻辑、用特定的编程语言编写代码的工作。</p></blockquote><p>其中编码过程中，程序员之间有约定速成的处理方法，统称为编码风格或编码方式。简言之，编写原始代码的过程=编码风格。</p><h3 id="1-2-编码风格教育缺失"><a href="#1-2-编码风格教育缺失" class="headerlink" title="1.2 编码风格教育缺失"></a>1.2 编码风格教育缺失</h3><p>代码错误</p><ul><li>逻辑错误：存在逻辑方面的漏洞，特殊情况下会导致程序运行异常</li><li>运算错误：特别是实数型运算时出现的误差不断积累，形成蝴蝶效应，造成运算上的严重误差</li><li>调用错误：库提供的函数可能存在函数编写者也没有意识到的问题，导致调用此类函数的程序无法运行</li><li>漏洞错误：函数调用、类的继承、组件之间的漏洞导致参数和返回的数据类型或数据值无法匹配</li><li>环境错误：如果子啊不同于编写程序时假定的运行环境下运行，会出现意外的效果</li><li>输入错误：输入程序员没有预料到的特殊值，导致运算结果出错</li><li>运行错误：没有按照程序指定的顺序运行。如果是控制发电站等大规模工程的程序，则会导致严重问题</li></ul><p>出现这些问题的原因多种多样，但最重要的是，开发人员没有经过充分训练，而且开发过程中没有遵循良好的编码习惯。</p><h3 id="1-3-打磨编码风格的时机"><a href="#1-3-打磨编码风格的时机" class="headerlink" title="1.3 打磨编码风格的时机"></a>1.3 打磨编码风格的时机</h3><p>趁早。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大学生 &gt; 码农 &gt; 初级程序员 &gt; 高级程序员 &gt; 首席程序员 &gt; 系统架构师 &gt; 系统分析师 &gt; 项目经理</span><br></pre></td></tr></table></figure><p><img src="/images/code128/p-01.jpg" alt="p-01.jpg"></p><h3 id="1-4-必须学习编码风格的原因"><a href="#1-4-必须学习编码风格的原因" class="headerlink" title="1.4 必须学习编码风格的原因"></a>1.4 必须学习编码风格的原因</h3><ul><li>1.为了缩短开发时间</li><li>2.为了便于维护</li><li>3.为了编写零漏洞的完美程序</li></ul><blockquote><p>所有软件研发项目中，开发成本占总成本的比例仅为20%，而维护成本占比高67%。        ——《人月神话》</p></blockquote><p><img src="/images/code128/p-02.jpg" alt="p-02.jpg"></p><p>维护工作主要由<strong>完善现有程序、修改错误等组成</strong>，即使开发新功能，通常也可以通过对现有程序进行变形而实现。因此只要现有程序是在严格遵守编码风格规则的基础上编写的，就可以大幅降低维护成本，进而提升开发公司的收益。</p><p><img src="/images/code128/p-03.jpg" alt="p-03.jpg"></p><h3 id="1-5-编码风格比数学或英语更重要"><a href="#1-5-编码风格比数学或英语更重要" class="headerlink" title="1.5 编码风格比数学或英语更重要"></a>1.5 编码风格比数学或英语更重要</h3><p>程序进行对话。</p><p><img src="/images/code128/p-04.jpg" alt="p-04.jpg"></p><h3 id="1-6-所有编程语言都需要编码风格"><a href="#1-6-所有编程语言都需要编码风格" class="headerlink" title="1.6 所有编程语言都需要编码风格"></a>1.6 所有编程语言都需要编码风格</h3><p>编程语言出现的时间不同，使用范围也各不相同，但适用于各自的编码风格规范却大同小异，因为所有编程语言都是将字符书写成语句的形态。<br>编码风格不受编程领域影响，编码风格适用于所有编程语言和业务领域。</p><h3 id="1-7-选择用C语言阐述编程风格的原因"><a href="#1-7-选择用C语言阐述编程风格的原因" class="headerlink" title="1.7 选择用C语言阐述编程风格的原因"></a>1.7 选择用C语言阐述编程风格的原因</h3><p>它得到了大范围的应用、可用于研究的源代码易于查找、它是各种语言的原型，可以最大程度保证程序员的自由。</p><p><img src="/images/code128/p-05.jpg" alt="p-05.jpg"></p><ul><li>C语言中可能出现的问题：</li></ul><ul><li>1.除数为0会出现问题；</li><li>2.使用空指针会出现问题；</li><li>3.可再次访问已释放的动态分配内存；</li><li>4.字符串末尾必须添加空字符；</li><li>5.向超出数组范围的数组元素赋值会出现问题；</li><li>6.数据类型不同的变量间可以进行运算；</li><li>7.数据类型不同的指针访问内存会产生意想不到的结果；</li><li>8.终止条件不明确导致无法检查递归函数；</li><li>9.无法检查地址及其运算；</li><li>10.使用指针变量前必须初始化。</li></ul><p>C语言极有可能引发问题，所以更适合阐述编码风格。</p><h3 id="1-8-编码风格有益于编译执行方式和混合执行方式"><a href="#1-8-编码风格有益于编译执行方式和混合执行方式" class="headerlink" title="1.8 编码风格有益于编译执行方式和混合执行方式"></a>1.8 编码风格有益于编译执行方式和混合执行方式</h3><p>解释执行，如web;</p><p>混合执行方式是指，编译后生成的不是机器语言而是中间语言，其他部分与编译执行方式无异。</p><h3 id="1-9-基于组件的软件开发方式与编码风格"><a href="#1-9-基于组件的软件开发方式与编码风格" class="headerlink" title="1.9 基于组件的软件开发方式与编码风格"></a>1.9 基于组件的软件开发方式与编码风格</h3><p>基于组件的开发方式CBD（Component Based Development），这种方式采用面向对象的技术编写代码单元，每个代码单元就是组件，再将这些组件组装起来形成软件。</p><p>基于组件的开发方式能够提高效率，微软提出了包含组件设计原则（Principles of Component Design）在内的微软解决方案框架MSF（Microsoft Solutions Framework）</p><p><img src="/images/code128/p-06.jpg" alt="p-06.jpg"></p><p>CBD的核心概念是将程序单元视为组件。</p><h3 id="1-10-码农的力量不容小觑"><a href="#1-10-码农的力量不容小觑" class="headerlink" title="1.10 码农的力量不容小觑"></a>1.10 码农的力量不容小觑</h3><p>码农负责编写整个系统中最基础的部分——代码，虽然与软件开发业务中的架构师工作相比，码农的工作或许看起来微不足道，但它实际占据着决定软件质量的核心地位。因此码农的作用不容忽视，码农编写的代码决定着整个系统的质量。</p><p>软件开发的核心应该是“代码！代码！代码”，只有代码质量达到了一定标准，软件质量才能令人满意。而保证代码质量的不是别人，正是程序员和码农。</p><h3 id="1-11-将编码惯例文档化以统一应用"><a href="#1-11-将编码惯例文档化以统一应用" class="headerlink" title="1.11 将编码惯例文档化以统一应用"></a>1.11 将编码惯例文档化以统一应用</h3><p>写代码和写文章之间有着千丝万缕的联系。写文章的人常常需要参考其他书目，比如讲些语法规则或者经典词句，这些类似于编程中的编码惯例。编程过程虽然没有全球统一的规则，但无论是编程语言创始人或大师们提出的管理，还是业内约定俗成的管理，都可以视为统一规则。</p><p>程序员也应该经常参考编程惯例，参考全球普遍认可的编码惯例。编程惯例就像一种惯用语句，如果不能与对方的语言和习惯形成共鸣，就很难理解其语言或代码，双方沟通会受到影响。</p><p>各公司应该收集各种编码惯例，从中选择与自身情况匹配的内容，并要求内部开发人员统一采纳。</p><hr><h2 id="2-程序设计相关-编码准则"><a href="#2-程序设计相关-编码准则" class="headerlink" title="2.程序设计相关 编码准则"></a>2.程序设计相关 编码准则</h2><h3 id="2-1-遵循最新标准"><a href="#2-1-遵循最新标准" class="headerlink" title="2.1 遵循最新标准"></a>2.1 遵循最新标准</h3><p>行业标准日趋多样和精确。</p><h3 id="2-2-合理限制开发人员的规模"><a href="#2-2-合理限制开发人员的规模" class="headerlink" title="2.2 合理限制开发人员的规模"></a>2.2 合理限制开发人员的规模</h3><blockquote><p>并不是投入的开发人员越多，生产效率就越高。    ——《人月神话》</p></blockquote><p>每个项目都应该适当限制开发人员数量，项目投入再多人力，也并不一定能显著提高生产效率。问题就在于<strong>沟通渠道</strong>（<code>n * (n - 1) / 2</code>）。</p><p>沟通的实现程度称为“沟通强度”，也有人称为“团队精神”。公司规模越小，沟通渠道越少，沟通强度反而越高。</p><p>大公司参与开发的人员较多，一般采用正式的方式进行沟通，强调采用规范化的文书、规范化的方式和渠道，从而减慢了沟通的速度。因此虽然沟通渠道变多了但沟通强度反而变弱、导致整体沟通效率降低。</p><p>从“管理的极限”看，7人左右比较合适。</p><h3 id="2-3-维护旧程序比开发新程序更常见"><a href="#2-3-维护旧程序比开发新程序更常见" class="headerlink" title="2.3 维护旧程序比开发新程序更常见"></a>2.3 维护旧程序比开发新程序更常见</h3><p>与编写程序的耗时相比，维护程序的耗时呈现逐渐增多的趋势，且这种趋势正在日渐加快。从这一层面看，程序员的工作既包含创新性业务，又包含功能型业务。其中，修改现有程序并对其进行维护的功能性工作较多。</p><p>制定编码风格需要坚持以“标注便于理解的注释，编写清晰简明的代码”为原则，明确规定各方面的详细规则。程序员则要遵循给定的编码规则，不断努力编写像小说或随笔一样具有较高可读性的代码，这也将有助于讲话后续对程序的修复、更新等维护工作。</p><h3 id="2-4-不要认为修改程序很容易"><a href="#2-4-不要认为修改程序很容易" class="headerlink" title="2.4 不要认为修改程序很容易"></a>2.4 不要认为修改程序很容易</h3><p>实际上，重新编写程序确实比修改原有程序更快。</p><p>要限制需求变更。</p><h3 id="2-5-慎重采用新技术"><a href="#2-5-慎重采用新技术" class="headerlink" title="2.5 慎重采用新技术"></a>2.5 慎重采用新技术</h3><p>类似用惯了斧子伐木的人突然改用电锯，可能出现故障、误伤、效率下降等问题。当前，经过一段时间的磨合，掌握正确的电锯使用方法后，用电锯伐木的效率会明显高于用斧子的情况。</p><p>我们应当对不熟悉的事物保持敬畏之心。采用新技术时，不要忘记为学习新技术预留时间，如果项目工期紧需要在掌握新技术之前🔚，则应该果断放弃新技术直接采用熟悉的技术。</p><p>新方法得到广泛认可并能稳定应用之前，采用相对不浪费时间的技术才是比较正确的做法。编码风格宣扬的既不是激进主义也不是保守主义，而是改良主义。它主张在正常我们熟悉的语言的同时，对其稍加改进。长沙应用各种新的程序开发方法、编程语言、CASE（计算机辅助软件工程）工具前，应该优先考虑制定规范的编码风格，之后再投入使用并严格遵循。</p><h3 id="2-6-不要采用RAF策略"><a href="#2-6-不要采用RAF策略" class="headerlink" title="2.6 不要采用RAF策略"></a>2.6 不要采用RAF策略</h3><p><img src="/images/code128/p-07.jpg" alt="p-07.jpg"></p><p>RAF策略：Run and Fix，“先查看运行结果再修改程序”的工作方式。</p><p>欲速则不达。但仍然有很多程序员盲目相信压缩工期的魔力，认为快速完成任务才是第一要务。</p><p>程序是基于看不见的抽象逻辑编写的，而仅凭逻辑很难预测结果。</p><p>即使是小规模程序单元，RAF策略也会严重影响生产效率。</p><p>正确的做法：</p><ul><li>1.增加在程序构思阶段投入的时间；</li><li>2.采用流程图和伪代码，充分梳理程序逻辑；</li><li>3.在纸上投入的时间要多于在电脑上投入的时间；</li><li>4.事先预测程序可能出现的问题，并寻找解决方法；</li><li>5.深思熟虑后再编写代码。</li></ul><hr><h2 id="3-间隔相关编码准则"><a href="#3-间隔相关编码准则" class="headerlink" title="3.间隔相关编码准则"></a>3.间隔相关编码准则</h2><h3 id="3-1-一行只写一条语句"><a href="#3-1-一行只写一条语句" class="headerlink" title="3.1 一行只写一条语句"></a>3.1 一行只写一条语句</h3><p>可读性。（Js-prettier可以处理）</p><p>其中的“行”是在编辑器上显示的行，而不是一条执行语句。</p><p>（Js-prettier可以处理）</p><h3 id="3-2-区分声明语句和执行语句"><a href="#3-2-区分声明语句和执行语句" class="headerlink" title="3.2 区分声明语句和执行语句"></a>3.2 区分声明语句和执行语句</h3><p>可读性。</p><p>用空行区分声明语句和执行语句。不过注意插入太多空行同样会影响可读性。</p><h3 id="3-3-区分段落"><a href="#3-3-区分段落" class="headerlink" title="3.3 区分段落"></a>3.3 区分段落</h3><p>可读性。</p><p>执行语句之间也需要互相明确区分，当然，声明语句之间最好也能够明确区分。</p><p>编写程序时，无论是声明语句还是执行语句，都应该注意将相似的部分集中在一起，并在其前后插入空行，以便区分于其他语句。根据各语句负责的功能，将其划分为不同段落，这样有助于提高程序可读性，同时添加各段落主要功能的注释语句，更会起到锦上添花的作用。</p><h3 id="3-4-区分各种控制语句"><a href="#3-4-区分各种控制语句" class="headerlink" title="3.4 区分各种控制语句"></a>3.4 区分各种控制语句</h3><p>可读性。</p><p>表达统一思想的段落内部也应该插入空行，以划分更细的层次。最常见的情况是针对控制语句，如果某人没能正确理解程序中的控制语句，那么他极有可能误解整个程序的功能。</p><p>即使在段落内部，也应该在控制语句前后插入空行，以便快速识别。</p><p><img src="/images/code128/p-08.jpg" alt="p-08.jpg"></p><p>switch 语句适用的段落划分准则：</p><ul><li>1.switch语句开始部分单独占据一行；</li><li>2.以空行区分各case语句；</li><li>3.像case语句一样，用空行隔开default语句，以示区分。</li></ul><p>插入空行的方法有助于明确区分if、else、while、switch语句个字的控制范围。</p><h3 id="3-5-区分各函数"><a href="#3-5-区分各函数" class="headerlink" title="3.5 区分各函数"></a>3.5 区分各函数</h3><p>可读性。</p><p>函数之间无空行的缺点：</p><ul><li>难以掌握函数的起始位置和结束位置；</li><li>难以了解程序由几个函数组成；</li><li>难以定位某个特定函数。</li></ul><p>需要在各函数之间插入足够多的空行（可以考虑多行，保证间距够大）。</p><h3 id="3-6-运算符前后留出空格"><a href="#3-6-运算符前后留出空格" class="headerlink" title="3.6 运算符前后留出空格"></a>3.6 运算符前后留出空格</h3><p>可读性。（Js-prettier可以处理）</p><p>在运算符前后各插入一个空格，使前后部分更加明确；分号后插入更多空格，可以使条件表达式、判断表达式、增减表达式更易区分。</p><p>不同情况下，适当插入一个或多个空格，可以使一条语句中连续使用的多个表达式层次更清晰。</p><h3 id="3-7-不要在一元运算符与操作数之间插入空格"><a href="#3-7-不要在一元运算符与操作数之间插入空格" class="headerlink" title="3.7 不要在一元运算符与操作数之间插入空格"></a>3.7 不要在一元运算符与操作数之间插入空格</h3><p>可读性。（Js-prettier可以处理）</p><p><code>++</code>、<code>--</code>这种只需要一个操作数的运算符称为一元运算符。</p><h3 id="3-8-分号前不要插入空格"><a href="#3-8-分号前不要插入空格" class="headerlink" title="3.8 分号前不要插入空格"></a>3.8 分号前不要插入空格</h3><p>可读性。</p><h3 id="3-9-不要滥用Tab键"><a href="#3-9-不要滥用Tab键" class="headerlink" title="3.9 不要滥用Tab键"></a>3.9 不要滥用Tab键</h3><p>可读性。（Js-prettier可以处理）</p><h3 id="3-10-逗号后必须插入一个空格"><a href="#3-10-逗号后必须插入一个空格" class="headerlink" title="3.10 逗号后必须插入一个空格"></a>3.10 逗号后必须插入一个空格</h3><p>可读性。（Js-prettier可以处理）</p><p>以更好地区分各参数。</p><h3 id="3-11-逗号后不要插入太多空格"><a href="#3-11-逗号后不要插入太多空格" class="headerlink" title="3.11 逗号后不要插入太多空格"></a>3.11 逗号后不要插入太多空格</h3><p>可读性。（Js-prettier可以处理）</p><p>一般1～2，基本1个够用。</p><h3 id="3-12-变量初始化时的列对齐"><a href="#3-12-变量初始化时的列对齐" class="headerlink" title="3.12 变量初始化时的列对齐"></a>3.12 变量初始化时的列对齐</h3><p>可读性。（Js-prettier可以处理）</p><p>根据变量的用途，利用空行进行区分；还可以使用tab键，对齐各变量初始值所在列，但它可能会损害可读性，如：</p><p><img src="/images/code128/p-09.jpg" alt="p-09.jpg"></p><p>应该在合适的范围内，即不能插入过多空格的前提下，对齐初始化值所在列。</p><p><img src="/images/code128/p-10.jpg" alt="p-10.jpg"></p><p>通过空格的多少控制不同含义的变量初始值在不同位置对齐。</p><h3 id="3-13-一行只声明一个变量"><a href="#3-13-一行只声明一个变量" class="headerlink" title="3.13 一行只声明一个变量"></a>3.13 一行只声明一个变量</h3><p>可读性。</p><hr><h2 id="4-编写缩进相关编码准则"><a href="#4-编写缩进相关编码准则" class="headerlink" title="4.编写缩进相关编码准则"></a>4.编写缩进相关编码准则</h2><h3 id="4-1-大括号的位置"><a href="#4-1-大括号的位置" class="headerlink" title="4.1 大括号的位置"></a>4.1 大括号的位置</h3><p>可读性。（Js-prettier可以处理）</p><p>第一种风格是，大括号始终与语句位于同一行。</p><p>第二种风格是，大括号和语句分占不同行。</p><p>第三种风格是，左边大括号与语句在同一行，右边大括号另起一行。<br></p><h3 id="4-2-统一大括号的位置"><a href="#4-2-统一大括号的位置" class="headerlink" title="4.2 统一大括号的位置"></a>4.2 统一大括号的位置</h3><p>可读性。（Js-prettier可以处理）</p><p>如果大括号不缩进，则很容易掌握函数结束的位置。</p><h3 id="4-3-内部代码块需要缩进"><a href="#4-3-内部代码块需要缩进" class="headerlink" title="4.3 内部代码块需要缩进"></a>4.3 内部代码块需要缩进</h3><p>可读性。（Js-prettier可以处理）</p><h3 id="4-4-输出部分需要缩进"><a href="#4-4-输出部分需要缩进" class="headerlink" title="4.4 输出部分需要缩进"></a>4.4 输出部分需要缩进</h3><p>可读性。（Js-prettier可以处理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xx)</span><br><span class="line">  <span class="built_in">console</span>.log(xxx);</span><br></pre></td></tr></table></figure><p>程序员选择不缩进的理由：</p><ul><li>全部精力集中于项目本身，对缩进并不关注；</li><li>改写代码并将原始代码文件移植到其他系统平台的过程中，缩进不知不觉地消失了；</li></ul><p>需要检查缩进的时间点：</p><ul><li>程序完结之前；</li><li>与他人进行程序交接之前；</li><li>文件改写完成之后。</li></ul><h3 id="4-5-不要毫无意义地缩进"><a href="#4-5-不要毫无意义地缩进" class="headerlink" title="4.5 不要毫无意义地缩进"></a>4.5 不要毫无意义地缩进</h3><p>可读性。（Js-prettier可以处理）</p><p>不要用毫无意义的缩进，如果只想表示强调，那么顽强可以用添加注释等方式代替缩进。</p><h3 id="4-6-保持缩进程度的一致性"><a href="#4-6-保持缩进程度的一致性" class="headerlink" title="4.6 保持缩进程度的一致性"></a>4.6 保持缩进程度的一致性</h3><p>可读性。（Js-prettier可以处理）</p><p>缩进程度与嵌套程度并不相关，嵌套较深需要注释进行说明和区分。</p><h3 id="4-7-选择合适的缩进程度"><a href="#4-7-选择合适的缩进程度" class="headerlink" title="4.7 选择合适的缩进程度"></a>4.7 选择合适的缩进程度</h3><p>可读性。（Js-prettier可以处理）</p><p>4/2都可以，但不能过浅或过深。</p><h3 id="4-8-不要缩写凸出形式的代码"><a href="#4-8-不要缩写凸出形式的代码" class="headerlink" title="4.8 不要缩写凸出形式的代码"></a>4.8 不要缩写凸出形式的代码</h3><p>可读性。（Js-prettier可以处理）</p><p>凸出形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  <span class="comment">// 此行突出</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>凸出书写的代码和在稿纸边缘以外写字是一样的。</p><hr><h2 id="5-注释相关编码准则"><a href="#5-注释相关编码准则" class="headerlink" title="5.注释相关编码准则"></a>5.注释相关编码准则</h2><h3 id="5-1-多种注释形态"><a href="#5-1-多种注释形态" class="headerlink" title="5.1 多种注释形态"></a>5.1 多种注释形态</h3><p>可读性。</p><p>程序专用编辑器不能实现黑体、加粗等样式效果，因此程序员设计了多种注释形态，以实现各类装饰效果</p><h4 id="5-1-1-不包含强调内容的单行注释"><a href="#5-1-1-不包含强调内容的单行注释" class="headerlink" title="5.1.1 不包含强调内容的单行注释"></a>5.1.1 不包含强调内容的单行注释</h4><p>最常见，没有需要特别强调的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单行注释常用于注释程序主体代码 */</span></span><br></pre></td></tr></table></figure><h4 id="5-1-2-包含强调内容的单行注释"><a href="#5-1-2-包含强调内容的单行注释" class="headerlink" title="5.1.2 包含强调内容的单行注释"></a>5.1.2 包含强调内容的单行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--&gt; 注意：需要处理错误信息 &lt;--*/</span></span><br></pre></td></tr></table></figure><p>或：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&gt;&gt;&gt;&gt;&gt;&gt;&gt; 精密计算例程 &lt;&lt;&lt;&lt;&lt;&lt;&lt;*/</span></span><br></pre></td></tr></table></figure></p><p>如何装饰单行注释取决于程序员的个人喜好，无论使用何种特殊字符，只要它能够吸引眼球，并能明确标识注释的起止点即可。</p><h4 id="5-1-3-不包含强调内容的多行注释"><a href="#5-1-3-不包含强调内容的多行注释" class="headerlink" title="5.1.3 不包含强调内容的多行注释"></a>5.1.3 不包含强调内容的多行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编写包含多行语句的注释</span></span><br><span class="line"><span class="comment">* 没有需要特别强调的内容，但需要用较长的句子进行更准确的说明时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以插入特殊字符区分注释内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编写包含多行语句的注释</span></span><br><span class="line"><span class="comment">* ----------------------------</span></span><br><span class="line"><span class="comment">* input1: 。。。</span></span><br><span class="line"><span class="comment">* input2: 。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-包含强调内容的多行注释"><a href="#5-1-4-包含强调内容的多行注释" class="headerlink" title="5.1.4 包含强调内容的多行注释"></a>5.1.4 包含强调内容的多行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* !!!!!!!!!!! 警告（Warning） !!!!!!!!!! */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* 需要特别注意这段程序，，，，，，，，，       */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br></pre></td></tr></table></figure><p>注释最重要的用途是引起程序员的注意，不要纠结于外观。</p><h4 id="5-2-区分单行注释和注释框"><a href="#5-2-区分单行注释和注释框" class="headerlink" title="5.2 区分单行注释和注释框"></a>5.2 区分单行注释和注释框</h4><p>可读性。</p><p>注释形式可大致分为：</p><ul><li>单行注释</li><li>非单行注释（多行注释）</li></ul><p>需要说明程序或函数时，应该采用多行注释。多行注释又称“注释框”或“块注释”。<br>注释框包含程序名、目标、编写者、修改者、编写日期和修改日期等众多信息，方便人们理解程序。除此之外程序员还可以增加任意信息。注释框相当于程序的参考文献，对于大规模项目尤为重要。</p><p>程序主体语句中不要使用注释框。任何人都能理解的内容，或代码中明确出现的内容都没有必要添加注释，更没有必要进行详细说明。如果实在想添加，那么单行注释足矣，而且此单行注释主要标注程序代码本身没有体现的信息。</p><h3 id="5-3-添加“变量字典编写专用注释”"><a href="#5-3-添加“变量字典编写专用注释”" class="headerlink" title="5.3 添加“变量字典编写专用注释”"></a>5.3 添加“变量字典编写专用注释”</h3><p>可读性。</p><p>但声明变量未必能让人理解变量具体信息，如单位。这时候可以在变量旁添加详细注释，这种方法称为“变量字典编写专用注释”，简称“字典注释”（diction comment）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> area;    <span class="comment">// 面积：计算正在施工中的建筑物的地基面积。 </span></span><br><span class="line"><span class="keyword">let</span> wide;    <span class="comment">// 宽度：以米为单位，计算地基横向长度。</span></span><br><span class="line"><span class="keyword">let</span> height;  <span class="comment">// 高度：以米为单位，计算地基纵向长度。</span></span><br></pre></td></tr></table></figure><p>字典注释不仅能够在程序内部描述各变量作用，还可以将各模块中变量声明的部分复制并保存到同一个文件，该文件即可视为能够说明所有变量的字典。这种字典在检查程序时非常重要，还可以避免变量命名冲突。</p><h3 id="5-4-向程序插入伪代码"><a href="#5-4-向程序插入伪代码" class="headerlink" title="5.4 向程序插入伪代码"></a>5.4 向程序插入伪代码</h3><p>可读性。</p><p>注释的存在是为了使程序便于理解，即为了使包含程序编写者在内的所有人都能轻松理解程序的“目标和逻辑”。程序的“目标和逻辑”中，“逻辑”可以用伪代码补充。在程序起始部分用注释形式标注伪代码后，程序的整体脉络旧一目了然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 计算两个数字变量num1、num2的最大值</span></span><br><span class="line"><span class="comment"> [该程序伪代码]  </span></span><br><span class="line"><span class="comment"> 如果 num1 大于 num2</span></span><br><span class="line"><span class="comment">   则num1是最大值</span></span><br><span class="line"><span class="comment">   返回num1</span></span><br><span class="line"><span class="comment"> 否则</span></span><br><span class="line"><span class="comment">   返回num2</span></span><br><span class="line"><span class="comment"> [伪代码结束]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>伪代码对于快速把握程序非常有效。</p><h3 id="5-5-通过注释标注程序目标"><a href="#5-5-通过注释标注程序目标" class="headerlink" title="5.5 通过注释标注程序目标"></a>5.5 通过注释标注程序目标</h3><p>可读性。</p><p>添加伪代码可以使程序逻辑一目了然。但有时候伪代码也并不短。这时候可以将程序的“目标”以注释的形式标注于程序最开始的部分：</p><p>/**</p><h2 id="编写目标：计算两个数字变量num1、num2的最大值"><a href="#编写目标：计算两个数字变量num1、num2的最大值" class="headerlink" title=" 编写目标：计算两个数字变量num1、num2的最大值"></a> 编写目标：计算两个数字变量num1、num2的最大值</h2><p> [该程序伪代码]<br> 如果 num1 大于 num2<br>   则num1是最大值<br>   返回num1<br> 否则<br>   返回num2<br> [伪代码结束]<br> */</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">伪代码的主要作用是体现程序的“逻辑”，而不能完全展现“目标”。如果程序本身没有明确标注目标，那么人们阅读该程序时就不得不根据伪代码进行推测。</span><br><span class="line"></span><br><span class="line">标注程序目标时，应该遵守“六何原则”：</span><br><span class="line"></span><br><span class="line">``` js</span><br><span class="line">/* 何时（when）  编写日期：2022年5月16日 */</span><br><span class="line">/* 何地（where） 场   所：XX事业部XX组 */</span><br><span class="line">/* 何人（who）   编写 者：XXX */</span><br><span class="line">/* 何事（what）  代码性质：c语言代码，约200行 */</span><br><span class="line">/* 为何（why）   编写理由：最大值最小值求值 */</span><br><span class="line">/* 如何（how）   编写环境：控制台 */</span><br></pre></td></tr></table></figure><p>我们应该在程序起始部分用注释形式添加伪代码和程序目标。</p><h3 id="5-6-程序起始部分必须添加头注释"><a href="#5-6-程序起始部分必须添加头注释" class="headerlink" title="5.6 程序起始部分必须添加头注释"></a>5.6 程序起始部分必须添加头注释</h3><p>可读性。</p><p>注释可以分为“主体注释”和“头注释”两类，主体注释位于程序代码之间，用于说明对应部分的作用；头注释位于程序起始部分，用于指出程序的题目、作者、目标等。<br>头注释相当于名片，我们通过头注释可以首先对程序有整体的认知，再基于主体注释对其进行更细致的了解。</p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件名：demo.ts</span></span><br><span class="line"><span class="comment">* 出处：blog.michealwayne.cn</span></span><br><span class="line"><span class="comment">* 编写者：MichealWayne</span></span><br><span class="line"><span class="comment">* 目标：读取用户登录记录，xxx。。。</span></span><br><span class="line"><span class="comment">* 提供方式：构建后的js</span></span><br><span class="line"><span class="comment">* 限制条件：1.nodejs 12.22以上</span></span><br><span class="line"><span class="comment">* 异常处理：1.出现各种错误时，应在xxx稳定上记录错误日志</span></span><br><span class="line"><span class="comment">* 历史记录：1.2022年5月16日，初始化，增加登录功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><ul><li>文件名：记录程序或模块保存到内存时的源文件名。目标文件名或可执行文件名与源文件名不同时，需要同时记录。如果存在其他需要链接的目标代码，可以用<code>+</code>符号连接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名：源代码：demo.ts</span></span><br><span class="line"><span class="comment"> * 目标代码：demo.js</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>编写者</p></li><li><p>目标：记录为什么要编写这个程序，该程序负责处理什么任务，在整个系统中担任什么角色等。</p></li><li><p>使用方式：方式、执行频率等。</p></li><li><p>所需文件：记录需要处理的文件名、属性等，同时需要标注该文件释放可读、可写、可修改、可删除。</p></li><li><p>限制条件：操作系统、CPU速度、程序大小、所需的硬盘容量等。</p></li><li><p>异常处理：一定程度上预测并管理致命的异常。</p></li><li><p>历史记录：修改时间、修改内容的核心、修改者。</p></li></ul><h3 id="5-7-在等于运算符旁添加注释"><a href="#5-7-在等于运算符旁添加注释" class="headerlink" title="5.7 在等于运算符旁添加注释"></a>5.7 在等于运算符旁添加注释</h3><p>可读性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++) &#123;  <span class="comment">// i从1开始计数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，在条件语句中使用等于运算符或赋值运算符时，应尽可能在旁边添加注释。</p><h3 id="5-8-在大括号闭合处添加注释"><a href="#5-8-在大括号闭合处添加注释" class="headerlink" title="5.8 在大括号闭合处添加注释"></a>5.8 在大括号闭合处添加注释</h3><p>可读性。</p><p>通常，应该在大括号闭合处的旁边添加注释，说明该大括号表示哪部分结束。按照惯例，应该用<code>end if</code>、<code>end main</code>、<code>end while</code>、<code>end class MyClass</code>这种以end开头的注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end if</span></span><br><span class="line">&#125; <span class="comment">// end demo</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-9-在函数内部添加详细介绍函数的注释"><a href="#5-9-在函数内部添加详细介绍函数的注释" class="headerlink" title="5.9 在函数内部添加详细介绍函数的注释"></a>5.9 在函数内部添加详细介绍函数的注释</h3><p>可读性。</p><p>如果函数正上方或正下方添加了关于其作用和含义的详细注释，那么就不必逐条查看代码，也能提高效率。</p><p>应当记录：</p><ul><li>函数的目标；</li><li>各参数允许的数据类型及含义；</li><li>返回值应用于何处</li></ul><h3 id="5-10-注释标记原则"><a href="#5-10-注释标记原则" class="headerlink" title="5.10 注释标记原则"></a>5.10 注释标记原则</h3><ul><li>代码本身足以说明问题时，不必添加注释；</li><li>代码本身不足以说明问题时，尽可能添加详细注释。</li></ul><hr><h2 id="6-标识符名称定义相关编码准则1"><a href="#6-标识符名称定义相关编码准则1" class="headerlink" title="6.标识符名称定义相关编码准则1"></a>6.标识符名称定义相关编码准则1</h2><h3 id="6-1-系统化定义变量名"><a href="#6-1-系统化定义变量名" class="headerlink" title="6.1 系统化定义变量名"></a>6.1 系统化定义变量名</h3><p>可读性。</p><p>应该统一变量命名规则，系统化整理变量名可以避免混淆。</p><p>### 6.2 用匈牙利表示法命名变量</p><p>可读性。（不是特别推荐）</p><p>变量名以能表示——包含数据类型在内的——变量特性或功能的字符串为前缀。如下为整数型变量添加字符<code>i</code>作为前缀：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iNumber</span><br><span class="line">iCounter</span><br></pre></td></tr></table></figure></p><p>指针类型变量应添加前缀<code>p</code>或<code>ptr</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pMyPointer</span><br><span class="line">ptrFilePointer</span><br></pre></td></tr></table></figure></p><p><img src="/images/code128/p-11.jpg" alt="p-11.jpg"></p><p>采用匈牙利表示法可以使变量的数据类型一目了然。但是使用匈牙利表示法需要记住每种数据类型并添加到变量名前缀，这非常繁琐。</p><h3 id="6-3-用变量名前缀表示变量数据类型"><a href="#6-3-用变量名前缀表示变量数据类型" class="headerlink" title="6.3 用变量名前缀表示变量数据类型"></a>6.3 用变量名前缀表示变量数据类型</h3><p>可读性。（不是特别推荐）</p><p><img src="/images/code128/p-12.jpg" alt="p-12.jpg"></p><h3 id="6-4-用变量名前缀表示变量存储类型"><a href="#6-4-用变量名前缀表示变量存储类型" class="headerlink" title="6.4 用变量名前缀表示变量存储类型"></a>6.4 用变量名前缀表示变量存储类型</h3><p>可读性。（不是特别推荐）</p><p><img src="/images/code128/p-13.jpg" alt="p-13.jpg"></p><p>存储类型指的是，考虑变量在内存中的生存期的长短、在程序代码中影响范围的大小，对变量进行分类。</p><p>还有用下划线区分变量的存储类型和数据类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g_uc_mynum;</span><br></pre></td></tr></table></figure></p><h3 id="6-5-用函数名前缀表示函数功能"><a href="#6-5-用函数名前缀表示函数功能" class="headerlink" title="6.5 用函数名前缀表示函数功能"></a>6.5 用函数名前缀表示函数功能</h3><p>可读性。</p><ul><li><code>avr</code>：计算平均值，如<code>avrOfTot</code></li><li><code>cnt</code>：计算数据个数，如<code>cntAllthing</code></li><li><code>check</code>：检查某数值，如<code>checkData</code></li><li><code>get</code>：表示用于获取某数值</li><li><code>set</code>：表示用于设置某数值</li><li><code>is</code>：用于提出“是什么”的疑问</li><li><code>key</code>：从数据中只获取关键字的值，如<code>keyPaymentTable</code></li><li><code>max</code>：表示获取最大</li><li><code>mid</code>：表示获取中间值</li><li><code>min</code>：表示获取最小值</li><li><code>put</code>：表示用于存储</li></ul><p><code>动词 + 宾语</code>的形式。</p><h3 id="6-6-编写个人专属前缀"><a href="#6-6-编写个人专属前缀" class="headerlink" title="6.6 编写个人专属前缀"></a>6.6 编写个人专属前缀</h3><p>可读性。</p><p>如<code>BreakSystem</code>类创建了一个实例：<code>bsNewBreak</code>。</p><p>需要注意的是，进行团队开发时，编写新的前缀需要告知团队中的所有人，或者在声明语句前添加相应注释。</p><hr><h2 id="标识符名称定义相关编码准则2"><a href="#标识符名称定义相关编码准则2" class="headerlink" title="标识符名称定义相关编码准则2"></a>标识符名称定义相关编码准则2</h2><h3 id="7-1-用有意义的名称命名"><a href="#7-1-用有意义的名称命名" class="headerlink" title="7.1 用有意义的名称命名"></a>7.1 用有意义的名称命名</h3><p>可读性。</p><p>标识符的名称一定要有意义。</p><h3 id="7-2-不要使用相似的变量名"><a href="#7-2-不要使用相似的变量名" class="headerlink" title="7.2 不要使用相似的变量名"></a>7.2 不要使用相似的变量名</h3><p>可读性。</p><p>比如通过变量名后加s以区分不同变量，如number和numbers，使用这种相似的变量名命名变量后，编程过程中容易混淆，应该用明显不同的单词命名，如number和digit。<br>不得不采用相似的变量名时，可以向原名称添加前缀或后缀。如day_yy、day_mm、day_dd。前缀有时比后缀更有效，比如iTotal和dTotal。</p><h3 id="7-3-在不影响含义的前提下尽可能简短命名"><a href="#7-3-在不影响含义的前提下尽可能简短命名" class="headerlink" title="7.3 在不影响含义的前提下尽可能简短命名"></a>7.3 在不影响含义的前提下尽可能简短命名</h3><p>可读性。</p><p>“短小精悍”。可以使用惯用缩写：</p><p><img src="/images/code128/p-14.jpg" alt="p-14.jpg"></p><p>其他的还有：</p><ul><li>Break -&gt; brk</li><li>Control -&gt; ctl</li><li>System -&gt; sys</li></ul><h3 id="7-4-用下划线和大小写区分较长变量名"><a href="#7-4-用下划线和大小写区分较长变量名" class="headerlink" title="7.4 用下划线和大小写区分较长变量名"></a>7.4 用下划线和大小写区分较长变量名</h3><p>可读性。</p><p>甚至可以下划线和大小写都用。</p><h3 id="7-5-变量名不要以下划线开始"><a href="#7-5-变量名不要以下划线开始" class="headerlink" title="7.5 变量名不要以下划线开始"></a>7.5 变量名不要以下划线开始</h3><p>可读性。</p><p>用下划线主要是为了避免冲突，但如果都推荐用下划线，反而就造成了命名冲突。</p><h3 id="7-6-不要过度使用下划线"><a href="#7-6-不要过度使用下划线" class="headerlink" title="7.6 不要过度使用下划线"></a>7.6 不要过度使用下划线</h3><p>可读性。</p><p>只用一个下划线，不要用多个。</p><h3 id="7-7-合理使用大小写命名标识符"><a href="#7-7-合理使用大小写命名标识符" class="headerlink" title="7.7 合理使用大小写命名标识符"></a>7.7 合理使用大小写命名标识符</h3><p>可读性。</p><ul><li>变量和对象名以小写字母开始；</li><li>函数、类、结构体、共用体等名称以大写字母开始（js函数一般不用）；</li><li>符号常量或宏函数的所有字母均大写。</li></ul><h3 id="7-8-不要滥用大小写区分1"><a href="#7-8-不要滥用大小写区分1" class="headerlink" title="7.8 不要滥用大小写区分1"></a>7.8 不要滥用大小写区分1</h3><p>可读性。</p><p>滥用1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num;</span><br><span class="line">let Num;</span><br><span class="line">let NUM;</span><br></pre></td></tr></table></figure></p><h3 id="7-9-不要滥用大小写区分2"><a href="#7-9-不要滥用大小写区分2" class="headerlink" title="7.9 不要滥用大小写区分2"></a>7.9 不要滥用大小写区分2</h3><p>可读性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iMyNumber = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> iMynumber = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="7-10-不能用相同名称同时命名类和变量"><a href="#7-10-不能用相同名称同时命名类和变量" class="headerlink" title="7.10 不能用相同名称同时命名类和变量"></a>7.10 不能用相同名称同时命名类和变量</h3><p>可读性。</p><h3 id="7-11-用大写字母表示变量名中需要强调的部分"><a href="#7-11-用大写字母表示变量名中需要强调的部分" class="headerlink" title="7.11 用大写字母表示变量名中需要强调的部分"></a>7.11 用大写字母表示变量名中需要强调的部分</h3><p>可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localButIMPORTANT</span><br></pre></td></tr></table></figure><hr><h2 id="8-运算符相关编码准则"><a href="#8-运算符相关编码准则" class="headerlink" title="8.运算符相关编码准则"></a>8.运算符相关编码准则</h2><h3 id="8-1-恰当应用条件运算符有助于提高可读性"><a href="#8-1-恰当应用条件运算符有助于提高可读性" class="headerlink" title="8.1 恰当应用条件运算符有助于提高可读性"></a>8.1 恰当应用条件运算符有助于提高可读性</h3><p>可读性。</p><p>如果if判断较多，有些情况下可以使用运算符缩减代码长度。</p><h3 id="8-2-不要凭借运算符优先级排列算式"><a href="#8-2-不要凭借运算符优先级排列算式" class="headerlink" title="8.2 不要凭借运算符优先级排列算式"></a>8.2 不要凭借运算符优先级排列算式</h3><p>可读性。</p><p>需要添加括号，让人能够轻松理解。</p><h3 id="8-3-指针运算符应该紧接变量名"><a href="#8-3-指针运算符应该紧接变量名" class="headerlink" title="8.3 指针运算符应该紧接变量名"></a>8.3 指针运算符应该紧接变量名</h3><p>可读性。（js倒不涉及）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> b, c;</span><br></pre></td></tr></table></figure><h3 id="8-4-慎选移位运算，多用算术运算"><a href="#8-4-慎选移位运算，多用算术运算" class="headerlink" title="8.4 慎选移位运算，多用算术运算"></a>8.4 慎选移位运算，多用算术运算</h3><p>可读性。</p><p>程序难以理解，也容易存在边界问题。</p><h3 id="8-5-不要追求极端效率"><a href="#8-5-不要追求极端效率" class="headerlink" title="8.5 不要追求极端效率"></a>8.5 不要追求极端效率</h3><p>要考虑可读性。</p><hr><h2 id="9-编写清晰代码所需编码准则"><a href="#9-编写清晰代码所需编码准则" class="headerlink" title="9.编写清晰代码所需编码准则"></a>9.编写清晰代码所需编码准则</h2><h3 id="9-1-不要投机取巧，应致力于编写清晰易懂的程序"><a href="#9-1-不要投机取巧，应致力于编写清晰易懂的程序" class="headerlink" title="9.1 不要投机取巧，应致力于编写清晰易懂的程序"></a>9.1 不要投机取巧，应致力于编写清晰易懂的程序</h3><p>考虑可读性，也不要过分注释。</p><h3 id="9-2-切忌混淆while语句中关系运算符和赋值运算符的优先级"><a href="#9-2-切忌混淆while语句中关系运算符和赋值运算符的优先级" class="headerlink" title="9.2 切忌混淆while语句中关系运算符和赋值运算符的优先级"></a>9.2 切忌混淆while语句中关系运算符和赋值运算符的优先级</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (c = (getChar() !== <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可观，也容易失误。</p><h3 id="9-3-不要进行隐式“非零测试”"><a href="#9-3-不要进行隐式“非零测试”" class="headerlink" title="9.3 不要进行隐式“非零测试”"></a>9.3 不要进行隐式“非零测试”</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getNum()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好明确写出条件表达式。</p><h3 id="9-4-不要在条件表达式中使用赋值语句"><a href="#9-4-不要在条件表达式中使用赋值语句" class="headerlink" title="9.4 不要在条件表达式中使用赋值语句"></a>9.4 不要在条件表达式中使用赋值语句</h3><p>while/if/for/switch不要使用赋值语句。</p><h3 id="9-5-避免产生副作用"><a href="#9-5-避免产生副作用" class="headerlink" title="9.5 避免产生副作用"></a>9.5 避免产生副作用</h3><p>比如++的取值等。几乎所有运算、控制、调用都可能引起副作用，遵循KISS原则编写程序。</p><h3 id="9-6-函数原型中也要标注参数的数据类型"><a href="#9-6-函数原型中也要标注参数的数据类型" class="headerlink" title="9.6 函数原型中也要标注参数的数据类型"></a>9.6 函数原型中也要标注参数的数据类型</h3><p>为了避免模糊性、强化明确性，必须在函数原型中也标记参数。</p><h3 id="9-7-形式参数也需要命名"><a href="#9-7-形式参数也需要命名" class="headerlink" title="9.7 形式参数也需要命名"></a>9.7 形式参数也需要命名</h3><p>Val、num可能还不够语义化。</p><h3 id="9-8-必须标注返回值的数据类型"><a href="#9-8-必须标注返回值的数据类型" class="headerlink" title="9.8 必须标注返回值的数据类型"></a>9.8 必须标注返回值的数据类型</h3><p>（ts可以遵守这条规则）</p><h3 id="9-9-留意结果值"><a href="#9-9-留意结果值" class="headerlink" title="9.9 留意结果值"></a>9.9 留意结果值</h3><p>各种运算、调用、控制返回值的最终结果的值。</p><h3 id="9-10-在for语句等条件表达式中谨慎运算"><a href="#9-10-在for语句等条件表达式中谨慎运算" class="headerlink" title="9.10 在for语句等条件表达式中谨慎运算"></a>9.10 在for语句等条件表达式中谨慎运算</h3><p>可以将运算执行、方法提前。</p><h3 id="9-11-大量使用冗余括号"><a href="#9-11-大量使用冗余括号" class="headerlink" title="9.11 大量使用冗余括号"></a>9.11 大量使用冗余括号</h3><p>可用可不用的括号有时能帮助理解，有助于区分关系运算符和逻辑运算符。</p><h3 id="9-12-如果else语句使用大括号，那么if语句也应该使用"><a href="#9-12-如果else语句使用大括号，那么if语句也应该使用" class="headerlink" title="9.12 如果else语句使用大括号，那么if语句也应该使用"></a>9.12 如果else语句使用大括号，那么if语句也应该使用</h3><h3 id="9-13-函数末尾务必编写return语句"><a href="#9-13-函数末尾务必编写return语句" class="headerlink" title="9.13 函数末尾务必编写return语句"></a>9.13 函数末尾务必编写return语句</h3><hr><h2 id="10-编写可移植代码所需编码准则"><a href="#10-编写可移植代码所需编码准则" class="headerlink" title="10.编写可移植代码所需编码准则"></a>10.编写可移植代码所需编码准则</h2><h3 id="10-1-文件名不超过14个字符"><a href="#10-1-文件名不超过14个字符" class="headerlink" title="10.1 文件名不超过14个字符"></a>10.1 文件名不超过14个字符</h3><p>不同操作系统对文件名长度有不同限制，保证程序能够顺利移植到对文件名长度有所限制的系统。</p><h3 id="10-2-不要在文件名中使用特殊字符"><a href="#10-2-不要在文件名中使用特殊字符" class="headerlink" title="10.2 不要在文件名中使用特殊字符"></a>10.2 不要在文件名中使用特殊字符</h3><h3 id="10-3-利用条件编译提高可移植性"><a href="#10-3-利用条件编译提高可移植性" class="headerlink" title="10.3 利用条件编译提高可移植性"></a>10.3 利用条件编译提高可移植性</h3><p>Js不涉及</p><h3 id="10-4-了解编译器的限制"><a href="#10-4-了解编译器的限制" class="headerlink" title="10.4 了解编译器的限制"></a>10.4 了解编译器的限制</h3><p>如调用栈限制。</p><h3 id="10-5-需考虑数据类型大小可能变化"><a href="#10-5-需考虑数据类型大小可能变化" class="headerlink" title="10.5 需考虑数据类型大小可能变化"></a>10.5 需考虑数据类型大小可能变化</h3><h3 id="10-6-不要指定绝对路径"><a href="#10-6-不要指定绝对路径" class="headerlink" title="10.6 不要指定绝对路径"></a>10.6 不要指定绝对路径</h3><h3 id="10-7-可移植性和高效性二选一"><a href="#10-7-可移植性和高效性二选一" class="headerlink" title="10.7 可移植性和高效性二选一"></a>10.7 可移植性和高效性二选一</h3><p><img src="/images/code128/p-15.jpg" alt="p-15.jpg"></p><p>提高效率的技术方法很大程序上都依赖系统，越是针对专门设备进行特殊化处理的程序，效率越高，也就是一定会牺牲可移植性。</p><h3 id="10-8-用数组代替指针以提高可移植性"><a href="#10-8-用数组代替指针以提高可移植性" class="headerlink" title="10.8 用数组代替指针以提高可移植性"></a>10.8 用数组代替指针以提高可移植性</h3><h3 id="10-9-选择可移植性更好的编程语言"><a href="#10-9-选择可移植性更好的编程语言" class="headerlink" title="10.9 选择可移植性更好的编程语言"></a>10.9 选择可移植性更好的编程语言</h3><p>可移植性和可读性通常成正比。</p><h3 id="10-10-不要插入低级语言编写的代码"><a href="#10-10-不要插入低级语言编写的代码" class="headerlink" title="10.10 不要插入低级语言编写的代码"></a>10.10 不要插入低级语言编写的代码</h3><p>汇编、机器语言。那么可移植性方面可能会出现问题。如果不得不用低级语言实现特定功能，则应该用相应语言编写库，事先编译，然后再以函数形式调用。</p><hr><h2 id="11-编写精确代码所需编码准则"><a href="#11-编写精确代码所需编码准则" class="headerlink" title="11.编写精确代码所需编码准则"></a>11.编写精确代码所需编码准则</h2><p>可拓展性。</p><h3 id="11-1计算机并不如想象得那么精确"><a href="#11-1计算机并不如想象得那么精确" class="headerlink" title="11.1计算机并不如想象得那么精确"></a>11.1计算机并不如想象得那么精确</h3><p>数字电路机器无法准确表示小数。</p><h3 id="11-2-需要进行准确计算时避开浮点数运算"><a href="#11-2-需要进行准确计算时避开浮点数运算" class="headerlink" title="11.2 需要进行准确计算时避开浮点数运算"></a>11.2 需要进行准确计算时避开浮点数运算</h3><p>浮点数的特性决定其无法进行精确运算，它一直存在误差，比如1/3。</p><h3 id="11-3-double型比float型更适合精确计算"><a href="#11-3-double型比float型更适合精确计算" class="headerlink" title="11.3 double型比float型更适合精确计算"></a>11.3 double型比float型更适合精确计算</h3><p>Doublue型运算速度比float要快（相差无几）。</p><blockquote><p>要处理精度高的数值，可以用科学计算专用语言FORTRAN，或者用数组实现精度更高的实数运算。</p></blockquote><h3 id="11-4-确认整数型大小"><a href="#11-4-确认整数型大小" class="headerlink" title="11.4 确认整数型大小"></a>11.4 确认整数型大小</h3><p>大部分UNIX系列操作系统定义整数型大小为4字节（32位），PC常用操作系统定义整数型大小为2字节（16位），有的是4字节（32字节），事先最好确认整数型数据大小。</p><p>整数型大小也会影响程序的可移植性。</p><h3 id="11-5-必须明确计算单位"><a href="#11-5-必须明确计算单位" class="headerlink" title="11.5 必须明确计算单位"></a>11.5 必须明确计算单位</h3><p>最好在头注释和正文注释中全部记录计算单位，而且在变量声明部分和实际计算部分也再次标记计算单位。可以降低实际计算语句中误解单位的可能性，程序也会相应变得更加精确。</p><h3 id="11-6-特别留意除法运算"><a href="#11-6-特别留意除法运算" class="headerlink" title="11.6 特别留意除法运算"></a>11.6 特别留意除法运算</h3><p>要想正真理解除法运算，就要对编译器处理计算表达式的顺序烂熟于心。不同编译器对表达式的处理方法略有不同。</p><p><img src="/images/code128/p-16.jpg" alt="p-16.jpg"></p><p><img src="/images/code128/p-17.jpg" alt="p-17.jpg"></p><h3 id="11-7-尽量避免数据类型转换"><a href="#11-7-尽量避免数据类型转换" class="headerlink" title="11.7 尽量避免数据类型转换"></a>11.7 尽量避免数据类型转换</h3><p>数据类型的转换始终会存在风险。将高类型（长字节）转换为低类型（短字节）时，会损失一定的数据精度。如将double型转换为float型。还要特别注意是否存在隐式数据类型转换。</p><p>一种做法是保证相关变量都声明为相同数据类型，还有一种方法是在变量名前添加可表示数据类型的前缀。</p><h3 id="11-8-精通编程语言的语法"><a href="#11-8-精通编程语言的语法" class="headerlink" title="11.8 精通编程语言的语法"></a>11.8 精通编程语言的语法</h3><p>略显繁琐的语法往往能够决定整个程序。要想编写精确程序必须精通采用的编程语言的语法。</p><h3 id="11-9-留意可能出现的非线形计算结果"><a href="#11-9-留意可能出现的非线形计算结果" class="headerlink" title="11.9 留意可能出现的非线形计算结果"></a>11.9 留意可能出现的非线形计算结果</h3><p>计算机反复运算的结果可能远远偏离我们的预期。特别是涉及浮点数的话，这种现象尤为突出。</p><p>务必多次校验运算结果。</p><hr><h2 id="12-提升性能所需编码准则"><a href="#12-提升性能所需编码准则" class="headerlink" title="12.提升性能所需编码准则"></a>12.提升性能所需编码准则</h2><p>可拓展性、稳定性。</p><h3 id="12-1-重视性能，限制输出"><a href="#12-1-重视性能，限制输出" class="headerlink" title="12.1 重视性能，限制输出"></a>12.1 重视性能，限制输出</h3><p>最好支持用户可以自由设置程序运行时是否输出提示信息，也就是用户可以选择输出或不输出这些信息。</p><p>比如C语言中，负责格式化输出的<code>printf()</code>函数的运算成本要远高于其他运算。</p><h3 id="12-2-用简单形式改写运算表达式"><a href="#12-2-用简单形式改写运算表达式" class="headerlink" title="12.2 用简单形式改写运算表达式"></a>12.2 用简单形式改写运算表达式</h3><p>从C编译器处理运算层面来看，乘法运算成本高于加减法，除法运算成本又高于乘法，浮点数之间的运算成本高于整数型运算，成本最低的运算是位运算或者逻辑运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位运算、逻辑运算 &lt; 加减法运算 &lt; 乘法运算 &lt; 除法运算 &lt; 处理浮点数</span><br></pre></td></tr></table></figure><p>尽可能选择成本较低的运算。</p><h3 id="12-3-需要高效处理大文件时应使用二进制文件"><a href="#12-3-需要高效处理大文件时应使用二进制文件" class="headerlink" title="12.3 需要高效处理大文件时应使用二进制文件"></a>12.3 需要高效处理大文件时应使用二进制文件</h3><p>用C语言处理文件时，一般使用ASCII格式的文件，优点在于在任何地方都可以查看该文件，因为任何计算机都提供可以查看ASCII格式文件的命令或程序。<br>但是ASCII文件的读写速度要低于二进制文件，而且所占空间更大。</p><p>因此如果程序性能至关重要或需要节约存储空间，最好选用二进制文件而非ASCII文件。</p><h3 id="12-4-了解并使用压缩-未压缩结构体优缺点"><a href="#12-4-了解并使用压缩-未压缩结构体优缺点" class="headerlink" title="12.4 了解并使用压缩/未压缩结构体优缺点"></a>12.4 了解并使用压缩/未压缩结构体优缺点</h3><p>压缩结构体：使用位域减少所占空间大小的结构体。<br>为了节约内存空间，信号处理领域多采用压缩结构体，但压缩结构体会减慢程序运行速度，因为位域运算需要消耗大量时间。相反，未压缩结构体虽然占据较多内存，但与压缩结构体相比，处理速度更快，而且不使用位域会使程序更容易理解、更加明确。</p><p>如果没有限制栈大小或栈足够大，或者并不需要很多信号处理变量，那么最好采用未压缩结构体；如果栈大小受限或需要很多信号处理变量，则最好使用压缩结构体。</p><h3 id="12-5-根据运行环境选择编程语言"><a href="#12-5-根据运行环境选择编程语言" class="headerlink" title="12.5 根据运行环境选择编程语言"></a>12.5 根据运行环境选择编程语言</h3><p>比如C/C++写的程序可以在操作系统中直接运行，速度比Java或C#编写的程序更快，但C/C++在网络环境下相对有些力不从心。</p><p>选择何种编程语言对程序的影响程度远大于缩进等细枝末节的影响。</p><h3 id="12-6-根据情况选择手段"><a href="#12-6-根据情况选择手段" class="headerlink" title="12.6 根据情况选择手段"></a>12.6 根据情况选择手段</h3><p>能够选择与业务情况、系统情况相吻合的恰当方法处理问题的程序员更为可贵。</p><p>能够从语言提供的各种工具中挑选最合适的，并知道如何充分利用该工具才最重要。</p><h3 id="12-7-选择更优秀的数据结构"><a href="#12-7-选择更优秀的数据结构" class="headerlink" title="12.7 选择更优秀的数据结构"></a>12.7 选择更优秀的数据结构</h3><p>内存廉价且足够大的情况下，没有必要节约内存。有时需要处理的数据太多，超出数组可以承受的范围时应该选择数组以外的其他数据结构，比如链表。<br>应该根据情况选择合适的数据结构，程序员还可以用结构体、共用体和枚举定义并使用用户独有的数据结构，即用户自定义数据结构。</p><p>选用不同的数据结构决定了排序方式和排序性能。</p><hr><h2 id="13-编写易于理解的代码所需编码准则"><a href="#13-编写易于理解的代码所需编码准则" class="headerlink" title="13.编写易于理解的代码所需编码准则"></a>13.编写易于理解的代码所需编码准则</h2><p>可维护性。</p><h3 id="13-1-不要使用goto语句"><a href="#13-1-不要使用goto语句" class="headerlink" title="13.1 不要使用goto语句"></a>13.1 不要使用goto语句</h3><p>Goto语句更易上手和使用，但从程序易于理解和维护的角度来看，应该使用能够将逻辑块紧密联系的结构化程序设计方式，goto常常打乱程序逻辑。</p><h3 id="13-2-不要替换C语言组成要素"><a href="#13-2-不要替换C语言组成要素" class="headerlink" title="13.2 不要替换C语言组成要素"></a>13.2 不要替换C语言组成要素</h3><p>汉字编程或自定义代码形态。</p><h3 id="13-3-缩短过长数据类型名称"><a href="#13-3-缩短过长数据类型名称" class="headerlink" title="13.3 缩短过长数据类型名称"></a>13.3 缩短过长数据类型名称</h3><p>缩短过长的数据类型名，用更容易理解的名字重命名（与变量特性相吻合）。</p><h3 id="13-4-使用if语句而非三元运算符"><a href="#13-4-使用if语句而非三元运算符" class="headerlink" title="13.4 使用if语句而非三元运算符"></a>13.4 使用if语句而非三元运算符</h3><p>三元运算符有时更简洁，但容易导致代码难以理解。</p><h3 id="13-5-数组维数应限制在三维之内"><a href="#13-5-数组维数应限制在三维之内" class="headerlink" title="13.5 数组维数应限制在三维之内"></a>13.5 数组维数应限制在三维之内</h3><p>会导致难以理解和想象。</p><h3 id="13-6-考虑驱动函数main函数的作用"><a href="#13-6-考虑驱动函数main函数的作用" class="headerlink" title="13.6 考虑驱动函数main函数的作用"></a>13.6 考虑驱动函数main函数的作用</h3><p>Main函数是驱动函数，main函数调用的函数称为被动函数，main函数类似书的封面，应该记录各种程序信息以便日后其他人可以快速查找和更容易理解。</p><h3 id="13-7-将常量替换为符号常量或const形态常量"><a href="#13-7-将常量替换为符号常量或const形态常量" class="headerlink" title="13.7 将常量替换为符号常量或const形态常量"></a>13.7 将常量替换为符号常量或const形态常量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">const</span> sleepTime = <span class="number">18</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">const</span> INITIAL_AIRCON_DEGREE = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> AIRCON_DEGREE_STEP = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SLEEP_TIME = INITIAL_AIRCON_DEGREE + AIRCON_DEGREE_STEP;</span><br></pre></td></tr></table></figure><h3 id="13-8-考虑变量声明部分的顺序"><a href="#13-8-考虑变量声明部分的顺序" class="headerlink" title="13.8 考虑变量声明部分的顺序"></a>13.8 考虑变量声明部分的顺序</h3><p>顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户自定义数据类型</span><br><span class="line">多个程序共用的外部变量</span><br><span class="line">程序单元内部多个函数共用的全局变量</span><br><span class="line">只有对应函数才会用到的局部变量</span><br></pre></td></tr></table></figure></p><h3 id="13-9-尽可能不使用全局变量"><a href="#13-9-尽可能不使用全局变量" class="headerlink" title="13.9 尽可能不使用全局变量"></a>13.9 尽可能不使用全局变量</h3><p>扰乱程序逻辑、增大理解难度。</p><h3 id="13-10-遵循KISS原则"><a href="#13-10-遵循KISS原则" class="headerlink" title="13.10 遵循KISS原则"></a>13.10 遵循KISS原则</h3><p>Keep it simple and short。</p><ul><li>易于修复代码漏洞（debugging）</li><li>易于重构代码（refractoring）</li><li>易于维护代码（maintenance）</li><li>易于修复代码（rebuilding）</li><li>易于复用代码（reusing）</li></ul><hr><h2 id="14-用户接口处理相关编码准则"><a href="#14-用户接口处理相关编码准则" class="headerlink" title="14.用户接口处理相关编码准则"></a>14.用户接口处理相关编码准则</h2><p>可拓展性。</p><h3 id="14-1-确保保存输入值的变量足够大"><a href="#14-1-确保保存输入值的变量足够大" class="headerlink" title="14.1 确保保存输入值的变量足够大"></a>14.1 确保保存输入值的变量足够大</h3><p>与double相比应选择long double，与int型相比应用long int型声明变量。</p><h3 id="14-2-转换说明符和参数个数应保持一致"><a href="#14-2-转换说明符和参数个数应保持一致" class="headerlink" title="14.2 转换说明符和参数个数应保持一致"></a>14.2 转换说明符和参数个数应保持一致</h3><p>printf()的使用</p><h3 id="14-3-使用fgets-和sscanf-函数而非scanf-函数"><a href="#14-3-使用fgets-和sscanf-函数而非scanf-函数" class="headerlink" title="14.3 使用fgets()和sscanf()函数而非scanf()函数"></a>14.3 使用fgets()和sscanf()函数而非scanf()函数</h3><p>scanf()对文件末尾出现的EOF的处理并不稳定，有时会遗漏EOF。</p><blockquote><p>windows环境下，EOF对应的键盘输入值为<code>^Z(Ctrl+Z)</code>，UNIX中对应的是<code>^D(Ctrl+D)</code>。</p></blockquote><h3 id="14-4-使用fflush-函数清空标准输入-输出设备缓冲"><a href="#14-4-使用fflush-函数清空标准输入-输出设备缓冲" class="headerlink" title="14.4 使用fflush()函数清空标准输入/输出设备缓冲"></a>14.4 使用fflush()函数清空标准输入/输出设备缓冲</h3><p>可以将缓冲内容强制传递到输入/输出设备。</p><hr><h2 id="15-编写零漏洞代码所需编码准则"><a href="#15-编写零漏洞代码所需编码准则" class="headerlink" title="15.编写零漏洞代码所需编码准则"></a>15.编写零漏洞代码所需编码准则</h2><h3 id="15-1-数组下标应从0开始"><a href="#15-1-数组下标应从0开始" class="headerlink" title="15.1 数组下标应从0开始"></a>15.1 数组下标应从0开始</h3><p>从1开始对数组进行计数引起的错误又称大小差一（off-by-one）错误。</p><h3 id="15-2-置换字符串时必须使用括号"><a href="#15-2-置换字符串时必须使用括号" class="headerlink" title="15.2 置换字符串时必须使用括号"></a>15.2 置换字符串时必须使用括号</h3><h3 id="15-3-文件必须有开就有关"><a href="#15-3-文件必须有开就有关" class="headerlink" title="15.3 文件必须有开就有关"></a>15.3 文件必须有开就有关</h3><h3 id="15-4-不要无视编译器的警告错误"><a href="#15-4-不要无视编译器的警告错误" class="headerlink" title="15.4 不要无视编译器的警告错误"></a>15.4 不要无视编译器的警告错误</h3><ul><li>致命错误（fatal error）</li><li>警告错误（warning error）：也不能忽视</li></ul><h3 id="15-5-掌握并在编码时防止运行时错误"><a href="#15-5-掌握并在编码时防止运行时错误" class="headerlink" title="15.5 掌握并在编码时防止运行时错误"></a>15.5 掌握并在编码时防止运行时错误</h3><p>运行时错误不同于编译错误和逻辑错误，运行时错误与运行时环境紧密相关。</p><p>典型的运行时错误——栈溢出是由于操作系统限制栈的大小而产生的。最好在函数内部添加限制调用次数的龃龉。</p><p>还有一个典型的运行时错误就是除以0，特别是在循环中的“不小心”除以0。这需要细致检查程序所有可能的运行情况。</p><h3 id="15-6-用静态变量声明大数组"><a href="#15-6-用静态变量声明大数组" class="headerlink" title="15.6 用静态变量声明大数组"></a>15.6 用静态变量声明大数组</h3><p><img src="/images/code128/p-18.jpg" alt="p-18.jpg"></p><p>除特别用extern、static、register声明的变量外，其他变量均为自动变量。自动变量存储于以栈形态管理数据的内存。如果一个程序用到的所有自动变量的综合超出栈的大小，就会触发栈溢出进而导致程序异常终止。</p><p>输入声明为静态变量，那么数组的存放位置就是堆，而不是栈，也就不会出现栈溢出。</p><h3 id="15-7-预留足够大的存储空间"><a href="#15-7-预留足够大的存储空间" class="headerlink" title="15.7 预留足够大的存储空间"></a>15.7 预留足够大的存储空间</h3><p>可以预留2～3倍甚至更多字符串存储空间。</p><h3 id="15-8-注意信息交换引发的涌现效果"><a href="#15-8-注意信息交换引发的涌现效果" class="headerlink" title="15.8 注意信息交换引发的涌现效果"></a>15.8 注意信息交换引发的涌现效果</h3><p>程序单元之间进行信息交换的过程中，可能出现信息丢失，也可能新增荣誉信息。</p><p>涌现性指的是能够引起意想不到的效果的性质，是复杂系统相关研究领域非常常见的词汇。<br>目前没有可行的对策但存在一种沿用至今的解决方式，即系统层面的综合测试方法。以严格的综合测试为基础，可以在一定程度上发现并预防涌现性现象，这要求在测试过程中投入域软件开发过程同样多的资源。</p><hr><h2 id="16-提升生产效率所需编码准则"><a href="#16-提升生产效率所需编码准则" class="headerlink" title="16.提升生产效率所需编码准则"></a>16.提升生产效率所需编码准则</h2><p>可拓展性。</p><h3 id="16-1-在对立关系中事先确定侧重于哪一方"><a href="#16-1-在对立关系中事先确定侧重于哪一方" class="headerlink" title="16.1 在对立关系中事先确定侧重于哪一方"></a>16.1 在对立关系中事先确定侧重于哪一方</h3><p>对立关系指的是，选择两个策略性目标之一，则无法追求另一个目标的实现。比如使用位运算符有助于提高处理速度但同时会损坏系统安全。</p><p>这种对立关系中，侧重于哪一方面、牺牲哪一方面的选择在一定程度上与价值观有关。标准的做法是，应当事先规定在对立关系中选择侧重哪一方面。应该逐一列举处于对立关系的各个对象，从中选择更希望侧重的一个方面，并在项目流程中始终坚持自己的选择。</p><h3 id="16-2-慎重采用最新工具"><a href="#16-2-慎重采用最新工具" class="headerlink" title="16.2 慎重采用最新工具"></a>16.2 慎重采用最新工具</h3><p>始终以挑剔的眼光看待工具，寻找更好的扩展应用、更好的开发工具。但需要注意，应用新工具时需要慎重，不要仓促地应用新的工具或方法论，因为它们有可能起到反作用。锋利的斧子固然有用，但首先要具备能够挥动斧子的力量。</p><h3 id="16-3-记住所有标准库"><a href="#16-3-记住所有标准库" class="headerlink" title="16.3 记住所有标准库"></a>16.3 记住所有标准库</h3><p>要想使用某种编程语言，就应该牢记该编程语言提供的标准函数。</p><h3 id="16-4-最大程度划分模块"><a href="#16-4-最大程度划分模块" class="headerlink" title="16.4 最大程度划分模块"></a>16.4 最大程度划分模块</h3><p>积木。</p><p>设计系统或程序时，应该最大限度实现模块化，更小、更细的模块才更为重要。</p><h3 id="16-5-明确区分术语"><a href="#16-5-明确区分术语" class="headerlink" title="16.5 明确区分术语"></a>16.5 明确区分术语</h3><p>沟通顺畅才能有更高的生产效率，开发多人参与的项目前，应该先统一术语。</p><h3 id="16-6-明确区分结构体、枚举体、共用体"><a href="#16-6-明确区分结构体、枚举体、共用体" class="headerlink" title="16.6 明确区分结构体、枚举体、共用体"></a>16.6 明确区分结构体、枚举体、共用体</h3><p><img src="/images/code128/p-19.jpg" alt="p-19.jpg"></p><h3 id="16-7-明确区分概念"><a href="#16-7-明确区分概念" class="headerlink" title="16.7 明确区分概念"></a>16.7 明确区分概念</h3><p>比如对象和类。</p><h3 id="16-8-明确区分对象、类、实例"><a href="#16-8-明确区分对象、类、实例" class="headerlink" title="16.8 明确区分对象、类、实例"></a>16.8 明确区分对象、类、实例</h3><p><img src="/images/code128/p-20.jpg" alt="p-20.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《这样编码才规范-128个编码好习惯》&quot;&gt;&lt;a href=&quot;#《这样编码才规范-128个编码好习惯》&quot; class=&quot;headerlink&quot; title=&quot;《这样编码才规范 128个编码好习惯》&quot;&gt;&lt;/a&gt;《这样编码才规范 128个编码好习惯》&lt;/h1&gt;&lt;p&gt;此书
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编码" scheme="http://blog.michealwayne.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Vue3和React18源码片段1——shared</title>
    <link href="http://blog.michealwayne.cn/2022/04/16/react/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Vue3%E5%92%8CReact18%E6%BA%90%E7%A0%81%E7%89%87%E6%AE%B51%E2%80%94%E2%80%94shared/"/>
    <id>http://blog.michealwayne.cn/2022/04/16/react/【笔记】Vue3和React18源码片段1——shared/</id>
    <published>2022-04-16T15:39:18.000Z</published>
    <updated>2022-04-19T07:36:54.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-和-React18-源码片段1——shared"><a href="#Vue3-和-React18-源码片段1——shared" class="headerlink" title="Vue3 和 React18 源码片段1——shared"></a>Vue3 和 React18 源码片段1——shared</h1><p>最近在整合框架时，又一次涉及到了 Vue/React 相关源码，也包括<code>tarjs</code>、<code>raxjs</code>、<code>uni-app</code>等跨端 DSL，优秀的框架通常都会注重性能和代码执行细节，因此借此文/系列开始进行整理。</p><h2 id="代码来源"><a href="#代码来源" class="headerlink" title="代码来源"></a>代码来源</h2><ul><li>Vue3.2：<a href="https://github.com/vuejs/core/tree/3.2" target="_blank" rel="noopener">https://github.com/vuejs/core/tree/3.2</a></li><li>React18.0：<a href="https://github.com/facebook/react/releases/tag/v18.0.0" target="_blank" rel="noopener">https://github.com/facebook/react/releases/tag/v18.0.0</a></li></ul><h2 id="一、工具函数部分shared"><a href="#一、工具函数部分shared" class="headerlink" title="一、工具函数部分shared"></a>一、工具函数部分<code>shared</code></h2><h3 id="Vue：packages-shared"><a href="#Vue：packages-shared" class="headerlink" title="Vue：packages/shared"></a>Vue：<code>packages/shared</code></h3><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稳妥的类型判断方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> objectToString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toTypeString = (value: unknown): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">  objectToString.call(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array类型判断，很直接用了Array.isArray，也可以用`toTypeString`判断。*移动端兼容没问题，PC IE9起步，不过可以用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray</span><br><span class="line"></span><br><span class="line"><span class="comment">// toTypeString判断。*Map和Set都是安卓5起、IE11起步，可以用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isMap = (val: unknown): val is Map&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Map]'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isSet = (val: unknown): val is Set&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Set]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用了instanceof，根据原型判断。注意Date实例toTypeString的结果是`[object Object]`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isDate = (val: unknown): val is <span class="built_in">Date</span> =&gt; val <span class="keyword">instanceof</span> <span class="built_in">Date</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isFunction = (val: unknown): val is <span class="built_in">Function</span> =&gt;</span><br><span class="line">  <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isString = (val: unknown): val is <span class="built_in">string</span> =&gt; <span class="keyword">typeof</span> val === <span class="string">'string'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isSymbol = (val: unknown): val is symbol =&gt; <span class="keyword">typeof</span> val === <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的Object比较宽泛，除了Object、Array外，其他Set、Map等引用类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isObject = (val: unknown): val is Record&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  val !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// duck type，根据关键方法进行判断，所以包含这些属性方法也能过</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isPromise = &lt;T = <span class="built_in">any</span>&gt;(val: unknown): val is <span class="built_in">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格的对象比较</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isPlainObject = (val: unknown): val is object =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Object]'</span></span><br></pre></td></tr></table></figure><h4 id="数据信息判断"><a href="#数据信息判断" class="headerlink" title="数据信息判断"></a>数据信息判断</h4><p>正整数字符串的判断：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正整数字符串的判断，主要排除NaN、Infinity、负数等边界</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIntegerKey = <span class="function">(<span class="params">key: unknown</span>) =&gt;</span></span><br><span class="line">  isString(key) &amp;&amp;</span><br><span class="line">  key !== <span class="string">'NaN'</span> &amp;&amp;</span><br><span class="line">  key[<span class="number">0</span>] !== <span class="string">'-'</span> &amp;&amp;</span><br><span class="line">  <span class="string">''</span> + <span class="built_in">parseInt</span>(key, <span class="number">10</span>) === key</span><br></pre></td></tr></table></figure></p><p>判断属性：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断属性key是否为对象数据val本身属性</span></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasOwn = (</span><br><span class="line">  val: object,</span><br><span class="line">  key: <span class="built_in">string</span> | symbol</span><br><span class="line">): key is keyof <span class="keyword">typeof</span> val =&gt; hasOwnProperty.call(val, key)</span><br></pre></td></tr></table></figure></p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>对象拓展/合并属性：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于拓展/合并属性。*Object.assign兼容移动端还好、PC IE11起步，可用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> extend = <span class="built_in">Object</span>.assign</span><br></pre></td></tr></table></figure></p><p>删除数组元素：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> remove = &lt;T&gt;<span class="function">(<span class="params">arr: T[], el: T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> i = arr.indexOf(el)</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    arr.splice(i, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字符串转数字：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理了NaN的边界</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toNumber = (val: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="built_in">parseFloat</span>(val)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? val : n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新旧值比较：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oldValue === oldValue主要考虑了NaN</span></span><br><span class="line"><span class="comment">// compare whether a value has changed, accounting for NaN.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasChanged = (value: <span class="built_in">any</span>, oldValue: <span class="built_in">any</span>): <span class="function"><span class="params">boolean</span> =&gt;</span></span><br><span class="line">  value !== oldValue &amp;&amp; (value === value || oldValue === oldValue)</span><br></pre></td></tr></table></figure></p><p>处理HTML转义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @from escapeHtml.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> escapeRE = <span class="regexp">/["'&amp;&lt;&gt;]/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params"><span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">''</span> + <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">const</span> match = escapeRE.exec(str)<span class="comment">// 匹配值将进行转义替换</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> escaped</span><br><span class="line">  <span class="keyword">let</span> index</span><br><span class="line">  <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (index = match.index; index &lt; str.length; index++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (str.charCodeAt(index)) &#123;<span class="comment">// 根据 Unicode 编码进行判断</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">34</span>: <span class="comment">// "</span></span><br><span class="line">        escaped = <span class="string">'&amp;quot;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">38</span>: <span class="comment">// &amp;</span></span><br><span class="line">        escaped = <span class="string">'&amp;amp;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">39</span>: <span class="comment">// '</span></span><br><span class="line">        escaped = <span class="string">'&amp;#39;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">60</span>: <span class="comment">// &lt;</span></span><br><span class="line">        escaped = <span class="string">'&amp;lt;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">62</span>: <span class="comment">// &gt;</span></span><br><span class="line">        escaped = <span class="string">'&amp;gt;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex !== index) &#123;</span><br><span class="line">      html += str.substring(lastIndex, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastIndex = index + <span class="number">1</span></span><br><span class="line">    html += escaped</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lastIndex !== index ? html + str.substring(lastIndex, index) : html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://www.w3.org/TR/html52/syntax.html#comments</span></span><br><span class="line"><span class="keyword">const</span> commentStripRE = <span class="regexp">/^-?&gt;|&lt;!--|--&gt;|--!&gt;|&lt;!-$/g</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHtmlComment</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src.replace(commentStripRE, <span class="string">''</span>)<span class="comment">// 删除html注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据比较：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @from looseEqual.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isArray, isDate, isObject &#125; <span class="keyword">from</span> <span class="string">'./'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looseCompareArrays</span>(<span class="params">a: <span class="built_in">any</span>[], b: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length !== b.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> equal = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; equal &amp;&amp; i &lt; a.length; i++) &#123;</span><br><span class="line">    equal = looseEqual(a[i], b[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> equal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较严格的比较</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> aValidType = isDate(a)</span><br><span class="line">  <span class="keyword">let</span> bValidType = isDate(b)</span><br><span class="line">  <span class="comment">// Date数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="keyword">return</span> aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  aValidType = isArray(a)</span><br><span class="line">  bValidType = isArray(b)</span><br><span class="line">  <span class="comment">// Array数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="keyword">return</span> aValidType &amp;&amp; bValidType ? looseCompareArrays(a, b) : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  aValidType = isObject(a)</span><br><span class="line">  bValidType = isObject(b)</span><br><span class="line">  <span class="comment">// Object数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if: this if will probably never be called */</span></span><br><span class="line">    <span class="keyword">if</span> (!aValidType || !bValidType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> aKeysCount = <span class="built_in">Object</span>.keys(a).length</span><br><span class="line">    <span class="keyword">const</span> bKeysCount = <span class="built_in">Object</span>.keys(b).length</span><br><span class="line">    <span class="keyword">if</span> (aKeysCount !== bKeysCount) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">      <span class="keyword">const</span> aHasKey = a.hasOwnProperty(key)</span><br><span class="line">      <span class="keyword">const</span> bHasKey = b.hasOwnProperty(key)</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (aHasKey &amp;&amp; !bHasKey) ||</span><br><span class="line">        (!aHasKey &amp;&amp; bHasKey) ||</span><br><span class="line">        !looseEqual(a[key], b[key])</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// NaN</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIndexOf</span>(<span class="params">arr: <span class="built_in">any</span>[], val: <span class="built_in">any</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> looseEqual(item, val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="React：packages-shared"><a href="#React：packages-shared" class="headerlink" title="React：packages/shared"></a>React：<code>packages/shared</code></h3><p>React 的 shared 模块更为松散。</p><h4 id="类型判断-1"><a href="#类型判断-1" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>isArray.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flow声明</span></span><br><span class="line">declare function isArray(a: mixed): boolean %checks(Array.isArray(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实也是用了Array.isArray</span></span><br><span class="line"><span class="keyword">const</span> isArrayImpl = <span class="built_in">Array</span>.isArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证类型</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-redeclare</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">a: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isArrayImpl(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> isArray;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>ReactSymbols.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MAYBE_ITERATOR_SYMBOL = <span class="built_in">Symbol</span>.iterator;</span><br><span class="line"><span class="keyword">const</span> FAUX_ITERATOR_SYMBOL = <span class="string">'@@iterator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为迭代器函数，也是根据关键属性函数进行判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getIteratorFn</span>(<span class="params">maybeIterable: ?any</span>): ?(<span class="params"></span>) =&gt; ?<span class="title">Iterator</span>&lt;*&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maybeIterable === <span class="literal">null</span> || <span class="keyword">typeof</span> maybeIterable !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> maybeIterator =</span><br><span class="line">    (MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span><br><span class="line">    maybeIterable[FAUX_ITERATOR_SYMBOL];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> maybeIterator === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> maybeIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据信息判断-1"><a href="#数据信息判断-1" class="headerlink" title="数据信息判断"></a>数据信息判断</h4><p>属性判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>hasOwnProperty.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hasOwnProperty;</span><br></pre></td></tr></table></figure></p><h4 id="环境信息判断"><a href="#环境信息判断" class="headerlink" title="环境信息判断"></a>环境信息判断</h4><p>是否为DOM环境：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>ExecutionEnvironment.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> canUseDOM: boolean = !!(</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.document !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.document.createElement !== <span class="string">'undefined'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a>数据处理</h4><p>对象拓展/合并：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>assign.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟Vue中extend函数一样</span></span><br><span class="line"><span class="keyword">const</span> assign = <span class="built_in">Object</span>.assign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> assign;</span><br></pre></td></tr></table></figure></p><p>数据比较：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>objectIs.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算是Object.is的polyfill</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x: any, y: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">// 后面的比较主要区分+0和-0</span></span><br><span class="line">    (x === y &amp;&amp; (x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y)) || (x !== x &amp;&amp; y !== y) <span class="comment">// eslint-disable-line no-self-compare</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.is iOS9/安卓5起支持，IE不兼容</span></span><br><span class="line"><span class="keyword">const</span> objectIs: <span class="function">(<span class="params">x: any, y: any</span>) =&gt;</span> boolean =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">Object</span>.is === <span class="string">'function'</span> ? <span class="built_in">Object</span>.is : is;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> objectIs;</span><br></pre></td></tr></table></figure></p><p>浅比较：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>shallowEqual.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> is <span class="keyword">from</span> <span class="string">'./objectIs'</span>;</span><br><span class="line"><span class="keyword">import</span> hasOwnProperty <span class="keyword">from</span> <span class="string">'./hasOwnProperty'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs equality by iterating through keys on an object and returning false</span></span><br><span class="line"><span class="comment"> * when any key has values which are not strictly equal between the arguments.</span></span><br><span class="line"><span class="comment"> * Returns true when the values of all keys are strictly equal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据键数量先排除一波</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for A's keys different from B.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentKey = keysA[i];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call(objB, currentKey) ||</span><br><span class="line">      !is(objA[currentKey], objB[currentKey])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> shallowEqual;</span><br></pre></td></tr></table></figure></p><hr><p>二、标识处理</p><h3 id="Vue：Patch-flag"><a href="#Vue：Patch-flag" class="headerlink" title="Vue：Patch flag"></a>Vue：<code>Patch flag</code></h3><p>Vue3的静态标记是diff性能优化的一个手段、主要是在与上次 virtual DOM 比较时，只对比带有Patch Flag的节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from patchFlags.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务内容不是本文关注的，</span></span><br><span class="line"><span class="comment">// 这里使用了掩码来避免比较冲突，对大部分前端同学来说其实比较陌生，</span></span><br><span class="line"><span class="comment">// 可见之前记录的位运算笔记：http://blog.michealwayne.cn/2019/10/29/notes/js%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/</span></span><br><span class="line"><span class="comment">// ShapeFlags.ts也用了相同的方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> PatchFlags &#123;</span><br><span class="line"></span><br><span class="line">  TEXT = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">// 32</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React：Symbol-Flag"><a href="#React：Symbol-Flag" class="headerlink" title="React：Symbol Flag"></a>React：<code>Symbol Flag</code></h3><p>React16起，源码中的大多判断处理就依赖与Symbol常量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from ReactSymbols.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol内存占用小，也有不重复、“私有”的特点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_ELEMENT_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PORTAL_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.portal'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_FRAGMENT_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.fragment'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_STRICT_MODE_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.strict_mode'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PROFILER_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.profiler'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PROVIDER_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.provider'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from ReactTypes.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type ReactProvider&lt;T&gt; = &#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span> | number,<span class="comment">// 用Symbol可以避免一些如注入类的安全风险</span></span><br><span class="line">  type: ReactProviderType&lt;T&gt;,</span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    children?: ReactNodeList,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>从 <code>shared</code> 包中就不难发现，<code>shared</code>承担高频工具函数、标识和通用处理，也是整个框架中至关重要的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue3-和-React18-源码片段1——shared&quot;&gt;&lt;a href=&quot;#Vue3-和-React18-源码片段1——shared&quot; class=&quot;headerlink&quot; title=&quot;Vue3 和 React18 源码片段1——shared&quot;&gt;&lt;/a&gt;Vu
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://blog.michealwayne.cn/tags/React/"/>
    
      <category term="Vue" scheme="http://blog.michealwayne.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【应用】web内存分析及工具</title>
    <link href="http://blog.michealwayne.cn/2022/03/06/notes/web%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.michealwayne.cn/2022/03/06/notes/web内存分析及工具/</id>
    <published>2022-03-06T12:20:06.000Z</published>
    <updated>2022-03-07T05:27:30.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web内存分析及工具"><a href="#web内存分析及工具" class="headerlink" title="web内存分析及工具"></a>web内存分析及工具</h1><p>js 自带 GC（垃圾回收）机制，因此绝大多数 web 开发人员不会在日常开发中考虑内存情况（包括我自己），在多数业务场景中，这可能没有问题，但在一些核心web应用场景下（比如某个页面投放在一级tab下这种 WebView 基本不会销毁的场景，或者像 PhoneGap / Electron 这种以 WebView 渲染为主的应用），会造成一些白屏崩溃这种意想不到的bug，影响用户体验。</p><blockquote><p>*文中大多三方链接需要翻墙访问</p></blockquote><h2 id="内存泄漏的影响"><a href="#内存泄漏的影响" class="headerlink" title="内存泄漏的影响"></a>内存泄漏的影响</h2><p>对于用户来说，一般内存泄漏场景根本感知不到，但是一旦内存泄漏比较严重，用户的直观感觉就是页面/电脑开始操作卡顿、直到某一时刻彻底卡死或者页面/应用崩溃闪退，这种情况下会让用户对你的产品丧失信任感。</p><ul><li>PC 浏览器：浏览器卡顿、甚至崩溃</li><li>iOS：早期 UIWebView 由于与 app 共享内存空间， 会容易导致app/浏览器卡顿、白屏、甚至崩溃，甚至 input 传个大图/文件如果处理不当就直接崩；之后 WKWebView 虽然优化了 WebView 内存及管理，但仍存在很多bug，加上 iPhone 本身内存空间较小，综合起来还是容易出现卡顿、白屏、甚至崩溃问题；</li><li>安卓：相比 iPhone，安卓设备通常内存空间较大，且 WebView 的内存分配更足，这为 WebView 的稳定性提供了一些帮助，但是安卓由于生态混乱，加上引擎等对 js 支持的问题，会导致很多奇葩问题，更容易出现内存泄漏。容易出现卡顿、白屏、甚至崩溃问题；</li></ul><p>相比于 PC 端，移动端硬件条件往往较为落后，并且 WebView 环境和内存限制也更为严格。并且移动端由于存在系统限制，不像PC端能方便进行浏览器更新/切换，因此更难以通过环境改善进行WebView管理优化，因此移动端的内存问题会更为严重，需要得到足够的重视。</p><blockquote><p>通常 PC 端通过代码或引导浏览器更新/切换来减少内存问题，PC 应用也可以更新内核来优化环境，总体成本较小。移动端主流的优化手段就是优化内核/内存管理，有能力/有切实需求的往往会自研内核以减少内存问题，像很多安卓应用会基于 QQX5 进行改造，这些成本也往往较大并且还有宿主环境的限制要求。关于内存优化及管理本文就不做具体说明了。</p></blockquote><h3 id="SPA-页面需要更加关注"><a href="#SPA-页面需要更加关注" class="headerlink" title="SPA 页面需要更加关注"></a>SPA 页面需要更加关注</h3><p>在 SPA 页面中，内存并不会在每次导航切换时自动清除，相比于 MPA 更容易引发内存泄漏。因此SPA中事件监听、DOM操作、网络请求、定时器等都需要更加关注。</p><hr><p>真机内存检测</p><h2 id="最通用的检测手段——Chrome-DevTool"><a href="#最通用的检测手段——Chrome-DevTool" class="headerlink" title="最通用的检测手段——Chrome DevTool"></a>最通用的检测手段——Chrome DevTool</h2><h3 id="1-“任务管理器”——查看整体情况"><a href="#1-“任务管理器”——查看整体情况" class="headerlink" title="1.“任务管理器”——查看整体情况"></a>1.<code>“任务管理器”</code>——查看整体情况</h3><p>入口为 Chrome 右上角<code>设置 - 更多工具 - 任务管理器</code>（<code>Setting - More Tools - Task Manager</code>）。</p><p><img src="/images/webMemory/p-chrome-1.png" alt="p-chrome-1"></p><p>并且我们可以通过右键菜单选择需要展示的字段：</p><p><img src="/images/webMemory/p-chrome-2.png" alt="p-chrome-2"></p><p>其中字段说明：</p><ul><li>任务：<code>Task</code></li><li>个人资料：<code>Profile</code></li><li>内存占用空间：<code>Memory Footprint</code></li><li>CPU</li><li>网络：<code>Network</code></li><li>进程ID：<code>Process ID</code></li><li>图片缓存：<code>Image Cache</code></li><li>脚本缓存：<code>Script Cache</code></li><li>CSS缓存：<code>CSS Cache</code></li><li>GPU缓存：<code>GPU Memory</code></li><li>SQLite使用的内存：<code>SQLite Memory</code></li><li>NaCI调试端口：<code>NaCI Debug Port</code></li><li>JavaScript 使用的内存：<code>JavaScript Memory</code></li><li>闲置状态唤醒：<code>Idle Wake Ups</code></li><li>文件描述符：<code>File Descriptors</code></li><li>进程优先级：<code>Process Priority</code></li><li>正在使用相应拓展程序的活动数：<code>Keepalive Count</code></li></ul><h3 id="2-Performance——js-Heap-查看时间轴上的内存变化情况"><a href="#2-Performance——js-Heap-查看时间轴上的内存变化情况" class="headerlink" title="2.Performance——js Heap 查看时间轴上的内存变化情况"></a>2.<code>Performance</code>——<code>js Heap</code> 查看时间轴上的内存变化情况</h3><p>Performance 大家会用的相对多些，只要我们勾选了 <code>Memory</code> 便可以增加内存的变化统计。</p><p><img src="/images/webMemory/p-chrome-3.png" alt="p-chrome-3"></p><h4 id="Recorder，结合用户事件进行记录"><a href="#Recorder，结合用户事件进行记录" class="headerlink" title="*Recorder，结合用户事件进行记录"></a>*Recorder，结合用户事件进行记录</h4><p>Chrome 97开始支持（大约是在2021.10），可以作为 Performance 的 plus 版，增加了用户操作等相关的事件记录，以更好得定位具体操作场景：</p><p><img src="/images/webMemory/p-chrome-7.png" alt="p-chrome-7"></p><p><img src="/images/webMemory/p-chrome-8.png" alt="p-chrome-8"></p><blockquote><p>官网使用介绍：<a href="https://developer.chrome.com/docs/devtools/recorder/" target="_blank" rel="noopener">《Chrome Developers——Record, replay and measure user flows》</a></p></blockquote><h3 id="3-Memory-——查看某段-一时刻内存具体快照信息"><a href="#3-Memory-——查看某段-一时刻内存具体快照信息" class="headerlink" title="3.Memory ——查看某段/一时刻内存具体快照信息"></a>3.<code>Memory</code> ——查看某段/一时刻内存具体快照信息</h3><p>真要定位内存问题，这是必不可少的工具，它的使用也比较简单。</p><p><img src="/images/webMemory/p-chrome-4.png" alt="p-chrome-4"></p><p>选择模式：</p><ul><li><code>Heap snapshot</code>：堆快照，用以打印堆快照，堆快照文件显示页面的 js 对象和相关 DOM 节点之间的内存分配；</li><li><code>Allocation instrumentation on timeline</code>: 在时间轴上记录内存信息，随着时间变化记录内存信息；</li><li><code>Allocation sampling</code>： 内存信息采样，使用采样的方法记录内存分配。此配置文件类型具有最小的性能开销，可用于长时间运行的操作。它提供了由 js 执行堆栈细分的良好近似值分配。</li></ul><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>选择模式进行快照后，可通过右上选择模块进行筛选：</p><ul><li>快照查看方式：默认<code>Summary</code><ul><li><code>Summary</code>： 可以显示按构造函数名称分组的对象。使用此视图可以根据按构造函数名称分组的类型深入了解对象（及其内存使用），适用于跟踪 DOM 泄漏。</li><li><code>Comparison</code>： 可以显示两个快照之间的不同。使用此视图可以比较两个（或多个）内存快照在某个操作前后的差异。检查已释放内存的变化和参考计数，可以确认是否存在内存泄漏及其原因。</li><li><code>Containment</code>： 此视图提供了一种对象结构视图来分析内存使用，由顶级对象作为入口。</li><li><code>Statistic</code>：内存使用饼状的统计图。</li></ul></li><li>对象归类的筛选：对<code>Constructor</code>的筛选</li><li>对象选择：默认<code>All objects</code></li></ul><h4 id="展示字段"><a href="#展示字段" class="headerlink" title="展示字段"></a>展示字段</h4><p>表中展示字段的说明：</p><ul><li><code>Contructor</code>：表示使用此构造函数创建的所有对象</li><li><code>Distance</code>：显示使用节点最短简单路径时距根节点的距离</li><li><code>Shallow Size</code>： 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大）</li><li><code>Retained Size</code>： 显示同一组对象中最大的保留大小。某个对象删除后（其依赖项不再可到达）可以释放的内存大小称为保留大小。</li><li><code>New</code>：（Comparison 特有）新增项</li><li><code>Deleted</code>：（Comparison 特有）删除项</li><li><code>Delta</code>：（Comparison 特有）增量</li><li><code>Alloc. Size</code>：（Comparison 特有）内存分配大小</li><li><code>Freed Size</code>：（Comparison 特有）释放大小</li><li><code>Size Delta</code>：（Comparison 特有）内存增量</li></ul><blockquote><p>官网术语解释：<a href="https://developer.chrome.com/docs/devtools/memory-problems/memory-101/" target="_blank" rel="noopener">《Chrome Developers——Memory terminology》</a></p></blockquote><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p><code>ctrl/command + F</code> 唤醒搜索，根据关键字进行筛选</p><p><img src="/images/webMemory/p-chrome-5.png" alt="p-chrome-5"></p><h3 id="4-Performance-monitor——简易查看"><a href="#4-Performance-monitor——简易查看" class="headerlink" title="4.Performance monitor——简易查看"></a>4.<code>Performance monitor</code>——简易查看</h3><p><img src="/images/webMemory/p-chrome-6.png" alt="p-chrome-6"></p><p>Performance monitor 是实时的，但是没办法看到细节信息。</p><p>Chrome排查内存的手段和场景还有很多，如</p><ul><li>检查ArrayBuffer<a href="https://developer.chrome.com/docs/devtools/memory-inspector/" target="_blank" rel="noopener">《Chrome Developers——Inspect JavaScript ArrayBuffer with the Memory inspector》</a></li></ul><hr><h2 id="移动端——Chrome-Safari"><a href="#移动端——Chrome-Safari" class="headerlink" title="移动端——Chrome/Safari"></a>移动端——Chrome/Safari</h2><p>相比于PC，移动端真机调试一直是比较麻烦的，特别是内存分析难以像样式调试这种可以借助一些 socket 连接手段（<a href="https://caniuse.com/mdn-api_performance_memory" target="_blank" rel="noopener">Performance Memory</a>兼容拉跨），所以要查看移动端页面的真实内存使用情况需要设备/环境帮助。</p><h3 id="iOS——Safari"><a href="#iOS——Safari" class="headerlink" title="iOS——Safari"></a>iOS——Safari</h3><p>有线，需要有一台 iPhone 、Mac 和数据线。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.确认手机设置（<code>设置</code> -&gt; <code>Safari</code> -&gt; <code>高级</code> -&gt; <code>Web检查器</code>为打开状态）；</li><li>2.USB连接真机；</li><li>3.确认设备信任；</li><li>4.手机和电脑都打开Safari；</li><li>5.Safari菜单中<code>开发</code>-<code>XXX 的 iPhone</code>，点击开始调试。</li></ul><p>注意如果要看时间线的内存变化，菜单选择为<code>时间线</code>、左侧编程选中<code>内存</code>模块，如：</p><p><img src="/images/webMemory/p-safari-1.png" alt="p-safari-1.jpg"></p><blockquote><p>特别提醒，要查看内存情况的话最好只选择<code>内存</code>一个指标模块，有多个指标选择的话容易 Safari 崩溃闪退。</p></blockquote><blockquote><p>*iOS 也能通过 ios-webkit-debug-proxy 然后使用 Chrome 进行调试，本身机制也是通过创建代理服务器与 Chrome 进行连接，可参考这篇文章：<a href="https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7" target="_blank" rel="noopener">《How to debug remote iOS device using Chrome DevTools》</a></p></blockquote><h3 id="安卓-鸿蒙——Chrome-Android-Studio"><a href="#安卓-鸿蒙——Chrome-Android-Studio" class="headerlink" title="安卓/鸿蒙——Chrome/Android Studio"></a>安卓/鸿蒙——Chrome/Android Studio</h3><p>与iOS调试比较类似，有线，需要有一台 安卓手机 、Windows/Mac电脑 和数据线。</p><blockquote><p>Chrome官方说明：<a href="https://developer.chrome.com/docs/devtools/remote-debugging/" target="_blank" rel="noopener">《Chrome Developers——Remote debug Android devices》</a></p></blockquote><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.确认手机设置（<code>开发者模式</code>打开 -&gt; <code>USB调试</code>打开状态）；</li><li>2.USB连接真机；</li><li>3.确认设备信任；</li><li>4.手机和电脑都打开 Chrome；</li><li>5.PC Chrome访问<code>chrome://inspect</code>：确认连接状态<br>  <img src="/images/webMemory/p-dchrome-1.png" alt="p-dchrome-1.jpg"></li><li>6.选择对应页面的’inspect’进行访问<br>  <img src="/images/webMemory/p-dchrome-2.png" alt="p-dchrome-2.jpg"></li></ul><p>Android Studio 的调试模式与 Chrome 类似，也依赖 Chrome，操作可以参考<a href="https://raygun.com/blog/debug-android-chrome/" target="_blank" rel="noopener">《How to debug Android Chrome from Windows, Linux, or Mac——Install Android Debug Bridge (ADB)》</a></p><blockquote><p>特别提醒：如果通过<code>&#39;inspect&#39;</code>进行访问时，发现调试控制台始终空白或者404，大概率为控制台涉及的js文件加载失败，大部分js文件需要翻墙访问，这时候需要翻一下。</p></blockquote><h4 id="有没有不用插线的远程方法"><a href="#有没有不用插线的远程方法" class="headerlink" title="有没有不用插线的远程方法"></a>有没有不用插线的远程方法</h4><p>有，但是需要设备在一个网段。在开发电脑上建立个 Web 服务器并托管一个站点，然后从 Android 设备访问内容。具体可以查看文档说明：<a href="https://developer.chrome.com/docs/devtools/remote-debugging/local-server/" target="_blank" rel="noopener">《Chrome Developers——Access local servers》</a></p><h3 id="app内页面"><a href="#app内页面" class="headerlink" title="app内页面"></a>app内页面</h3><p>一般通用的方案就是装 debug app，然后可以通过 IDE debug 或者再借助 Safari/Chrome。这种方式的主要问题就是有 debug 包及环境的要求；<br>要么就是用客户端开发的模拟器进行排查。这种方式的主要问题就是因为是模拟环境，与真实环境有一定区别；<br>要么就是客户端提供控制台，将内存信息放到控制台中展示，如滴滴的<a href="https://github.com/didi/DoraemonKit" target="_blank" rel="noopener">DoraemonKit</a>，但要注意，iOS 现在 App 基本会用 WKWebView，这种情况下客户端是拿不到页面（WebView）的内存信息的（因为系统共享 WebView 虚拟内存），因此像 DoraemonKit 的内存模块也是无法观察页面内存情况，这时候的方案就是获取整个设备的内存信息，通过观察设备内存变化来进行判断，缺点就是难以保证其他应用及系统的影响；</p><p>iOS 开发获取内存的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前app消耗的内存，注意捕获不了WebView的内存消耗</span><br><span class="line">+ (NSUInteger)useMemoryForApp &#123;</span><br><span class="line">  task_vm_info_data_t vmInfo;</span><br><span class="line">  mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">  kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">  if (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">    int64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;</span><br><span class="line">return memoryUsageInByte / 1024 / 1024;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取整个设备的内存情况</span><br><span class="line">+ (NSUInteger)totalMemoryForDevice &#123;</span><br><span class="line">  return [NSProcessInfo processInfo].physicalMemory / 1024 / 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="js-VM"><a href="#js-VM" class="headerlink" title="*js VM"></a>*js VM</h4><p>最后还有一种方式就是利用Chrome和服务器搭建一套js VM 调试生态，如下小程序开发者工具也是这种模式，有兴趣可以看下Chrome DevTools Protocol： <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">https://chromedevtools.github.io/devtools-protocol/</a></p><h3 id="小程序——开发者工具"><a href="#小程序——开发者工具" class="headerlink" title="小程序——开发者工具"></a>小程序——开发者工具</h3><p>像微信/支付宝的小程序开发者工具，通常都较好得利用了Chrome 67起支持的<a href="https://developer.chrome.com/blog/new-in-devtools-67/#vm" target="_blank" rel="noopener">js VM内存工具</a>，因此可以非常方便得远程进行真机内存分析。</p><p><img src="/images/webMemory/p-weapp-1.png" alt="p-weapp-1.jpg"></p><hr><p>借助 Puppeteer，我们可以做到内存检测的自动化</p><h2 id="快速手段——FuiteJs"><a href="#快速手段——FuiteJs" class="headerlink" title="快速手段——FuiteJs"></a>快速手段——FuiteJs</h2><p>github地址：<a href="https://github.com/nolanlawson/fuite" target="_blank" rel="noopener">https://github.com/nolanlawson/fuite</a></p><p>Fuite是一个 js 写的 cli 工具，它基于 <a href="https://pptr.dev/" target="_blank" rel="noopener">Puppeteer</a> 分析页面是否存在内存泄漏，对SPA友好</p><blockquote><p>注意：Fuite需要 nodejs v14.14.0及以上的环境，（目前 nodejs 稳定版在16+）</p></blockquote><h3 id="原理机制"><a href="#原理机制" class="headerlink" title="原理机制"></a>原理机制</h3><p>Fuite 比较简单，主要通过监控路由跳转来判断是否存在内存泄漏：</p><ul><li>1.使用 Puppeteer 打开对于参数的页面；</li><li>2.找到页面中所有路由页面并打开；</li><li>3.模拟后退（路由返回）；</li><li>4.重复（默认为7次）以确认是否存在内存泄漏。整个库的主要逻辑处理就是这块。判断依据：<ul><li>Objects：对象（Chrome heap snapshots）</li><li>Event listeners：事件监听</li><li>DOM节点</li><li>Arrays, Maps, Sets、普通Object</li></ul></li></ul><p>如果 Fuite 发现存在泄漏情况，它将在控制台或者 output文件中展示信息。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h4><p>安装及测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx fuite https://blog.michealwayne.cn</span><br></pre></td></tr></table></figure><p>使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuite [options] &lt;url&gt;</span><br></pre></td></tr></table></figure></p><p>参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url                        URL to load in the browser and analyze</span><br></pre></td></tr></table></figure></p><p>其中Options:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-o, --output &lt;file&gt;        Write JSON output to a file</span><br><span class="line">-i, --iterations &lt;number&gt;  Number of iterations (default: 7)</span><br><span class="line">-s, --scenario &lt;scenario&gt;  Scenario file to run</span><br><span class="line">-S, --setup &lt;setup&gt;        Setup function to run</span><br><span class="line">-H, --heapsnapshot         Save heapsnapshot files</span><br><span class="line">-d, --debug                Run in debug mode</span><br><span class="line">-p, --progress             Show progress spinner (use --no-progress to disable)</span><br><span class="line">-b, --browser-arg &lt;arg&gt;    Arg(s) to pass when launching the browser</span><br><span class="line">-V, --version              output the version number</span><br><span class="line">-h, --help                 display help for command</span><br></pre></td></tr></table></figure></p><h4 id="引用式"><a href="#引用式" class="headerlink" title="引用式"></a>引用式</h4><pre><code class="js"><span class="keyword">import</span> { findLeaks } <span class="keyword">from</span> <span class="string">'fuite'</span>;<span class="keyword">const</span> myScenario = {  <span class="keyword">async</span> setup(page) { <span class="comment">/* ... */</span> },            <span class="comment">// 默认无</span>  <span class="keyword">async</span> createTests(page) { <span class="comment">/* ... */</span> },    <span class="comment">// 默认拿href</span>  <span class="keyword">async</span> iteration(page, data) { <span class="comment">/* ... */</span> }    <span class="comment">// 默认为页面后退的往返</span>};<span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> result <span class="keyword">of</span> findLeaks(<span class="string">'https://blog.michealwayne.cn'</span>, {  scenario: myScenario,        <span class="comment">// scenario参数可选，默认为defaultScenario</span>})) {  <span class="built_in">console</span>.log(result);}</code></pre><blockquote><p>有意思的是，Fuite 的作者用 Fuite 对10个前端主流框架的主页进行了测试，发现都存在泄漏问题（作者在统计中隐藏了具体名称，有兴趣可以试一下）：</p></blockquote><p><img src="/images/webMemory/p-author-page-1.png" alt="p-author-page-1.jpg"></p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>我们可以扩展延伸 Fuite 的功能和使用场景，以更好地服务业务内存检测：</p><ul><li>1.服务化：我们可以将 Fuite 放在服务器，通过配置化进行定时检查，以及对应的异常报警等，将内存检测服务化、平台化；</li><li>2.集群处理：使用 Fuite 通常耗时会比较久，如果有多个地址需要检测的话建议起多进程集群进行分开检测；</li><li>3.改造：Fuite 逻辑是获取页面中所有路由进行检测，我们可以调整筛选控制，并且对 MPA 的处理进行业务优化，以提升检测效率和覆盖率。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>并非所有内存泄漏都是需要解决的问题，如 v8 的 JIT 也会导致内存增长，但作为 web 开发者，我们有义务通过工具方法找出业务中所有内存泄漏的场景。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://developer.chrome.com/docs/devtools/open/" target="_blank" rel="noopener">https://developer.chrome.com/docs/devtools/open/</a></li><li><a href="https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/" target="_blank" rel="noopener">https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/</a></li><li><a href="https://developer.chrome.com/docs/devtools/memory-problems/" target="_blank" rel="noopener">https://developer.chrome.com/docs/devtools/memory-problems/</a></li><li><a href="https://github.com/nolanlawson/fuite" target="_blank" rel="noopener">https://github.com/nolanlawson/fuite</a></li><li><a href="https://developer.chrome.com/blog/new-in-devtools-67/" target="_blank" rel="noopener">https://developer.chrome.com/blog/new-in-devtools-67/</a></li><li><a href="https://gilfink.medium.com/help-my-memory-is-leaking-bf5dcaf83fc6" target="_blank" rel="noopener">https://gilfink.medium.com/help-my-memory-is-leaking-bf5dcaf83fc6</a></li><li><a href="https://chromedevtools.github.io/" target="_blank" rel="noopener">https://chromedevtools.github.io/</a></li><li><a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">https://chromedevtools.github.io/devtools-protocol/</a></li><li><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="noopener">https://github.com/google/ios-webkit-debug-proxy</a></li><li><a href="https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7" target="_blank" rel="noopener">https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7</a></li><li><a href="https://raygun.com/blog/debug-android-chrome/" target="_blank" rel="noopener">https://raygun.com/blog/debug-android-chrome/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web内存分析及工具&quot;&gt;&lt;a href=&quot;#web内存分析及工具&quot; class=&quot;headerlink&quot; title=&quot;web内存分析及工具&quot;&gt;&lt;/a&gt;web内存分析及工具&lt;/h1&gt;&lt;p&gt;js 自带 GC（垃圾回收）机制，因此绝大多数 web 开发人员不会在日常开
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="工具" scheme="http://blog.michealwayne.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="前端" scheme="http://blog.michealwayne.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="调试" scheme="http://blog.michealwayne.cn/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】包管理工具pnpm整理</title>
    <link href="http://blog.michealwayne.cn/2022/02/19/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pnpm%E6%95%B4%E7%90%86/"/>
    <id>http://blog.michealwayne.cn/2022/02/19/notes/【笔记】包管理工具pnpm整理/</id>
    <published>2022-02-19T03:21:10.000Z</published>
    <updated>2022-03-09T09:10:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包管理工具-pnpm-整理"><a href="#包管理工具-pnpm-整理" class="headerlink" title="包管理工具 pnpm 整理"></a>包管理工具 pnpm 整理</h1><p>官网：<a href="https://pnpm.io/" target="_blank" rel="noopener">https://pnpm.io/</a>，github：<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">https://github.com/pnpm/pnpm</a></p><blockquote><p>其实 pnpm 官网从使用、特性、原理社区等建设得都很细致，真正打算使用的话建议通读下官网。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><p>Fast, disk space efficient package manager</p></blockquote><p>pnpm 也是一款包管理工具，这点与 npm/yarn/cnpm/tnpm 一样，目前主流版本为<code>6.x</code>，<code>7.0</code>也已开始。</p><p><img src="/images/pnpm/p-download.png" alt="p-download.png"></p><p>其实 pnpm 是一个挺早的项目，在 21 年才在国内火了起来。</p><p>截止目前（2022.02.19）来看，该<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">项目</a>已上升至 15k 的 star，并且像 vue3 等一些著名项目也开始使用了 pnpm：</p><p><img src="/images/pnpm/p-vue.jpg" alt="p-vue.jpg"></p><p>从<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">源码</a>来看，pnpm 是一个高浓度 TypeScript 项目（目前代码中 99%+都是 ts），所以源码方面可以放心食用。</p><ul><li>从依赖来看，可以重点留意<a href="https://www.npmjs.com/package/verdaccio" target="_blank" rel="noopener">verdaccio</a>和<a href="https://www.npmjs.com/package/c8" target="_blank" rel="noopener">c8</a>，这是 npm 注册及管理的工具；并且源码中多包使用了<a href="https://www.npmjs.com/package/syncpack" target="_blank" rel="noopener">syncpack</a></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>直接拿官网的宣称：pnpm 是一款快速、节省磁盘空间的包管理器。</p><ul><li>快速：pnpm 比替代方案（yarn/npm 等）快 2 倍</li><li>高效：node_modules 中的文件是从一个单一的可内容寻址的存储中链接过来的</li><li>支持 monorepos：pnpm 内置支持了单仓多包</li><li>严格：pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li></ul><p>pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，核心优势就是<strong>快</strong>以及<strong>磁盘利用得好</strong>。其他优势也可以在作者 blog 中查看：<a href="https://www.kochan.io/" target="_blank" rel="noopener">https://www.kochan.io/</a></p><p>以下是一些比较数据，也可以在官网上看到：</p><p><img src="/images/pnpm/p-compare-1.png" alt="p-compare-1"></p><p><img src="/images/pnpm/p-compare-2.png" alt="p-compare-2"></p><h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>根据核心优势，就需要大致了解下 node_modules 的安装和依赖模式：</p><ul><li><p>Nested installation（嵌套安装）: 在 <code>npm@3</code> 之前，<code>node_modules</code> 结构是干净、可预测的，因为 <code>node_modules</code> 中的每个依赖项都有自己的 <code>node_modules</code> 文件夹，在 <code>package.json</code> 中指定了所有依赖项。结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">  - package A</span><br><span class="line">      - packageX 1.0</span><br><span class="line">      - packageY 1.0</span><br><span class="line">  - package B</span><br><span class="line">      - packageX 2.0</span><br><span class="line">      - packageY 2.0</span><br><span class="line">  - package C</span><br><span class="line">      - packageX 1.0</span><br><span class="line">      - packageY 2.0</span><br><span class="line">  - package D</span><br><span class="line">      - packageX 2.0</span><br><span class="line">      - packageY 1.0</span><br></pre></td></tr></table></figure></li><li><p>Flat installation（扁平安装）：<code>npm@3 / yarn</code>，扁平化结构，多个版本的包只能有一个被提升上来（hoist 机制），优势就是避免了一些重复，其余版本的包会嵌套安装到各自的依赖当中（类似 npm2 的结构），至于哪个版本的包被提升，依赖于包的安装顺序。结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    - package X =&gt; 1.0 版本</span><br><span class="line">    - package Y =&gt; 1.0 版本</span><br><span class="line"></span><br><span class="line">    - package A</span><br><span class="line">    - package B</span><br><span class="line">        - packageX 2.0</span><br><span class="line">        - packageY 2.0</span><br><span class="line">    - package C</span><br><span class="line">        - packageY 2.0</span><br><span class="line">    - package D</span><br><span class="line">        - packageX 2.0</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure></li></ul><p>pnpm 既然改了依赖方式，那么就可以看当前模式的主要问题：</p><ul><li>重复安装，如上所示的 packageX 2.0 和 packageY 2.0 被重复安装多次，从而造成 npm 和 yarn 的性能一些性能损失。这种场景在 monorepo 多包场景下尤其明显，另外扁平化的算法实现也相当复杂，改动成本很高。</li><li>Phantom dependencies，幽灵依赖或幻影依赖，即某个包没有在 <code>package.json</code> 被依赖，但是用户却能够引用到这个包。</li></ul><p>pnpm 的改变：</p><ul><li><p>Net 网状 + Flat 平铺 的 <code>node_modules</code> 结构</p><ul><li>虚拟存储目录：<code>.pnpm</code>， 以平铺的形式储存着所有的包，正常的包都可以在这种命名模式的文件夹中被找到（peerDep 例外）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.pnpm/&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span><br><span class="line"></span><br><span class="line">// 组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称)</span><br></pre></td></tr></table></figure><p>该目录通过<code>&lt;package-name&gt;@&lt;version&gt;</code>来实现相同模块不同版本之间隔离和复用，由于它只会根据项目中的依赖生成，并不存在提升，所以不存在幽灵依赖。</p></li></ul><p>结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    - .pnpm</span><br><span class="line">        - package A</span><br><span class="line">            - node_modules</span><br><span class="line">                - A -&gt; &lt;store&gt;/A</span><br><span class="line">                    - index.js</span><br><span class="line">                    - package.json</span><br><span class="line">    - package B</span><br><span class="line">        - node_modules</span><br><span class="line">                - B -&gt; &lt;store&gt;/B</span><br><span class="line">                    - index.js</span><br><span class="line">                    - package.json</span><br></pre></td></tr></table></figure><p>如官网描述：<br><img src="/images/pnpm/p-pnpm-nodemodules.png" alt="p-pnpm-nodemodules.png"></p><p>那么它如何跟文件资源进行关联的呢？答案是 Store + Links，可以看官网介绍<a href="https://pnpm.io/symlinked-node-modules-structure" target="_blank" rel="noopener">《Symlinked <code>node_modules</code> structure》</a>或掘金上这篇易于理解的文章<a href="https://juejin.cn/post/7053340250210795557#heading-6" target="_blank" rel="noopener">《pnpm 的破解之道：网状 + 平铺的 node_modules 结构》</a></p><p>根目录下的 <code>node_modules</code> 下面不再是眼花缭乱的依赖，而是跟 <code>package.json</code> 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 <code>node_modules</code> 当中，但整体上，根目录的 <code>node_modules</code> 比以前还是清晰和规范了许多。</p><p>pnpm 这种依赖管理的方式也巧妙地规避了非法访问依赖的问题，pnpm 不允许安装 <code>package.json</code> 中没有包含的包，也就是说只要一个包未在 <code>package.json</code> 中声明依赖，那么在项目中是无法访问的。</p><blockquote><p>在此背景情况下，据说 yarn 也计划开始存储模式的优化。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在 <code>node_modules</code> 的依赖模式改变下，因为软链的关系必然也会导致一些问题：</p><ul><li>1.子依赖提升到同级的目录结构的兼容性问题，类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配；</li><li>2.软链在不同操作系统的实现不太一样，且在非 SSD 的硬盘上，还是会有一定的磁盘 io 损耗的。</li><li>3.多包某种情况下，依赖出现两次：可见官网说明<a href="https://pnpm.io/how-peers-are-resolved" target="_blank" rel="noopener">https://pnpm.io/how-peers-are-resolved</a></li></ul><p>其余大部分问题可在<a href="https://pnpm.io/zh/faq" target="_blank" rel="noopener">官网 faq</a>中找到，也可以看 github 上一些 <a href="https://github.com/pnpm/pnpm/issues" target="_blank" rel="noopener">issue</a> 反馈，包括现在的问题：</p><p><img src="/images/pnpm/p-bugs.jpg" alt="p-bugs.jpg"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>极为简单</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pnpm</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>与 yarn 类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pnpm add xxx  <span class="comment"># 安装xxx到dependencies</span></span><br><span class="line"></span><br><span class="line">pnpm add -D xxx  <span class="comment"># 安装xxx到devDependencies</span></span><br><span class="line"></span><br><span class="line">pnpm install <span class="comment"># 安装项目所有依赖</span></span><br><span class="line"></span><br><span class="line">pnpm install -S xxx 安装xxx并添加到dependencies</span><br><span class="line"></span><br><span class="line">pnpm remove xxx <span class="comment"># 删除dependencies中的xxx</span></span><br><span class="line"></span><br><span class="line">pnpm remove -D xxx <span class="comment"># 删除devDependencies中的xxx</span></span><br></pre></td></tr></table></figure><h4 id="pnpm-workspace-yaml"><a href="#pnpm-workspace-yaml" class="headerlink" title="pnpm-workspace.yaml"></a><code>pnpm-workspace.yaml</code></h4><p>此文件定义了工作空间的根目录，并能够使您从工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pnpm-workspace.yaml</span><br><span class="line">packages:</span><br><span class="line">  # 所有在 packages/ 和 components/ 子目录下的 package</span><br><span class="line">  - &apos;packages/**&apos;</span><br><span class="line">  - &apos;components/**&apos;</span><br><span class="line">  # 不包括在 test 文件夹下的 package</span><br><span class="line">  - &apos;!**/test/**&apos;</span><br></pre></td></tr></table></figure><p>其他如钩子、别名等不太常用的功能查询官网<a href="https://pnpm.io/zh/motivation" target="_blank" rel="noopener">https://pnpm.io/zh/motivation</a>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>新的工具必然带来性能/空间上的提升，但在业务使用中我们需要注意它的隐患，避免乐观主义陷阱。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://pnpm.io/" target="_blank" rel="noopener">https://pnpm.io/</a></li><li><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">https://github.com/pnpm/pnpm</a></li><li><a href="https://pnpm.io/zh/blog" target="_blank" rel="noopener">https://pnpm.io/zh/blog</a></li><li><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">https://www.kochan.io/nodejs/why-should-we-use-pnpm.html</a></li><li><a href="https://juejin.cn/post/7053340250210795557#heading-6" target="_blank" rel="noopener">https://juejin.cn/post/7053340250210795557#heading-6</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;包管理工具-pnpm-整理&quot;&gt;&lt;a href=&quot;#包管理工具-pnpm-整理&quot; class=&quot;headerlink&quot; title=&quot;包管理工具 pnpm 整理&quot;&gt;&lt;/a&gt;包管理工具 pnpm 整理&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;https://pnpm.i
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nodejs" scheme="http://blog.michealwayne.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>js 中 parseInt 和 parseFloat 的执行机制</title>
    <link href="http://blog.michealwayne.cn/2022/01/03/notes/%E7%BB%86%E8%B0%88js%E4%B8%AD%E7%9A%84parseInt%E5%92%8CparseFloat/"/>
    <id>http://blog.michealwayne.cn/2022/01/03/notes/细谈js中的parseInt和parseFloat/</id>
    <published>2022-01-03T11:38:23.000Z</published>
    <updated>2022-01-11T05:13:52.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-中-parseInt-和-parseFloat-的执行机制"><a href="#js-中-parseInt-和-parseFloat-的执行机制" class="headerlink" title="js 中 parseInt 和 parseFloat 的执行机制"></a>js 中 parseInt 和 parseFloat 的执行机制</h1><p><code>parseInt()</code>和<code>parseFloat()</code>这两个常用 API 其实还是有很多“坑”的，最近发现有同学不小心踩到了，再加上挺久没看 js 了，便以此文统一梳理一下。（本文比较适合常与数字打交道的 jser 或对这两 API 运作感兴趣的同学）</p><h2 id="执行检验"><a href="#执行检验" class="headerlink" title="执行检验"></a>执行检验</h2><blockquote><p>在 19 年描述 js 数值时（<a href="https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md#q3%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%95%B0%E5%AD%97%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">Q3.说出以下转换数字数值转换的结果</a>），有提到 <code>parseInt</code>和<code>parseFloat</code>的运行机制，其实这两 API 还是有蛮多坑的，虽然平时不太会踩到。</p></blockquote><p>首先猜测以下执行自我检验一番：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parseInt */</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123abc'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc123'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e6'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'    1    '</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x11'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'a'</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1e6</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1n</span>);</span><br><span class="line"><span class="built_in">parseInt</span>();</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个“超纲”题</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.00000001</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">-99999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">99999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">9999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">9999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'11111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'11111111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1e21</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123aef'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xf'</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'111'</span>, <span class="number">2</span> ** <span class="number">32</span> + <span class="number">2.1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="keyword">const</span> objTest1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">parseInt</span>(objTest1);</span><br><span class="line">objTest1.toString = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>;</span><br><span class="line"><span class="built_in">parseInt</span>(objTest1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parseFloat */</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123abc.456.789'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'    123abc    '</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1e6'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'+Infinity'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">123.456</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1e6</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">0.00000001</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0x1a'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1n</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>();</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个“超纲”题</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">9999999999999999</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11111111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="built_in">parseFloat</span>);</span><br><span class="line"><span class="keyword">const</span> objTest2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">parseFloat</span>(objTest2);</span><br><span class="line">objTest2.toString = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>;</span><br><span class="line"><span class="built_in">parseFloat</span>(objTest2);</span><br></pre></td></tr></table></figure><h2 id="ECMAScript-规范"><a href="#ECMAScript-规范" class="headerlink" title="ECMAScript 规范"></a>ECMAScript 规范</h2><p>无论啥内核、浏览器或是 NodeJs，都会遵循 ECMA 的主要规范，因此要思考上列的执行结果，可以重点了解 ECMA 规范的执行描述。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a><code>parseInt()</code></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure><p>其中参数：</p><ul><li><code>string</code>：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。标准输入：<br><img src="/images/js/parseInt/p-parseInt-input-string.jpg" alt="p-parseInt-input-string.jpg"></li><li><code>radix</code>：<strong>可选</strong>，介于<code>2</code>~<code>36</code>之间的整数。告知<code>parseInt()</code>函数<code>string</code>（比如 11）是<code>radix</code>（比如 2）进制的表示，如果<code>radix</code>不存在，<code>parseInt</code>将固定返回<code>string</code>以十进制显示的数。</li></ul><p>另外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span> === <span class="built_in">Number</span>.parseInt; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="ECMAScript（6-0）-规范说明"><a href="#ECMAScript（6-0）-规范说明" class="headerlink" title="ECMAScript（6.0） 规范说明"></a>ECMAScript（6.0） 规范说明</h4><p>官网描述：<br><img src="/images/js/parseInt/p-parseInt-1.jpg" alt="p-parseInt-1.jpg"></p><p>简单翻译一下执行步骤：</p><ul><li>1.定义变量<code>inputString</code>，它是入参<code>string</code>执行 <code>ToString(string)</code> 的字符串结果。（<code>ToString</code>是一个内部 abstract operations、不对外，具体执行见<a href="https://262.ecma-international.org/6.0/#sec-tostring" target="_blank" rel="noopener">文档</a>或文末附录）；</li><li>2.执行出现异常则返回（<a href="https://262.ecma-international.org/6.0/#sec-returnifabrupt" target="_blank" rel="noopener"><code>ReturnIfAbrupt</code></a>，关于<code>ReturnIfAbrupt</code>的执行其实还蛮复杂的，涉及 ECMA 规范的规格术语，本文不做描述）；</li><li>3.定义变量<code>S</code>，它是<code>inputString</code>创建的一个子字符串，它由第一个不是空白字符的代码单元和该代码单元之后的所有代码单元组成，即去除前置空格，也就是说<code>parseInt(&#39;123&#39;)</code>和<code>parseInt(&#39; 123&#39;)</code>效果相同。如果找不到这样的单元，则<code>S</code>为空字符串（<code>&quot;&quot;</code>）；</li><li>4.定义变量<code>sign</code>为<code>1</code>；</li><li>5.如果变量<code>S</code>不为空并且<code>S</code>的第一个单元是<code>0x002D</code> （<code>HYPHEN-MINUS</code>，即减号），变量<code>sign</code>改为<code>-1</code>；</li><li>6.如果变量<code>S</code>不为空并且<code>S</code>的第一个单元是<code>0x002B</code> （<code>PLUS SIGN</code>，即加号） 或<code>0x002D</code> （HYPHEN-MINUS，即减号），去除<code>S</code>的第一个单元，即去除<code>&#39;+&#39;</code>/<code>-</code>符号；</li><li>7.定义变量<code>R</code>为<code>ToInt32(radix)</code>，即对进制声明进行<a href="https://262.ecma-international.org/6.0/#sec-toint32" target="_blank" rel="noopener">ToInt32</a>数字转换，也就是说<code>parseInt(&#39;123&#39;, 8)</code> 和 <code>parseInt(&#39;123&#39;, &#39;8&#39;)</code>效果相同；</li><li>8.执行出现异常则返回（<code>ReturnIfAbrupt</code>）；</li><li>9.定义变量<code>stripPrefix</code> 为 <code>true</code>；</li><li>10.如果变量<code>R</code>不等于<code>0</code>，则：<ul><li>如果变量<code>R</code>小于 2 或大于 36，直接返回<code>NaN</code>；</li><li>如果变量<code>R</code>不等于 16，变量<code>stripPrefix</code> 改为 <code>false</code>；</li></ul></li><li>11.如果变量<code>R</code>等于<code>0</code>，则变量<code>R</code>改为<code>10</code>；</li><li>12.如果变量<code>stripPrefix</code>值为<code>true</code>，则：<ul><li>如果变量<code>S</code>字符串长度不小于 2 并且前两个字符单元是<code>0x</code>或<code>0X</code>，则删除这两字符，且设置变量<code>R</code>为<code>16</code>；</li></ul></li><li>13.设置变量<code>Z</code>，如果变量<code>S</code>包含一个不是变量<code>R</code>数字的字符单元，则<code>Z</code>为<code>S</code>的子字符串，且由第一个这样的字符单元之前的所有代码单元组成，即<code>parseInt(&#39;789&#39;, 8)</code>和<code>parseInt(&#39;7&#39;, 8)</code>效果相同；否则，<code>Z</code> 为 <code>S</code>；</li><li>14.如果变量<code>Z</code>为空，直接返回<code>NaN</code>；</li><li>15.设置变量<code>mathInt</code>为由<code>Z</code>以基数<code>R</code>进行表示的数学进制整数值，其中使用字母<code>A-Z</code>和<code>a-z</code>表示值为 10 ～ 35 的数字（如果<code>R</code>为 10，且<code>Z</code>包含 20 个以上的有效数字，则根据实现的选择，第 20 位之后的每个有效数字都可以替换为 0）<br>，如果 <code>R</code> 不是 2、4、8、10、16 或 32，则 <code>mathInt</code> 可能是对数学整数值的依赖实现的近似值，该值由 <code>Z</code> 以基数<code>R</code> 表示法表示。</li><li>16.如果<code>mathInt</code>等于 0，则：<ul><li>如果<code>sign</code>等于-1，则返回<code>-0</code>；</li><li>否则返回<code>+0</code>；</li></ul></li><li>17.设置变量<code>number</code>为<code>mathInt</code>的 Number 值；</li><li>18.返回<code>sign * number</code></li></ul><p>看起来有点复杂，画了个流程图：<br><img src="/images/js/parseInt/p-rule_parseInt.png" alt="p-rule_parseInt.png"></p><blockquote><p><code>parseInt()</code> 只能将字符串的前导部分解释为整数值；它忽略任何不能被解释为整数符号的一部分的代码单元，并且没有给出任何此类代码单元被忽略的迹象。</p></blockquote><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a><code>parseFloat()</code></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(string)</span><br></pre></td></tr></table></figure><p>其中参数：</p><ul><li><code>string</code>：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。标准输入：<br><img src="/images/js/parseInt/p-parseFloat-input-string.jpg" alt="p-parseFloat-input-string.jpg"></li></ul><p>另外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span> === <span class="built_in">Number</span>.parseFloat; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="ECMAScript（6-0）-规范"><a href="#ECMAScript（6-0）-规范" class="headerlink" title="ECMAScript（6.0） 规范"></a>ECMAScript（6.0） 规范</h4><p>官网描述：</p><p><img src="/images/js/parseInt/p-parseFloat-1.jpg" alt="p-parseFloat-1.jpg"></p><p>执行步骤：</p><ul><li>1.定义变量<code>inputString</code>，它是入参<code>string</code>执行 <code>ToString(string)</code> 的字符串结果。；</li><li>2.执行出现异常则返回（<code>ReturnIfAbrupt</code>）；</li><li>3.定义变量<code>trimmedString</code>，它是<code>inputString</code>创建的一个子字符串，它由第一个不是空白字符的代码单元和该代码单元之后的所有代码单元组成，即去除前置空格，也就是说<code>parseFloat(&#39;123.456&#39;)</code>和<code>parseFloat(&#39; 123.456&#39;)</code>效果相同。如果找不到这样的单元，边<code>trimmedString</code>为空字符串（<code>&quot;&quot;</code>）；</li><li>4.如果<code>trimmedString</code>或<code>trimmedString</code>的任何前缀都不满足<a href="https://262.ecma-international.org/6.0/#sec-tonumber-applied-to-the-string-type" target="_blank" rel="noopener"><code>StrDecimalLiteral</code></a>的语法，则返回<code>NaN</code>；<br><code>StrDecimalLiteral</code> 语法：<br><img src="/images/js/parseInt/p-strDecimalLiteral.jpg" alt="p-strDecimalLiteral.jpg"><br>文档不是很清晰，画了张铁路图：<br><img src="/images/js/parseInt/p-strDecimalLiteral_rd.jpg" alt="p-strDecimalLiteral_rd.jpg"></li><li>5.定义变量<code>numberString</code>，它是<code>trimmedString</code> 的最长前缀（可能是<code>trimmedString</code>） 本身，<code>numberString</code>满足<code>StrDecimalLiteral</code> 的语法。</li><li>6.定义变量<code>mathFloat</code>，它是 <code>numberString</code> 的 <code>MV</code>（mathematical value）：从文字中导出<code>MV</code>，其次对这个值进行四舍五入（也有 20 位的阈值处理），这一步处理与<code>parseInt()</code>有很大的不同。至于具体 MV 基本就是大学里学的内容，可见<a href="https://262.ecma-international.org/6.0/#sec-runtime-semantics-mv-s" target="_blank" rel="noopener">文档</a>；</li><li>7.如果<code>mathFloat</code> 等于 0，则：<ul><li>如果<code>trimmedString</code>的第一个字符等于<code>&quot;-&quot;</code>，则返回<code>-0</code>；</li><li>否则返回<code>+0</code>；</li></ul></li><li>8.返回<code>mathFloat</code>的 Number 值；</li></ul><p>也画了个流程图：<br><img src="/images/js/parseInt/p-rule_parseFloat.png" alt="p-rule_parseFloat.png"></p><blockquote><p><code>parseFloat()</code> 只能将字符串的前导部分解释为整数值；它忽略任何不能被解释为整数符号的一部分的代码单元，并且没有给出任何此类代码单元被忽略的迹象。</p></blockquote><h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><p>声明文件（<code>lib.es5.d.ts</code>）很简单：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a string to an integer.</span></span><br><span class="line"><span class="comment"> * @param string A string to convert into a number.</span></span><br><span class="line"><span class="comment"> * @param radix A value between 2 and 36 that specifies the base of the number in `string`.</span></span><br><span class="line"><span class="comment"> * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.</span></span><br><span class="line"><span class="comment"> * All other strings are considered decimal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parseInt</span>(<span class="params"><span class="built_in">string</span>: <span class="built_in">string</span>, radix?: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a string to a floating-point number.</span></span><br><span class="line"><span class="comment"> * @param string A string that contains a floating-point number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parseFloat</span>(<span class="params"><span class="built_in">string</span>: <span class="built_in">string</span></span>): <span class="title">number</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>再次注意<code>NaN</code>也是<code>&quot;number&quot;</code>哦</p></blockquote><hr><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>以典型的<a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>（依赖 v8）为例，可以看下<code>parseInt()</code>和<code>parseFloat</code>的具体代码实现和单测内容（版本：<code>tags/9.9.56</code>）</p><h4 id="parseInt-源码"><a href="#parseInt-源码" class="headerlink" title="parseInt 源码"></a><code>parseInt</code> 源码</h4><p>(主要文件：<code>/Source/JavaScriptCore/runtime/ParseInt.h</code>)</p><p>主要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口，方法定义</span></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseInt</span><span class="params">(StringView s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.is8Bit())</span><br><span class="line">        <span class="keyword">return</span> parseInt(s, s.characters8(), radix);</span><br><span class="line">    <span class="keyword">return</span> parseInt(s, s.characters16(), radix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5.1 15.1.2.2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;</span><br><span class="line">ALWAYS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseInt</span><span class="params">(StringView s, <span class="keyword">const</span> CharType* data, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. Let inputString be ToString(string).</span></span><br><span class="line">    <span class="comment">// 2. Let S be a newly created substring of inputString consisting of the first character that is not a</span></span><br><span class="line">    <span class="comment">//    StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white</span></span><br><span class="line">    <span class="comment">//    space.) If inputString does not contain any such characters, let S be the empty string.</span></span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))</span><br><span class="line">        ++p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Let sign be 1.</span></span><br><span class="line">    <span class="comment">// 4. If S is not empty and the first character of S is a minus sign -, let sign be -1.</span></span><br><span class="line">    <span class="comment">// 5. If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first character from S.</span></span><br><span class="line">    <span class="keyword">double</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[p] == <span class="string">'+'</span>)</span><br><span class="line">            ++p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[p] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. Let R = ToInt32(radix).</span></span><br><span class="line">    <span class="comment">// 7. Let stripPrefix be true.</span></span><br><span class="line">    <span class="comment">// 8. If R != 0,then</span></span><br><span class="line">    <span class="comment">//   b. If R != 16, let stripPrefix be false.</span></span><br><span class="line">    <span class="comment">// 9. Else, R == 0</span></span><br><span class="line">    <span class="comment">//   a. LetR = 10.</span></span><br><span class="line">    <span class="comment">// 10. If stripPrefix is true, then</span></span><br><span class="line">    <span class="comment">//   a. If the length of S is at least 2 and the first two characters of S are either ―0x or ―0X,</span></span><br><span class="line">    <span class="comment">//      then remove the first two characters from S and let R = 16.</span></span><br><span class="line">    <span class="comment">// 11. If S contains any character that is not a radix-R digit, then let Z be the substring of S</span></span><br><span class="line">    <span class="comment">//     consisting of all characters before the first such character; otherwise, let Z be S.</span></span><br><span class="line">    <span class="keyword">if</span> ((radix == <span class="number">0</span> || radix == <span class="number">16</span>) &amp;&amp; length - p &gt;= <span class="number">2</span> &amp;&amp; data[p] == <span class="string">'0'</span> &amp;&amp; (data[p + <span class="number">1</span>] == <span class="string">'x'</span> || data[p + <span class="number">1</span>] == <span class="string">'X'</span>)) &#123;</span><br><span class="line">        radix = <span class="number">16</span>;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (radix == <span class="number">0</span>)</span><br><span class="line">        radix = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.a If R &lt; 2 or R &gt; 36, then return NaN.</span></span><br><span class="line">    <span class="keyword">if</span> (radix &lt; <span class="number">2</span> || radix &gt; <span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters</span></span><br><span class="line">    <span class="comment">//     A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant</span></span><br><span class="line">    <span class="comment">//     digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation;</span></span><br><span class="line">    <span class="comment">//     and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the</span></span><br><span class="line">    <span class="comment">//     mathematical integer value that is represented by Z in radix-R notation.)</span></span><br><span class="line">    <span class="comment">// 14. Let number be the Number value for mathInt.</span></span><br><span class="line">    <span class="keyword">int</span> firstDigitPosition = p;</span><br><span class="line">    <span class="keyword">bool</span> sawDigit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; length) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = parseDigit(data[p], radix);</span><br><span class="line">        <span class="keyword">if</span> (digit == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sawDigit = <span class="literal">true</span>;</span><br><span class="line">        number *= radix;</span><br><span class="line">        number += digit;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12. If Z is empty, return NaN.</span></span><br><span class="line">    <span class="keyword">if</span> (!sawDigit)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternate code path for certain large numbers.</span></span><br><span class="line">    <span class="keyword">if</span> (number &gt;= mantissaOverflowLowerBound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (radix == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> parsedLength;</span><br><span class="line">            number = parseDouble(s.substring(firstDigitPosition, p - firstDigitPosition), parsedLength);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (radix == <span class="number">2</span> || radix == <span class="number">4</span> || radix == <span class="number">8</span> || radix == <span class="number">16</span> || radix == <span class="number">32</span>)</span><br><span class="line">            number = parseIntOverflow(s.substring(firstDigitPosition, p - firstDigitPosition), radix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 15. Return sign x number.</span></span><br><span class="line">    <span class="keyword">return</span> sign * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中没有“骚”操作，从执行到备注都完全贴合规范。</p><h4 id="parseInt-unit-test"><a href="#parseInt-unit-test" class="headerlink" title="parseInt unit test"></a>parseInt unit test</h4><p>（文件：<code>chromium / v8 / v8 / 9.9.56 / . / test / webkit / parseInt-expected.txt</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PASS parseInt(&apos;123&apos;) is 123</span><br><span class="line">PASS parseInt(&apos;123x4&apos;) is 123</span><br><span class="line">PASS parseInt(&apos;-123&apos;) is -123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123x4&apos;) is 0x123</span><br><span class="line">PASS parseInt(&apos;-0x123x4&apos;) is -0x123</span><br><span class="line">PASS parseInt(&apos;-&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;0x&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;-0x&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;123&apos;, undefined) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, null) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 0) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 10) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 16) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, undefined) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, null) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 0) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 10) is 0</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 16) is 0x123</span><br><span class="line">PASS parseInt(Math.pow(10, 20)) is 100000000000000000000</span><br><span class="line">PASS parseInt(Math.pow(10, 21)) is 1</span><br><span class="line">PASS parseInt(Math.pow(10, -6)) is 0</span><br><span class="line">PASS parseInt(Math.pow(10, -7)) is 1</span><br><span class="line">PASS parseInt(-Math.pow(10, 20)) is -100000000000000000000</span><br><span class="line">PASS parseInt(-Math.pow(10, 21)) is -1</span><br><span class="line">PASS parseInt(-Math.pow(10, -6)) is -0</span><br><span class="line">PASS parseInt(-Math.pow(10, -7)) is -1</span><br><span class="line">PASS parseInt(&apos;0&apos;) is 0</span><br><span class="line">PASS parseInt(&apos;-0&apos;) is -0</span><br><span class="line">PASS parseInt(0) is 0</span><br><span class="line">PASS parseInt(-0) is 0</span><br><span class="line">PASS parseInt(2147483647) is 2147483647</span><br><span class="line">PASS parseInt(2147483648) is 2147483648</span><br><span class="line">PASS parseInt(&apos;2147483647&apos;) is 2147483647</span><br><span class="line">PASS parseInt(&apos;2147483648&apos;) is 2147483648</span><br><span class="line">PASS state = null; try &#123; parseInt(&apos;123&apos;, throwingRadix); &#125; catch (e) &#123;&#125; state; is &quot;throwingRadix&quot;</span><br><span class="line">PASS state = null; try &#123; parseInt(throwingString, throwingRadix); &#125; catch (e) &#123;&#125; state; is &quot;throwingString&quot;</span><br></pre></td></tr></table></figure><h4 id="parseFloat-源码"><a href="#parseFloat-源码" class="headerlink" title="parseFloat 源码"></a><code>parseFloat</code> 源码</h4><p>(主要文件：<code>/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseFloat</span><span class="params">(StringView s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> size = s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        UChar c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (isASCIIDigit(c))</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.is8Bit()) &#123;</span><br><span class="line">        <span class="keyword">const</span> LChar* data = s.characters8();</span><br><span class="line">        <span class="keyword">const</span> LChar* end = data + size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip leading white space.</span></span><br><span class="line">        <span class="keyword">for</span> (; data &lt; end; ++data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isStrWhiteSpace(*data))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty string.</span></span><br><span class="line">        <span class="keyword">if</span> (data == end)</span><br><span class="line">            <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsStrDecimalLiteral(data, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> UChar* data = s.characters16();</span><br><span class="line">    <span class="keyword">const</span> UChar* end = data + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip leading white space.</span></span><br><span class="line">    <span class="keyword">for</span> (; data &lt; end; ++data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStrWhiteSpace(*data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Empty string.</span></span><br><span class="line">    <span class="keyword">if</span> (data == end)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsStrDecimalLiteral(data, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// See ecma-262 6th 11.8.3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">jsStrDecimalLiteral</span><span class="params">(<span class="keyword">const</span> CharType*&amp; data, <span class="keyword">const</span> CharType* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RELEASE_ASSERT(data &lt; end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> parsedLength;</span><br><span class="line">    <span class="keyword">double</span> number = parseDouble(data, end - data, parsedLength);</span><br><span class="line">    <span class="keyword">if</span> (parsedLength) &#123;</span><br><span class="line">        data += parsedLength;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for [+-]?Infinity</span></span><br><span class="line">    <span class="keyword">switch</span> (*data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data + <span class="number">1</span>, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data + <span class="number">1</span>, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not a number.</span></span><br><span class="line">    <span class="keyword">return</span> PNaN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，<code>parseInt</code>的注释要更为完善。</p><h4 id="parseFloat-test"><a href="#parseFloat-test" class="headerlink" title="parseFloat test"></a>parseFloat test</h4><p>（文件：<code>chromium / v8 / v8 / 9.9.56 / . / test / webkit / parseFloat-expected.txt</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PASS parseFloat() is NaN</span><br><span class="line">PASS parseFloat(&apos;&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos; &apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos; 0&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;0 &apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;x0&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;0x&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos; 1&apos;) is 1</span><br><span class="line">PASS parseFloat(&apos;1 &apos;) is 1</span><br><span class="line">PASS parseFloat(&apos;x1&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;1x&apos;) is 1</span><br><span class="line">PASS parseFloat(&apos; 2.3&apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;2.3 &apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;x2.3&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;2.3x&apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;0x2&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;1&apos; + nonASCIINonSpaceCharacter) is 1</span><br><span class="line">PASS parseFloat(nonASCIINonSpaceCharacter + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;1&apos; + illegalUTF16Sequence) is 1</span><br><span class="line">PASS parseFloat(illegalUTF16Sequence + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(tab + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(nbsp + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ff + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(vt + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(cr + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(lf + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ls + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ps + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(oghamSpaceMark + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(mongolianVowelSeparator + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(enQuad + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(emQuad + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(enSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(emSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(threePerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(fourPerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(sixPerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(figureSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(punctuationSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(thinSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(hairSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(narrowNoBreakSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(mediumMathematicalSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ideographicSpace + &apos;1&apos;) is 1</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从 ECMA 规范和典型内核的代码实现中我们可以发现，<code>parseFloat</code>和<code>parseInt</code>存在很多边界处理，这也是造成踩坑的主要原因。</p><p>至此可以再回过头想想最初的那些执行问题，绝大部分都能得到解释。至于“超纲”题，有兴趣可以去看下 ECMA 规范中的数字及类型转换部分。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="tostring"><a href="#tostring" class="headerlink" title="tostring"></a>tostring</h4><p><img src="/images/js/parseInt/p-table12-tostring.jpg" alt="p-table12-tostring.jpg"></p><h4 id="MV（mathematical-value）"><a href="#MV（mathematical-value）" class="headerlink" title="MV（mathematical value）"></a>MV（mathematical value）</h4><p><img src="/images/js/parseInt/p-mv.png" alt="p-mv.png"></p><h4 id="parseFloat-input-string-格式"><a href="#parseFloat-input-string-格式" class="headerlink" title="parseFloat input string 格式"></a>parseFloat input string 格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Diagram(</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">  Optional(</span><br><span class="line">    Choice(0,</span><br><span class="line">      &apos;+&apos;,</span><br><span class="line">      &apos;-&apos;,</span><br><span class="line">    ), &apos;skip&apos;</span><br><span class="line">  ),</span><br><span class="line">  Choice(1,</span><br><span class="line">    &apos;Infinity&apos;,</span><br><span class="line">    Sequence(</span><br><span class="line">      Choice(0,</span><br><span class="line">        Sequence(</span><br><span class="line">          ZeroOrMore(&apos;0-9&apos;),</span><br><span class="line">          Optional(&apos;.&apos;, &apos;skip&apos;),</span><br><span class="line">          OneOrMore(&apos;0-9&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      Optional(</span><br><span class="line">        Sequence(</span><br><span class="line">          Choice(0,</span><br><span class="line">            &apos;e&apos;,</span><br><span class="line">            &apos;E&apos;,</span><br><span class="line">          ),</span><br><span class="line">          Optional(</span><br><span class="line">            Choice(0,</span><br><span class="line">              &apos;+&apos;,</span><br><span class="line">              &apos;-&apos;,</span><br><span class="line">            ), &apos;skip&apos;</span><br><span class="line">          ),</span><br><span class="line">          OneOrMore(&apos;0-9&apos;),</span><br><span class="line">        )</span><br><span class="line">      , &apos;skip&apos;)</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="parseInt-input-string-格式"><a href="#parseInt-input-string-格式" class="headerlink" title="parseInt input string 格式"></a>parseInt input string 格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Diagram(</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">  Optional(</span><br><span class="line">    Choice(0,</span><br><span class="line">      &apos;+&apos;,</span><br><span class="line">      &apos;-&apos;,</span><br><span class="line">    ), &apos;skip&apos;</span><br><span class="line">  ),</span><br><span class="line">  ZeroOrMore(&apos;0-R&apos;),// R 为进制最大值</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://262.ecma-international.org/6.0/" target="_blank" rel="noopener">https://262.ecma-international.org/6.0/</a></li><li><a href="https://262.ecma-international.org/6.0/#sec-tostring-applied-to-the-number-type" target="_blank" rel="noopener">https://262.ecma-international.org/6.0/#sec-tostring-applied-to-the-number-type</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat</a></li><li><a href="https://webkit.org/" target="_blank" rel="noopener">https://webkit.org/</a></li><li><a href="https://github.com/WebKit/WebKit" target="_blank" rel="noopener">https://github.com/WebKit/WebKit</a></li><li><a href="https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md#q3%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%95%B0%E5%AD%97%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js-中-parseInt-和-parseFloat-的执行机制&quot;&gt;&lt;a href=&quot;#js-中-parseInt-和-parseFloat-的执行机制&quot; class=&quot;headerlink&quot; title=&quot;js 中 parseInt 和 parseFloat 的
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="js" scheme="http://blog.michealwayne.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【综合】web性能及优化</title>
    <link href="http://blog.michealwayne.cn/2021/12/12/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91web%E6%80%A7%E8%83%BD%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.michealwayne.cn/2021/12/12/【综合】web性能及优化/</id>
    <published>2021-12-12T10:36:06.000Z</published>
    <updated>2022-01-25T04:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web性能及优化"><a href="#web性能及优化" class="headerlink" title="web性能及优化"></a>web性能及优化</h1><h4 id="更新信息"><a href="#更新信息" class="headerlink" title="*更新信息"></a>*更新信息</h4><ul><li>2022.01.23：更新端侧应用的性能优化手段；整理常用优化手段；</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户在访问 web 网页时，大部分都希望网页能够在一秒完成。事实上，加载时间每多 1 秒，就会流失 7%的用户。如果时间超过 8s 就会感到不耐烦，如果加载需要太长时间，用户就会放弃访问。这也就是著名的 “8s 原则”。</p><p>虽然当今设备及网络环境都大幅提升，但“带宽低”、“速度慢”、“内存小”的平均情况仍然是明显性能瓶颈，特别是移动端的各种条件限制。</p><p>性能优化是一个非常庞大的工程，包括指标制定、标准确定、进行优化手段、进行性能测试、确定性能指标采集上报、确定性能监控及预警、评估收益等等。本文重点描述指标制定和优化手段。</p><h2 id="一、如何评估网页性能"><a href="#一、如何评估网页性能" class="headerlink" title="一、如何评估网页性能"></a>一、如何评估网页性能</h2><h3 id="性能度量指标"><a href="#性能度量指标" class="headerlink" title="性能度量指标"></a>性能度量指标</h3><p>我们都明白性能的重要性，但当我们谈起性能时，我们具体指的是什么？其实性能是相对的：</p><ul><li>由于网速或设备的差异，某个网站可能对一个用户来说速度很快，但可能对另一个用户来说速度很慢。</li><li>两个网站完成加载所需的时间或许相同，但其中一个却显得加载速度更快（如果该网站逐步加载内容，而不是等到最后才一起显示）。</li><li>一个网站可能看起来加载速度很快，但随后对用户交互的响应速度却很慢（或根本无响应）。</li></ul><p>因此，在谈论性能时，重要的是做到精确，并且根据能够进行定量测量的客观标准来论及性能。这些标准就是指标。</p><ul><li><a href="https://web.dev/fcp/" target="_blank" rel="noopener"><strong>FCP</strong></a>：First Contentful Paint，首次内容绘制，测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。</li><li><strong>FPM</strong>：First Meaningful Paint，首次有效绘制，当主要内容呈现在页面上；</li><li><strong>HRT</strong>：Hero Rendering Times，英雄渲染时间，度量用户体验的新指标，当用户最关心的内容渲染完成；</li><li><a href="https://web.dev/tti/" target="_blank" rel="noopener"><strong>TTI</strong></a>：Time to Interactive，可交互时间，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击 UI 并与其交互；<br>输入响应（Input responsiveness，界面响应用户输入所需的时间）</li><li><strong>PSI</strong>：Perceptual Speed Index，感知速度指数，测量页面在加载过程中视觉上的变化速度，分数越低越好；</li><li><a href="https://web.dev/lcp/" target="_blank" rel="noopener"><strong>LCP</strong></a>：Largest Contentful Paint 最大内容绘制，测量页面从开始加载到最大文本块或图像元素在屏幕上完成渲染的时间。</li><li><a href="https://web.dev/fid/" target="_blank" rel="noopener"><strong>FID</strong></a>：First Input Delay，首次输入延迟，测量从用户第一次与您的网站交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器实际能够对交互做出响应所经过的时间。</li><li><a href="https://web.dev/tbt/" target="_blank" rel="noopener"><strong>TBT</strong></a>：Total blocking time 总阻塞时间，测量 FCP 与 TTI 之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。</li><li><a href="https://web.dev/cls/" target="_blank" rel="noopener"><strong>CLS</strong></a>：Cumulative Layout Shift，累积布局偏移，测量页面在开始加载和其生命周期状态变为隐藏期间发生的所有意外布局偏移的累积分数。</li></ul><blockquote><p>注：FMP 与英雄渲染时间非常相似，但它们不一样的地方在于 FMP 不区分内容是否有用，不区分渲染出的内容是否是用户关心的。</p></blockquote><p>但仅仅因为某个指标基于客观标准并且能够进行定量测量，也并不一定意味着那些测量值就是有用的。我们也需要自定义指标，由业务需求和用户体验来决定。</p><p>有时候，可能会有某个特定网站比较独树一帜，需要额外的指标来捕获完整的性能全貌。例如，LCP 指标用于测量页面的主要内容何时完成加载，但在某些情况下，最大元素并不是页面主要内容的一部分，因此 LCP 就不再是相关指标。</p><p>为了解决这种情况，Web 性能工作组还推出了一系列较低级别的标准化 API，可用于实现您自己的自定义指标：</p><ul><li><a href="https://w3c.github.io/user-timing/" target="_blank" rel="noopener">用户计时 API https://w3c.github.io/user-timing/</a></li><li><a href="https://w3c.github.io/longtasks/" target="_blank" rel="noopener">长任务 API https://w3c.github.io/longtasks/</a></li><li><a href="https://wicg.github.io/element-timing/" target="_blank" rel="noopener">元素计时 API https://wicg.github.io/element-timing/</a></li><li><a href="https://w3c.github.io/navigation-timing/" target="_blank" rel="noopener">导航计时 API https://w3c.github.io/navigation-timing/</a></li><li><a href="https://w3c.github.io/resource-timing/" target="_blank" rel="noopener">资源计时 API https://w3c.github.io/resource-timing/</a></li><li><a href="https://w3c.github.io/server-timing/" target="_blank" rel="noopener">服务器计时 https://w3c.github.io/server-timing/</a></li></ul><h3 id="RAIL-模型"><a href="#RAIL-模型" class="headerlink" title="RAIL 模型"></a>RAIL 模型</h3><p><a href="https://web.dev/rail/" target="_blank" rel="noopener">RAIL</a> 是 response （响应）、 animation（动画）、idle（浏览器空置状态）和 load（加载）。</p><p>从这四个模块角度来思考你的产品。如果在每个模块上，你都可以达到性能优化的目标值，那么最终用户感受到的将会是极致的体验。</p><p>RAIL 模型中，通常建议性能阈值：</p><ul><li><code>Response</code>：点击/轻触后 100 ms 内得到响应；</li><li><code>Animation</code>：每一帧的渲染在 16 ms 内完成；拖拽后的页面渲染也要在 16 ms 内完成；</li><li><code>Idle</code>：合理地使用浏览器空闲时间；任务要在 50 ms 内完成；</li><li><code>Page Load</code>：加载的过程要满足“响应”目标；最重要的内容要在 1000 ms 内完成加载。</li></ul><p><img src="/images/webOptimize/p-2-rail-model.png" alt="p-2-rail-model.png"></p><p>在次性能目标/阈值基础上，结合 APM 统计，便能对线上用户的 RAIL 性能情况得到统计和评估。</p><h3 id="开发者性能检测工具"><a href="#开发者性能检测工具" class="headerlink" title="开发者性能检测工具"></a>开发者性能检测工具</h3><p>很多工具能够帮助我们获取或分析上文中的一些通用性指标。</p><h4 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h4><p>Chrome 浏览器开发者工具中的<code>Lighthouse</code>和<code>Performance</code>能有效帮助我们进行性能分析：</p><ul><li><code>Lighthouse</code>：生成性能分析报告。并且给予相关优化建议；</li><li><code>Performace</code>：分析运行时数据报告，包含阻塞、重排等细节信息；</li></ul><p><img src="/images/webOptimize/p-1_chrome-devtools.jpg" alt="p-1_chrome-devtools.jpg"></p><p>根据这两个有效工具能够帮我们分析当前页面/运行的性能情况，以便有效做出优化。具体工具使用可以直接参考官网文档<a href="https://developer.chrome.com/docs/devtools/evaluate-performance/" target="_blank" rel="noopener">《Chrome-Analyze runtime performance》</a>、<a href="https://developers.google.com/web/updates/2018/05/lighthouse" target="_blank" rel="noopener">《Using Lighthouse To Improve Page Load Performance》</a></p><h4 id="lighthouse-本地使用"><a href="#lighthouse-本地使用" class="headerlink" title="*lighthouse 本地使用"></a>*lighthouse 本地使用</h4><p><code>node12.x</code>起，可以直接安装<code>lighthouse</code>在本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g lighthouse</span><br></pre></td></tr></table></figure><p>简单分析：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lighthouse https://blog.michealwayne.cn</span><br></pre></td></tr></table></figure><p>以此为基础，我们可以可以将分析工作自动化及平台化。比如<a href="https://web.dev/measure/" target="_blank" rel="noopener">https://web.dev/measure/</a></p><p><img src="/images/webOptimize/p-3_pagespeed.jpg" alt="p-3_pagespeed.jpg"></p><h4 id="React-Profiler"><a href="#React-Profiler" class="headerlink" title="*React Profiler"></a>*React Profiler</h4><p>React Profiler 是 React 官方提供的性能审查工具。React 16.5 添加了对新 DevTools 分析器插件的支持。该插件使用 React 的实验性 Profiler API 来收集有关渲染的每个组件的时间信息，以便识别 React 应用程序中的性能瓶颈。使用官网说明<a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html</a></p><p><img src="/images/webOptimize/p-5_react-profiler.jpg" alt="p-5_react-profiler.jpg"></p><h4 id="通过-webpack-bundle-analyzer-和-vue-cli-report-分析模块"><a href="#通过-webpack-bundle-analyzer-和-vue-cli-report-分析模块" class="headerlink" title="*通过 webpack-bundle-analyzer 和 vue-cli report 分析模块"></a>*通过 webpack-bundle-analyzer 和 vue-cli report 分析模块</h4><p>通过<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>，我们可以分析各个模块的大小，进行对性能影响最大的模块进行优化。<a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener">vue-cli report</a> 也集成了这功能。</p><p><img src="/images/webOptimize/p-6_webpack-report.jpg" alt="p-6_webpack-report.jpg"></p><h4 id="真实的性能分析工具：WebPageTest"><a href="#真实的性能分析工具：WebPageTest" class="headerlink" title="真实的性能分析工具：WebPageTest"></a>真实的性能分析工具：WebPageTest</h4><p>WebPageTest（地址<a href="https://www.webpagetest.org/" target="_blank" rel="noopener">https://www.webpagetest.org/</a>），通过浏览器访问，基于输入的 WebSite URL，以及选择的国家城市、浏览器类型、网络带宽等信息，启动对应的远程服务器上的浏览器进行性能分析测试。相似的还有 YSlow、PageSpeed。</p><h3 id="其他性能测试方案"><a href="#其他性能测试方案" class="headerlink" title="其他性能测试方案"></a>其他性能测试方案</h3><h4 id="使用性能-SDK"><a href="#使用性能-SDK" class="headerlink" title="使用性能 SDK"></a>使用性能 SDK</h4><p>如 APM-SkyWalking client。优点是方案与到时候线上用户一致，缺点是在测试环节样本少，需要暴露到线上。</p><h4 id="借助工具录视频"><a href="#借助工具录视频" class="headerlink" title="借助工具录视频"></a>借助工具录视频</h4><p>通过自动化工具进行视频录制，优点是可以和 QA 设施相结合，还能同时测试内存和 CPU 等信息。缺点是对于真实用户的监控力度不足。</p><h4 id="借助端侧打点"><a href="#借助端侧打点" class="headerlink" title="借助端侧打点"></a>借助端侧打点</h4><p>与端侧能力相结合，通过像素检测等手段进行打点上报。优点是能兼顾线上用户及 QA 设施结合。缺点是只能作用在端内业务，无法检测端外业务。</p><h2 id="二、性能优化原则"><a href="#二、性能优化原则" class="headerlink" title="二、性能优化原则"></a>二、性能优化原则</h2><ul><li><strong>数据驱动</strong>。依据数据而不是凭空猜测，性能指标需要满足可度量的条件，当我们怀疑性能有问题时，应该通过日志数据、测试和来分析。</li><li><strong>忌过早优化和过度优化</strong>。过早优化很容易拍脑袋，优化过程也要考虑性价比。</li><li><strong>深入理解业务</strong>。选择合适的衡量指标。性能优化服务于业务，业务服务于最终用户，关注以用户为中心的真实体验。</li><li><strong>持久战</strong>。性能优化也有渐进明细的规划和实施特征。</li><li><strong>正推&amp;反推</strong>。结合正推和反推制定目标，正推：线索 -&gt; 本质/痛点 -&gt; 解决方案 -&gt; 目标；反推：目标 -&gt; 解决方案 -&gt; 本质/痛点 -&gt; 线索，综合制定目标。如 30%的性能提升，带来 10%的流量增加。</li></ul><h3 id="业界性能标准"><a href="#业界性能标准" class="headerlink" title="*业界性能标准"></a>*业界性能标准</h3><p>百度、美团等主要指标以 FCP、FMP 和卡顿率为主；阿里云 ARMS 性能监控方案，定义性能指数 Apdex，使用白屏时间作为计算指标。</p><p>业界较为通用的标准：</p><table><thead><tr><th>业务类别</th><th>快</th><th>较快</th><th>慢</th><th>很慢</th><th>指标示例</th></tr></thead><tbody><tr><td>时间敏感</td><td><code>&lt;1s</code></td><td><code>1~1.5s</code></td><td><code>1.5~2.5s</code></td><td><code>&gt;2.5s</code></td><td>首屏/白屏</td></tr><tr><td>时间不敏感</td><td><code>&lt;2s</code></td><td><code>2~4s</code></td><td><code>4~8s</code></td><td><code>&gt;2.5s</code></td><td>onload</td></tr></tbody></table><p>像 2C 的页面，“秒开”应作为性能目标，如：</p><table><thead><tr><th>类型</th><th>FCP</th><th>秒开率</th><th>1.5 秒开率</th><th>2 秒开率</th></tr></thead><tbody><tr><td>全离线</td><td>700ms</td><td>90%</td><td>98%</td><td>99%</td></tr><tr><td>部分离线/SSG/SSR</td><td>1000ms</td><td>80%</td><td>95%</td><td>98%</td></tr><tr><td>端内</td><td>1200ms</td><td>70%</td><td>90%</td><td>95%</td></tr><tr><td>端外</td><td>1500ms</td><td>50%</td><td>60%</td><td>80%</td></tr></tbody></table><h2 id="三、通用性能优化手段"><a href="#三、通用性能优化手段" class="headerlink" title="三、通用性能优化手段"></a>三、通用性能优化手段</h2><p>性能优化手段可以大致分为以下几个阶段：</p><p><img src="/images/webOptimize/p-main.png" alt="p-main.png"></p><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>好的前端模式设计能带来性能优化事半功倍的效果，目前主流的做法就是通过借助端侧或者服务端能力。</p><h4 id="借助端侧能力"><a href="#借助端侧能力" class="headerlink" title="借助端侧能力"></a>借助端侧能力</h4><p>端侧业务可以借助客户端能力进行性能优化。常用的方式如下：</p><ul><li>离线：通过将在线请求的资源本地化提升加载性能<ul><li>通用资源离线。页面及业务代码在线，通用资源走端侧离线，适用运营活动等流动页面。</li><li>页面整体离线。页面相关静态资源基本全部离线，适用于强性能、稳定性要求的页面。</li></ul></li><li>混合/原生：借助端侧能力降低渲染成本<ul><li>原生组件。弹窗、toast、Video 等控件原生调用。</li><li>原生渲染。通过 DSL 控制原生呈现、RN、小程序等。</li></ul></li></ul><h4 id="借助服务端能力"><a href="#借助服务端能力" class="headerlink" title="借助服务端能力"></a>借助服务端能力</h4><p>意义在于弥补主要内容在前端渲染的成本，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。比较推荐的通用做法是：使用服务端渲染静态 HTML 来获得更快的首次有效绘制，一旦 js 加载完毕再将页面接管下来。</p><ul><li>SSG。通常需要业务定制，不过也有像 JAMStack 等相对通用型框架；也包括 PHP、Java 等实现；</li><li>SSR。Nextjs、Nustjs 等，也包括 PHP、Java 等实现。</li><li>微前端。如 qiankun 等基于 single-spa 的系列、fronts 等基于 module-federation 的系列。</li><li>*bigPipe：一种动态网页加载技术。将网页分解成称为 pagelets 的小块，然后分块传输到浏览器端，进行渲染。</li></ul><blockquote><p>借助服务端能力一定要注意“三高”的控制及监控。</p></blockquote><h4 id="前端框架选择"><a href="#前端框架选择" class="headerlink" title="前端框架选择"></a>前端框架选择</h4><p>从性能角度考虑：</p><ul><li>纯 web：性能最佳，开发成本相对较大，适合极高性能要求的单数据流业务场景，如首页。模板渲染可使用<a href="http://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li><li>Vue：开发成本最小。可考虑使用<a href="https://github.com/vuejs/petite-vue" target="_blank" rel="noopener">petite-vue</a>等 lite 库减负。</li><li>React：开发成本小。可考虑使用<a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a>等 lite 库减负。</li><li>其他：像<a href="https://github.com/sveltejs/svelte" target="_blank" rel="noopener">Svelte</a>其实也比较轻，但目前沉淀少，开发成本较大。</li></ul><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><h4 id="静态资源准备工作"><a href="#静态资源准备工作" class="headerlink" title="静态资源准备工作"></a>静态资源准备工作</h4><ul><li>图片格式选择：丰富色彩使用 jpg、透明色使用 png、单调色彩使用 <code>2/4/8/16/32/64/128/256</code> 位 png（每个通道 8 位为每个通道提供 256 个值，RGB 三个通道一共可以为每个像素提供 16777216 种颜色。）；根据环境使用 WebP；减少 gif 的使用，使用 CSS3/SVG/canvas 动画、lottie 等新形式，一些场景下视频也比 gif 效率高。</li><li>响应式图片。<code>srcset</code>，<code>sizes</code>和<code>&lt;picture&gt;</code>元素使用响应式图片。还可以通过<code>&lt;picture&gt;</code>元素使用 WebP 格式的图像。</li><li>CSS3/SVG 代替图片，SVG 也可以通过<a href="https://github.com/svg/svgo" target="_blank" rel="noopener">svgo</a>等工具进行压缩优化。</li><li>使用字体图标代替图片图标<br><img src="/images/webOptimize/p-4_img-optimize.png" alt="p-4_img-optimize.png"></li></ul><h4 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h4><ul><li><p>HTML</p><ul><li>正确的标签写法。当 HTML 标签不满足 web 语义化时，浏览器需要更多时间去解析 DOM 标签的含义，进行语法纠错。</li><li>减少 iframes 使用，或者延迟 iframes 加载，保证不会影响父文档加载。</li><li>删除无效内容，减少 DOM 节点。</li><li>删除元素默认属性。</li><li>避免节点深层级嵌套，避免生成 dom 树时占用太对内存。</li><li>减少 table 布局，table 开销非常大。</li><li>css、js 尽量外链，js 考虑异步引入。</li></ul></li><li><p>CSS 优化</p><ul><li>降低 CSS 选择器复杂性。避免使用通用选择器<code>*</code>；选择器层级不宜过多；提高关键选择器（最右）的匹配强度，比如不适用元素选择器；谨慎使用一些<code>expensive</code>的属性，如<code>nth-child</code>。</li><li>避免浮动布局，使用 <code>flexbox</code>。</li><li>善用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" target="_blank" rel="noopener"><code>will-change</code></a> 属性：<code>will-change</code> 属性告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。</li><li>善用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display" target="_blank" rel="noopener"><code>font-display</code></a> 属性优化字体：<code>font-display</code> 属性定义了浏览器如何加载和显示字体文件，允许文本在字体加载或加载失败时显示回退字体。可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能。</li><li>善用 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Performance/CSS#contain_%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener"><code>contain</code></a> 属性：<code>contain</code> 属性允许开发者指示元素及其内容尽可能独立于文档树的其余部分。 这允许浏览器针对 DOM 的有限区域而不是整个页面重新计算布局/样式。</li></ul></li><li><p>JS 优化</p><ul><li>使用原生方法。</li><li>异步化。任务冲突时（主线程和合成线程调度不合理）使用<code>requestAnimatinFrame(..)</code>/<code>setTimeout(..)</code>分割队列；Web Worker 等。</li><li>减少重绘重排<ul><li>对高频触发的事件进行节流或防抖。</li><li>减少 DOM 操作，批量操作 DOM：请尽可能减少访问 DOM 的次数（缓存 DOM 属性和元素、把 DOM 集合的长度缓存到变量中并在迭代中使用）；如果操作需要进行多次重排与重绘，建议先让元素脱离文档流；善于使用事件委托。</li></ul></li><li>考虑使用事件委托</li><li>循环/运算优化<ul><li><code>switch</code> 和 <code>if...else</code> 的使用</li><li>善用位运算</li></ul></li><li>流程控制优化。一些流程控制相关的一些做法可以略微提升性能（这些细节在大型开源项目中大量运用）：避免使用 <code>for...in</code>（它能枚举到原型，所以很慢）；在 js 中倒序循环会略微提升性能；减少迭代的次数；基于循环的迭代比基于函数的迭代快；用 Map 表代替大量的 <code>if-else</code> 和 <code>switch</code>等。</li><li>数据读取优化。如字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢；变量从局部作用域到全局作用域的搜索过程越长速度越慢；对象嵌套的越深，读取速度就越慢；对象在原型链中存在的位置越深，找到它的速度就越慢；</li><li>配合 V8 等引擎的优化。如 JIT、Hidden Class、函数的解析方式有 lazy parsing 懒解析和 eager parsing 饥饿解析</li></ul></li><li><p>vue</p><ul><li>根据场景使用 no-reactive data</li><li>不要将所有数据都放到 data 中</li><li>尝试 JSX/TSX 写法</li><li>善用 Functional component</li><li>子组件拆分</li><li>使用局部变量</li><li>根据业务场景使用 v-show</li><li>keep-alive 缓存组件</li><li>列表使用 key，且不建议使用索引</li><li>使用事件代理</li><li>虚拟列表</li><li>组件按需加载</li><li>去除无用的路由、状态管理引用</li><li>…</li></ul></li><li><p>React</p><ul><li>善用 Functional Component；</li><li>善用 React.memo、PureComponent/shouldComponentUpdate</li><li>善用 useMemo、useCallback</li><li>useEffect 设置合理的依赖项</li><li>批量更新，unstable_batchedUpdates</li><li>发布订阅者跳过中间组件 Render、跳过回调函数改变触发的 Render</li><li>状态下放，缩小状态影响范围</li><li>避免在 didMount、didUpdate 中更新组件 state</li><li>子组件拆分</li><li>使用局部变量</li><li>css 控制节前展示隐藏</li><li>列表使用 key，且不建议使用索引</li><li>使用事件代理</li><li>虚拟列表</li><li>组件按需加载</li><li>去除无用的路由、状态管理引用</li><li>…</li></ul></li></ul><h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><ul><li><p>构建优化</p><ul><li>提取三方库代码。如使用<code>html-webpack-externals-plugin</code>。</li><li>Webpack 按需引入。</li><li>使用动态引入。</li><li>Tree Shaking、Scope hoisting、Code-splitting。Webpack 与 Rollup 都支持 Scope Hoisting。code-splitting 能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。</li></ul></li><li><p>压缩文件。webpack 插件（webpack4 默认<code>optimization.minimize</code>配置）：</p><ul><li>js：UglifyPlugin</li><li>css：MiniCssExtractPlugin、clean-css</li><li>html：HtmlWebpackPlugin、html-minifier</li><li>图片：tinypng、image-webpack-loader</li></ul></li><li><p>预渲染。根据业务场景，类似 SSG 方案将主要内容渲染至 html，如使用<a href="https://www.npmjs.com/package/prerender-spa-plugin" target="_blank" rel="noopener"><code>prerender-spa-plugin</code></a>插件。</p></li><li><p>根据资源优先级和阻塞情况，优先加载关键资源。</p><ul><li>将 CSS 文件放在 HTML 头部，js 文件放在 HTML 底部。</li><li>按需异步加载 js：acync、defer、动态脚本。</li><li>懒加载。延迟加载所有体积较大的组件、字体、JS、视频或 Iframe。可以通过 Intersection Observer 延迟加载图片、视频、广告脚本、或任何其他资源。可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。</li><li>优先加载关键的 CSS。可以将首屏渲染必须用到的 CSS 提取出来内嵌到<code>&lt;head&gt;</code>中，然后再将剩余部分的 CSS 用异步的方式加载。可以借助工具<a href="https://github.com/addyosmani/critical" target="_blank" rel="noopener">critical</a></li><li>利用<a href="https://w3c.github.io/resource-hints/" target="_blank" rel="noopener">资源提示 Resource hints</a>，<code>dns-prefetch</code>、<code>preconnect</code>、<code>prefetch</code>与<code>prerender</code>、这些可以帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。</li><li>利用<a href="https://www.w3.org/TR/preload/" target="_blank" rel="noopener">预加载 Preload</a>，Preload 提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过声明性标记预加载 CSS 资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://undefined.cn/moo-css-base.min.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或，通过JavaScript预加载 CSS 资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> res = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">  res.rel = <span class="string">'preload'</span>;</span></span><br><span class="line"><span class="javascript">  res.as = <span class="string">'style'</span>;</span></span><br><span class="line"><span class="javascript">  res.href = <span class="string">'https://undefined.cn/moo-css-base.min.css'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.head.appendChild(res);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>PRPL 描述了一种用于使网页加载并变得更快的交互模式：Push (or preload)：推送或预加载最重要的资源；Render：尽快渲染初始路径；Pre-cache：预缓存剩余资源；Lazy load：延迟加载其他路由和非关键资源。</p></blockquote><p><img src="/images/webOptimize/p-load_flow.png" alt="p-load_flow.png"></p><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS 缓存优化；</li><li>预解析 DNS，减少 DNS 查找。关于 DNS 的预解析可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch" target="_blank" rel="noopener">《MDN-dns-prefetch》</a>；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"https://blog.michealwayne.cn"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>页面中资源的域名的合理分配，涉及域名不要太多（通常不要超过 6 个）；</li></ul><h4 id="HTTP-s-请求"><a href="#HTTP-s-请求" class="headerlink" title="HTTP(s) 请求"></a>HTTP(s) 请求</h4><ul><li><p>减少请求</p><ul><li>资源合并。根据复用情况使用<code>s.thsi.cn</code>的<code>cb</code>拼接；</li></ul></li><li><p>使用 HTTP2。相比 HTTP1.1，HTTP2 解析速度更快，也提供了部首压缩功能。更为重要的，多路复用实现并行能力。当前<code>*.thsi.cn</code>具备了 HTTP2 能力，因此静态资源应尽可能得部署在 thsi。</p></li><li><p>善用缓存，不重复加载相同的静态资源。正确设置 <code>expires</code>，<code>cache-control</code> 和其他 HTTP 缓存头。</p><ul><li>强缓存。如长期不变的资源设置<code>Cache-Control:max-age=31536000</code></li><li>协商缓存。资源可能随时发生变动。</li></ul></li><li><p>静态资源使用 CDN。借助边缘能力，静态资源尽可能放<code>*.thsi.cn</code></p></li><li><p>服务端启动 gzip</p></li><li><p>避免重定向。服务端的 302、<code>&lt;meta&gt;</code>标签实现的重定向以及前端<code>location.replace(..)</code>的重定向都会引发新的 DNS 查询。</p></li><li><p>懒加载。考虑请求优先级，非首屏图片/资源考虑延迟加载。</p></li><li><p>离线化。见下文</p></li></ul><h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><ul><li><p>减少渲染成本</p><ul><li>控制首次渲染节点及样式，不易过多。</li><li>简单图形以 CSS 呈现。</li><li>避免首次渲染时的重绘重排。</li></ul></li><li><p>预渲染。见下文</p></li><li><p>骨架屏。可以自己手动写骨架，也可以通过一些基于 puppeteer 的骨架生成方案。</p></li></ul><h3 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h3><ul><li><p>减少重绘重排</p><ul><li>对高频触发的事件进行节流或防抖</li><li>减少 DOM 操作，批量操作 DOM</li></ul></li><li><p>动画</p><ul><li>在 GPU 上呈现动画，适时开启硬件加速。属性包括 3D transforms (<code>transform: translateZ()</code>, <code>rotate3d()</code>等)，<code>animating transform</code> 和 <code>opacity</code>, <code>position: fixed</code>，<code>will-change</code>，和 <code>filter</code>。如 <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code> 和 <code>&lt;iframe&gt;</code>，也位于各自的图层上。 将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成，从而改善性能，尤其是在移动设备上。虽然一些像 <a href="https://greensock.com/gsap/" target="_blank" rel="noopener">GSAP</a>、 <a href="http://velocityjs.org/" target="_blank" rel="noopener">VelocityJs</a> 等一些 js 动画库声称性能上可以做得比 CSS 好，但目前绝大多数业务场景用不到这些库；反观 CSS3，简单的<code>transform</code>便能减少 reflow。</li><li>较复杂动画中，用 lottie/视频 代替 gif。</li><li><code>requestAnimationFrame</code> 实现视觉变化。</li></ul></li><li><p>交互</p><ul><li>快速响应的用户界面。PSI 是提升用户体验的重要指标，可以多使用一些骨架或 Loading 过渡。比如一些游戏类场景，可以先通过 loading 进度条保证主要资源提前加载或处理完成，带来运行时的体验提升。</li><li>避免阻塞性执行，保证输入响应（Input responsiveness），如输入框的节流处理等。</li></ul></li></ul><p><img src="/images/webOptimize/p-7_ux-optimize.png" alt="p-7_ux-optimize.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>canvas 性能优化</p><ul><li>离屏</li><li>图像缓存</li></ul></li><li><p>web worker</p><ul><li>应用场景：编码/解码大字符串；复杂数学运算（包括图像，视屏处理）；大数组排序；</li></ul></li><li>PWA：Service Worker &amp; Offline data<ul><li>应用场景：端外复杂 web 应用，可见<a href="https://web.dev/learn/pwa/" target="_blank" rel="noopener">https://web.dev/learn/pwa/</a>。注意 PWA 的缓存控制以及它不解决首次启动问题。</li></ul></li></ul><hr><h2 id="4-端侧应用的性能优化手段-hybrid"><a href="#4-端侧应用的性能优化手段-hybrid" class="headerlink" title="4.端侧应用的性能优化手段(hybrid)"></a>4.端侧应用的性能优化手段(hybrid)</h2><p>借助端侧能力，hybrid 的性能优化效果远大于普通的处理优化，目前在主流应用中广泛应用。</p><h3 id="端侧-Web-运行环境优化"><a href="#端侧-Web-运行环境优化" class="headerlink" title="端侧 Web 运行环境优化"></a>端侧 Web 运行环境优化</h3><ul><li><p>内核升级。iOS 升级 WKWebView、Android 升级 X5。</p></li><li><p>协议及 WebView 启动优化，如全局化 WebView。</p></li></ul><h3 id="离线化"><a href="#离线化" class="headerlink" title="离线化"></a>离线化</h3><p>离线化可以最大程度地摆脱网络环境对 web 的影响。基本运作是将项目的静态资源打成离线包，客户端在启动应用等时机进行加载及解压操作。在访问资源时，客户端根据 URL 标识进行拦截，如果能在本地找到对应资源文件，则直接以本地信息响应，否则加载远程页面。</p><ul><li>优点：避免资源请求，首开性能极佳（全离线 FCP 通常能保证在 800ms 内）；</li><li>缺点：维护成本较高；</li><li>适用场景：迭代频率相对稳定、高加载性能要求的业务场景。</li></ul><h4 id="离线包方案"><a href="#离线包方案" class="headerlink" title="离线包方案"></a>离线包方案</h4><p>需要与客户端配合，方案可以借鉴阿里mPaaS——<a href="https://help.aliyun.com/document_detail/49762.html" target="_blank" rel="noopener">H5 容器和离线包</a></p><h3 id="webview-预热"><a href="#webview-预热" class="headerlink" title="webview 预热"></a>webview 预热</h3><p>在应用启动等特定触发时机下，在后台无感知启动 webview 并预热页面，此 webview 全局化、池化，在访问 URL 时即直接调起预热 webview。</p><ul><li>优点：访问是统一 webview ，加载体验最佳（外界最佳实践 200ms）；</li><li>缺点：有性能开销（空间换时间）；仅能使用于业务最重要业务场景；</li><li>适用场景：如资讯、双十一活动等高频业务。</li></ul><blockquote><p>性能要求极强的场景甚至可以考虑 NSR</p></blockquote><h3 id="WebView-资源预加载"><a href="#WebView-资源预加载" class="headerlink" title="WebView 资源预加载"></a>WebView 资源预加载</h3><p>在应用启动时，在后台无感知启动 WebView，此 WebView 通过配置项预先加载应用内常用 js/css/image/font 资源，以在访问页面时资源请求命中本地缓存。</p><ul><li>优点：不影响业务开发，成本小；</li><li>缺点：通用资源的定义和配置需要评估、避免请求浪费；</li><li>适用场景：应用存在高频公共资源，但这些资源无法使用离线方案。</li></ul><h4 id="通用预加载方案接入"><a href="#通用预加载方案接入" class="headerlink" title="通用预加载方案接入"></a>通用预加载方案接入</h4><p>可借助通用预热方案，启动预热 WebView，此 WebView 根据配置进行资源预加载。</p><p>当然，无论是离线还是预热，我们仍然需要考虑资源优化，比如通过分包、图片远程等方式，减少不必要的资源加载。</p><hr><h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><ul><li>《Google-Developer Loading Performace》<a href="https://developers.google.com/web/fundamentals/performance/get-started?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/get-started?hl=zh-cn</a></li><li>《Google-Developer Rendering Performace》<a href="https://developers.google.com/web/fundamentals/performance/rendering?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering?hl=zh-cn</a></li><li>《以用户为中心的性能指标》<a href="https://web.dev/user-centric-performance-metrics/" target="_blank" rel="noopener">https://web.dev/user-centric-performance-metrics/</a></li><li>《WebDev RAIL 模型》<a href="https://web.dev/rail/" target="_blank" rel="noopener">https://web.dev/rail/</a></li><li>《MDN-Web 性能》<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Performance</a></li><li><p>《MDN-Performance》<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p></li><li><p>《嗨，送你一张 Web 性能优化地图》<a href="https://github.com/berwin/Blog/issues/23" target="_blank" rel="noopener">https://github.com/berwin/Blog/issues/23</a></p></li><li>《Web Vitals》<a href="https://web.dev/learn-web-vitals/" target="_blank" rel="noopener">https://web.dev/learn-web-vitals/</a></li><li>《合集-Web 性能优化》<a href="https://asmcn.icopy.site/awesome/awesome-wpo/" target="_blank" rel="noopener">https://asmcn.icopy.site/awesome/awesome-wpo/</a>，（有广告）</li><li>《大型网站性能优化实战——从前端、网络、CDN 到后端、大促的全链路性能优化详解》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web性能及优化&quot;&gt;&lt;a href=&quot;#web性能及优化&quot; class=&quot;headerlink&quot; title=&quot;web性能及优化&quot;&gt;&lt;/a&gt;web性能及优化&lt;/h1&gt;&lt;h4 id=&quot;更新信息&quot;&gt;&lt;a href=&quot;#更新信息&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能" scheme="http://blog.michealwayne.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《软件开发的201个原则》（201 Principles of software development）读书笔记</title>
    <link href="http://blog.michealwayne.cn/2021/11/28/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84201%E4%B8%AA%E5%8E%9F%E5%88%99%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2021/11/28/notes/【笔记】《软件开发的201个原则》/</id>
    <published>2021-11-28T09:20:09.000Z</published>
    <updated>2021-11-29T05:11:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《软件开发的201个原则》（201-Principles-of-software-development）"><a href="#《软件开发的201个原则》（201-Principles-of-software-development）" class="headerlink" title="《软件开发的201个原则》（201 Principles of software development）"></a>《软件开发的201个原则》（201 Principles of software development）</h1><blockquote><p>作者：Alan M. Davis，Offtoa 公司联合创始人兼首席执行官（2012年开始）；曾任Omni-Vista 公司的联合创始人、董事长兼首席执行官，Requisite 公司的董事会创始成员，BTG 公司副总裁。</p></blockquote><p>从项目管理十大领域及其他涉及领域进行分类记录：</p><p><img src="/images/20211128/p-guide.png" alt="p-guide"></p><h3 id="书中划分维度-章节"><a href="#书中划分维度-章节" class="headerlink" title="* 书中划分维度/章节"></a>* 书中划分维度/章节</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p><img src="/images/20211128/p-1.jpg" alt="p-1.jpg"></p><h4 id="（第二章）一般原则"><a href="#（第二章）一般原则" class="headerlink" title="（第二章）一般原则"></a>（第二章）一般原则</h4><p>对应原则1～37。</p><h4 id="（第三章）需求工程原则"><a href="#（第三章）需求工程原则" class="headerlink" title="（第三章）需求工程原则"></a>（第三章）需求工程原则</h4><p>对应原则38～60。</p><p>需求工程包括以下活动：</p><ul><li>1.提出或研究需要解决的问题；</li><li>2.具体说明一个能解决该问题的系统外部（黑盒）行为。</li></ul><p>需求工程的最终产出是需求规格说明书（Requirement Specification）。</p><h4 id="（第四章）设计原则"><a href="#（第四章）设计原则" class="headerlink" title="（第四章）设计原则"></a>（第四章）设计原则</h4><p>对应原则61～86。</p><p>设计包括以下活动：</p><ul><li>1.定义满足需求的软件架构（architecture）；</li><li>2.具体说明架构中的各个软件组件的算法。</li></ul><p>架构包括：软件中所有模块的定义，它们之间如何提供接口，它们之间如何组装，组件的拷贝如何实例化和销毁。</p><p>设计的最终产出是设计规格说明书（Design Specification）。</p><h4 id="（第五章）编码原则"><a href="#（第五章）编码原则" class="headerlink" title="（第五章）编码原则"></a>（第五章）编码原则</h4><p>对应原则87～106。</p><p>编码是包含以下行为的集合：</p><ul><li>1.将设计阶段确定的算法转换为用计算机语言编写的程序；</li><li>2.将程序（通常是自动化的）转换为可被计算机直接执行的语言。</li></ul><p>编码的主要输出结果就是程序清单。</p><h4 id="（第六章）测试原则"><a href="#（第六章）测试原则" class="headerlink" title="（第六章）测试原则"></a>（第六章）测试原则</h4><p>对应原则107～126。</p><p>测试是包含以下行为的集合：</p><ul><li>1.对独立的软件组件执行测试（即单元测试，Unit Testing），以确保其行为与组件设计规格说明中的定义足够接近；</li><li>2.对执行过单元测试的组件集合执行测试（即集成测试，Integration Testing），以确保这些组件一起工作时的行为足够接近设计规格说明中的定义；</li><li>3.对集成测试过的所有组件进行测试（即软件系统级测试，Software Systems-level Testing），以确保它们可以作为一个系统来运行，且行为足够接近软件需求规格说明中的定义；</li><li>4.制订软件系统级测试的测试计划；</li><li>5.制订软件集成测试的测试计划；</li><li>6.制订单元测试的测试计划；</li><li>7.建立测试装置（test hamess）和测试环境（test environment）。</li></ul><h4 id="（第七章）管理原则"><a href="#（第七章）管理原则" class="headerlink" title="（第七章）管理原则"></a>（第七章）管理原则</h4><p>对应原则127～172。</p><p>管理是围绕软件开发的所有工程活动，是进行计划（plan）、控制（control）、监视（monitor）和报告（report）的一组活动。</p><h4 id="（第八章）产品保证原则"><a href="#（第八章）产品保证原则" class="headerlink" title="（第八章）产品保证原则"></a>（第八章）产品保证原则</h4><p>对应原则173～184。</p><p>产品保证是通过使用分权制衡（checks and balances）来确保软件质量的一系列活动。产品保证通常包括如下几项：</p><ul><li>1.软件配置管理（Software configuration management）：是管理软件变更的过程；</li><li>2.软件质量保证（Software quality assurance）：是检查所有做法和产品是否符合既定流程和标准的过程；</li><li>3.软件验证和确认（Software verification and validation）：这个过程用于验证（verify）每个中间产品是否正确地建立在以前的中间产品的基础上，以及确认（validate）每个中间产品是否适当地满足客户的要求；</li><li>4.测试（Testing）。</li></ul><h4 id="（第九章）演变原则"><a href="#（第九章）演变原则" class="headerlink" title="（第九章）演变原则"></a>（第九章）演变原则</h4><p>对应原则185～201。</p><p>演变是与修改软件产品相关的一系列工作。用于：</p><ul><li>1.满足新功能；</li><li>2.更有效地运行；</li><li>3.正常运行（当检测到原始产品中的错误时）。</li></ul><hr><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>豆瓣：英文原版<a href="https://book.douban.com/subject/4775995/" target="_blank" rel="noopener">https://book.douban.com/subject/4775995/</a>，中文版<a href="https://book.douban.com/subject/35628886/" target="_blank" rel="noopener">https://book.douban.com/subject/35628886/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《软件开发的201个原则》（201-Principles-of-software-development）&quot;&gt;&lt;a href=&quot;#《软件开发的201个原则》（201-Principles-of-software-development）&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://blog.michealwayne.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《人件》（Peopleware，第三版）读书笔记（下）人件》（第三版）</title>
    <link href="http://blog.michealwayne.cn/2021/11/07/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BA%BA%E4%BB%B6%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2021/11/07/notes/【笔记】《人件》（第三版）（下）/</id>
    <published>2021-11-07T12:15:56.000Z</published>
    <updated>2021-11-16T07:46:47.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《人件》（Peopleware，第三版）读书笔记（下）"><a href="#《人件》（Peopleware，第三版）读书笔记（下）" class="headerlink" title="《人件》（Peopleware，第三版）读书笔记（下）"></a>《人件》（Peopleware，第三版）读书笔记（下）</h1><blockquote><p>也许，软件系统的主要问题不在于技术，而在于社会性因素。</p></blockquote><h2 id="高效团队养成"><a href="#高效团队养成" class="headerlink" title="高效团队养成"></a>高效团队养成</h2><p>好的工作体验总是伴随着一定的挑战性。在我们那些珍贵的工作记忆中，浮现在眼前的都是团队的互动。当一组人融合为一个整体时，工作的全部特征就改变了。工作中的挑战固然重要，但重要的不是它本身，而是它指引着我们共同努力的方向。挑战是我们成为整体的载体。在那些能够让大家尽情发挥到自己极限的工作团队里，团队互动就是全部工作。</p><h3 id="整体大于部分之和"><a href="#整体大于部分之和" class="headerlink" title="整体大于部分之和"></a>整体大于部分之和</h3><p>对拥有共同任务的一群人都称其为团队。然而，很多这样的小组并不像团队。他们没有对成功进行共同定义，或者没有一种可识别的团队精神。某些东西缺失了，那是一种被我们称为“凝聚力”的现象。</p><h4 id="有凝聚力团队的概念"><a href="#有凝聚力团队的概念" class="headerlink" title="有凝聚力团队的概念"></a>有凝聚力团队的概念</h4><blockquote><p>一个有凝聚力的团队是一组紧密交织在一起的人，他们的整体大于个体之和。</p></blockquote><p>一旦团队产生了凝聚力，成功的几率将大大增加。这样的团队不需要传统意义上的管理，更不需要激励，他们斗志昂扬。</p><p>产生这种现象的原因并不复杂：团队都是围绕共同目标成立的。在凝聚为团队之前，团队中的每个人可能都有自己不同的目标。但作为凝聚过程的一部分，他们聚拢所有，汇成一个共同目标。公司级目标至关重要，因为它对团队而言意义非凡。目标自身对团队成员来说可能有一定的随机性，但大家可以竭力去追求目标的实现。</p><h4 id="歇斯底里式的乐观管理"><a href="#歇斯底里式的乐观管理" class="headerlink" title="歇斯底里式的乐观管理"></a>歇斯底里式的乐观管理</h4><p>相信员工都会自动认同组织的目标，只能说明管理上的盲目乐观。要让个体把自身融入组织目标中的机制实在太复杂了。例如某一位数据库专家，他更倾向于把自己描述为一位父亲、或本地学校委会的一员。在这些角色中，他随时都在通过深入思考做出价值判断。让人诧异的是，他是否会在谈及工作时停止进行价值判断呢？他不会，他会在工作中持续地评判和他个人能力及信任度有关的各种言论。组织里的人时刻都在批判组织目标，而且，他们认为大多数目标都过于随意。</p><p>这里的困境在于，倘若你是一名老板，你可能真心诚意地接受了企业的经营目标，要是你的员工不够热情你就会感到失望。但回头想想，你自己对企业目标的强认可也许也不仅仅是职业素养的表现吧？难道不是你的老板或者企业高层通过一点点聪明的设计，让企业的目标和你个人目标一致带来的吗。利用组织阶梯，保证管理者有强烈个人动机去接受企业目标，这种设计很巧妙。然而到了最底层，在真正开展工作的地方，这种设计就失效了。在那里，我们仅仅希望用所谓的“职业素质”来保证大家都向同一个方向前进，这完全就是撞大运。</p><p>所有员工拥有共同信念，别再心存这样的幻想啦。</p><h4 id="纳瓦隆大炮"><a href="#纳瓦隆大炮" class="headerlink" title="纳瓦隆大炮"></a>纳瓦隆大炮</h4><p>企业的目标或多或少总是会让大家感到过于专制——企业对人们来说本来就是专制的——但带有强制性的目标并不意味着没人接受。如果真是这样，那么就不会有体育竞赛了，体育竞赛的目标总是强制的。</p><p>团队外围的人可能对团队的成败感兴趣，但他们的兴趣相对团队成员来说就微乎其微了。在凝聚力强的团队中工作的人们常常会过度投入，以至于疯狂到想要使用纳瓦隆大炮。</p><p>尽管有凝聚力的团队拥有这样的动力及热情，管理者却不愿意经历必需的痛苦去孵化它。部分原因在于不理解为什么团队需要凝聚力。对达成目标有强烈驱动力的管理者会发现团队并不会帮助达成目标，反而是团队里的人在达成目标。为达成目标，分解的每个任务基本都是由团队中的个体来完成的，大部分工作也是由个体单独完成的。</p><blockquote><p>团队存在的目标不是达成目标，而是让目标一致。</p></blockquote><h4 id="有凝聚力团队的标志"><a href="#有凝聚力团队的标志" class="headerlink" title="有凝聚力团队的标志"></a>有凝聚力团队的标志</h4><p>最重要的一项是在项目和任务执行过程中的低人员流失率。团队成员都愿意留下来完成项目。可悲的是，管理者通常会忽视团队成功的标志。即使情况已经很糟糕，他们仍然不愿意关注人员的流失；让流失率较低时，他们根本不会去想。</p><p>有凝聚力的团队通常都有一个很强的自我认知。队友之间都用一些朗朗上口的称呼而且会分享诸多玩笑。团队可能拥有明显的地盘，大家聚在一块儿共进午餐。</p><p>在好的团队中，有一种精英的感觉。队员们都觉得自己是独特事物的一部分，他们感觉比机器强多了。他们自有一种傲慢，从而使得那些不在团队的人们感到不舒服。</p><p>有凝聚力的团队对生产出来的产品有强烈的归属感。参与者都希望一个产品或某个组成部分能够留下大家的名字。每个人都希望别人看到自己的成果。</p><p>有凝聚力的团队的最后一个标志是队员们对工作乐在其中。有凝聚力的团队显得健康而拥有活力，交流轻松自如，自信而充满热情。</p><h4 id="团队和团伙"><a href="#团队和团伙" class="headerlink" title="团队和团伙"></a>团队和团伙</h4><p>团队和团伙的区别就像微风和阵风，他们意义相同，都是凉的流动空气。若你感到让人心旷神怡，你会说这是微风；如果让人烦闷不安，你会说这是阵风。同理，当一个密切协作的工作小组凝聚在一起并让大家感到愉快时，大家会说这是一个团队；但如果让大家感觉是一种威胁，人们会使其为团伙。</p><p>对团伙的恐惧是管理缺乏安全感的表现。越感觉不安全，越害怕团伙这个想法。个中自有因由：管理者往往不是真正意义上的团队成员，所以被排除在团队外的感觉超过了跟团队紧密相连的感觉。团队内部的信任程度也要高于把团队联系在公司内的信任度。然后就会滋生一种糟糕的想法，认为紧密连接的团队可能会脱离集体而把所有的动力和热情用于竞争。就是这些原因造成了缺乏安全感的管理者们惧怕团伙的情形。他会感觉跟一群统一的可替代的塑料人一起工作会更好。</p><p>一个拥有凝聚力的工作组可能自傲、自足、让人头疼还有点排外，但对比拼凑起来的可替换部件，它却能帮助管理者实现真正的目标。</p><h3 id="黑衣团伙"><a href="#黑衣团伙" class="headerlink" title="黑衣团伙"></a>黑衣团伙</h3><h4 id="传奇团队的人员组成"><a href="#传奇团队的人员组成" class="headerlink" title="传奇团队的人员组成"></a>传奇团队的人员组成</h4><p>在软件交付前，要找到最后的缺陷很难，但一些测试人员能够做得更好。于是这一家公司集合了一些才华卓越的测试人员，分配给他们任务，要求关键软件交付给客户之前做最后的测试。于是具有传奇色彩的黑衣团队（Black Team）诞生了。黑衣团队最让人吃惊的不是他们在一开始有多好，而是在接下来的一年时间里的改进。一些神奇的事情发生了：团队形成了自己的个性。在测试的对抗哲学影响下，这一个性在团队成员中形成，它让大家积极主动地去发现缺陷。他们并不完全是为开发人员提供支持，恰恰相反，他们乐于提交一个程序去接受一系列测试，更像是一种考验。提交你的程序去接受黑衣团队测试，就像去经受冷血魔王的考验一样。</p><h4 id="可怜的地球生物，谁能拯救你们呢？"><a href="#可怜的地球生物，谁能拯救你们呢？" class="headerlink" title="可怜的地球生物，谁能拯救你们呢？"></a>可怜的地球生物，谁能拯救你们呢？</h4><p>团队开始树立起毁灭者的形象。他们毁灭的不仅仅是你的代码，而是你的一整天。他们使用各种惨无人道的手段来造成程序失败，比如缓冲区过载、空文件比较或者输入无理的长字符串。看着自己的程序被如此邪恶的方式给践踏，你越感到难过，但他们越开心。</p><p>为了加强邪恶形象的效果，团队开始身着黑衣（黑衣团队得名的由来）。逐渐程序员们开始抱怨黑衣团队这种病态的折磨。</p><p>不用说，公司自然乐见于此，团队找到的每一个缺陷都不是客户发现的，团队获得了巨大的成功。作为一个测试组织，它成功了，但更重要的，团队作为一个社会单元成功了。团队内部的化学反应本身成了目标。</p><p>随着时间推移，团队成员逐渐转移到其他事情上。由于团队担负了如此重要的任务，每离开一位就有新人加入，这样一直到全部原班人马都离开了团队。但黑衣团队仍然存在，团队失去了原来的所有人，但团队的动力和个性依然存在。</p><h3 id="团队自毁"><a href="#团队自毁" class="headerlink" title="团队自毁"></a>团队自毁</h3><p>当你试图解决问题时感觉被卡住了，Edward deBono《水平思考》（Lateral Thinking）建议，与其一根筋地寻找实现目标的方法，不如尝试寻找实现目标对立面的方法。这种方法能够让你理清阻碍你创造性思维的杂乱因素。</p><p>团队自毁“技巧”清单：</p><ul><li>防御式管理</li><li>官僚主义</li><li>物理分隔</li><li>时间碎片</li><li>牺牲产品质量</li><li>伪造截止日期</li><li>团伙控制</li></ul><h4 id="防御式管理"><a href="#防御式管理" class="headerlink" title="防御式管理"></a>防御式管理</h4><p>作为一名管理者，对于大多数风险采取防御动作再正常不过了。如果你要使用一件极容易失败的工具，你会准备一个备用品；如果你的客户总是犹豫矫情，你会多花时间来细化产品规格定义；如果你的合作商总是忘记承诺，每次会议你会发布纪要。然而在一个领域里，防御一定会带来反效果：当你的人能力不足时，你不可能运用防御措施来保护自己。倘若你的员工能力达不到工作的要求，你就会失败。当然如果确实不足以胜任工作，就应该去找新人。但是一旦你已经决定使用这一组人，那么最佳战术就是信任他们。因为想保证成功而采取的任何防御性措施都指挥让事情变得糟糕，即使短期能够给你一些宽慰，长期看一定没有帮助，相反会成为团队凝聚的毒药。</p><p>如果你是管理者，你当然会感觉你的判断比你手下的人要好很多。你拥有更多的经验，而且高于施加给他们的卓越标准；这也是你成了管理者的原因。在项目的任何时间点，如果你不去做判断，你的团队就更容易犯错误，但那又怎样呢？让他们去犯错吧。这并不代表你就不能（偶尔）去改变一个决定或者帮助项目调整方向。但如果大家认为不允许他们自己犯下任何错误时，你就传递了一个对团队不信任的信号。没有什么比这个信号更能够阻止团队形成了。</p><p>大多数管理者都认为自己善于判断他的下属何时值得信任，何时需要质疑。但就我们的经验来看，大多数管理者在错误地使用不信任。他们都基于这样一条基本的假设，如果大家能够正确地运作，就可以自主地运作。这等于没有任何的自主权利，真正有意义的自主是走一条不同于管理者决定的道路。从更宽泛的意义上来看，这也是正确的：（在你的管理者或者政府眼里）做正确的事情跟自主无关；有权做错误的事情才称得上是自由。</p><p>最显而易见的防御式管理方法是程序化的方法论和管理者的技术干涉。长远来看，这两种方法都会导致失败，而且是导致团队自毁的有效手段。不被信任的人不会有动力愿意在一起组成一个协作的团队。</p><h4 id="官僚主义"><a href="#官僚主义" class="headerlink" title="官僚主义"></a>官僚主义</h4><p>Caper Jones在20世纪70年代和80年代都做过关于个类型系统开发成本的调查。一种类型叫“文案工作”，Jones认为那是不需要动脑子的整理文档的工作，因为决定文档内容的工作都被归纳在其他活动中了，如分析、设计、测试计划等。换个角度看，他所谓的“文案工作”类型就是纯粹的官僚。这种类型的工作是系统开发的第二大类，大约超过30%的花销都花在这上面。</p><p>令人失望的是，现在的一个趋势让越来越多的开发人员进入官僚体系里。可能这就是防御性管理流行的一个信号。虽然这种趋势是全球性的，但各个地区却不相同。</p><p>无须思考的文案工作就是一种浪费，我们应该向他们宣战，因为这些事情让人没法干活。这是官僚主义在伤害团队的形成。团队需要相信他们为之组成的目标。目标可能是随机的，但一定需要有，而且至少有证据表明管理层也是认可的。仅仅告诉大家目标很重要，然后让大家花1/3的时间做文案工作是不够的。文案写手不可能进入SWAT团队模式，也不可能视自己为追求成功的奋斗者。</p><h4 id="物理分隔"><a href="#物理分隔" class="headerlink" title="物理分隔"></a>物理分隔</h4><p>原本可以紧密协作的团队被安排在不同的区域、楼层，甚至是不同的大楼。团队工作的交互可能没什么大影响，但团队日常的交流就没有了。团队里的人可能跟不是一个团队的邻居更亲密些，因为他们经常见面。由于没有团队的空间，没有团队的即时互动，也就没有形成团队文化的可能。</p><p>在物理上分隔需要紧密交流的人本来就不合理，邻桌的员工彼此成了噪声和打扰的来源。但当他们都在一个团队中时，他们倾向性地会同时进入安静模式，这样对流的打扰就少很多了。让团队成员在一起也给了大家日常互动的机会，而这是团队形成所必需的。</p><h4 id="时间碎片"><a href="#时间碎片" class="headerlink" title="时间碎片"></a>时间碎片</h4><p>每个人的指责都成了碎片，因为他们的技能和知识造成他们时不可或缺的，没法把事情再分出去。这没有任何道理，碎片化对团队形成是有害的，而且也伤害效率。人们只能有效跟踪有限的人际互动。让一个人同时在4个项目里时，他就需要承受4倍的人际互动，就等于把所有时间都花在角色切换上了。</p><p>没有人可以同时是多个有凝聚力团队的一员。紧密协作的有凝聚力团队是排他的，碎片化的团队不可能形成凝聚力。糟糕的事情是我们容忍了太多没有必要的碎片化。我们其实可以做到不战而胜，简单来说就是定下目标，让大家在一段时间只做一项工作，从而减少碎片化，让团队真正有机会形成。</p><h4 id="牺牲产品质量"><a href="#牺牲产品质量" class="headerlink" title="牺牲产品质量"></a>牺牲产品质量</h4><p>没人会真正说自己的产品具有质量缺陷，他们会说这是成本压缩的产品，其实往往就是同一回事。通常，缩短产品生产时间的方法到最后就会造成质量下降。产品的最终用户一般愿意接受这样的置换，但这是对开发人员良心的拷问，他们的自我价值及实现被破坏了，现实要求他们只能生产出质量低于他们力所能及的产品。</p><p>团队建立起来的自我认知在决定牺牲质量时就荡然无存了。大家知道，只有停止做这样的事情才能得到解脱。项目结束后，大家都想尽量彼此分开，然后去做其他有意义的事情。</p><h4 id="伪造截止日期"><a href="#伪造截止日期" class="headerlink" title="伪造截止日期"></a>伪造截止日期</h4><p>当一个管理者摆出“我们必须在。。。之前完成”的姿态时，大家可能连眼皮都不会太一下。他们经历过太多次了，知道这是什么样的游戏。</p><p>你的员工很容易知道你是否在欺骗。在一个典型的伪造截止日期的谈话中，管理者宣布工作必需在某某日期前完成。要按照这个时间，工作根本没有成功的希望，因而对员工来说信号很明确：老板是一个帕金森式的机器人，从来不尊重和关心他们。老板相信如果不加束缚，大家是不会有产出的。在这样的项目中，就别想有什么凝聚力的团队了。</p><h4 id="团伙控制"><a href="#团伙控制" class="headerlink" title="团伙控制"></a>团伙控制</h4><p>团队活动的愉悦以及团队互动产生的动力是我们建立互信的基础。商业组织怎么能够对这些事情无动于衷或者对自己的团队漠不关心呢？部分原因出自不安全感，另一部分原因是高层管理对团队显然的无知。团队现象发生在金字塔的最底端。对于我们常说的“管理团队”，这根本不存在——在管理层从来没有有凝聚力的团队。即使管理者加入到真正的团队，也只是因为他们的双重职责：一面是管理，一面是小组的一员。他们被自己管理的员工认为是一个兼职队员。公司组织越往高层，有凝聚力的团队这个概念就越被人遗忘。</p><p>#### </p><h3 id="再谈团队自毁"><a href="#再谈团队自毁" class="headerlink" title="再谈团队自毁"></a>再谈团队自毁</h3><h4 id="可恶的标语和纪念碑"><a href="#可恶的标语和纪念碑" class="headerlink" title="可恶的标语和纪念碑"></a>可恶的标语和纪念碑</h4><p>大部分形式的团队自毁，其危害来自于贬低工作或贬低做工作的人。工作的重要性和把工作做好的价值可以催化团队。团队给自己的任务是要达到匠艺的水平。所有成员都知道工作质量对于组织的重要性，而团队会通过遵守更高的标准脱颖而出。没有这一突显的因素，小组还是小组，不会成为真正的团队。</p><p>在这个复杂的机制里，想象一下我们买了条标语，提醒大家“质量第一”。他们称为励志小附件的东西，就是形式大于实质的表现。他们好像在宣扬质量、领导力、创造力、团队协作、忠诚守信和其他组织美德的重要性。但其实通过这样简单的形式却发出了完全不同的信号：管理者相信这些美德可以通过搞些招贴就能提高，并不需要努力工作或者什么管理才能。所有人很快就能发现，这些招贴就是不用努力工作、无须才能的保证。</p><p>励志小附件假到让大家起鸡皮疙瘩，它们给健康的组织带来危害。</p><h4 id="加班：一种意外的副作用"><a href="#加班：一种意外的副作用" class="headerlink" title="加班：一种意外的副作用"></a>加班：一种意外的副作用</h4><p>副作用很明显：犯错、累倒、离职率上升和付薪的无用时间。当然，还有对一个良性运转的工作团队的自毁反应。</p><p>在任何四五个人的团队里，一定会有几个人不能承受在其他人看来很灵活的加班时间。过去的加班仅仅是几次晚班或者偶尔一天的周末，大家都能够咬咬牙。但如果加班延长到几个月，即便是最为精诚团结的团队成员也要受到影响时，就一定会对团队的凝聚力造成破坏。不能够分担痛苦的人会一点点被其他人疏远。</p><p>毫无疑问，延长加班时间就是一项减产的实践。额外几个小时的产出总会被之后的副作用抵消，即使不考虑它对团队的破坏也是一样。只是当你考虑到团队成员不同的加班能力会破坏团队凝聚力的时候，这一点就更具说服力。</p><blockquote><p>“我们并非是要通过加班来完成工作，而是希望能够在工作根本无法按时完成时通过加班来避免指责。”</p></blockquote><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>你一定听说过，公司的存在就是为了能够跟其他公司竞争，所以延伸一下，公司内部的一点点竞争也是保持公司竞争力的健康手段。另一些管理者则认为，如果团队成员感觉到自己被强迫与队友竞争，那是有问题的。从极端角度来看，竞争当然会阻碍团队凝聚。要是团队被告知：明年，他们之中只有最棒的一个才能留下来，毫无疑问，他们不可能在工作中友好相处并走向成功。</p><h4 id="考虑一个类比"><a href="#考虑一个类比" class="headerlink" title="考虑一个类比"></a>考虑一个类比</h4><p>兄弟姐妹之间的竞争并不完全可行。例如我们知道，兄弟姐妹倘若是在激烈竞争的环境中成长，在长大之后通常都会变得疏远。那些竞争较少的孩子们一旦成人，更有可能建立起温馨的亲属情谊。目前，对于父母是否激励或制止兄弟姐妹之间的竞争，已达成了共识。竞争之所以产生，或许出于父母对子女的感情关心不够，他们没有足够的时间，没有给予足够的尊重、关心和爱护。</p><h4 id="这有关系吗？辅导的重要性"><a href="#这有关系吗？辅导的重要性" class="headerlink" title="这有关系吗？辅导的重要性"></a>这有关系吗？辅导的重要性</h4><p>在需要一起工作的人群中强调竞争带来的长期影响是什么？首先，牺牲的是对健康团队而言必需的简单有效的个体辅导。</p><p>今时今日，一个典型的知识型团队需要各种不同的技能，老板掌握的只是其中一些，老板只能辅导团队的部分人员，其他人怎么办？我们慢慢认同应该由团队成员自己提供大部分的辅导。</p><p>观察一个紧密协作的团队工作，你会发现直截了当的个体辅导时常发生。团队成员坐在一起结对传递知识。每当此时，总是一人教一人学。他们的角色随着时间推移不断交换，或许A辅导了B关于TCP/IP的知识，B又会辅导A怎样实现队列。一旦这种方式得到了良好运转，参与者几乎是不自觉的，甚至不会有谁感觉到是在辅导；对大家来说，这就是工作。</p><p>无论提及与否，辅导都是成功团队互动的关键因素。它提供了参与者协作和自我提升的机会。同时，辅导会让人感觉愉快。</p><p>若大家感觉不够安全，辅导行为就不可能发生。在一个竞争环境中，除非你疯了，否则才不会让人看到你正在接受辅导呢。</p><h4 id="再谈团队自毁-1"><a href="#再谈团队自毁-1" class="headerlink" title="再谈团队自毁"></a>再谈团队自毁</h4><p>内部竞争会直接造成辅导工作异常艰难，甚至根本就不可能。由于辅导是健康团队工作的核心，管理者做的任何增强团队内部竞争的事情都是在进行团队自毁。下面是一些能够引起团队自毁副作用的管理行为：</p><ul><li>年度薪酬评审</li><li>目标管理法MBO</li><li>表彰个别员工的突出成就</li><li>跟绩效相关的证书、奖励和奖金</li><li>任何形式的绩效考核</li></ul><p>W.Edwards Deming在他1982年出版的《走出危机》一书中，总结了协作被普遍遵守的“十四点”。隐藏于其中的第12B条基本可以看做是深思熟虑的结果：</p><blockquote><p>在管理及工程过程中消除障碍人们追求匠艺的障碍，就意味着（和其他事情一起）废除掉年度或量化评级与目标管理的方式。</p></blockquote><p>戴明的观点在于MBO等系列方法都是管理者站不住脚的借口。使用简单的外部激励来促进绩效，会使得管理者们不去处理应该思考的复杂事物，如能力投资、个人直接动机、团队形成、人员留用及可持续的分析以及对工作流程的再设计。</p><p>针对团队成员的任何不同的奖励机制都可能增加内部竞争。管理者需要采取措施降低或抵消这样的影响。</p><h4 id="混合的隐喻"><a href="#混合的隐喻" class="headerlink" title="混合的隐喻"></a>混合的隐喻</h4><p>我们都见过体育团队不受某个队员失败的影响而获得成功；我们也见过尽管个别球员拥有精彩的表现，团队还是输得很惨。所以个体的成败与整个团队的成败看起来风马牛不相及。这种状况并不完美，只能让最初对于竞争的倾向更加恶化。</p><p>对比之下，像唱诗班、合唱团这样的组织就建立起了几乎完美的个体与团体成败绑在一起的关系。</p><h3 id="一顿意面晚餐"><a href="#一顿意面晚餐" class="headerlink" title="一顿意面晚餐"></a>一顿意面晚餐</h3><h4 id="团队效应开始起作用"><a href="#团队效应开始起作用" class="headerlink" title="团队效应开始起作用"></a>团队效应开始起作用</h4><p>成功会孕育成功，高产的和谐会带来更高产的和谐。一位与生俱来的管理者会下意识地感觉到什么是一项好的团队活动。这种感觉一直会持续到项目中的决策管理上。整个体验上围绕着小巧、简单、协作的成功来组织的。不仔细观察，你可能无法察觉管理者的存在；事情就自然而然发生了。</p><p>好的管理者会经常给团队提供机会，让大家来一起享受成功。这些机会可能是一些小的策划、演示或模拟练习，总之是任何能够让团队快速习惯共同成功的事情。最棒的成功就是看不到任何明显的管理，团队是平等而友好个体的聚合，在一起努力工作。最棒的老板就是这样能够不断地管理，切让团队成员感觉不到是在被管理。</p><p>表明看来如此容易，以至于大家都不相信他们是在做管理。</p><h3 id="敞开和服"><a href="#敞开和服" class="headerlink" title="敞开和服"></a>敞开和服</h3><p>有时候，人员组成了一个小组，小组的人却不想凝聚成一个团队；他们就是独狼，喜欢一个人。</p><p>在《人和项目管理》一书中，Rob Thomsett 分析了阻碍团队形成的病因。然而这些病因基本上无药可治，唯一可行的疗法就是将那些阻碍团队凝聚的个人提出团队。从学术上来讲，这可能是合理的，但现实操作起来，你会发现这其实再愚蠢不过了。因为那个你想踢出去的人在其他方面可能是一把好手。很多事情都需要在没有凝聚力的团队中开展。</p><h4 id="感觉好，请“病”假"><a href="#感觉好，请“病”假" class="headerlink" title="感觉好，请“病”假"></a>感觉好，请“病”假</h4><p>并不是生理上的病态，而是指在这种地方工作，需要扭曲一些精神上的生存法则，而这些法则本身是保护我们心理健康的。这些法则中最重要的就是关于自我认知。要是一项工作伤害了你的自我认知，本身就是“病态”。</p><p>只有在工作中感觉良好，才会增强自我认知。从事这样的工作，是对自身在相关领域竞争力的认可，并且能够给予员工足够的自主权，让他们能够同时履行对应职责。一经授权，这些优秀员工的管理者会小心翼翼地呵护这种自主权。他们知道，虽然员工的失败会让老板感到难堪，但这只不过是游戏中的一个小插曲罢了。他们对于偶然的倒退心有准备，也愿意接受其中一个人的失败带来的直接后果。一旦事情发生，他们也会心存怀疑，要是自己亲自操刀而不是管理别人来执行，这种失败或许永远不会发生。但这又有什么大不了的呢？你已经做到了唯才是举，人尽其才，那就要做到用人不疑。</p><p>敞开和服（Open Kimono）的态度恰好是防御式管理的反面。用人不疑，你将他放在这个岗位上，就要信任他，不需要做任何防御。你领导下的所有人都是值得信任的。一个不被你信任，工作没有自主权的人，对你来说简直一无是处。</p><p>老板将自己的声誉托付给下属，会让大家感到那么一点小小的兴奋和刺激。这会使每个人竭尽全力。大家不仅仅是在完成工作，更是在证明对他们的信任是值得的。正是这种敞开和服的管理方式让大家最有可能形成团队。</p><h4 id="走出去"><a href="#走出去" class="headerlink" title="走出去"></a>走出去</h4><p>老板防着自己人的最常见办法就是进行物理监控。</p><p>如果你的下属很有能力，要提升成功几率，可能没什么比偶尔让你自己远离他们更加有效了。任何一种容易隔离出来的任务都是一个好机会。这些任务不需要真正的管理存在。</p><p>因为这样的计划有些大胆，你的管理层和同事一定会心存疑问。但答案很简单，从他们交付的产品就能知道。如果他们交付了一个精心设计得到的完整结果，就证明他们努力工作了；倘若没有，就说明他们人浮于事。</p><p>离开办公室在诸多方面皆有裨益。首先排除了对你最有价值资源的各种干扰和打断。在短时间内，找个借口让你的团队走出去吧。除了可以让他们效率更高之外，这种完全自主的时间则有机会让他们形成一个士气高昂的团队。</p><h4 id="存在规则，但我们要打破规则"><a href="#存在规则，但我们要打破规则" class="headerlink" title="存在规则，但我们要打破规则"></a>存在规则，但我们要打破规则</h4><p>工程类职业有一种众所周知的开发模式，这种模式在其他地方是没有的，那就是<strong>臭鼬工程项目</strong>。指的是项目可以在上层管理不知情的情况下悄悄开展。当底层的员工深信产品的正确性，因而不愿意接受管理层取消项目的决定时，这种项目就会诞生。这样的项目可大有学问。有趣的是，臭鼬工程的另一方面就是犯上作乱。管理层说不，项目却照常进行。</p><h4 id="带嘴唇的鸡"><a href="#带嘴唇的鸡" class="headerlink" title="带嘴唇的鸡"></a>带嘴唇的鸡</h4><p>20世纪70年代中期，组织系统顾问Larry Constantine 为特定的几家公司提供健康公司社会生态圈方面的帮助。在他给公司提供的建议中，有一点就是让最底层员工能够在团队选择过程中具有发言权。员工们自发组成参选团队来“竞标”项目。评判标准为成员的胜任程度，成员之间的互补程度，以及把各个成员放在一起对其他项目的影响程度。公司由此挑选最适合的团队。</p><p>这样的设计给了员工两个维度上不同寻常的自由：他们能够选择自己工作的项目和自己的团队。令人惊讶的发现是第一个维度并不起什么作用。管理层一开始担心只有最耀眼的项目会有人竞标，事实却并非如此，即使最烦琐的项目也有人竞标。能够有机会与自己渴望共事的人一起工作看起来更加重要。</p><h4 id="这里谁说了算"><a href="#这里谁说了算" class="headerlink" title="这里谁说了算"></a>这里谁说了算</h4><p>最好的老板都会冒些风险，他们勇于在他们的员工身上冒险。并不是说好的管理者就不管理，而是他们不会给出固定的方向或者独断专行。他们必须时刻做出决定和判断。这里给出的建议是他们应该充分利用那种与生俱来的权威。在匠艺级的大师与学徒之间横亘着这种与生俱来的权威——大师知道如何开展工作，学徒不会。服从这样的权利不会贬低任何一个人，不会消除激励，也不会让同事之间变得不融洽。这种服从的反面则是出于不安全感而要求的服从，它表明“隶属于我麾下的员工必须执行我的决定”。</p><p>在最好的组织里，这种与生俱来的权威在各个方面发挥着效力。大家知道一个管理者的长处，可能是制定大方向、进行谈判或者招聘，而且大家对他做这些事情心悦诚服。每个员工皆有一技之长，而且在相应的领域具有权威性，从而被大家所信任。在敞开和服的氛围下，团队有最大的融合可能。</p><h3 id="团队形成的化学反应"><a href="#团队形成的化学反应" class="headerlink" title="团队形成的化学反应"></a>团队形成的化学反应</h3><p>一些组织被公认为在培育良好的融合团队方面保持了持续的好运。当然，这不是什么好运而是化学反应。在这些组织中，融合团队的养成提供了肥沃土壤。这样的环境没有防御保守的气息，没有个人罔顾集体努力，只想着获得成功。大家的工作是一个整合的产品，每个人对产品质量感到自豪。</p><p>在拥有最佳化学反应的组织里，管理人员把自己的精力放在建立和维护这样的健康化学反应上了。团队和部门能够焕发健康的气息，这全是因为管理者在背后推动。因为没有有效的体系理论来总结他们的方法，所以很难分解和分析这些组成部分。但做这种分析仍然值得尝试。</p><ul><li>建立对质量的执著追求</li><li>提供诸多满意的闭环</li><li>建立精英意识</li><li>允许和鼓励差异性</li><li>维护和保护成功团队</li><li>提供战略而不是战术方向</li></ul><h4 id="对质量的执著追求"><a href="#对质量的执著追求" class="headerlink" title="对质量的执著追求"></a>对质量的执著追求</h4><p>“只有完美对我们才足够好”给了团队真正融合的机会。它之所以让团队凝聚起来，是因为它拉远了团队每个人与其余世界的距离。</p><p>你的市场人员、产品使用者、客户和你的上级领导永远不会为高质量而摇旗呐喊，从短期经济回报上分析，追求一流的质量并不合理。若你的团队对质量报以执著追求，他们总是会交付超出市场要求的高质量产品。只有不受短期经济回报的影响，他们才能够这样做。收益会长期回报给你们，大家在质量上的高追求，会驱动他们精益求精，更好地保持对质量的追求。</p><h4 id="结婚时，我告诉她我爱她"><a href="#结婚时，我告诉她我爱她" class="headerlink" title="结婚时，我告诉她我爱她"></a>结婚时，我告诉她我爱她</h4><p>人类自己就是需要不停确认他是否沿着正确的方向前进。人类团队同样如此，在哲学上，这种确认称之为闭环（Closure）。闭环就是整体的每个部分皆需要一致满足的“过程”。</p><p>组织同样需要这样的闭环，这种闭环就是成功完成给定的任务，加上过程中不时地对按计划执行的确认。企业到底需要多少次确认，取决于就此风险需要付出多少投资。有些时候，一个组织可能四年一次闭环就足以满足需求了。</p><p>这里存在的问题是：组织在闭环上的需求远远低于在组织中工作的人们。如果工作了四年，都没有进行一次确认工作是否满意的“过程”，难免会让团队的每个人都忍不住想，“我可能熬不到这件事结束了”。特别是在团队逐步形成的时候，频繁的闭环是很重要。团队成员需要建立一种共同成功和共同认可的习惯，这是能够帮助团队提升士气的一种机制。</p><p>那些建立化学反应的管理者努力把工作分解为小块，同时确保每块工作都能够显式地展示完成后的成果。团队不停地预热，直到那个时刻到来，团队临近最后凝聚，在成功中达到顶峰。它成功为团队的下一步积蓄更新的能量，这会让大家觉得更加紧密。</p><h4 id="精英团队"><a href="#精英团队" class="headerlink" title="精英团队"></a>精英团队</h4><p>那些认为爆米花“不职业”的人，会认为团队的精英意识是右翼颠覆。普遍认为如果团队在某一方面过于标新立异，管理者就没法完成他的份内工作。团队能够遵从企业的统一标准，是管理者管控得当的标志。然而从被管理的员工角度出发，这样的标志是毁灭性的。管理者越是觉得舒适，就越会让团队失去新鲜血液。</p><p>大家都需要一种独特感来体察内心的宁静，从而在宁静之中发酵出团队的凝聚力。即使管理者尝试去抑制独特性，独特性还是会滋生出来。</p><p>团队精英意识带来的真正威胁并非无法管理，而是让管理无所适从。团队可能坚定不移地追求成功，管理者却担心自己被看做是懦夫。普通的管理者没有安全感，以至于走不出管理的陷阱。一流的管理者知道人们不能被任何合理方法控制。成功管理的核心是让大家齐心协力，然后助推大家到一个连管理者自己都无法让他们停止的点。</p><p>一个富有凝聚力的团队能够让大家更加高效，营造出目标驱动的氛围。当团队凝聚时，你确实需要放弃控制，或者放弃这种受控制的假象。团队的独特点并不需要任何基础的东西。不管精英的特点是什么，它都是形成团队标识的基础，这种标识是有凝聚力团队的一个本质要素。</p><p>这里，一个重要的限定条件是团队需要在某些方面感到独特，但并非所有方面。遵守组织规则的团队比比皆是，军事化的团队和大多数体育竞技团队都统一着装。但只要他们能够在一些方面感受到自己的独特，在其他方面就能够去遵守。</p><h4 id="不要拆散洋基队"><a href="#不要拆散洋基队" class="headerlink" title="不要拆散洋基队"></a>不要拆散洋基队</h4><p>如果团队以及凝聚，就不要拆散团队。至少，要给大家一个机会在一起尝试另外的项目。</p><h4 id="团队行为的网络模型"><a href="#团队行为的网络模型" class="headerlink" title="团队行为的网络模型"></a>团队行为的网络模型</h4><p>多数情况下，管理者并不是团队的一员。团队是由平等的个体组成的。大多数情况下，管理者都游离在团队之外，不时为团队提供来自上面的方向，同时清除行政和过程中的障碍。</p><p>在最棒的团队中，不同的个体时不时会展现出领导力，在自己擅长的专业领域带领大家。团队的结构是一个网络，而非分层结构。</p><h4 id="中餐菜谱的选择"><a href="#中餐菜谱的选择" class="headerlink" title="中餐菜谱的选择"></a>中餐菜谱的选择</h4><p>存在一点差异次啊能极大地帮助我们形成一个有凝聚力的团队。一名行动不便的开发人员加入到一个新组建的工作小组中，会让团队团结的几率大大增加。加入一名实习生都能产生同样的效果。不管这种差异的元素是什么，对团队成员来说，象征意义更重要。这是一个明确的信号，不要称为某个人的克隆，也不需要完全统一的“橡胶人”。</p><p>当一个团队真正凝聚起来时，任何代价都是值得的。</p><h2 id="沃土"><a href="#沃土" class="headerlink" title="沃土"></a>沃土</h2><h3 id="自我愈复系统"><a href="#自我愈复系统" class="headerlink" title="自我愈复系统"></a>自我愈复系统</h3><p>有时候，系统背离了最初的设计；有时候，横空出现的设计是有必要的。那些让系统运转的人们忙于修复系统。事情总是如此。</p><h4 id="确定性与非确定性系统"><a href="#确定性与非确定性系统" class="headerlink" title="确定性与非确定性系统"></a>确定性与非确定性系统</h4><p>当你对之前全人工的系统进行自动化时，系统会变成确定性的。新系统只能相应制造者设计的那些显式的命令。于是，自我治愈的能力就丧失了。任何需要被响应的要求都必须预先设计进去。如果需要治愈这样的系统，就只能在系统运行环境之外来处理。维护人员只能对系统进行分解，添加一个乃至更多新的计划好的响应来对其进行重建。</p><p>从一种视角看，去除掉混乱不可控的自我修复能力，是自动化的积极一面。系统会首先被“恰到好处”地规划，在运行时不需要再修修补补。但显而易见，这一做法可能花销很大。如果新系统管理的业务随机变化到一定程度，系统自动化就是一个错误。确定性未必有利，系统会被迫持续不断地进行维护。</p><p>非确定性系统之所以能够毫无痛苦并优雅地完成自我修复，是因为组成系统的人熟知根本的目标。一旦新的形势出现，他们可以立刻获知什么行动才是有意义的。要点在于：让系统变为确定性会导致它失去治愈自身的能力。</p><p>在某种意义上，你工作或管理的组织就是一个系统。它是互相协作的人为达成某种目标的过程的混合物。</p><h4 id="方法学的隐蔽含义"><a href="#方法学的隐蔽含义" class="headerlink" title="方法学的隐蔽含义"></a>方法学的隐蔽含义</h4><p>方法学是一种通用的系统原理，阐述了思想密集型的工作该如何管理。编撰方法学的人们都很聪明，落实这些方法的人则可能是笨伯。他们从来不需要开动自己的大脑，所有能做的就是照本宣科，从工作开始到成功结束。方法学会做出所有决策，而大家什么决策都不用做。组织这样完全变得确定化了。这样的团队也会丧失自我愈复能力，到了一定程度就变得确定。</p><p>项目成员是最熟悉项目范围的人，如果给定的方向对他们没有意义，方法就不会奏效。</p><p>大型方法学与小型方法学之间存在巨大差异，小型方法学是完成某项工作的基本途径。这样的方法学包括两个方面：定制的计划和使计划有效的必备技能。</p><p>大型方法学试图进行集中式思考，所有有意义的决策都必须由方法学的构建者做出，而不是由真正做事情的人来决定。</p><h4 id="疯狂的方法学"><a href="#疯狂的方法学" class="headerlink" title="疯狂的方法学"></a>疯狂的方法学</h4><p>大型方法学可能会极大地影响那些完全胜任的员工，通过强迫他们工作在一个固定的模子里，从而确保</p><ul><li>泥沼般没完没了的文案</li><li>少的可怜的真正可行方法</li><li>从来没有的责任心</li><li>消磨殆尽的热情</li></ul><p>文案：大型方法学鼓励大家去编写文档而不是开展工作，这种对文档的痴迷应该源于偏执的防御性思考。<strong>事无巨细的文档引入的是问题，而非解决方案。</strong></p><p>方法：在时下的技术萌芽期，对我们从事的多数工作而言，还处于缺乏完整方法的阶段。当出现真正的选择方案时，人们必须了解和掌握它们中的所有方法。对一种方法进行标准化，就是排除其他方法。这种观点认为知识弥足珍贵，我们应该珍惜使用。</p><p>责任心：要是某种方法学不生效，应归咎于方法学本事，而不是苛责于人。在这种环境下，人们愿意承担责任。</p><p>热情：实施一种方法学的决策给每个人传递着同样的信息，没有什么比得起管理者认为自己的员工无能更让大家丧气的了。</p><h4 id="恶意合规问题"><a href="#恶意合规问题" class="headerlink" title="恶意合规问题"></a>恶意合规问题</h4><p>在多种经济环境中引入方法学就可能产生按规工作的行为。大家可能真的会一板一眼地按照方法学里写的来，工作就会被拖延到几乎停滞。</p><h4 id="鸡和鸡蛋"><a href="#鸡和鸡蛋" class="headerlink" title="鸡和鸡蛋"></a>鸡和鸡蛋</h4><p>大多数方法学声称的好处实际是方法收敛的好处。在一定程度上，不同的人做同样的工作，若运用相同的方法且运用得当，确实存在一些优势。方法收敛是一件好事，但它并非唯一达到收敛的途径。方法学制定法规来强制收敛，这就带来了不可避免的副作用，一边是维法者强力的推进，一边是脑力劳动者强烈的自主意识。更好的收敛途径：</p><ul><li>培训：人们做他们知道该如何做的事。倘若你让他们知道方法的核心，他们就会去尝试使用。</li><li>工具：一些建模、设计、实现或测试的自动化工具能够让你得到比法规更多的方法上的收敛。</li><li>同行评审：在执行了有效的同行评审机制的组织里（质量管理、走查、验收、技术研讨），自然就会有收敛的趋势。</li></ul><p>只有当这种自然引导的收敛完成后，你才能去想着发布一个标准。在没有形成事实上的标准之前，是没有办法做声明的。</p><h4 id="再谈高科技假象"><a href="#再谈高科技假象" class="headerlink" title="再谈高科技假象"></a>再谈高科技假象</h4><p>在工作环境中，对于大型方法学的痴迷是高科技假象的另一种表现。这来源于对技术的崇拜，相信只有技术才真正具有意义。即使完全没有指导，大家也不会总是做出错误的决定。</p><p>相反的做法是为每一种新措施实施一个试点项目。在试点项目里，不需要遵循已有的标准，而且团队不能用以前的标准方法来完成工作。标准要求至少工作部分的内容要采用非标准的方式开展。人们在尝试新事物的时候表现会更好。</p><p>所有的生产力提升都源自于<a href="https://www.zhihu.com/question/304499279" target="_blank" rel="noopener"><strong>霍桑效应</strong></a>。为了让霍桑效应能够发挥作用，你不得不对法规采取非标准化。不管什么标准，实施时都应该简单而温和，加在你员工身上的所有标准加起来不应该超过10页纸。即使在这样的松散指导下，你还是应该准备好为特例让路，这样才能创造出一个百花齐放、百家争鸣的开发环境。</p><h3 id="与风险共舞"><a href="#与风险共舞" class="headerlink" title="与风险共舞"></a>与风险共舞</h3><p>要是风险没有得到妥善处理，原因很可能就出在组织制度和文化上。</p><h4 id="不要逃避风险"><a href="#不要逃避风险" class="headerlink" title="不要逃避风险"></a>不要逃避风险</h4><p>项目风险是一件好事情，说明项目是有价值的。在项目运行过程中，很多事情都可能出错，管理这些风险就是你工作的主要部分。</p><h4 id="我们几乎从不管理的一种风险"><a href="#我们几乎从不管理的一种风险" class="headerlink" title="我们几乎从不管理的一种风险"></a>我们几乎从不管理的一种风险</h4><p>我们习惯性地不去管理的风险是我们自己的失败。之所以没有将其列举到你的风险清单上，是因为它会让你自己看起来很糟，像个失败者。</p><p><strong>不是让所有风险都消失，而是确保风险发生时有相应的应对措施。</strong>应对措施应该提前就经过规划和演练了。</p><p>当风险发生、系统无法按期交付时，才来计划应对措施已经太晚了。</p><p>倘若一项风险出现的几率极低，那么不去管理还情有可原，但只是因为结果“想起来太可怕了”而不去管理这项风险，那就实在是没有道理了。</p><h4 id="为什么不达标的风险总是没有得到管理"><a href="#为什么不达标的风险总是没有得到管理" class="headerlink" title="为什么不达标的风险总是没有得到管理"></a>为什么不达标的风险总是没有得到管理</h4><p>当需要完成的任务被视为挑战时，进取精神往往取代了风险管理。越是时间紧张，大家越是倾向性地不愿将更多的时间花在制定应对措施计划上。</p><p>这并非完全是坏事，如果一位管理者和他的团队都不进行风险管理，那一定会有其他人需要进行风险管理。中层管理者和决策者往往善于将期望获得的结果说成是挑战。他们把挑战塑造为一种卓越的证明。但很多时候，他们并不是要指引团队去追求卓越，而是让团队尽可能廉价地完成项目。</p><p>虚假的挑战项目都有共同的特点：边际收益（因为组织回避风险，它们并非存在真正的技术风险），但时间安排的巨大风险基本是不受管理的。</p><h3 id="会议、独白和交流"><a href="#会议、独白和交流" class="headerlink" title="会议、独白和交流"></a>会议、独白和交流</h3><p>一些组织开会开到上瘾，以至于把工作放到了第二位。他们组织会议没啥目的性，也没明确定义说明是会议结束。</p><h4 id="神经硬化"><a href="#神经硬化" class="headerlink" title="神经硬化"></a>神经硬化</h4><p>当任何行动的参与方人数增加时，会议就会变得越来越流行。会议可以带来更多的信息透明，为了信息透明来参会的恶人更多会寻求发言机会。最糟糕的会议就像是一堆空谈者的集会，没有人听别人说什么，每个人都只顾着表达自己的意见或者等着表达。因为与这么多人需要发言，会议时间自然被拖长到不受控制了。</p><p>复杂度巨大这个提法当然是让每个人都感觉能够接受，因为一旦这成了会议的正当理由，就没有人会去思考另外一种可能：竞争性的空谈。</p><h4 id="“科技手段增强”的会议"><a href="#“科技手段增强”的会议" class="headerlink" title="“科技手段增强”的会议"></a>“科技手段增强”的会议</h4><p>在会议上广泛使用的科技（如笔记本电脑）对召开会议一点用处都没有；这些科技仅仅是为参会的人们逃离毫无意义的会议提供了便利。科技增强带来了会议的沉闷可怕。</p><h4 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h4><p>理论依据是站着会让大家都不太舒服，所以不抬可能空谈。这样的会议会精短一些，因而大有裨益。</p><p>即便是这样的站立会议，如果没有目标和主题也会拖组织效率的后腿，那么会议的目标和主题应该是什么呢？这就取决于会议的种类了。</p><h4 id="基本的健康会议"><a href="#基本的健康会议" class="headerlink" title="基本的健康会议"></a>基本的健康会议</h4><p>为完成一件事情而专门组织的会议可以称为工作会议。举办一次典型的工作会议就是为了要达到一个决议。需要谁参会呢？那些对决议点头的人，其他人就不需要了。为了保证大家都不会茫然，工作会议需要一个相关的日程安排，有明确的目标并且能够执行。这样可以保证即使不参会的人也能知道会议安排，不在日程上的话题是不会被讨论的。没人需要带着防御心理去参会。</p><p>工作会议有一个吸引人的特质，你知道会议何时完成。一旦达成决定，就不需要继续开会了。反之也是一样：如果你们能够确定结束会议的条件，那么这就是一个工作会议；否则就不是。</p><h4 id="仪式"><a href="#仪式" class="headerlink" title="仪式"></a>仪式</h4><p>迫于时间而结束的会议是一种仪式。这种会议的目的不是达到某个特定的决议，都是FYI（for your information，仅供参考）。</p><p>仪式是一系列的对话，对话本身是件好事。不好的是那些没有真正倾听的人被关在了对话发生的屋子里。那些相信这样的会议应该被对话取代的人，很容易观察到这样的一对一可以在其他地方发生，从而放开其他人让他们去做真正的工作。</p><p>工作环境中不时会有真正需要这样仪式的时候。仪式可能是庆祝某次成功、给大家讲解战略方向的改变，活着评估一个即将结束的项目。这些正当的仪式都有些不同寻常之处，这些不同寻常之处也是为什么正当的原因。常见仪式的一个例子就是每周/每天的项目状态会，会上，十几二十几个被锁到一间屋子里轮流向老板汇报工作。</p><h4 id="太多参与者"><a href="#太多参与者" class="headerlink" title="太多参与者"></a>太多参与者</h4><p>工作会议的参与者仅局限于利益相关的人，人数越少越好。仪式会议的参与者就没有限制了，只要负责人认为有价值参加的人都可以来，人数多一点更好。</p><p><strong>会议的成本直接取决于参会人员的多少。</strong>有一名管理者，每次开会前都会让一个人离场，她允许那个离场员工在离场前进行简短的陈词。她清楚地告诉大家选择的标准并不是这个员工相应的能力，而是他用会议时间可以完成工作的重要性。真正从释放一名员工身上得到的收益并不大，但这种行为传递的信号却不可或缺。</p><h4 id="开放空间社交"><a href="#开放空间社交" class="headerlink" title="开放空间社交"></a>开放空间社交</h4><p>会议和演讲都是烦琐的事物，真正的价值体验在那些间隙时间，一段演讲开始或结束等待的公共区、茶歇休息、午餐排队、与其他参会者一起饮茶或聚餐的时间。基于这些事实，一些有思想的人开始形成“开放空间”的想法。一次开放空间的会议完全就是茶歇和午餐。没有真正的会议，只是一个长时间的间隙。</p><h4 id="治愈会议上瘾组织的处方"><a href="#治愈会议上瘾组织的处方" class="headerlink" title="治愈会议上瘾组织的处方"></a>治愈会议上瘾组织的处方</h4><p>你改变不了你的上级，但你可以改变你的地盘，还有那些和你一起工作的同事和下属。这种改变总是知易行难，你的目标是消灭大多数仪式性的会议，而将时间花在一对一的交流上，通过运用“会议怎样才算结束？”的测试来限制每次参与工作会议的人数。要是需要什么仪式，则鼓励大家用开放空间社交来创造非结构化的自发互动。最重要的是，消减你自己需要用仪式会议来做确认的需求。</p><h3 id="终极管理罪恶得主是…"><a href="#终极管理罪恶得主是…" class="headerlink" title="终极管理罪恶得主是…"></a>终极管理罪恶得主是…</h3><p>终极的管理罪恶是浪费大家的时间。作为管理者，你有一些你自己的诉求，这些诉求会让你做出的事情与合理利用你手下员工的时间相悖。</p><h4 id="项目状态会议之关于状态"><a href="#项目状态会议之关于状态" class="headerlink" title="项目状态会议之关于状态"></a>项目状态会议之关于状态</h4><p>召开一次真正的工作会议，原因是需要所有被邀请的人一起来处理某种问题。会议的目的是达成一致，这样的会议在定义上就一定具有临时性。随之带来的就是这种会议不太可能遵循常规计划。如此推理，任何常规规划的聚会更多的可能是出于仪式目的，而要多过专注于达成一致性的目标。周例会就是一个典型的例子。看起来例会的目的是报告状态，但实际上真正的目的是状态的确认，并且不是针对工作状态，而是老板的状态。</p><p>当老板特别关注时，这些如仪式般造成负担的状态更新会议可能发展到无法控制的地步。</p><h4 id="早期超编"><a href="#早期超编" class="headerlink" title="早期超编"></a>早期超编</h4><p>会议并非是唯一浪费大家时间的地方，当过多人在项目初期就加入时，基本上总是会浪费大家的时间。项目开始于计划与设计，这些活动最好由小团队来完成。当设计很重要时，可能需要占到整个项目周期的一般。人力规划：</p><p><img src="/images/peopleware/p-03.jpg" alt="p-03.jpg"></p><p>当项目迫于紧张的时间压力下时，这一问题就凸显出来了。如果客户和高层管理下大了命令，例如这项工作一年时间，这个限制就会缩短项目预期的结束时间。</p><p><img src="/images/peopleware/p-04.jpg" alt="p-04.jpg"></p><p>很自然的，一种倾向就是把因为缩短时间而压缩的人力投入到前期去。这就是典型的早期超编：</p><p><img src="/images/peopleware/p-05.jpg" alt="p-05.jpg"></p><p>要是你知道项目无论如何都会延期，那么子啊高层倾向于在项目早期多投入的情况下，你最好考虑一下如果不再添加额外忍受是显得更好还是更糟。因为这种因素造成的项目早期超编，这种情况非常普遍。</p><h4 id="再说碎片化"><a href="#再说碎片化" class="headerlink" title="再说碎片化"></a>再说碎片化</h4><p>还有一种对时间的浪费却很可能是无法察觉的，因而没法改进。这跟之前提到的碎片化有关，这里的重点在于脑力劳动者的时间被多个同时进行的任务碎片化，这种碎片化必然导致此人会工作在不同小组里，而这样的工作组是不可能凝聚成真正团队的。</p><p>时间碎片化几乎都会带来团队自毁，除此之外还会浪费个人的时间。一个同时兼具多项任务的员工每天必然会花费一部分时间用在工作准备上，这些时间根本就看不到。</p><p>当两项任务需要的工作习惯本质上不相同时，碎片化尤为有害。持续重启造成的时间浪费只会让员工感到沮丧。</p><h4 id="尊重你自己的投资"><a href="#尊重你自己的投资" class="headerlink" title="尊重你自己的投资"></a>尊重你自己的投资</h4><p>你投入到工作中的人力资本也代表了不少钱。</p><h4 id="“邪恶”电邮"><a href="#“邪恶”电邮" class="headerlink" title="“邪恶”电邮"></a>“邪恶”电邮</h4><p>我们都习惯于海量的协调沟通邮件。这样做真的好吗？</p><p>双边关系中的一方如果过度表现，另一方就一定会表现不足。同事之间的自组织与相互协调才是良好团队协作的重要表现。一个好的教练知道自己的工作不是去协调队员的互动而是帮助大家进行自组织。因此大部分邮件就是问题的一部分，而非解决方案。</p><h4 id="公司内垃圾邮件"><a href="#公司内垃圾邮件" class="headerlink" title="公司内垃圾邮件"></a>公司内垃圾邮件</h4><p>大部分垃圾邮件都来自于同事，任何发给一个同事却传送多于半打人的邮件都可能是垃圾。</p><p>一个简单的测试企业内部垃圾邮件的方法是采用安全组织的思考方式。当安全至为关键时，信息传播应根据需要进行筛选。</p><h4 id="“FYI”到底啥意思？"><a href="#“FYI”到底啥意思？" class="headerlink" title="“FYI”到底啥意思？"></a>“FYI”到底啥意思？</h4><p>把你加为抄送人的发件人当时在想什么呢？很有多可能，很多并不值得我们赞赏：</p><ul><li>“如果我不多抄送些人，谁知道我在工作啊？”</li><li>“我不敢不发，因为如果发生什么事大家会抱怨为什么他们不知道。”</li><li>“这是一个开放的组织，所以每个人应该看到所有事情。”</li><li>“我希望大家都看看我是多么好的一个写手。”</li></ul><h4 id="是开放型组织，还是公社？"><a href="#是开放型组织，还是公社？" class="headerlink" title="是开放型组织，还是公社？"></a>是开放型组织，还是公社？</h4><p>“开放型组织”暗示大家都为自己的工作感到自豪，而且很乐意别人看到自己的工作。我们都希望跟这样的团队一起工作，但我们需要更理性：大家允许你通过拉动的方式了解他们做的工作是好的；但如果大家用推送的方式把所有信息都给你，这就不好了。</p><blockquote><p>人生短暂，如果你需要知道所有才能工作，你可能走不了多远。</p></blockquote><h4 id="撤销被动的同意"><a href="#撤销被动的同意" class="headerlink" title="撤销被动的同意"></a>撤销被动的同意</h4><p>有一条不成文规定：沉默等于同意。如果你发现自己每天花费大量时间子啊阅读没有价值的东西时，很可能就是因为你在被抄送人员里，担心被视为默认。</p><p>你需要撤销这样的规则。有效的撤销——确立只有显式同意才算同意。</p><h4 id="建立一个少垃圾邮件、自我协调的组织"><a href="#建立一个少垃圾邮件、自我协调的组织" class="headerlink" title="建立一个少垃圾邮件、自我协调的组织"></a>建立一个少垃圾邮件、自我协调的组织</h4><p>不仅要测试收到的邮件是否需要知道，对于你希望发出的邮件也要做同样的测试。每次当你想要发一封协调邮件给你的同事或为你工作的员工时，考虑一下你需要让这个人变得自我协调步骤。</p><p>告诉一个人该做什么确实简单，但让这个人逐渐形成自我协调的能力，那就太复杂了。但是从长远看，这种努力是会得到回报的。</p><h3 id="让改变成为可能"><a href="#让改变成为可能" class="headerlink" title="让改变成为可能"></a>让改变成为可能</h3><p>大家对改变的排斥不是针对某一特定的改变，而是拒绝任何改变。根源就是大家天性讨厌改变。</p><h4 id="现在，聆听另一位著名顾问的几句话"><a href="#现在，聆听另一位著名顾问的几句话" class="headerlink" title="现在，聆听另一位著名顾问的几句话"></a>现在，聆听另一位著名顾问的几句话</h4><blockquote><p>我们应该认识到：没有什么事情比让一个人成为新秩序的导入者更难驾驭，更难确定成功，更难管理风险的了。因为所有收益于旧秩序的人都将成为他的敌人；而那些也许会受益于新秩序的人只可能成为他缺乏热情的保卫者。——马基雅弗利</p></blockquote><p>围绕改变的天平两端是不平衡的。一边是那些熟知旧规则的人将成为你的敌人——你将迫使他们重新成为不适应的新手——而你从即将获益的那些人里只能获得极少的支持。原因就在于大家讨厌改变。当我们开始改变时，是否能获得成功，我们心里并没有底。这种不确定性比起潜在获益更能深入人心。</p><h4 id="老板，这想法很妙。我马上着手进行"><a href="#老板，这想法很妙。我马上着手进行" class="headerlink" title="老板，这想法很妙。我马上着手进行"></a>老板，这想法很妙。我马上着手进行</h4><p>“改变阻力连续区”：</p><p><img src="/images/peopleware/p-06.jpg" alt="p-06.jpg"></p><p>每个人对改变的反应都处于这个连续区中。</p><p>我们首先要意识到“盲目遵从”带来的危险。他们盯着新潮的流行东西，观点瞬息万变，瞬间就会放弃对你的支持。</p><p>“相信但保持质疑”的人才是唯一拥护改变的真正盟友。两个极端，无论是“盲目遵从”，还是“激励反对”，都是真正的敌人。<strong>改变能否成功，取决于你怎样管理那些“相信但保持质疑”的人。</strong>不要指望靠逻辑思维来作为你的王牌：那些抱观望态度无所谓观点的同盟者从来都不会受理性讨论的影响，即使讨论证明了建议的新方式要比现有方法好得多。当安排你去推进改变时，如下事情需得自我重复。</p><blockquote><p>对改变的基本反应并非逻辑思考得来的，而是情绪化的。</p></blockquote><p>作为系统开发人员，我们身处冷静、平静、理性的世界。编译器是不会为我们感到高兴或愤怒的，可能这就是为什么我们倾向于运用逻辑作为解决问题的主要方法。</p><p>在《管理转型》（Managing Transitions）中，威廉.布瑞琦（William Bridges）建议我们不要贬低旧的方式。相反，我们需要用感恩旧方式的方法来帮助推动改变。</p><h4 id="一个更好的变化模型"><a href="#一个更好的变化模型" class="headerlink" title="一个更好的变化模型"></a>一个更好的变化模型</h4><p>我们大多数人对改变的认知：</p><p><img src="/images/peopleware/p-07.jpg" alt="p-07.jpg"></p><p>在这样的认知中，一个突发奇想的电子引起了一种从旧到新的直接改变。但坦白说，事情没那么简单。家庭治疗师维吉尼亚.萨提亚提出对待改变的模式：</p><p><img src="/images/peopleware/p-08.jpg" alt="p-08.jpg"></p><p>外来元素的引入会成为改变的催化剂催生出改变。如果没有这种催化剂，就不会有渴求改变的认知。</p><p>当你尝试去驾驭改变时，遭遇的第一件事情就是混乱。经历混乱是绝对必要的，而且没有捷径可以跨越。</p><p>对于处于混乱中的人们，可以利用转型的想法为大家带来痛苦即将结束的希望。</p><p>实践与整合（Practice-and-Integration）阶段出现在学习曲线上扬处。由于新方式下的熟练程度还不够，你们还不能完全适应，但已经意识到新方式开始发挥作用或者有成功的希望。</p><h4 id="安全第一"><a href="#安全第一" class="headerlink" title="安全第一"></a>安全第一</h4><p>除非大家都感到安全，否则就不要发起改变。而且，只有大家清楚自己不会因为提出改变或经历改变遭遇贬低或降级时，他们才会感到安全。</p><p>改变只有在容忍失败——至少是一点失败——的情况下才有机会成功。</p><h3 id="组织型学习"><a href="#组织型学习" class="headerlink" title="组织型学习"></a>组织型学习</h3><h4 id="经验与学习"><a href="#经验与学习" class="headerlink" title="经验与学习"></a>经验与学习</h4><p>组织型学习并不能和经验的单纯积累画等号。高科技公司可以以惊人的速度积累经验，但是他们依然无法保证如何学习跟上这种速度。</p><p>当一个组织开始考虑经验的表现形式时，此时，经验便能转换为学习。这个过程存在两种迥然不同的形式：<strong>*该组织将新的技能传授给自己的员工</strong>，或者<strong>该组织以另一种不同的方式来运作。</strong></p><p>对于第一种形式，变化会直接带来人力资本的增加，如果接受培训的员工离开了，投资旧泡汤了，知识的传授也随之付诸东流。若是第二种形式，变化会临时性地存储在那些实施了再设计的人的大脑中。最终，它将变成整个组织的知识储备。然而由于在过渡时期，知识掌握在少数人手中，如果这些关键人物离开，整个组织的学习活动也将受到伤害。</p><p>无论采取哪种形式，组织都将面临以下风险：<strong>学习受限于一个组织留住员工的能力</strong>。</p><h4 id="组织型学习的关键问题"><a href="#组织型学习的关键问题" class="headerlink" title="组织型学习的关键问题"></a>组织型学习的关键问题</h4><p>组织型学习的关键问题不在于如何开展学习，而在于在何处开展。</p><p>那些处于组织顶层的人们并不会将心思放在日常的工作事物中，与之相反，底层的人们通常受限于他们所在的组织边界，可能会对一些重要的时机视而不见，很少能主导实际的改变。如果关键的学习既没有在顶层，也没有在底层发生，那就可能二者取其中。这意味着在许多组织中，多数自然而然产生的学习中心都发生在位于组织中间的管理层。成功的学习下组织通常都拥有一支非常强大的中间管理层。</p><h4 id="管理团队"><a href="#管理团队" class="headerlink" title="管理团队"></a>管理团队</h4><p>通过消除中间管理层来碾平组织结构图的确是减少学习的秘方。但是反过来却未必正确：依赖于中间管理层自身并不能让学习取得成功。为了形成一个重要的学习中心，中层管理者需要相互交流，并子啊一起高效融洽地工作。这是一个极为罕见的现象。在多数情况下，“管理团队”就是一个让人遗憾的误称。管理团队中的成员在项目状态会上虽然会集中坐在一起，轮流向上级汇报工作，但是他们彼此很少合作。</p><h4 id="空白地带的危险"><a href="#空白地带的危险" class="headerlink" title="空白地带的危险"></a>空白地带的危险</h4><p>在任何规模的组织中，最适宜的学习中心通常都位于中层管理者之间的空白地带。倘若这样的空白地带成为重要的交流渠道，倘若中层管理者能够作为组织的重新设计者协同工作，共同承担，那么学习的益处便由可能获得。</p><h3 id="构建社区"><a href="#构建社区" class="headerlink" title="构建社区"></a>构建社区</h3><h4 id="偏离公司政治"><a href="#偏离公司政治" class="headerlink" title="偏离公司政治"></a>偏离公司政治</h4><p>社区并不会从工作过程中自然形成，它需要被创建出来。如何创建社区，如何使其健康发展以及满足更多人的需求，这便是政治。</p><p>亚里士多德将政治学作为组成哲学的五种高尚科学之一：</p><ul><li>形而上学：对于存在、宇宙及其中事物本质的研究；</li><li>逻辑学：我们认识事物的方式，基于我们的认知能力所得出的结论，以及演绎和推理的原则；</li><li>伦理学：我们对人类的认识，以及由此推断出的人与人之间的交互准则；</li><li>政治学：我们如何将伦理学应用到更大的人类族群当中，政治学便是关于创建并管理这样的人类族群的科学，它要求作为形而上学主题的人类在伦理行为和逻辑认知上具有一致性；</li><li>美学：对超自然实体中富豪和图像的欣赏，美学告诉我们伦理学和政治学之间的和谐美。</li></ul><p>亚里士多德政治学是高效管理的关键性实践，拒绝了它，你将损失惨重，因为这才是管理者真正的职责。相似的，资深员工也应该承担构建社区的职责。</p><h4 id="为什么需要社区"><a href="#为什么需要社区" class="headerlink" title="为什么需要社区"></a>为什么需要社区</h4><p>能够成功构建社区的组织更能留住人。当员工有了足够的社区意识时，他们就不想离开了。你对人力资本的投资由此也得到了回报，进而愿意投资更多，再进而你的员工将会表现更好，也更喜欢你的公司。这种正面的增强会形成一种良性循环。</p><p>在未来，你会觉得在公司成功创建的社区才是人们真正喜欢的、尊重的，并付出自己忠诚的。这就是你的成就。</p><h4 id="没有魔法"><a href="#没有魔法" class="headerlink" title="没有魔法"></a>没有魔法</h4><p>与任何一种艺术一样，创建一个成功的社区需要天分、勇气和创造力。同时你需要付出很多时间。你的创造形式应该是与众不同的。</p><h2 id="快乐地工作"><a href="#快乐地工作" class="headerlink" title="快乐地工作"></a>快乐地工作</h2><p>所谓工作，就是要使员工的效率最大化，而这已经足以剥夺他们的快乐了。当然没人直截了当地说工作本不应该快乐，然而事实却是如此。</p><h3 id="混乱与秩序"><a href="#混乱与秩序" class="headerlink" title="混乱与秩序"></a>混乱与秩序</h3><p>我们经常将混乱视为自己的特殊领域，我们认为让一切井然有序就是我们的工作。开放的管理者却有一套截然不同的方法。他们愿意给其他人保留一小部分的混乱。采用这种方法，管理者的工作就是将混乱分成不同的部分，分发给下面的人搭理。</p><h4 id="进步是我们最大的问题"><a href="#进步是我们最大的问题" class="headerlink" title="进步是我们最大的问题"></a>进步是我们最大的问题</h4><p>混乱的程度一直在下降，特别是在新的技术领域。我们都渴望改进我们的工作方式，使软件开发这个行业能够更加有序，这是一种进步。在这个过程中，某些疯狂的乐趣就丢失了，而一个人的快乐可能正是另一个人的痛苦。无论如何，向着更加有秩序、更可控的方向前进正是大势所趋。深谋远虑的管理者不会阻止这种趋势，但也可能会适当地尝试逆势而为，从而给工作注入更多的能量。这就使得我们可以采取某种策略，建设性地重新引入少量无序。</p><p>实现该策略的几种方法：</p><ul><li>试点项目</li><li>战争游戏</li><li>头脑风暴</li><li>激发性训练</li><li>培训、旅游、会议、庆祝和撤退</li></ul><p>当然限制不必如此严格。</p><h4 id="试点项目"><a href="#试点项目" class="headerlink" title="试点项目"></a>试点项目</h4><p>在试点项目中，我们可以抛开常规，尝试一些新的未经证明的技术。改变总是有成本的，另一方面，生产效率会随着我们采用的新技术而提高。这种总体上产生的正面效应就是霍桑效应（Hawthorne Effect），即人们在尝试新颖的东西时，所激发的能量与兴趣可以促进人们的生产下来。</p><p>根据我们的经验，采用了任何改进方法的试点项目，带来的生产效率都要大大高于平均值。这意味着，如果你选择在试点项目中采用某些新技术，可以降低你的投入。</p><p>在任何情况下，比起没有试点项目，将所有项目做成试点项目都是大有裨益的。</p><p>对于试点项目的一个警告是：在任何一个项目中不要试验超过一种类型的开发技术。虽然总是谈到标准的重要性，让人惊讶的是，很多项目管理者在试点项目中却彻头彻尾地抛弃了所有的项目标准。他们通常在同一额项目中尝试使用新的硬件、新的软件、新的质量控制过程和新的原型技术等。</p><p>实施试点项目的合理做法是每次只允许对开发过程的一个组成部分进行细微的调整。在一个最健康的环境中，项目人员应该知道，对于每一个试点项目，鼓励试验一个技术点，同时还需哟啊遵循其他的项目标准。</p><h4 id="战争游戏"><a href="#战争游戏" class="headerlink" title="战争游戏"></a>战争游戏</h4><p>有时一些具有竞争性但又无所谓输赢的活动可以带来具有建设意义的无序性。战争游戏可以帮助你评估自己的相对优势和劣势，进而帮助企业评估自己的整体优势与劣势。</p><p>最有效的战争游戏方式是将参与人员分成不同的团队：</p><ul><li>选择一个小的开发项目或者一个人物划分清楚的项目作为实验用的小白鼠。最好能够选择公司中的一个实际项目，1～2人月的工作量。然后，选择一个新的、具有挑战性的问题。当然这个问题应该能够应用到员工的开发技能。</li><li>通过发布工作的具体声明使项目以正式的方式运转。</li><li>正式宣布在即将到来的周末将有一个24小时的项目锦标赛。确保所有人都能理解，将比赛安排在周末是使团队有个属于他们自己的地方进行比赛。鼓励每个团队由四个人组成，比赛完全基于自愿原则。</li><li>事先发布工作声明，并且规定游戏规则和目标。</li><li>锦标赛开始当天，仅参赛人员出场，提供他们之所需。让所有团队都做相同的工作，以确保他们之间的确属于竞争关系。</li><li>为比赛安排组织者，他们的职责是确保每个人都遵循那些基本的原则，防止致命问题的发生。如有团队取得阶段性成功，应营造出锣鼓喧天的欢庆感觉。</li><li>寻找机会让每个人都能在某种程度获胜。要大声宣布任何团队取得的任何成就。</li><li>安装获胜产品，或者同时安装多个获胜产品。小心记录产品稳定性、缺陷数量、用户接受程度、改变所需成本等任何有可能影响产品成功的信息。然后，将这些数据报告给开发团队。</li></ul><p>需要注意：首先，这些事情是要花钱的；其次，可以多花些时间凸显项目中的问题，使组织者活跃起来，进而引入更多的检查点和阶段性成果。再次，根据项目所需时间来准确地界定项目范围。最后，在食物上要显得慷慨一点。</p><p>通宵进行比赛往往会带来更多的乐趣，人们总是喜欢共患难，精疲力竭，让每个人都能看到其他人头发凌乱、不修边幅的邋遢样子。</p><h4 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h4><p>头脑风暴没有多少规则，我们的目的就是要在整个过程中制造混乱。在头脑风暴中，负责人应该保证整个过程既是无序的，又是愉快的，而且能够产生出实际的成果。作为组织者，你需要强调的是点子的数量而不是质量，要让整个过程非常松散，甚至有些愚蠢。我们不在过程中对征集的点子进行评判，而是在之后做这样的事情。作为组织者，当发现大家没有什么点子可出时，可以采取以下措施：</p><ul><li>类比思考（大自然是如何处理整个相似问题的？）</li><li>反其道而行之（我们所要达到目标的反面是什么？）</li><li>身临其境（如果是你，你会如何解决？）</li></ul><h4 id="培训、旅行、会议、庆祝和撤退"><a href="#培训、旅行、会议、庆祝和撤退" class="headerlink" title="培训、旅行、会议、庆祝和撤退"></a>培训、旅行、会议、庆祝和撤退</h4><p>特别是对于正在成长的团队来说，值得花钱让他们走出办公室。毫无疑问，好的秩序是我们日常工作之所需。但是，我们依然希望能够看到一些冒险和一些适当的具有建设意义的无序性。</p><h3 id="自由电子"><a href="#自由电子" class="headerlink" title="自由电子"></a>自由电子</h3><h4 id="小作坊现象"><a href="#小作坊现象" class="headerlink" title="小作坊现象"></a>小作坊现象</h4><p>作坊式创业者，他们要么编写程序要么从事设计工作，要么负责管理，想什么时候工作就什么时候工作，每做完一个项目都会休上两三个月的假。他们拥有更多的自由，更多的休假时间，更多的选择工作的机会。他们工作得更加愉快，挣钱也更多。</p><h4 id="同事、大师、内部创业者"><a href="#同事、大师、内部创业者" class="headerlink" title="同事、大师、内部创业者"></a>同事、大师、内部创业者</h4><p>企业面临巨大的压力，他们需要向那些最优秀的员工提供更好的工作环境，以防止这些员工转行到作坊产业。其中一种途径便是创造一些职责比较松散的职位，工作在这些职位上的员工有更大的话语权来决定自己的工作。极端情况下，他们的任务甚至可能是一个空头支票。</p><p>增加“自由电子”式职位的作用远远不止于应对作坊产业这么简单。在现代企业中，之所以存在如此之多的大师、内部创业者和内部咨询者，是因为这些企业的盈利依赖于他们。这些“自由电子”以不成正比的方式为公司创造着效力。他们被这种工作方式所激励，从而积极思考如何反过来回报自己的公司。</p><h4 id="没有前车之鉴"><a href="#没有前车之鉴" class="headerlink" title="没有前车之鉴"></a>没有前车之鉴</h4><p>在西方世界中，西方人认为事情都应该由本人自己处理，或者他们可以自行决定从什么地方获取建议。但是这种自由主义到了工作场所便销声匿迹了。在工作中，我们认为每个人都需要一个确切的方向，这个方向是由我们的上层制定的。大多数人把从老板哪里获得工作计划，然后按时完成该计划当作成功。</p><p>最好的管理者就在于有能力找出少数几个关键的苗子，这些苗子既成熟稳重，又视野开阔。找到后，就放手让他们去干。</p><h3 id="霍尔加-丹斯克"><a href="#霍尔加-丹斯克" class="headerlink" title="霍尔加.丹斯克"></a>霍尔加.丹斯克</h3><p>即便只是针对组织内部进行的单个具有实质性的改变，也会给企业带来巨大的好处。</p><h4 id="然而，为什么是我？"><a href="#然而，为什么是我？" class="headerlink" title="然而，为什么是我？"></a>然而，为什么是我？</h4><p>即便只是做出单个改变，单纯利用一个人的力量也会很困难。在我们主张的这些改变中，成功的关键就在于你不要去尝试和公牛进行搏斗。事实上你也没有强大到可以做到这一点。</p><p>一个人若是单独行动，那就没办法产生出有意义的变化，而且你也没有必要这样单独行动。</p><h4 id="沉睡巨人"><a href="#沉睡巨人" class="headerlink" title="沉睡巨人"></a>沉睡巨人</h4><p>霍尔加.丹斯克——丹麦传说中的“沉睡巨人”，在国家处于和平时，他安静地睡着。但是一旦国家处于危险中，他便会苏醒，面目是否狰狞。</p><p>要是企业内部存在太多的熵，太缺乏常识，就濒临危险了。你的那些同事和下属平时极为理性，一旦耐性耗尽忍无可忍，他们可能就化身为巨人了。无论他们是不是在为全局着想，只要他们看到一些愚蠢的事情时，就会直接指出。而一些损害工作环境的行为的的确确是彻头彻尾的蠢行。</p><h4 id="醒来吧，霍尔加-丹斯克"><a href="#醒来吧，霍尔加-丹斯克" class="headerlink" title="醒来吧，霍尔加.丹斯克"></a>醒来吧，霍尔加.丹斯克</h4><p>要唤醒这样的巨人并不难，如果我们所做的傻事太过明显，只需要一根很小的导火索就能唤醒他们。</p><hr><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>豆瓣：<a href="https://book.douban.com/subject/25956450/" target="_blank" rel="noopener">https://book.douban.com/subject/25956450/</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《人件》（Peopleware，第三版）读书笔记（下）&quot;&gt;&lt;a href=&quot;#《人件》（Peopleware，第三版）读书笔记（下）&quot; class=&quot;headerlink&quot; title=&quot;《人件》（Peopleware，第三版）读书笔记（下）&quot;&gt;&lt;/a&gt;《人件》（
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://blog.michealwayne.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《人件》（Peopleware，第三版）读书笔记（上）人件》（第三版）</title>
    <link href="http://blog.michealwayne.cn/2021/10/07/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BA%BA%E4%BB%B6%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2021/10/07/notes/【笔记】《人件》（第三版）（上）/</id>
    <published>2021-10-07T12:15:56.000Z</published>
    <updated>2021-11-09T08:58:30.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《人件》（Peopleware，第三版）读书笔记（上）"><a href="#《人件》（Peopleware，第三版）读书笔记（上）" class="headerlink" title="《人件》（Peopleware，第三版）读书笔记（上）"></a>《人件》（Peopleware，第三版）读书笔记（上）</h1><blockquote><p>也许，软件系统的主要问题不在于技术，而在于社会性因素。</p></blockquote><h2 id="一、管理人力资源"><a href="#一、管理人力资源" class="headerlink" title="一、管理人力资源"></a>一、管理人力资源</h2><p>作为管理者，我们多数人很容易陷入一种典型的失败情境：<strong>习惯把人当作固定的模块来管理。</strong>这是因为我们作为开发者时通过模块化方法的自由处理取得良好的绩效，因此长年累月会对此方法产生依赖。但沿用同样的方法对人力资源管理往往不奏效。</p><h3 id="此时此刻，一个项目正在走向失败"><a href="#此时此刻，一个项目正在走向失败" class="headerlink" title="此时此刻，一个项目正在走向失败"></a>此时此刻，一个项目正在走向失败</h3><p>书中对500个项目的统计结果：</p><ul><li>15%的项目出现问题，项目取消、终止、延迟或者交付的产品从未被使用。</li><li>对于持续时间达到25个工作年及以上的项目，25%的项目最后宣告失败。</li></ul><p>“政治”（politics）是受访者最常提及的失败原因。它包含着诸多不相关联或松散关联的东西，如交流问题、人员安排问题、与上级或客户关系不和、缺乏动力、高离职率等。它们构成了项目的社会学。真正的政治问题不过是这些病态特征的冰山一角。</p><p>认识到问题真正的本质分属社会学的范畴，与政治无关，能帮助我们面对问题时更游刃有余。项目及团队社会学或许超出了你的专业范畴，却没有超出你的能力之外。</p><p><strong>我们工作中的问题更多属于社会学范畴，而非技术范畴。</strong></p><p>大多数管理者坦承：他们对人的担心更甚于对技术的担心，但他们很少以此方式去管理。滋生这种现象的部分原因来自于管理者的提拔机制。对新晋管理者的训练是如何完成一项工作，而不是如何管理它。很少有公司会考察新晋管理者在工作中能否展示出相应的能力与良好的心态来胜任管理工作。他们缺乏管理经验也没有具体的实践。</p><h4 id="高科技的幻觉"><a href="#高科技的幻觉" class="headerlink" title="高科技的幻觉"></a>高科技的幻觉</h4><p>广为人知的理论认为凡是接触新技术的人就被想当然地看做属于高科技领域。在本书作者看来，他们通常都不是，只有在领域从事基础研究、获得根本突破的科研人员才是高科技工作者，其他人只是在运用他们的研究成果。</p><p>我们大多数人是在从事人类交流的职业，我们的成功源自于所有参与良好的人与人之间的互动，我们的失败则归因于这种互动的缺失。人与人之间的互动非常复杂，没有简单规律可循，但在工作中它的确更为重要。</p><h3 id="干酪汉堡，做一个，卖一个"><a href="#干酪汉堡，做一个，卖一个" class="headerlink" title="干酪汉堡，做一个，卖一个"></a>干酪汉堡，做一个，卖一个</h3><p>开发的本质完全迥异于生产。然而，开发管理者的思想通常被生产环境衍生出来的管理哲学所左右。</p><p>“干酪汉堡，做一个，卖一个”的思维观念在开发领域是致命的。这种做法只能让你的团队士气低落，让他们无法将精力集中到真正的问题上。</p><h4 id="错误在所难免"><a href="#错误在所难免" class="headerlink" title="错误在所难免"></a>错误在所难免</h4><p>营造一个不容许任何失误的氛围会让大家持有戒心。他们不愿意去尝试那些有可能变坏的事情。相反的做法是<strong>鼓励大家犯错</strong>，可以不时问问大家遭遇了那些死胡同并明确地让大家明白最好的答案不是没有。</p><h4 id="管理：傻瓜定义"><a href="#管理：傻瓜定义" class="headerlink" title="管理：傻瓜定义"></a>管理：傻瓜定义</h4><p>“管理就是踢屁股”，管理者负责全盘思考，而他的手下就照章办事，这种想法可能对于制作干酪汉堡会奏效，但在依靠脑力而非体力的环境中是没有用的。</p><p>即使向人们施压可以增加短期产出，长远来看还是无效的：对于所有工作者来说，若是他们感到动力不足而需要老板来“弥补”，没有什么比这更让人沮丧的了。</p><p>最可悲的是，这种管理手段几乎永远都会让生产力过剩。根本不需要使用严格的度量来促使大家工作——大部分人是热爱他们的工作的。你有时候需要采取一些手段让大家少工作一会儿，这样就可以做一些更有意义的工作。</p><h4 id="人力商店"><a href="#人力商店" class="headerlink" title="人力商店"></a>人力商店</h4><p>对于盲目尊崇生产世界管理风格的管理者来说，员工的独特个性是一种持续的困扰。个性化的管理者却能认识到是这种独特性使项目团队产生了化学反应，是团队充满活力与高效的源泉。</p><h4 id="稳定的项目濒临死亡"><a href="#稳定的项目濒临死亡" class="headerlink" title="稳定的项目濒临死亡"></a>稳定的项目濒临死亡</h4><p>稳定的生产思维对项目工作尤为有害。我们很容易忘记项目生命周期的最终目标就是要结束自己。一个项目唯一的稳定期就是将死之时。除非你正在一个被取消或将要取消的项目中，所有的项目管理关注点都应该投入到开发的动态调整上。</p><p>然而在一个新项目中，我们衡量员工的价值却使用了稳定状态下的特征：他们写了多少代码或者产出了多少稳定。我们对于每个员工在整个开发投入中的切合度关注甚少。</p><p><strong>催化剂</strong>很重要，因为项目总是处于不断变化的状态，一个能让项目更稳定的人抵得上两个做事的人。</p><h4 id="我们只是做事，没时间考虑工作本身"><a href="#我们只是做事，没时间考虑工作本身" class="headerlink" title="我们只是做事，没时间考虑工作本身"></a>我们只是做事，没时间考虑工作本身</h4><p>作为管理者，我们都花了太多时间去做事，却没有花足够的时间提出关键问题：这件事到底该不该做？</p><p>稳定阶段的干酪汉堡心态使得我们根本没有去思考这项工作。这种心态会推着我们把百分百的投入放到实施状态。倘若真要为没有思考时间寻找借口，那么这个借口永远都是时间压力——就好像还有什么工作可以在没有时间压力的情况下完成似的。</p><p>随着更多利益的介入，思考方法的重要性也显著提高。正所谓磨刀不误砍柴工，我们必须学习如何多花时间子啊思考上，少花时间在实施上。项目需要的投入越夸张，成员就越应该学习如何更好地写作，对这份工作的热爱也会变得更重要。</p><p>项目越是需要在一个无法完成的固定时间交付，项目团队就越不能缺乏频繁的头脑风暴，或者项目组聚餐之类的活动来帮助团队形成一个统一的整体。</p><p>在做事情上我们都是如此的一根筋，我们话费不到5%的时间在计划、新方法调研、培训、读书、评估、预算、排期、人员安排这一系列活动上。</p><p>关于读书的统计结果尤为让人失望：以软件开发人员的平均水平为例，平均每人没有一本和工作相关的书，甚至没有阅读过一本相关书籍。</p><h3 id="维也纳在等你"><a href="#维也纳在等你" class="headerlink" title="维也纳在等你"></a>维也纳在等你</h3><p>对于大家都说的“聪明的工作”，一个共识就是现实生活中管理者如何让人们牺牲自我生活为代价来承受更大的工作强度和更长的工作时间。</p><h4 id="西班牙理论"><a href="#西班牙理论" class="headerlink" title="西班牙理论"></a>西班牙理论</h4><p>西班牙理论认为世界上的价值总量是定额的，因而财富累积的道路就是学会从大地或者别人的背上去攫取。</p><p>另一种英国理论认为，价值是通过智慧和科技创造出来的。</p><p>所以在英国人进行着工业革命的时候，西班牙人推动者他们的轮子来开发新大陆的土地并统治印第安人。他们越洋过海，将大量的黄金搬运回国，而他们的努力换来的却是通货膨胀。（黄金太多可用商品太少）</p><p>西班牙的价值理论在很多管理者身上都可以看到，特别是在他们讨论生产效率时。生产效率本应该是让单位时间内的工作产生更高的价值，然而它却常被看作是如何在单位付酬的情况下攫取更多价值。二者存在天壤之别。</p><p>奉行西班牙理论的管理者梦想通过不付薪酬的加班来获得生产效率的提高。这根本就不是生产效率，他们连哄带骗地让员工延长工作时间，他们给员工强化交付日期的重要性。</p><h4 id="来自家里的一句话"><a href="#来自家里的一句话" class="headerlink" title="来自家里的一句话"></a>来自家里的一句话</h4><p>虽然员工在办公室里得到的信息是“工作时间长点、强度大点”，但他们在家里得到的信息却迥然不同：“生命正在流逝”。人生苦短，生活中还有许多事情比愚笨的工作更重要。</p><h4 id="不存在加班的谎言"><a href="#不存在加班的谎言" class="headerlink" title="不存在加班的谎言"></a>不存在加班的谎言</h4><p>让定薪员工加班是无知的管理人士脑海中的臆想。是啊，周六工作几小时可能会对周一的最后期限有帮助，带来的后果却是需要花“地下时间”（指虽是工作时间但做着与工作无关的事情的那些时间）来弥补他们自己的生活。计算投入与产出，每加班一个小时，就需要一个或更多小时的地下时间。从长远看其实入不敷出。</p><blockquote><p>疯狂的孩子慢一点，关掉你的电话玩玩消失，没什么大不了。失去一两天不会有啥影响。你何时会想到。。。。。。维也纳在等你？</p></blockquote><p>类似于不付薪酬的加班时间，对于持西班牙理论的管理者来说，对地下时间也是视而不见的。<strong>没有人能真正工作超过40小时，至少不可能持续，特别是对需要创造力的脑力劳动来说更是如此。</strong></p><p>加班就像冲刺，跑马拉松跑到最后100码，体力还有剩余才算有意义。</p><h4 id="工作狂"><a href="#工作狂" class="headerlink" title="工作狂"></a>工作狂</h4><blockquote><p>慢点儿，你做得很好啦，这辈子你不可能做你想做的所有事情。在这暧昧的夜晚，尽管如此的浪漫。但你何时会想到。。。。。。维也纳在等你？</p></blockquote><p>一旦认同这样的理念，员工就会在完成项目后永远消失。为了不那么重要的价值（工作），而牺牲了生命中更重要的价值（家人、爱情、家庭、青春。。。），这种认识让人倍受打击。这会让一个不经意间做了牺牲的人愤怒得想要复仇。</p><p>工作狂是一种病，但不像酗酒那样只影响不幸的少数人。不管你多么需要大家投入额外时间加班加点，都不能让大家以牺牲个人生活为代价。失去好的员工绝对不划算。</p><h4 id="工作效率：赢得战斗，输掉战争"><a href="#工作效率：赢得战斗，输掉战争" class="headerlink" title="工作效率：赢得战斗，输掉战争"></a>工作效率：赢得战斗，输掉战争</h4><p>大部分人提及生产效率，十有八九不会谈到“员工流失”这个词。一些组织采取的提高效率的典型手段：</p><ul><li>对人们加压以获得更长的工作时间</li><li>产品开发的流程机械化</li><li>牺牲产品的质量</li><li>标准化工作程序</li></ul><p>在获得高生产效率时，一定要考虑可能的人员流失，不然所谓的“提高”可能会因重要人员的流失而被抵消。</p><p>生产效率的定义是收益除以成本。看得见的收益就是通过工作赚取金钱，而成本则是全部的花销，包括替换那些疲惫不堪的工作人员。</p><blockquote><p>压力不会让人工作得更好——只是工作得更快。</p></blockquote><h3 id="质量——如果时间允许"><a href="#质量——如果时间允许" class="headerlink" title="质量——如果时间允许"></a>质量——如果时间允许</h3><p>20世纪心理学理论指出：人类的特征被一系列基本天性控制：生存、繁衍、领地等。任何强烈的情绪表达都显示了大脑中的原始价值观受到了威胁。一个新手管理者也许会相信工作可以在不掺杂个人情绪的情况下完成，但只要管理者具备一点点经验，就会知道事与愿违。我们的工作给了我们表达自己情绪的很多机会。</p><p>在个人生活中，造成情绪化反应的因素可能很多，然而在工作环境中，主要的导火索就是对自信的威胁。我们通常倾向于将我们的自信与生产出的产品质量（并非产品数量）紧紧关联。采取任何可能牺牲产品质量的行动都可能挑起员工反对你的情绪。</p><h4 id="飞离卓越的航班"><a href="#飞离卓越的航班" class="headerlink" title="飞离卓越的航班"></a>飞离卓越的航班</h4><p>管理人员设定的不可到达的期限威胁着产品的质量，但他们不会这样去思考这一问题——他们自认为给了团队一个有趣的挑战，可以激发他们去追求卓越。</p><p>有经验的员工（老油条）却不这么想。他们知道在枪口下，他们的任何努力都是收到约束的。不能自由调配资源，以满足准时交付的要求。</p><p>“昨天就赶着要这个产品了，即使质量粗糙也行。”多数情况下，你对市场的判断或许正确，但通过施压让大家制造出达不到自己质量标准的产品终归是错误的。</p><p>我们这些管理者总是认为质量只是产品的另外一个特性，可以视市场的需求而调整。然而，产品制造者对待质量却完全不同，因为他们的自信来自于产品质量，所以会有自己的一套质量标准。对他们而言，要让自己满意，最低标准就是要达到过去做到的最好质量。这当然要比市场要求并愿意为之付出的标准更高。</p><p>软件行业已经让客户接受了自主开发的应用程序平均100行代码就有1～3个缺陷，极具讽刺的是，这样灾难性的记录常被归咎于制造者缺乏对质量的认知。而且一旦质量降低，那些被责怪做事修修补补永无止境的员工就成了质量问题的罪人。</p><p>我们需要假定：为我们工作买单的人对质量和成本之间的关系有一个清醒的认知。这里明确的一点是，客户想象的产品质量往往比制造者认为的要低。这是一个天大的冲突。降低产品质量可能会让一些人不再购买，即使靠降低成本来提升单个产品的利润，也无法抵消由于质量下降带来的市场占有率的降低。</p><p>让买方而不是制造者来设定质量标准，即我们所谓的飞离卓越的航班。如果我们忽略对制造者的态度及效能带来的影响，那么让市场来产生标准也许是可以接受的。</p><p>长远来看，以市场为基础制定的质量标准花销更大。即：<strong>质量，远远不只是最终用户的要求，而是达到高产能的一种方法。</strong></p><blockquote><p>到大街上随便找100个人，问他们认为谁是以高质量著称的组织、文化或者国家。估计一半的人会回答“日本”，再问100人什么组织、文化或者国家以高效能著称。同样大多数人会说“日本”。按常规理论，若要提高产品质量，就必然需要在生产过程中花费更多。“价格和质量的对立在日本并不存在，相反，高质量带来的成本的降低却是被广泛接受的想法。”</p></blockquote><h4 id="质量是免费的，但是……"><a href="#质量是免费的，但是……" class="headerlink" title="质量是免费的，但是……"></a>质量是免费的，但是……</h4><p>菲利普.克劳士贝（Philip Crosby）《质量免费》中：让制造者来设定他们自己满意的质量标准，会带来生产效率的提高，从而抵消为提高质量而产生的额外成本。但“只有天空才是质量的上限，我们提升的质量是免费的。”的意识是弊大于利的，这根本不可能形成证明的质量意识，这种态度恰恰是克劳士贝倡导的反面。</p><p>关于质量和生产效率之间的关系，需要用一种不同的表达方式来传达信息：<strong>只有愿为质量倾其所有的人，质量才是免费的。</strong></p><p>一个组织，如果为了质量一毛不拔，那么收获的质量也将会一文不值。“质量——如果时间允许”这种策略会导致产品不会有任何质量可言。</p><p>开发人员形成的文化是交付的质量要超越市场的质量要求。他们追求质量的标志成为提高他们工作满意度的动因，从而拥有行业内最低的人员流失率。</p><h4 id="否决的力量"><a href="#否决的力量" class="headerlink" title="否决的力量"></a>否决的力量</h4><p>一些日本企业中，项目团队拥有否决发布被认为是未成熟产品的权利。即使客户愿意接受不满足标准的产品，团队仍然可以坚持己见，直到产品质量达标才交付。当然管理者存在同样的压力：他们必须尽快交付。但重视质量的文化又来已久，所以这些管理者知道不能哄骗他们的员工去接受质量上的缺陷。</p><p>你能给予你的团队成员否决交付的权利吗？当然，要迈出第一步需要钢铁一般兼任的神经。你面临的问题在于帕金森定律会与你做对：</p><h3 id="再谈帕金森定律"><a href="#再谈帕金森定律" class="headerlink" title="再谈帕金森定律"></a>再谈帕金森定律</h3><p>英国作家诺斯古德.帕金森（C.Northcote Parkinson）于1954年引入了一个概念，认为工作会自动膨胀，沾满一个人可以用的所有时间，这被称为帕金森定律。</p><p>定律为他们提供了强有力的证据，只有设定不可能完成的交付日期，才能保证工作的完成。</p><h4 id="帕金森定律和牛顿定律"><a href="#帕金森定律和牛顿定律" class="headerlink" title="帕金森定律和牛顿定律"></a>帕金森定律和牛顿定律</h4><p>牛顿定律经过了严格的验证和测试，并且通过了几个世纪的后续研究。</p><p>帕金森没有收集数据，甚至可能根本就不知道什么是统计推论规则。他的“定律”被接受并非因为它是真理，而是因为它有趣。当然帕金森定律还是有真实成分的，他本人说他的定律是通过观察一个虚拟的政府官僚机构得出的。官僚机构很容易产生这样的问题，因为员工很少从工作中收获满足感。但你很可能不在官僚机构工作，j就算你在，你可能也花了不少力气保证你的员工不这么做，否则他们不会有任何产出。结果就是大家都可能从工作中得到最大满足。因此，一个简单的事实值得澄清：帕金森定律基本不可能运用到你的工作中。</p><p>在一个健康的工作环境里，要是某人表现欠佳，可能是因为能力不足，缺乏自信。活着无法理解项目中别人的想法和项目目标。通过增加进度压力无助于解决上述问题。一旦某位员工表现出工作低效，对工作质量漠不关心，就是发出了明确的信号，说明他被工作困难给压垮了。他需要的不是更多的压力，而是调换工作。</p><p>即使在极端情况下，依靠某人是唯一的出路，管理者也应该将此作为最后的选择，团队发出的声音会更好</p><h4 id="来自新南威尔士大学的数据"><a href="#来自新南威尔士大学的数据" class="headerlink" title="来自新南威尔士大学的数据"></a>来自新南威尔士大学的数据</h4><p>要帮助管理者认识到帕金森定律不适用于大多数员工，方法是通过严格收集得到的数据。</p><p>相比于管理人员的估算，程序员自己给出的估算对应的产能会高一点，若二者一起做估算，对应的产能结果处于二者之间。但由第三方进行估算（通常是系统分析师），这种情况下，程序员的产能持续高于程序员或管理人员来做估算。</p><blockquote><p>当一个项目的时间计划制定得根本毫无道理或不现实，甚至不可能通过加班来达成时，项目团队会变得愤怒和烦躁，他们的士气会跌到谷底。</p></blockquote><p>老板不给任何时间压力的项目产能最高。是否在一个项目上采取时间进度压力，应该像是否惩罚你的孩子一样来决定：如果惩罚比较少见，而时间点也能够掌握得恰到好处，惩罚就可能起作用。若需要经常施以惩罚，就说明你自身是有问题的。</p><h4 id="帕金森主题的变异"><a href="#帕金森主题的变异" class="headerlink" title="帕金森主题的变异"></a>帕金森主题的变异</h4><p>只要让帕金森定律变异一点，就能在很多组织中造成惊人的事实：</p><p>一个组织的工作如果都忙忙碌碌，就会膨胀以至于沾满整个工作日。</p><h3 id="苦杏素"><a href="#苦杏素" class="headerlink" title="苦杏素"></a>苦杏素</h3><p>苦杏素是从杏树里提炼出来的无色液体。在瑞典，超市里就能买到这东西，价格跟杏仁提取物相当。然而在墨西哥，50美元只能买到那么一滴，因为它可以“治愈”癌症，事实上它不能治愈任何疾病。这是一个残忍的骗局，但出于绝望中的人们是不会理性去看待证据的。</p><p>同理，不少管理人员也足够绝望，这种绝望让他们很容易成为某种号称能够提高产能的苦杏素的受害者。他们买到的技术其实缺乏任何客观证据的支撑。但因为需求如此迫切，他们就会忽略对证据的审视。</p><h4 id="在睡梦中减肥"><a href="#在睡梦中减肥" class="headerlink" title="在睡梦中减肥"></a>在睡梦中减肥</h4><p>我们面临不少需要提高产能的压力，这个问题的解决美元简化之道，因为所有的简单手段在之前就已经被尝试和实施过。我们相信那些做出优越成绩的组织并不是采用了什么特别高级的技术。之所以表现良好，就在于他们做到了更高效的人员挂你、改进的办公场所以及企业文化，还有就是实施了一些量化的手段。</p><p>技术手段未必有效，至少短期看来不能立竿见影，这多少让人有些泄气；而我们提倡的对企业文化的改进又很难运用，而且见效缓慢。</p><h4 id="七宗罪"><a href="#七宗罪" class="headerlink" title="七宗罪"></a>七宗罪</h4><p>不能解决问题的简单技术方案带来的假象就像那些诱惑了奥德修斯的原罪一样，每一项都有着独特的吸引力，却是一无是处的虚假承诺。一旦你迷信这些，就会犹豫着是否该去做那些为建设一个健康企业文化必须付出的辛劳工作。</p><p>软件管理的七个假象：</p><ul><li>有一个你不知道的新窍门可以让产能飙升。我们要做的就是让大家能够健康发展：人们愿意全身心参与、去学习、去提高。</li><li>其他管理者正在收获100%、200%乃至更多的增长。即使我们拿掉编码和测试，也不能期望100%的提升，还有分析、讨论、文档、培训、验收、交流和交付需要完成呢。</li><li>技术日新月异，你已经过时啦。硬件变化确实很大，但软件开发行业却很平稳。我们仍然有很大一部分时间花在低技术含量的需求和文档上。软件产能每年也就增长3～5%，仅仅比钢铁和汽车行业好一点点。</li><li>改变程序语言会给你带来巨大提升。针对某类功能的专业快速实现工具，除非你在过去十几年都冬眠去了，否则改变一种编程语言是不会给你带来什么根本变化的，可能给你5%的提升。</li><li>因为库存backlog的缘故，你需要马上让产能翻倍。乐观的成本估计只有实际成本的一半，甚至更少。倘若我们知道系统的真正成本，就能看清楚项目的实质：一个经济上的失败之作。项目根本就不应该在库存里，而应该丢到被拒绝的那一堆里。</li><li>你自动化了其他所有东西；难道不是要你自动化掉你的软件开发人员吗？软件开发者主要的工作是通过与人沟通把用户对需求的表述变成正式的程序。对于这些工作，不管我们怎么改变，在开发生命周期都是必需的，而且不太可能被自动化解决。</li><li>你的员工在巨大的压力下工作得更好。他们更乐于减少压力。</li></ul><h4 id="这就是管理"><a href="#这就是管理" class="headerlink" title="这就是管理"></a>这就是管理</h4><p>管理者的作用不是让大家去工作，而是创造环境，让大家可以顺利开展工作。</p><h2 id="二、办公环境"><a href="#二、办公环境" class="headerlink" title="二、办公环境"></a>二、办公环境</h2><p>有千万种方法可能会令人损失一天的工作实际，但却没有一种方法能够弥补回来。</p><h3 id="家具警察"><a href="#家具警察" class="headerlink" title="家具警察"></a>家具警察</h3><p>对看到的每项可能的干扰，你可能会寻求简单机械的方法来保护你的员工。给你一定的选择自由，你可能会去调查封闭空间对比开放空间的优势。但管理你公司工作环境的人不会花费太多时间来考虑这种问题，他们不收集任何原始数据。部分原因在于他们自己不会置身于这样糟糕的环境去开展工作。他们通常会组建家具警察（Furniture Police），采用的解决方案与你做的几乎背道而驰。</p><h4 id="警察思路"><a href="#警察思路" class="headerlink" title="警察思路"></a>警察思路</h4><p>规定大家到了晚上要清理每张桌子，除了公司日历啥都不允许挂。。。</p><p>从家具警察的角度来看，地下室环境才是他们的最爱，因为哪里更容易产生统一的规划。然而人们更喜欢在自然光下工作，靠窗边感觉会更好些，这种良好的感觉能之间转换为工作的更高质量。人们都希望把自己的地方打造得带有自己的风格，以方便自己工作。</p><p>警察思维的规划者设计出来的工作环境就像设计监狱一样：用最小的成本达到最好的封闭性。</p><h3 id="朝九晚五在这里啥也完成不了"><a href="#朝九晚五在这里啥也完成不了" class="headerlink" title="朝九晚五在这里啥也完成不了"></a>朝九晚五在这里啥也完成不了</h3><p>各个领域的开发人员都形成了一种风俗：加班就是命中注定。这说明一项工作在预算时间内根本完不成。有一种令人困扰的可能性是，加班增加不了工作产出，它只不过提升了平均质量而已。</p><p>起早摸黑，又或者宅在家里工作都是对办公环境的一种抵触。让人最惊讶的事情还不是工作环境不适合完成工作，而是大家都知道却没人站出来寻求改变。</p><h4 id="弃权政策"><a href="#弃权政策" class="headerlink" title="弃权政策"></a>弃权政策</h4><p>改变环境并没有超出人类的能力范围，基本上每家公司都有家具警察这样一个权利小组，他们控制着公司的物理环境。要让他们看到改变的原因，活着拿走他们的控制权并非不可能。</p><h4 id="编码战争游戏：观察生产效率的因素"><a href="#编码战争游戏：观察生产效率的因素" class="headerlink" title="编码战争游戏：观察生产效率的因素"></a>编码战争游戏：观察生产效率的因素</h4><ul><li>个体差异：个体差异非常大。能力最强的人较最差的产出比大概是10:1；能力最强的人比居间的产出高2.5倍左右；能力靠前一半的人较之后一半的产出比大于2:1。</li><li>组织差异：最好的组织比最差的要快十倍以上。</li></ul><p>以下因素与产出效率基本没什么关系：</p><ul><li>语言、经验年限、缺陷个数、薪酬</li></ul><p>高产出效率有正向关联的一个意想不到的因素：<strong>和谁搭档</strong>。两个来自同一组织的人表现会趋于一致，这说明效率最高的人聚集在一些组织中，效率低的则会在另一些组织。</p><blockquote><p>倘若程序员产出呈现10:1的差异是可以理解的，那么软件组织在产出上的10:1差异也是存在的。    ——Harlan Mills</p></blockquote><p>管理人员长期对个体的差异性深信不疑，他们认为这种差异是自然产生的，所以很难去改变。但集群效应则困难得多，一些公司还要更糟糕，他们的公司环境文化不但不能吸引或留住好的人才，更是让真正的人才无法在这种环境下有效工作。</p><h4 id="工作环境的影响"><a href="#工作环境的影响" class="headerlink" title="工作环境的影响"></a>工作环境的影响</h4><p>工作环境的质量直接关系着开发者的效率。好的人才会流向提供了良好工作环境的组织，从长远来看，安静、宽敞和注重隐私的环境无论是帮助你现在的团队更高效地完成工作，还是帮助你吸引和留住人才，又有什么区别呢？</p><h3 id="在空间上省钱"><a href="#在空间上省钱" class="headerlink" title="在空间上省钱"></a>在空间上省钱</h3><p>得出“在工作环境中节省一分就是在运营中挣得一分”这种逻辑显然没有认真做过成本收益分析，没有从收益分析中理解收益。他们只知道节流、却不知道怎么开源。缩减的开支必须与失去效率的风险放到一起比较。就拿当前这一波削减工作环境成本的活动来说，与它带来的潜在风险相比，节省的成本简直微不足道。为开发人员在环境上的整个投入只是他薪酬的很少一部分，者取决于房地产价格、薪酬水平等因素，但大致来看，一般是介于6%～16%之间，在工作环境及附属设施上花费一块钱对应于直接支付给工作者的15块，如果再把员工福利也算在内那么薪资与环境费用之比轻易就超出了20倍。这比例足以说明在工作环境上节省成本存在风险，费尽心力去节省那一块钱损失的却是20元。</p><blockquote><p>富有远见的管理者不会罔顾员工工作效率是否会受到影响，就将大家搬到更便宜、更吵闹或者更拥挤的隔间里。</p></blockquote><h4 id="席卷大地的瘟疫"><a href="#席卷大地的瘟疫" class="headerlink" title="席卷大地的瘟疫"></a>席卷大地的瘟疫</h4><p>在一个科幻预言故事中，约翰.布努那（John Brunner）描绘了我们的空气、土地和水污染持续加重，直到下一个世纪末。不管污染变得多么严重也没人站出来抱怨。《绵羊抬头》（The Sheep Look Up）</p><p>在没有任何警告的情况下，开放式设计的工位就像一场席卷大地的瘟疫一般扩散。提倡这样设计的人没有提供哪怕一丝一毫的证据来证明工作效率不会受到影响。他们非不愿，而是不能。要做到意义明确的生产效率度量，本身极为复杂和困难。这种度量需要根据不同的工作种类量体裁衣。它需要专业的技能、细致的研究以及大量的数据收集。</p><p>这样设计工作的人认为在信息处理环境中，采用开放式办公环境设计的根本考虑因素在于：系统的店里分配能力、计算机支持能力及制造商和分销商服务。就这样。这样的观点缺失对员工真正生产效率的任何考虑。我们所能看到的用来证明开放式设计提升工作效率的论点的唯一方法就是不断重复。</p><h4 id="几点事实"><a href="#几点事实" class="headerlink" title="几点事实"></a>几点事实</h4><p>赛前的报告提及自己工作环境较为安静的人，要比另一类人多1/3的机会完成交付，并且没有缺陷。实现零缺陷的参赛者人数跟报告噪声层级可接受的人数基本成反比：零缺陷员工——66%报告噪声层级可接受；一个或多个缺陷员工——8%报告噪声层级可以接受。</p><p>当一名员工抱怨噪声太大时，他就是在告诉你他可能更容易犯错。</p><p>人员密度（如每千平方英尺员工人数）跟人均独立空间成反比。噪声跟密度是直接成正比的，人均空间分配一旦减半，就会加倍地提高噪声水平。</p><p>当办公环境让人异常烦躁时，大家就会找地方躲起来。去会议室、图书馆或者去买杯咖啡，反正不会回来，他们是躲起来工作去了。好消息是你的员工愿意享受完成工作带来的成就感，所以他们会想尽办法来达成目标。一旦工作开始启动，他们就会努力寻找能够工作的地方。</p><p>假如你的组织发生了上述现象，就是在对工作环境进行控诉。</p><h3 id="间奏曲：生产效率度量和不明飞行物"><a href="#间奏曲：生产效率度量和不明飞行物" class="headerlink" title="间奏曲：生产效率度量和不明飞行物"></a>间奏曲：生产效率度量和不明飞行物</h3><h4 id="吉尔布定律"><a href="#吉尔布定律" class="headerlink" title="吉尔布定律"></a>吉尔布定律</h4><p>你想量化的任何东西都能够以某种程度度量，至少聊胜于无。</p><p>吉尔布定律并没有保证度量免费或便宜，而且可能度量也不是完全准确——但总比没有度量好。</p><p>当然，对生产效率进行度量是可能的。如果你召集一组人员做同样或相似的工作，而且给他们一天时间找到一种合理的自度量体系，他们一定可以产生一些东西来证印证吉尔布定律。然后，度量出的数字可以帮助他们调整自己的表现，结合质量体系或者同行评审机制，就能建立互相学习的方法。计算出来的该小组的平均值可以给管理层一个可靠的指标来度量改进办公室环境这一参数带来的影响。</p><p>如果一个组织不能评估自己的生产效率，只能说还没有努力尝试。</p><h4 id="但是，不知你可否接受"><a href="#但是，不知你可否接受" class="headerlink" title="但是，不知你可否接受"></a>但是，不知你可否接受</h4><p>由于组织之间的表现可以有十比一的差距，你不可能忽略你当前所处的位置。如果你不知道，你就不可能做出任何改变。若是只有市场了解，自然会有一些让你不舒服的外力来纠正存在的问题。</p><h4 id="闭上你的眼睛去度量"><a href="#闭上你的眼睛去度量" class="headerlink" title="闭上你的眼睛去度量"></a>闭上你的眼睛去度量</h4><p>工作度量可以是很有效的方法改进、员工激励以及增加工作满意度的工具，但却从来没有被用在这些方面。度量体系往往会变成对大家的威胁，反而增加大家的负担。</p><p>为了能够让度量这个理念发挥应有的潜力，管理层必须足够主动和安全地把自己从这个圈子里摘出去。这就意味着个人的数据不会被传递到管理层手里，而且组织中每个人都心知肚明，收集的个人表现数据只能用于个人提升。度量体系就是自评估的一个练习，只有处理过的平均值才会交给老板看。</p><p>然而，要做到准确地收集这种个人敏感数据，就需要个人的积极配合并且是有意愿的合作。如果数据的保密性被破坏，如果数据被用来对付哪怕一个个体，整个数据收集体系就会即刻停滞。</p><p>员工会倾向性地针对数据做管理者们相同的事情。人们会尝试去改善做得不好的事情，或者尝试在他们擅长的领域精益求精。极端情况下，一名员工可能会自己“炒掉”自己，从而不再依赖于他们缺失的技能。管理者因此并不需要真正看到个体数据，以期获得收益。</p><h3 id="大脑时间于身体时间"><a href="#大脑时间于身体时间" class="headerlink" title="大脑时间于身体时间"></a>大脑时间于身体时间</h3><p>由于工作空间是人们独立工作和协同工作的混合区，从而带来了模式上的冲突。那些独立工作的人们对于这种冲突尤感不便。虽然在任何给定的时间段，他们只代表了少数人，但就此忽略他们却是一种错误；因为这是在他们独立工作期间大家应该做的工作。其余时间就耗费在部门活动、休息与聊天中了。</p><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>在单一思考的工作时间里，理想情况下人们处于心里学家称为“流（Flow）”的状态中。流是一种深度的近乎于冥想的融入情况。在此种状态下，有一种普适幸福感存在，人们几乎不会意识到时间的流逝：“我开始工作，等我抬头一看，三个小时就过去了。” 这里不会有工作量的感知；工作开展就像流一样自然。</p><p>并非所有工作都需要进入流的状态才能高产，但对于从事工程、设计、开发、写作或类似的工作，流是必需的。这些任务都需要精神高度集中，只有处在流的状态下，你才能够很好地工作。</p><p>不幸的是，你无法像开关那样随时启动流。你需要一个缓慢的过程来进入状态、15分钟或更长时间的集中才能把自己锁定在流里面。在这个引入过程中，你对噪声和干扰是非常敏感的。在一个毁灭性的环境，你可能让你很难甚至不可能进入流的状态。</p><p>一旦锁定在流里，状态可能会被一个针对你的干扰或者持续的噪声破坏。每次被打断后，就需要再一个引入过程使你回到流的状态。而在引入过程中，你并不是真正在工作。</p><h4 id="没有流的无休止状态"><a href="#没有流的无休止状态" class="headerlink" title="没有流的无休止状态"></a>没有流的无休止状态</h4><p>假设打来的电话平均时间为5分钟，你重新引入的时间为15分钟，那么一个电话在流时间上的损失就是20分钟。一打电话就会浪费掉半天时间，再加上其他的干扰，剩下的半天时间也泡汤了。这就是为什么“朝九晚五在这里什么也做不了。”</p><p>与工作有效性降低一样严重的是随之而来的焦躁。一个急切尝试想进入流状态，却又不停被打断的员工一定满脸郁闷。倘若你是一名管理者，你可能不会太在意这种无法进入流的焦躁。事实上，你就是在不停被打断的模式下完成自己的大部分工作的。但任何阻碍让大家进入流的事情都会造成工作效率与满意度的降低、从而导致工作成本的上升。</p><h4 id="根据流来计算时间"><a href="#根据流来计算时间" class="headerlink" title="根据流来计算时间"></a>根据流来计算时间</h4><p>通常，现在公司的时间计算系统是传统模式。在这种模式下，完成的工作与花费了多少带薪工作时间成比例。当员工根据这样的体系填写时间表时，他们并不会区分花费在工作上的有效时间和焦躁时间。他们汇报的是身体时间而不是大脑时间。更糟糕的是这样的工作计量数据也用来支撑薪酬计算。</p><p>关于流和引入时间的现象给了我们一个更加真实的方法来分析一项开发工作的时间花销。要计算的不是在岗时间、而是你真正权力发挥开展工作的时间。一个小时的流时间真正有产出，但夹杂在11个打断之间的10个6分钟的工作时段等于什么都完不成。</p><p>流计算系统的机制并不复杂，将原来的记录小时数改为记录没有打断的小时数即可。为了得到真实的数据，你必须消除大家的顾虑，不用担心是否填写了太少的不间断小时数。要让大家认识到，若一个星期仅有一两个小时不被打断，并非他们的错误，而是组织的问题，它没有为大家提供一个流友好的环境。</p><p>流计算的工作时间计算体系优势：1.让大家能够关注流时间的重要性。如果他们获知每个工作日都应该保留2到3个小时的不间断时间，他们就会自发地去保护那些时间。意识到打断的后果可以避免大家不被同伴随意打扰。2.这样能够建立起一个有效工作时间的统计。倘若一个产品预计需要三千个有效流时间，已经记录了两千个有效流时间，那么你可以有根据地相信任务已经完成了2/3。相反如果使用出勤小时数来做这样的统计，无疑是愚昧而又危险的 。</p><h4 id="E参数"><a href="#E参数" class="headerlink" title="E参数"></a>E参数</h4><p>若你认同一个良好的环境需要给员工提供在流中工作的可能，那么收集不被打断的时间数据，就可以作为度量环境好坏的参考。倘若不被打断的时间与总时间的比例相对较高，例如到了40%，那么在这个环境中，只要需要，大家随时都可以进入流的状态。比例偏低，则说明存在焦躁情绪，会降低效率。这样的度量为环境参数或者E参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E参数 = 不被打断的小时数 / 出勤时间的小时数</span><br></pre></td></tr></table></figure><p>该参数在同个组织的不同地方存在巨大差异。</p><p>E参数可能会威胁到目前的现状。如果根据E参数做出明显判断决定，这样也是异端邪说。</p><h4 id="一座丝巾花园"><a href="#一座丝巾花园" class="headerlink" title="一座丝巾花园"></a>一座丝巾花园</h4><p>一开始度量E参数时，倘若数值在零附近徘徊，我们也不必感到惊讶。不要绝望，要记住你不仅仅是在收集数据，你还在帮助改变大家的态度。总是强调不被打断的小时数，就是在逐步提醒官方，应该给大家提供部分没有打扰的工作时间。这种认可让大家不由自主地想要躲起来，忽略一两个电话，或者关起门来工作。</p><p>这种现象几乎是自发产生的，没有谁代表公司权力机构来建议说，这就是官方的”请勿打扰”标识，完全是大家集体产生的意见，每个人很快就理解了这个标志的重要性。</p><p>强调一点E参数能够帮助我们改变公司的文化，让大家意识到不要随意打断别人。</p><h4 id="对工作的思考"><a href="#对工作的思考" class="headerlink" title="对工作的思考"></a>对工作的思考</h4><p>今天我们见过的大部分办公场所都存在太多的噪声与干扰，以至于让严肃的思考基本无从开展。更让人感到羞愧的是：你的员工每天早晨带着自己的大脑来工作。只要能够让工作环境变得稍微有点显得平静安宁，他们就能全身心扑在工作上，而不需要花费任何额外的成本。</p><h3 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h3><p>你在开始收集工作时间的质量数据时，会很快注意到导致打断的罪魁祸首——呼入的电话。一天接十几个电话算不了什么，但如果考虑它带来的重新引入（reimmersion）的时间，可能耗费的就是一整天了。当一天就这样结束了，而你还在迷惑时间到底花在哪儿时，你可能根本想不起来谁为了什么事给你打电话。</p><h4 id="进入另一个世界"><a href="#进入另一个世界" class="headerlink" title="进入另一个世界"></a>进入另一个世界</h4><p>想象进入了没有电话的世界，在这个世界你写张便签来邀约午餐或会议，从另一个便签得到回复。每个人都需要提前一点做好计划，每天早晨花半个小时读邮件，然后回复。在这个世界每周三早晨都是公司委员会的例会，你是一名代表，负责监督费用使用情况。</p><h4 id="魔界奇谈"><a href="#魔界奇谈" class="headerlink" title="魔界奇谈"></a>魔界奇谈</h4><p>确实有一些方法能够减少电话打断带来的不良影响。最重要的就是意识到电话在多大程度上决定了我们的时间分配。</p><p>我们的工作方式确实被电话改变了，但我们不应该对打断带来的影响视而不见。管理者至少应该警惕打断对想要完成工作的员工带来的影响。然而往往管理者自己才是做得最糟的。</p><h4 id="修改过的电话道德"><a href="#修改过的电话道德" class="headerlink" title="修改过的电话道德"></a>修改过的电话道德</h4><p>要通向正常工作条件的道路，就需要一个全新的对待打断和电话的态度。负责完成工作的人必须得到祥和而安静的空间来开展工作，这意味着需要一段时间完全没有打扰的自由空间。当他们需要进入流的工作状态时，要有一种可被接受的、行之有效的办法来忽略那些来电。“可被接受”意味着公司文化允许大家在某些时间选择不被电话打断，“行之有效”意味着大家不需要等到铃声响毕再重新开始工作。</p><p>当电子邮件首先被提出后，我们大多数人都认为它巨大的价值在于节约用纸。但相对于对重新引入时间的节省，就显得微不足道了。电话是打断性质的，而电子邮件不会；邮件的接收者可以再他方便的时候来处理。对于大多数业务交流来说，系统流量的总和可以证明“在接收者方便时处理”的优先级排定是可行的。经过一段时间的适应，工作人员开始倾向于使用电子邮件。现在我们大多数人意见坦然接受了语音留言或电子邮件，其实关键不在技术，而在于习惯的改变。</p><p>我们需要扪心自问，为这样的消息或问题值得去打断目前的工作吗？我可以等目前工作完成了再去回答吗？这个消息需要马上回应吗？如果不是，在造成麻烦之前，还可以延后多少再去处理？</p><p>一旦你开始问这些问题，最适应你的交流模式就呼之欲出了。</p><h4 id="不兼容的多任务处理"><a href="#不兼容的多任务处理" class="headerlink" title="不兼容的多任务处理"></a>不兼容的多任务处理</h4><p>如果你在做诸如设计这样的思维密集型工作，打断就是生产效率的杀手。推而广之，若是要求脑力劳动者进行多任务处理，管理者就需要分析不同任务对流状态的要求。将一个需要流状态的任务和一些经常打断性的工作放在一起只能滋生焦躁。这种做法不可能形成合理的电话道德。</p><p>任何紧密装置都比不上改变观念来得重要。脑力劳动者的工作特点：对于花费的时间，质量胜于数量。</p><h3 id="门的回归"><a href="#门的回归" class="headerlink" title="门的回归"></a>门的回归</h3><p>创造一个合理的工作环境，成败与否可以由一些公认的标志来决定。一个显而易见的成功标志就是门。如果环境有足够多的门，员工就可以有选择性地控制噪声和干扰来满足工作的变化。最显而易见的失败标志就是传呼系统。通过巧妙地处理这些标志，不但可以激起大家对工作环境的关注，同时带来的效果也立竿见影。</p><p>过去十几年，工作条件不断恶化，但却是出自受害者的自愿，我们发出的声音还不够响亮，抱怨还不够频繁。虽然大多数人都相信更嘈杂、更拥挤的环境会伤害生产效率，但我们保持了沉默，因为缺乏明确的统计数据来佐证我们的观点。</p><p>要建立一个正常环境，首先就是不断重复那种斩钉截铁的断言。如果你认为环境正在阻碍你工作，你就必须发出你的声音。一旦大家意识到自己的感受并不孤立，大家对环境的意识就加强了。随着这种意识的加强，两件可喜的事情就会伴随而来：首先是环境的改善，因为大家更加注意噪声和打断；其实，受害者不再逆来顺受。现在上层管理者要想在不重视环境的情况下贸然采取其他提升工作效率的手段，就没那么容易了。</p><h4 id="闪亮的问题"><a href="#闪亮的问题" class="headerlink" title="闪亮的问题"></a>闪亮的问题</h4><p>人们对环境的闪亮程度确实并不在意，这一事实经常被误解为他们不关心工作环境的任何属性。如果你专门问他们关于噪声、个人隐私、桌面和柜台空间的态度，你会听到一些非常强烈的观点来说明这些属性非常重要。</p><p>办公环境设计往往过分关注外观，事实上与设计密切相关的是要看工作环境能否让你安心开展工作。有益工作的办公室不是地位的象征，而是一种必需品。你要么为打造这样的环境买单，要么就是牺牲生产效率来偿付。</p><h4 id="创意空间"><a href="#创意空间" class="headerlink" title="创意空间"></a>创意空间</h4><p>对待员工对噪声的抱怨，可以治标或者治本。治本就意味着隔离噪声——用门和墙——这些都要花钱。治标就便宜多了，播放音乐或者让大家使用自己的iPod戴上耳机来避免噪声。倘若采用了这些方法，可能会带来一种无形的惩罚，从而影响员工表现：他们会失去创造力。</p><p>很多专业工作者的日常任务都是在左脑的处理中心完成的，音乐并不会对这些工作造成影响，因为是右脑在倾听音乐。但并非所有工作都在左脑，创造性的突破包含右脑的功能，如果右脑正在忙于聆听音乐，那么就会与创造性突破失之交臂。</p><p>环境对创造力带来的负面影响并不显眼。创造力本来就是间歇性的，即使变少了，我们也察觉不出。人们不会对创造性想法进行定量，创造力的下降是一个长期积累效应。组织会变得低效、员工对工作产生倦怠，最好的员工会离开。</p><h4 id="活力空间"><a href="#活力空间" class="headerlink" title="活力空间"></a>活力空间</h4><p>封闭办公室并非就是一个人的办公室，两人、三人或者四人的办公室反而更加合理，最好是按照工作组来划分办公室。两名员工在一起工作的时间如果达到了50%，那么他们俩就是同一间办公室的自然候选人。</p><p>即便是在开放式的办公环境，一起工作的员工也应该将格子间修改为一个共同的小套间。若这种改变可行，大家就会很巧妙地根据工作需要去设计自己的区域：工作区、讨论区和社交区。因为他们工作步调很一致，制造噪声影响别人的几率就会比随机选择的邻居少了很多。这种空间具有活力，因为容易互动，也很自然。适当控制这样的空间会获得额外的收益。</p><h4 id="打破企业常规"><a href="#打破企业常规" class="headerlink" title="打破企业常规"></a>打破企业常规</h4><p>生活中，让人不爽的事实是最好的工作环境不可能被完全复制。若是赞成让员工按照自己的想法摆弄他们的空间，结果必然是不整齐。每个人以及每个团队的空间都个性鲜明，若还没有，那就最好回去做出更多的变化。</p><p>管理者要做得最好，就应该保证为大家提供足够的空间，足够的安宁以及足以保护个人隐私的方法，让大家能够创造自己的工作空间。按照这种思想，就不可能存在整齐划一。当大家挂起稀奇古怪的照片、在桌上堆满东西，家具移来移去，活着合并他们的办公室时，你最好一笑置之。只有当大家把空间按照适合自己的工作组织好后，他们才能够抛开空间的影响，完全投入到工作中。</p><h3 id="采取保护步骤"><a href="#采取保护步骤" class="headerlink" title="采取保护步骤"></a>采取保护步骤</h3><p>自己想想环境的问题，弄清楚想要改进的方向很有必要。若要弄明白自己需要什么样的环境，就需要找到工作环境的不变特性。</p><blockquote><p>有一种建筑的永恒之道。历经数千年，历久弥新。历史上那些让人们有家一般感觉的建筑、村庄、部落和寺庙都是由那些真正理解“道”之核心的人建造的。不遵循此方法就不可能建造出宏伟的建筑、伟大的城市或美丽的栖息之地——让你产生归宿感，倍感活力的栖息之地。这种“道”帮助寻找它的人发现那些融合在树木山川之间，弥合在我们生活之中的建筑。——克里斯托弗.亚历山大 《建筑的永恒之道》</p></blockquote><h4 id="亚历山大的有机控制理论"><a href="#亚历山大的有机控制理论" class="headerlink" title="亚历山大的有机控制理论"></a>亚历山大的有机控制理论</h4><p>想象一下，你的组织要筹建一个新的复杂空间，那么哪里才是你开始的起点？几乎确定无疑，就是制定一个总体计划，根据《建筑的永恒之道》所言，多数情况下，开始迈出的第一步常常会带来最致命的偏差。按照这种方式，用于不可能创造出活力四射、激情澎湃、和谐蕴藉的环境。总体计划总是梦想着宏伟的工程，钢筋水泥的延伸，通过模块方法不断重复地建造出整齐划一的建筑。于是乎，一个枯燥乏味风格雷同的空间诞生了，它除了能满足某些人的自我野心外，根本不适合人们工作。</p><p>大多数这样整齐划一的公司环境只对那些推动建设的公司董事具有象征意义。这种总体计划就是一种进行全面极权控制的尝试，一个单调而统一的观念主宰一切。没有任何建筑竭力去体现异曲同工之妙。极权观点的副作用就是设施的概念是一成不变的。</p><p>对于这样的总计划，亚历山大提出了演进计划（meta-plan）的概念，其哲学是设施能够根据使用者按需演进。演进计划分为三部分：</p><ul><li>逐渐发展的哲学</li><li>一组支配发展的模式或达成共识的设计原则</li><li>使用空间者对设计的局部控制</li></ul><p>在演进计划下，设施一小步一小步地进化出建筑群园区与社区。遵循共识的原则，它们守护着和谐的愿景，但并不千篇一律，就像成熟的村落一般展现出不断进化的魅力意义，这就是亚历山大提出的有机控制。</p><p><img src="/images/peopleware/p-01.jpg" alt="p-01.png"></p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>模式183“工作空间封闭性”（Workspace Enclosure）：空间过于封闭或开放，人们都不能有效工作。一个好的工作空间需要找到二者的平衡。你不应该听到与自己工作空间发出的声音差异很大的噪声。工作空间应该是足够封闭的，能够屏蔽掉这类噪声。一些证据显示，如果四周的人都做着同类事情，那么完成任务的情况要好于做不同事情的情况……工作空间应该允许你面朝不同的方向。——克里斯托弗.亚历山大 《模式语言》</p><p>设计团队需要根据自身项目的特性剪裁出一些新模式。</p><h5 id="第一个模式：从工具箱里定制工作空间"><a href="#第一个模式：从工具箱里定制工作空间" class="headerlink" title="第一个模式：从工具箱里定制工作空间"></a>第一个模式：从工具箱里定制工作空间</h5><p>被安排活着选派在一起工作的小组需要拥有设计自己的工作空间的权力。理想情况下，他们应该在统一的空间规划部门帮助下展开设计。然后团队成员和他们的空间顾问一起来完成他们可能的空间布局设计。</p><p>因为允许员工参与设计他们自己的工作空间，无论是公司办公桌还是其他设施都需要能够真正组件化。与只适用于简单的小隔间不同，这些设施必须能适应多种不同的配置。</p><h5 id="第二个模式：窗户"><a href="#第二个模式：窗户" class="headerlink" title="第二个模式：窗户"></a>第二个模式：窗户</h5><p>亚历山大对没有窗户的空间容忍度极低：“没有窗外风景的房子，对于居住在里面的人而言，就像是牢笼”。</p><p>我们听说，虽然公司非常希望每个人都拥有一扇窗户，但现实却不允许。其实这当然可行，在不超过预算的情况下建设足够多的窗户已有现成证明。最明显的证据就是宾馆。造成没有足够窗户问题的直接原因就是长宽比例。几年前荷兰立法要求必须为每一位工人提供他自己的窗户，这项法律迫使建筑者建造狭长的建筑，类似于酒店和公寓大楼。在立法生效后进行的一项研究调查中发现，每平方米空间的成本并没有显著变化。就算为了让每位员工能够在更合理的空间工作而花销高点，也是物超所值的，因为总能在其他地方做到节余。真正的问题在于这部分成本是显而易见的，而它带来的好处却没有被仔细衡量，不具有可视性。</p><h5 id="第三个模式：室内和室外空间"><a href="#第三个模式：室内和室外空间" class="headerlink" title="第三个模式：室内和室外空间"></a>第三个模式：室内和室外空间</h5><p>狭长的布局同时也能够让我们更容易融合室内和室外空间。如果你在一个拥有室外建筑的地方工作过，就很难想象将你自己限制在室内环境工作。</p><h5 id="第四个模式：公共空间"><a href="#第四个模式：公共空间" class="headerlink" title="第四个模式：公共空间"></a>第四个模式：公共空间</h5><p>小组互动的空间需要提供能够容纳所有人员的桌椅，可供书写的表面，以及允许随意张贴的区域。最理想的是能够有空间让小组成员一起准备餐食，并一起进餐。</p><blockquote><p>没有一起聚餐的人类不可能形成群体。    ——克里斯托弗.亚历山大 《模式语言》</p></blockquote><h4 id="模式之模式"><a href="#模式之模式" class="headerlink" title="模式之模式"></a>模式之模式</h4><p>在成功的空间设计中，一次次观察到这些模式的原因在于它们跟人类的特性息息相关。这样的空间考虑了人性化的功用，抓住了问题的关键——人既是个体的人，又是群体的人。人的个体属性和集体倾向都得到了认可，从而让人能够自由发挥。</p><p>所有模式都有一个最基本的元素，那就是依赖于不可复制的配方。两个人不是非要使用同一种工作空间。没有两个休息区完全一样，图书馆或者阅读区亦是如此。空间的结构、形状和组织，对使用空间的人们来说是一个很有趣的话题。场地的设计需要吻合工作的种类，而在这个工作场所工作的各级人员则需要在设计中加入自己的印迹。</p><h4 id="回归现实"><a href="#回归现实" class="headerlink" title="回归现实"></a>回归现实</h4><p>在当下，如果你就职于一家大型机构，你不太可能让当权者承认自己的错误，然后让大家来设计一个所谓永恒的办公环境。可能你也不愿意在一家虽然环境诱人，规模却很小的公司工作。</p><p>尽管如此，总有一个可能的办法让大家在充满活力而高效的环境里工作。这种可能性之所以存在，是因为通过整体计划设计的空间几近于饱和，想要添加点额外的东西总是难上加难。要是没法满足要求，那就换个角度向外看。申请把你的小组搬出公司的摩天大楼。只要团队愿意，谁在乎呢？</p><p>你不需要去解决整个机构的空间设计问题。如果能为自己的团队解决这个问题，你就已经很超前了。倘若你的团队更加高效、人员流失更少，更能说明你是一个优秀的管理者。</p><p>大多数时候，把一个项目团队或工作组从公司大楼搬出去是合理的。在一个松散的环境里工作，会更有热情而且成功率更高。大家更少被噪声、干扰和焦躁情绪影响。有点古怪的环境有助于团队形成自己的个性。如果你是能够直接影响最高管理层的人，考虑一下哪些项目是最重要的，把关键项目移出去。</p><h2 id="三、正确的人"><a href="#三、正确的人" class="headerlink" title="三、正确的人"></a>三、正确的人</h2><p>无论做出何种努力，最终结果更多在于是谁来做而不是怎么做。然而，现代管理学仍然没有足够重视雇用和留用正确的人。</p><ul><li>找到合适的人</li><li>让他们愉快工作，不愿离开</li><li>让他们自由发挥</li></ul><p>当然，即使是最好的团队。你也需要协调每个人的贡献形成一个集体，但那是管理中相对有章可循的部分。对大多数尝试来说，成功还是失败在组建团队并形成最初方向时就已经设定了。一旦拥有一群才能超卓的成员，管理者就可以在开动后退居二线了。</p><h3 id="霍恩布洛尔因素"><a href="#霍恩布洛尔因素" class="headerlink" title="霍恩布洛尔因素"></a>霍恩布洛尔因素</h3><p>C-S-Forester 关于拿破仑战争的系列小说围绕着英国皇家海军霍恩布洛尔船长展开。从管理学层面，霍恩布洛尔船长的故事可以看作是管理学范畴的读物。运转一艘大型横帆战舰，管理整支舰队要做的工作，与管理一个项目或一个公司的部门大同小异。</p><h4 id="天生与后天练就"><a href="#天生与后天练就" class="headerlink" title="天生与后天练就"></a>天生与后天练就</h4><p>霍尔布洛尔知道只有少数能够跟他并肩战斗的人才是他真正的资源。让这部分人成长起来，而且了解什么时候该依靠他们，这是霍恩布洛尔船长最大的能力。</p><p>在这个人人平等的时代，我们都不会去考虑某个人是否天生不胜任某事。我们假设每个人天生都有价值。管理者的工作应该是用自己的领导能力去发掘下属的潜力。怎样塑造原始的人力资源是管理学的根本。但是这样的观点我们觉得并非现实。通过经年累月的时间，家长对塑造孩子可以施加影响，而个人对自己也可能做出巨大的改变。然而，管理者却不可能从本质上改变他们的员工。人们通常在短时间内很难做出改变，管理者也很难找到杠杆的支点来撬动他们发生本质的改变。所以，在为你工作期间，人们在离开时和刚进来时并没有什么区别。一开始不适合工作的人，那就永远都不适合。</p><p>这意味着从一开始就找到正确的人至关重要。</p><h5 id="整齐的塑料人"><a href="#整齐的塑料人" class="headerlink" title="整齐的塑料人"></a>整齐的塑料人</h5><p>即使是新晋的管理者，在初次面试人的时候也知道一些招聘原则。例如不能以貌取人。但让人奇怪的是，许多招聘上的失误又都是由于过度重视外表而忽略了真正能力造成的。者并非招聘者的疏忽或肤浅，而是物种的进化让我们更关注那些非凡的人。这种趋势直接服务于物种的进化。</p><p>究其原因，影响招聘的并不仅仅是你个人存在这种倾向，你所在的组织下意识地也在制造自己的标准。你采纳的标准并不属于你自己，你是在为你的各级上层招聘。当你每次在决定雇用一个人时，高层管理的喜好都在左右着你。这种几乎无形的压力推动着公司趋于平均化，促使你去招聘长相相似、思想相似的人。在一个健康的公司文化下，这种影响微乎其微以至于可以忽略；若公司文化不够健康，想要招到一个与其他人比较显得特立独行的关键人物，就变得异常困难，甚至根本不可能。</p><h4 id="着装标准"><a href="#着装标准" class="headerlink" title="着装标准"></a>着装标准</h4><p>对于不安到需要强加着装标准的权威政权，整齐划一就显得很重要。公司有时预委会制定着装标准，虽然不是强迫极端严格的服装统一，但也很大程度上影响着员工的判断力。当这种事情第一次发生时，产生的影响是很恶劣的。大家都不去讨论和思考其他问题了，所有有意义的工作都停滞了。最有价值的员工开始意识到他们的发型和领带重要。最后他们会选择离开，其余的人拖着沉重缓慢的步伐继续前行，尝试着证明正确人物的存在并非如此重要。</p><blockquote><p>虽然尸体不会立刻就耸拉下来，毕竟还有那么多双手尝试着托起来；但托尸体这件事可不能令人满意。</p></blockquote><h4 id="词汇代号：专业"><a href="#词汇代号：专业" class="headerlink" title="词汇代号：专业"></a>词汇代号：专业</h4><p>要是内部员工对任何异于习惯的行为都感到不安，那才是真正的问题。不专业这个词语经常被用来形容那些让人吃惊或有威胁的行为。任何让自信不足的管理者害怕的事物都是不专业的。长发男生那就是不专业的，休闲鞋是不专业的。。。</p><p>反过来，专业意味着不会让人吃惊。考量你是否专业，涉及你的长相、动作以及和别人雷同的想法，就是要做一只勤劳的蜜蜂。</p><p>当然这种变态的专业论无疑是病态的。在一个更加健康的组织文化里，衡量一个人专业与否，看的是他的学识和能力。</p><h4 id="企业熵"><a href="#企业熵" class="headerlink" title="企业熵"></a>企业熵</h4><p>熵是水平的，或者说是相同的。熵越多，产生能量或者动量的能力就越弱。在一个公司或组织里，熵被认为是态度、外貌和思考的过程的统一。</p><blockquote><p>管理热力学第二定律：组织里的熵总是增加的。</p></blockquote><p>这就是为什么老龄化的机构比有活力的年轻公司来，总是觉得约束更多，因而缺少了工作的乐趣。</p><p>我们无法改变这个整体现象，但可以在自己的领域做出改变。最成功的管理者总是能摇动熵、带来正确的员工，并让他们展现自我，甚至允许他们偏离公司的标准。你所在的组织可能已经僵化了，但可以让你负责的部门幸免于难。</p><h3 id="谈谈领导力"><a href="#谈谈领导力" class="headerlink" title="谈谈领导力"></a>谈谈领导力</h3><p>这里所谈的领导力通常指的是如何巧妙利用权力在组织中达成一个目标。只有管理者才需要去领导。管理者被送去参加各种各样的领导力培训班，去学习如何更好地使用他们的权力来指挥消暑。在这种观点下，领导力是自上而下的——领导在上，跟随者在下。从组织的架构图看，上面的人领导你，而你则领导架构图中直接位于你所在方框下面的人。</p><h4 id="作为工作压榨机制的领导力"><a href="#作为工作压榨机制的领导力" class="headerlink" title="作为工作压榨机制的领导力"></a>作为工作压榨机制的领导力</h4><p>“领导的速度决定团队的效率”，这种领导力就是工作榨取的机制，他追求数量而非质量。管理者领导你，就是想办法让你工作更卖命、时间更长、没法休息。</p><p>用枪来指挥意味着你是站在手下的背后进行“领导”，这与工作榨取风格的领导力雷同。在工作环境中，拥有职务和地位的权力就是那支枪。</p><h4 id="作为服务的领导力"><a href="#作为服务的领导力" class="headerlink" title="作为服务的领导力"></a>作为服务的领导力</h4><p>实际上，最为卓越的领导力——大家真切表达出来并且深深敬重的那种——经常来自于那些没有地位权力的人。这样的领导力通常发生在公司层级结构之外。</p><p>领导力并不是从我们身上压榨出什么东西，而是一种服务。如果不靠职位的授权来领导——不需要任何人任命你为领导——你需要做的事：</p><ul><li>主动承担任务</li><li>明确地胜任工作</li><li>为任务准备提前做足必要的功课</li><li>让每个人创造最大的价值</li><li>实施过程中保持幽默和明显的善意</li><li>有感染力自然大有裨益</li></ul><h4 id="领导力和创新"><a href="#领导力和创新" class="headerlink" title="领导力和创新"></a>领导力和创新</h4><p>在组织中，这种不依靠授权来领导的倾向，是人们能够创新以及敢于突破行业限制的标志。创新依靠领导力，而领导力又需要创新。二者互为依存，若一项能力存在不足，就会影响另一项能力。</p><p>即使最好的创新也需要一点离经叛道才能产生影响：离经叛道的领导力。创新者自己可以不是一个伟大的领导者，但必须有人是。在这个创新过程中，这种离经叛道的领导力带来的是时间——让一个关键人物不去做产生利润的工作，而去尝试处于萌芽中的想法——同时，为了能够让创新发挥效力，即使再难，也需要对组织进行重组。</p><p>因为没人知道下一个创新会如何改变一个组织，所以也就没人能够提供足够的理由赋予关键支持者去做需要完成的事情，这也解释了为什么将领导力作为一种服务，总是在没有官方授权的方式下展开。</p><h4 id="领导力：言与行"><a href="#领导力：言与行" class="headerlink" title="领导力：言与行"></a>领导力：言与行</h4><p>如果企业都能够接受自然而然产生的领导力，企业内就不需要那么多空对空的谈话了。</p><h3 id="雇一名杂耍演员"><a href="#雇一名杂耍演员" class="headerlink" title="雇一名杂耍演员"></a>雇一名杂耍演员</h3><p>去招聘一位工程师、设计师、程序员或者一名团队经理，这样的常识却被抛在了脑后。你不去看他的设计、程序或者其他东西，面试全靠说。你当然需要看看候选人以前生产的产品样品，这往往被开发团队的管理者忽略了。当你负责职位面试时，似乎有一条约定俗成的边界，认为可以只跟候选人聊聊过去的工作，但不用看到实物；其次，只要你问了候选人，大部分人都会很高兴地带来一件样品。</p><h4 id="作品集"><a href="#作品集" class="headerlink" title="作品集"></a>作品集</h4><p>让每个学生自己收集作品集，以展示他们的工作成果。</p><h4 id="技能测试"><a href="#技能测试" class="headerlink" title="技能测试"></a>技能测试</h4><p>如果重视新聘员工所具备的用于工作中的各种技能，那么我们为何不设计一个测试来度量这些技能呢？但这种测试度量了错误的东西。</p><p>技能测试一般都会针对被雇用者进入公司后马上会面临的任务来进行。他会被测试是否胜任于职位需要的统计分析、程序设计或其他知识。在几乎所有的技术领域，你都能买到这种技能测试，它们也或多或少能够预测一个新进员工的表现。我们发现，大部分技能测试都针对左脑。这是因为一名新员工的任务大部分都依赖左脑。但在接下来的职业生涯中，他们做的事情会很大程度上依靠右脑，比如说管理就需要整体思考、启发性判断和机遇经验的直觉判断。所以技能测试可能造成你招进来的人，短期表现良好却无法获得长期成功。也许你应该尝试着只雇用那些技能测试失败的人。</p><p>我们并不鼓励在招聘中采用技能测试。并不是说技能测试就不好，你就该坚决不用。相反，你应该去用，只是不该用于招聘。通过购买或自己开发的经典技能测试说给员工提供的很好的自我评价工具。一个健康组织所必需的，是能够为员工经常性地提供独立的自我评价的机会。</p><h4 id="组织一场试演"><a href="#组织一场试演" class="headerlink" title="组织一场试演"></a>组织一场试演</h4><p>在我们所在的行业，社会成分比技术成分多，更多是依靠员工和其他人交流的能力而不是他们跟机器交流的能力。所以在招聘过程中，至少需要关注那些社会和人际交流的特征。我们发现，最有效的方法就是为应聘者组织一场试演。</p><p>这个想法很简单，让应聘者按自己过去工作的某个方面准备一个10或15分钟的演讲，可以是关于一种新技术的第一手体验，或者是从痛苦经历中学到的管理知识，或者是关于一个很有趣的项目。应聘者自己选择话题，然后你定一个日子并且邀请未来可能和他一起工作的人来当听众。</p><p>之所以要组织这样的会，就是要考察应聘者的交流技巧，同时也给未来同事们一个参加招聘过程的机会。</p><p>在试演完成、应聘者离开后，你可以组织一次听众讨论。每个人都评价一下应聘者跟工作的契合度，以及是否能够融入团队。</p><p>一次成功的试演就像一次同行认证；反之似乎也成立，一次失败的试演也能提升已有员工的士气。</p><p>关于试演的一个警告：确保应聘者讲述的是跟你组织从事的工作紧密相关的事情，要很不容易被一些极左的话题讨论给蒙蔽了。</p><h3 id="与他人良好合作"><a href="#与他人良好合作" class="headerlink" title="与他人良好合作"></a>与他人良好合作</h3><p>合同工、外包人员和离岸人员增加了组建一个良好团队需要考虑的维度。在此基础之上，几乎无处不在的全球化决定了就算是一个最常见、最简单的内部开发团队也需要你去考虑团队成员不同的文化背景。</p><h4 id="首先、机遇"><a href="#首先、机遇" class="headerlink" title="首先、机遇"></a>首先、机遇</h4><p>在《软件工程经济学》中，巴里.贝姆指出软件行业从一个每年不足10亿美元的产业成为每年300多亿美元的产业用了不到25年时间，其中大部分都花费在人的身上。那么这些人是从什么地方来的呢？关键在于利用了受到良好教育却在早期职业发展受限的女性。雇用单位针对这些女性开展专项技能培训，比如程序设计、调试及系统设计。大量女性的加入带来的不仅仅是人力资源的增加，她们改变了团队的组织及交流方式。当她们成为管理者时，她们带来了新的管理风格。现在的全男性团队已经显得有所缺失而热情不足了，女性在行业里已经产生了巨大的影响。</p><h5 id="食物魔法"><a href="#食物魔法" class="headerlink" title="食物魔法"></a>食物魔法</h5><p>全球化和市场一体化打破了原有的边界，为我们的项目带来了更多差异化，使我们的项目拥有更多的民族背景及新的文化模式。如果说这些变化看起来像是需要解决的问题，那么它们同时也带来了机遇。就像我们珍惜餐桌上不同背景的同事带来的各式食物一样，我们也应该珍惜不同的工作、思考及交流方式。</p><h4 id="是的，但是…"><a href="#是的，但是…" class="headerlink" title="是的，但是…"></a>是的，但是…</h4><p>但一个团队接受新人新事总是有极限的。团队磨合需要时间，而在磨合期内，团队的组成不能轻易改变。</p><h3 id="童年的终结"><a href="#童年的终结" class="headerlink" title="童年的终结"></a>童年的终结</h3><p>阿瑟.克拉克在他的科幻小说《童年的终结》中描绘了由于新一代人不仅仅在数量上，更在质量上优于他们的父母而造成的张力。</p><p>现在，新加入工作大军的年轻人差异并不算大，但不同年代的差异还是需要去理解和适应的。</p><h4 id="科技——和它的反面"><a href="#科技——和它的反面" class="headerlink" title="科技——和它的反面"></a>科技——和它的反面</h4><p>一代人的科技成为了下一代人的环境。对于这些事物的使用，他们不需要你来教，你所说的各种有关使用的道德规范，他们完全掩耳不闻。当然即使如此，在他们从公司新人成为对公司有价值的员工的过程中，也需要学习和理解应该如何合理使用你们的科技/环境。</p><h4 id="持续不断的局部注意力"><a href="#持续不断的局部注意力" class="headerlink" title="持续不断的局部注意力"></a>持续不断的局部注意力</h4><p>如果做最简单的归纳，员工年代的划分都是根据关注度：年轻一代关注的内容繁多，而老一辈的员工通常会集中精力，把注意力投向一两件事上。</p><p>学习过程中伴随着iPod里的音乐，来来往往的短信，随时打开的社交网络，还有在历史作业旁边不时闪烁的电子游戏窗口，这就是微软前副总裁琳达.斯通所谓的“持续不断的局部注意力”（continuous partial attention）。最年轻的员工会告诉你，在这样的环境中他们的工作效率最高。</p><p>问题是这种持续不断的局部注意力正好是我们前面提到的流的反面。如果你认同流的状态才是完成真正工作的方法，就需要限制一下人们注意力的分散。虽然花在Facebook上的时间只占总时间的百分之二，但一个固定的时间段与整天不时去看看还是不同的。不能进入流状态的员工是低效的，他们也不太可能融入到不同年代员工组成的团队中。</p><h4 id="明确合同"><a href="#明确合同" class="headerlink" title="明确合同"></a>明确合同</h4><p>为年轻员工清楚讲述合同规则，实际上是给他们机会融入组织。持续不断的局部注意力的时间段需要被定义为个人非工作时间，在每个工作日都应该有个限制，工作日剩下的时间应该全力工作。</p><p>会议上的不专注更应该被看做是会议文化的紊乱，而不是某些人的工作道德问题。站立会议或者不允许携带笔记本电脑的会议就是在明确规则，但除了这样的措施要求，你需要考虑你的会议哲学，多数情况下这都是一个好主意。</p><h4 id="昔日的杀手级应用"><a href="#昔日的杀手级应用" class="headerlink" title="昔日的杀手级应用"></a>昔日的杀手级应用</h4><p>不要期待年轻一代的员工会多么尊重电子邮件。越是年轻的员工群体，就越可能认为邮件冗长乏味，简直浪费时间，简洁的短信更符合他们的口味。</p><h3 id="在这儿很开心"><a href="#在这儿很开心" class="headerlink" title="在这儿很开心"></a>在这儿很开心</h3><p>问题1：这几年你们组织的员工流失率是多少？问题2：换一个人平均花销有多大？</p><p>如果你能够给出这两个问题的任何答案，就过关了，否则就是失败。</p><p>我们有意去忽略离职率这个问题，因为这只能得到自寻烦恼的坏消息。</p><h4 id="离职率：明显的花费"><a href="#离职率：明显的花费" class="headerlink" title="离职率：明显的花费"></a>离职率：明显的花费</h4><p>我们能够获知的离职率大多在每年33%～80%之间，平均一名员工在职时间为15～36个月。假设你公司的离职率在这个范围中间，平均一名员工在职时间两年多一点。雇用一名新员工要多花一个半到两个月的工资，或者雇用公司内部做同样事情的人。雇用的员工能够马上进入角色开始工作，在项目上马上计费的情形是完全不现实的。我们都知道新人第一天完全是负生产力，因为必须有人出来带新人让他们上手。</p><p>5个月后，他开始发挥全力。对一个新人开始阶段的合理评估时间大概是3个工作曰。换人的成本大概等于4.5～5个月的人力成本，或者是雇用这名员工两年总花销的20%。</p><h4 id="离职的隐形成本"><a href="#离职的隐形成本" class="headerlink" title="离职的隐形成本"></a>离职的隐形成本</h4><p>员工离职的代价是总人力成本的20%，但这还只是显式成本。隐形成本其实更高。</p><p>在离职率高的公司里，员工大多很短视，因为他们知道自己不会在这个地方待很长时间。所以当你为员工争取更好的工作环境，若上层管理者发出反抗及疑问的声音，不要感到诧异。</p><p>这个人可能已经心生去意，因此，短期成本对他来说才是实打实的，什么长线收益，对他们来说根本没有意义。</p><p>在一个离职率高的组织里，没有人会去长线思考问题。倘若大家只准备在这儿待一两年，要留住最好的员工，只能是给出快速承诺。可能刚刚上手的员工会提升成一线经理。</p><p>一个工龄40年的人化5年时间工作，然后35年时间都在进行管理。这体现了一个长而狭窄的阶层架构。15%的员工在工作，剩下85%在管理，只有10%的成本花在员工身上，其余90%都用在管理者身上了。</p><p>这样的结构不仅仅具有毫无意义的沉重头部，下面工作的人也很少，真正的头重脚轻。我们很多人相信，人才晋升快速的公司是很有行动力的。这很自然，因为年轻员工都很有向前发展的冲劲，但从企业发展的角度来看，晚提拔是健康的标志。在离职率很低的企业里，进入最高管理层需要在公司工作10年之后。一线工作的员工平均工龄为5年，公司的组织架构是扁平的。</p><h4 id="人们为何要离开"><a href="#人们为何要离开" class="headerlink" title="人们为何要离开"></a>人们为何要离开</h4><p>对于遭遇高离职率的公司来说（大于30%），下面的因素可能造成高的离职率：</p><ul><li>过客心态：同事造成不希望长期投入工作的感觉；</li><li>可被替代感：管理层认为员工只是可被替代的部件。</li></ul><p>这种阴暗效益产生恶性循环。</p><h4 id="一种特殊的病理学：公司搬迁"><a href="#一种特殊的病理学：公司搬迁" class="headerlink" title="一种特殊的病理学：公司搬迁"></a>一种特殊的病理学：公司搬迁</h4><p>没有什么比感觉不安全的管理者把公司搬迁到比较偏远的地区更自大的行为了。这样的搬迁让他们有了控制员工个人生活的权利。越是自我的管理者，越是对搬迁公司有强烈爱好。</p><p>一般一个被搬迁的员工只是双职工家庭的一半。另一半可能不会同时搬迁，所以公司的搬迁对两个人的关系会造成很大的影响，现代夫妻不会忍受和原谅这种事情的。</p><p>决定让公司搬迁，会让员工流失非常多，而且这还仅仅是初始阶段的损失。当他们发现自己不喜欢新环境的时候，他们只能再次离开。</p><h4 id="永恒之地的观念"><a href="#永恒之地的观念" class="headerlink" title="永恒之地的观念"></a>永恒之地的观念</h4><p>最优秀的组织（一些超低流失率）并非完全相同，他们的差异性较之共性更引入注意。但有一个特点是它们作为最佳组织都都具备的。<strong>最优秀的组织会有意识地去追求成为最佳</strong>。这样的共同目标提供了一致的方向、合作的满足感和强大的凝聚力。这样的地方滋生一种永恒之地的观念，感觉只有傻瓜才会去其他地方寻找工作。公司为员工设立了社区花园，午餐时间，那片院子里就充满了业余的园丁，大家隔着篱笆谈论着如何种番茄。</p><p>你可以证明社区花园短期没啥意义，但在最优秀的组织里，短期不是唯一重要的事情，重要的是成为最好的，这是一个长期概念。</p><p>大家留在这样的公司，是因为它让你意识到公司总是期待你留下来。公司为你的个人成长投入巨大，这种情况下你很难不感受到希望你留下来的信号。</p><p>拥有最低离职率的公司，它们的一个共同特点就是广泛的再培训。他们知道重新培训能够帮助组织树立永恒之地的观念，从而形成低离职率和强烈的社区感。</p><h3 id="人力资本"><a href="#人力资本" class="headerlink" title="人力资本"></a>人力资本</h3><p>花销是指一笔钱被花掉了。到月底，你的钱花了，暖气也用了。另一方面，投资则是用一种资产去购买另外一种资产。价值没有被使用，只是从一种形式转换成了另外一种，当你在支出项中选择投资而不是花销时，你就在对这笔钱支出进行资本化。</p><h4 id="对人来说呢？"><a href="#对人来说呢？" class="headerlink" title="对人来说呢？"></a>对人来说呢？</h4><p>通行的会计准则是将所有工资作为花销，不会作为资本投资。有些时候这是合理的，但有些时候却不然。假设你送员工去参加一周的培训，他的工资和培训费被花在了一些到月底也不会消失的事情上。他学到的东西在接下来的时间里还是在他的脑子里。如果你能够聪明地使用培训经费，那就是一笔投资，而且很可能是非常有价值的一笔。但根据会计惯例，这就是一笔花费。</p><h4 id="谁在意这些？"><a href="#谁在意这些？" class="headerlink" title="谁在意这些？"></a>谁在意这些？</h4><p>真正有意义的并不在于如何为IRS或者投资人提供报告，而是管理者如何看待在员工身上投资的这笔钱。人力资本可能很可观；如果错误地把这样的投资看成是花费，很可能会让管理者放弃组织在这方面有价值的投资。这经常会被称为“底线意识”，但我们更愿意叫他：“吃老本”。</p><h4 id="衡量人力资本投资"><a href="#衡量人力资本投资" class="headerlink" title="衡量人力资本投资"></a>衡量人力资本投资</h4><p>你的公司在你和你的同事身上投资了多少？一个简单的度量方法是考虑如果你离开公司，会发生什么。组织会为这些无产出时间付出的费用，可以计算出阴影区域的货币数值。</p><p><img src="/images/peopleware/p-02.jpg" alt="p-02.png"></p><h4 id="新人上手需要多长时间？"><a href="#新人上手需要多长时间？" class="headerlink" title="新人上手需要多长时间？"></a>新人上手需要多长时间？</h4><p>6个月从一个负产出者到达前任的产出效率，这对一个新进的软件应用开发人员来说是比较合理的，但如果对稍微复杂一些的工作，可能就远远不够了。</p><p>假设有新一轮的“精兵简政”的裁员，花在这名员工身上的工资以及其他花费会被节省下来，但投资就完全泡汤了。</p><h4 id="玩华尔街的游戏"><a href="#玩华尔街的游戏" class="headerlink" title="玩华尔街的游戏"></a>玩华尔街的游戏</h4><p>每年的裁员、减产、缩减组织或收缩规模，华尔街对此都表示欢迎，就好像这样的撤退才是最终的目的。值得指出的是情况并非如此：这种措施的目的是增员，而不是减员。</p><p>有意识地主动管理这项人力投资的公司一定会得到长线汇报。依靠脑力劳动着的公司必须认识到他们在人力资本上的投资是至关重要的。好的公司早就这样干了。</p><hr><p>豆瓣</p><ul><li><a href="https://book.douban.com/subject/25956450/" target="_blank" rel="noopener">https://book.douban.com/subject/25956450/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《人件》（Peopleware，第三版）读书笔记（上）&quot;&gt;&lt;a href=&quot;#《人件》（Peopleware，第三版）读书笔记（上）&quot; class=&quot;headerlink&quot; title=&quot;《人件》（Peopleware，第三版）读书笔记（上）&quot;&gt;&lt;/a&gt;《人件》（
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://blog.michealwayne.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《A Philosophy of Software Design》软件设计哲学（下）</title>
    <link href="http://blog.michealwayne.cn/2021/09/12/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AA%20Philosophy%20of%20Software%20Design%E3%80%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2021/09/12/notes/【笔记】《A Philosophy of Software Design》软件设计哲学（下）/</id>
    <published>2021-09-12T08:06:18.000Z</published>
    <updated>2021-09-14T07:02:20.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《A-Philosophy-of-Software-Design》软件设计哲学（下）"><a href="#《A-Philosophy-of-Software-Design》软件设计哲学（下）" class="headerlink" title="《A Philosophy of Software Design》软件设计哲学（下）"></a>《A Philosophy of Software Design》软件设计哲学（下）</h1><p>作者：John Ousterhout（斯坦福大学的 Bosack Lerner 计算机科学教授。他是 Tcl 脚本语言的创建者，并且以在分布式操作系统和存储系统中的工作而闻名。Ousterhout 在耶鲁大学获得了物理学学士学位，并在卡内基梅隆大学获得了计算机科学博士学位。他是美国国家工程院院士，并获得了无数奖项，包括 ACM 软件系统奖，ACM Grace Murray Hopper 奖，美国国家科学基金会总统年轻研究者奖和 UC Berkeley 杰出教学奖。）</p><p>这本书是关于如何使用复杂性来指导软件设计的整个生命周期。本文为 11 ～ 21 章笔记，后续会调整内容，给予更贴近前端的案例。</p><p>todo：案例替换；文案优化</p><h2 id="设计它两次（Design-it-Twice）"><a href="#设计它两次（Design-it-Twice）" class="headerlink" title="设计它两次（Design it Twice）"></a>设计它两次（Design it Twice）</h2><p>设计软件非常困难，因此你对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策可以考虑多个选项，最终将获得更好的结果：即“设计两次”。</p><p>假设你正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。你无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。</p><p><strong>尝试选择彼此根本不同的方法，这样你将学到更多。</strong>即使你确定只有一种合理的方法，无论你认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。</p><p>在对备选方案进行粗略设计之后，列出每个方案的优缺点。<strong>一个接口最重要的考虑因素是高级软件的易用性</strong>。在前例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：</p><ul><li>一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。</li><li>一个接口比另一个接口更通用吗？</li><li>一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。</li></ul><p>比较了备选设计之后，你将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者你可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。</p><p>有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用你在原始替代方案中发现的问题来推动新设计。如果你在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。</p><p>两次设计原则可以在系统的许多级别上应用。对于模块，你可以首先使用此方法来选择接口，如上所述。然后，你可以在设计实现时再次应用它：对于文本类，你可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果你可以比较几种选择，则更容易确定最佳方法。</p><p>对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），你可能不需要一两个小时就能考虑替代方法。与你将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。<strong>对于较大的模块，你将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。</strong></p><p>我已经注意到，真正聪明的人有时很难接受两次设计原则。当他们长大后，聪明的人会发现，他们对任何问题的第一个快速构想就足以取得良好的成绩。无需考虑第二种或第三种可能性。这使得容易养成不良的工作习惯。但是，随着这些人变老，他们将被提升到越来越困难的环境中。最终，每个人 ​​ 都达到了你的第一个想法不再足够好的地步。如果你想获得非常好的结果，那么无论你多么聪明，都必须考虑第二种可能性，或者第三种可能性。大型软件系统的设计属于此类：没有人能很好地在首次尝试时就将其正确。</p><p>不幸的是，我经常看到聪明的人坚持要实现第一个想到的想法，这会使他们无法发挥其真正的潜力（这也使他们沮丧地工作）。也许他们下意识地相信“聪明的人第一次就能做到”，因此，如果他们尝试多种设计，那将意味着他们毕竟并不聪明。不是这种情况。不是说你不聪明；问题真的很难解决！此外，这是一件好事：<strong>处理一个必须认真思考的难题比处理一个根本不需要思考的难题更有趣。</strong></p><p>“两次设计”方法不仅可以改善你的设计，而且可以提高你的设计技能。设计和比较多种方法的过程将教你使设计更好或更坏的因素。随着时间的流逝，这将使你更容易排除不良的设计并磨练真正的出色设计。</p><h2 id="为什么写注释？四个理由（Why-Write-Comments-The-Four-Excuses）"><a href="#为什么写注释？四个理由（Why-Write-Comments-The-Four-Excuses）" class="headerlink" title="为什么写注释？四个理由（Why Write Comments? The Four Excuses）"></a>为什么写注释？四个理由（Why Write Comments? The Four Excuses）</h2><p>代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有注释，你就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。</p><p>不幸的是，这种观点并未得到普遍认同。生产代码（编译/构建前）的很大一部分基本上不包含任何注释。许多开发人员认为注释是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。</p><p><strong>好的注释可以对软件的整体质量产生很大的影响；写好注释并不难；并且（可能很难相信）写注释实际上很有趣。</strong></p><p>当开发人员不写注释时，他们通常会以以下一种或多种借口为自己的行为辩护：</p><ul><li>“好的代码可以自我记录。”</li><li>“我没有时间写注释。”</li><li>“注释过时，并会产生误导。”</li><li>“我所看到的注释都是毫无价值的；何必？” 在以下各节中，我将依次讨论这些借口。</li></ul><h3 id="Good-code-is-self-documenting-好的代码可以自我记录"><a href="#Good-code-is-self-documenting-好的代码可以自我记录" class="headerlink" title="Good code is self-documenting 好的代码可以自我记录"></a>Good code is self-documenting 好的代码可以自我记录</h3><p>有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对你的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。接口的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。</p><p>一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既<strong>费时又痛苦</strong>。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。</p><p>此外，<strong>注释是抽象的基础</strong>。抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以忽略的细节。<strong>如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。</strong>没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 <code>end</code> 指示的字符，或者如果 <code>start &gt; end</code> 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写注释也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。</p><h3 id="I-don’t-have-time-to-write-comments-我没有时间写注释"><a href="#I-don’t-have-time-to-write-comments-我没有时间写注释" class="headerlink" title="I don’t have time to write comments 我没有时间写注释"></a>I don’t have time to write comments 我没有时间写注释</h3><p>优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果你允许取消对文档的优先级，则最终将没有文档。</p><p>与该借口相反的是投资思路。<strong>如果你想要一个干净的软件结构，可以长期有效地工作，那么你必须花一些额外的时间才能创建该结构。</strong>好的注释对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写注释不需要花费很多时间。询问自己，假设你不包含任何注释，那么你花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设你花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的注释不会增加你的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。</p><p>此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。第 15 章认为，这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些注释立即付诸行动。</p><h3 id="Comments-get-out-of-date-and-become-misleading-注释过时并产生误导"><a href="#Comments-get-out-of-date-and-become-misleading-注释过时并产生误导" class="headerlink" title="Comments get out of date and become misleading 注释过时并产生误导"></a>Comments get out of date and become misleading 注释过时并产生误导</h3><p>注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。后面（第 16 章）讨论了如何组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。</p><h3 id="All-the-comments-I-have-seen-are-worthless-我所看到的所有注释都是毫无价值的"><a href="#All-the-comments-I-have-seen-are-worthless-我所看到的所有注释都是毫无价值的" class="headerlink" title="All the comments I have seen are worthless 我所看到的所有注释都是毫无价值的"></a>All the comments I have seen are worthless 我所看到的所有注释都是毫无价值的</h3><p>在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。</p><h3 id="Benefits-of-well-written-comments-编写良好的评论的好处"><a href="#Benefits-of-well-written-comments-编写良好的评论的好处" class="headerlink" title="Benefits of well-written comments 编写良好的评论的好处"></a>Benefits of well-written comments 编写良好的评论的好处</h3><p>既然我已经讨论了（并希望揭穿了这些）反对撰写注释的论点，让我们考虑一下从良好注释中将获得的好处。注释背后的总体思想是捕获设计者所想但不能在代码中表示的信息。这些信息从低级详细信息（例如，激发特殊代码的硬件怪癖）到高级概念（例如，类的基本原理）。当其他开发人员稍后进行修改时，这些注释将使他们能够更快，更准确地工作。没有文档，未来的开发人员将不得不重新编写或猜测开发人员的原始知识。这将花费额外的时间，并且如果新开发者误解了原始设计者的意图，则存在错误的风险。</p><p>回顾此前在软件系统中表现出复杂性的三种方式：</p><ul><li>变更放大：看似简单的变更需要在许多地方进行代码修改。</li><li>认知负荷：为了进行更改，开发人员必须积累大量信息。</li><li>未知未知数：尚不清楚需要修改哪些代码，或必须考虑哪些信息才能进行这些修改。</li></ul><p>好的文档可以帮助解决最后两个问题。通过为开发人员提供他们进行更改所需的信息，并使开发人员容易忽略不相关的信息，文档可以减轻认知负担。没有足够的文档，开发人员可能必须阅读大量代码才能重构设计人员的想法。文档还可以通过阐明系统的结构来减少未知的未知数，从而可以清楚地了解与任何给定更改相关的信息和代码。</p><p>并且此前（第二章）指出，导致复杂性的主要原因是依赖性和模糊性。好的文档可以阐明依赖关系，并且可以填补空白以消除模糊性。</p><h2 id="注释应该描述代码中不明显的内容（Comments-Should-Describe-Things-that-Aren’t-Obvious-from-the-Code）"><a href="#注释应该描述代码中不明显的内容（Comments-Should-Describe-Things-that-Aren’t-Obvious-from-the-Code）" class="headerlink" title="注释应该描述代码中不明显的内容（Comments Should Describe Things that Aren’t Obvious from the Code）"></a>注释应该描述代码中不明显的内容（Comments Should Describe Things that Aren’t Obvious from the Code）</h2><p>编写注释的原因是，使用编程语言编写的语句无法捕获编写代码时开发人员想到的所有重要信息。注释记录了这些信息，以便后来的开发人员可以轻松地理解和修改代码。<strong>注释的指导原则是，注释应描述代码中不明显的内容。</strong></p><p>从代码中看不到很多事情。有时，底层细节并不明显。例如，当一对索引描述一个范围时，由索引给出的元素是在范围之内还是之外并不明显。有时不清楚为什么需要代码，或者为什么要以特定方式实现代码。有时，开发人员遵循一些规则，例如“总是在 b 之前调用 a”。你可能可以通过查看所有代码来猜测规则，但这很痛苦且容易出错。注释可以使规则清晰明了。</p><p>注释的最重要原因之一是抽象，其中包括许多从代码中看不到的信息。抽象的思想是提供一种思考问题的简单方法，但是代码是如此详细，以至于仅通过阅读代码就很难看到抽象。注释可以提供一个更简单，更高级的视图（“调用此方法后，网络流量将被限制为每秒 maxBandwidth 字节”）。即使可以通过阅读代码推断出此信息，我们也不想强迫模块用户这样做：阅读代码很耗时，并且迫使他们考虑很多不需要使用的信息模块。开发人员应该能够理解模块提供的抽象，而无需阅读其外部可见声明以外的任何代码。</p><h3 id="Pick-conventions-选择约定"><a href="#Pick-conventions-选择约定" class="headerlink" title="Pick conventions 选择约定"></a>Pick conventions 选择约定</h3><p><strong>编写注释的第一步是确定注释的约定，例如你要注释的内容和注释的格式。</strong>如果你正在使用存在文档编译工具的语言进行编程，例如 Java 的 Javadoc，C ++的 Doxygen 或 Go！的 godoc，请遵循工具的约定。这些约定都不是完美的，但是这些工具可提供足够的好处来弥补这一缺点。如果在没有现有约定可遵循的环境中进行编程，请尝试从其他类似的语言或项目中采用这些约定；这将使其他开发人员更容易理解和遵守你的约定。</p><p>约定有两个目的。</p><ul><li>首先，它们确保一致性，这使得注释更易于阅读和理解。</li><li>其次，它们有助于确保你实际编写评论。如果你不清楚要发表的评论以及发表评论的方式，那么很容易最终根本不发表评论。</li></ul><p>大多数注释属于以下类别之一：</p><ul><li>接口：在模块声明（例如类，数据结构，函数或方法）之前的注释块。注释描述模块的接口。对于一个类，注释描述了该类提供的整体抽象。对于方法或函数，注释描述其整体行为，其参数和返回值（如果有），其生成的任何副作用或异常，以及调用者在调用该方法之前必须满足的任何其他要求。</li><li>数据结构成员：数据结构中字段声明旁边的注释，例如类的实例变量或静态变量。</li><li>实现注释：方法或函数代码内部的注释，它描述代码在内部的工作方式。</li><li>跨模块注释：描述跨模块边界的依赖项的注释。</li></ul><p>最重要的注释是前两个类别中的注释。<strong>每个类都应有一个接口注释，每个类变量应有一个注释，每个方法都应有一个接口注释。</strong>有时，变量或方法的声明是如此明显，以至于在注释中没有添加任何有用的东西（getter 和 setter 有时都属于此类），但这很少见。评论所有内容要比花精力担心是否需要评论要容易得多。实施注释通常是不必要的。跨模块注释是最罕见的，而且编写起来很成问题，但是当需要它们时，它们就很重要</p><h3 id="Don’t-repeat-the-code-不要重复代码"><a href="#Don’t-repeat-the-code-不要重复代码" class="headerlink" title="Don’t repeat the code 不要重复代码"></a>Don’t repeat the code 不要重复代码</h3><p>不幸的是，许多注释并不是特别有用。最常见的原因是注释重复了代码：可以轻松地从注释旁边的代码中推断出注释中的所有信息。</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a horizontal scroll bar</span></span><br><span class="line">hScrollBar = <span class="keyword">new</span> JScrollBar(JScrollBar.HORIZONTAL);</span><br><span class="line">add(hScrollBar, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a vertical scroll bar</span></span><br><span class="line">vScrollBar = <span class="keyword">new</span> JScrollBar(JScrollBar.VERTICAL);</span><br><span class="line">add(vScrollBar, BorderLayout.EAST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the caret-position related values</span></span><br><span class="line">caretX     = <span class="number">0</span>;</span><br><span class="line">caretY     = <span class="number">0</span>;</span><br><span class="line">caretMemX  = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>这些注释均未提供任何价值。对于前两个注释，代码已经很清楚了，它实际上不需要注释。在第三种情况下，注释可能有用，但是当前注释没有提供足够的细节来提供帮助。</p><p>编写注释后，请问自己以下问题：从未看过代码的人能否仅通过查看注释旁边的代码来编写注释？如果答案是肯定的（如上述示例所示），则注释不会使代码更易于理解。像这样的注释是为什么有些人认为毫无价值的原因。</p><p>另一个常见的错误是在注释中使用与要记录的实体名称相同的词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Obtain a normalized resource name from REQ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] getNormalizedResourceNames(</span><br><span class="line">            HTTPRequest req) ...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Downcast PARAMETER to TYPE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">downCastParameter</span><span class="params">(String parameter, String type)</span> ...</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * The horizontal padding of each line in the text.</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> textHorizontalPadding </span>= <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>这些注释只是从方法或变量名中提取单词，或者从参数名称和类型中添加几个单词，然后将它们组成一个句子。例如，第二个注释中唯一不在代码中的是单词“ to”！再说一次，这些注释可以仅通过查看声明来编写，而无需任何了解变量的方法。结果，它们没有价值。</p><p>如果注释旁边的代码中的注释信息已经很明显，则注释无济于事。这样的一个例子是，当注释使用与所描述事物名称相同的单词时。</p><p>同时，注释中缺少一些重要信息：例如，什么是“标准化资源名称”，以及 getNormalizedResourceNames 返回的数组的元素是什么？“贬低”是什么意思？填充的单位是什么，填充是在每行的一侧还是在两者的两侧？在注释中描述这些内容将很有帮助。</p><p><strong>编写良好注释的第一步是在注释中使用与所描述实体名称不同的词</strong>。为注释选择单词，以提供有关实体含义的更多信息，而不仅仅是重复其名称。例如，以下是针对 textHorizo​​ntalPadding 的更好注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The amount of blank space to leave on the left and</span></span><br><span class="line"><span class="comment"> * right sides of each line of text, in pixels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> textHorizontalPadding = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>该注释提供了从声明本身不明显的其他信息，例如单位（像素）以及填充适用于每行两边的事实。如果读者不熟悉该术语，则注释将解释什么是填充，而不是使用术语“填充”。</p><h3 id="Lower-level-comments-add-precision-低级注释可提高精度"><a href="#Lower-level-comments-add-precision-低级注释可提高精度" class="headerlink" title="Lower-level comments add precision 低级注释可提高精度"></a>Lower-level comments add precision 低级注释可提高精度</h3><p>现在你知道了不应该做的事情，让我们讨论应该在注释中添加哪些信息。注释通过提供不同详细程度的信息来增强代码。一些注释提供了比代码更低，更详细的信息。这些注释通过阐明代码的确切含 ​​ 义来增加精度。其他注释提供了比代码更高，更抽象的信息。这些注释提供了直觉，例如代码背后的推理，或者更简单，更抽象的代码思考方式。与代码处于同一级别的注释可能会重复该代码。本节将更详细地讨论下层方法，而下一节将讨论上层方法。</p><p>在注释变量声明（例如类实例变量，方法参数和返回值）时，精度最有用。变量声明中的名称和类型通常不是很精确。注释可以填写缺少的详细信息，例如：</p><ul><li>此变量的单位是什么？</li><li>边界条件是包容性还是排他性？</li><li>如果允许使用空值，则意味着什么？</li><li>如果变量引用了最终必须释放或关闭的资源，那么谁负责释放或关闭该资源？</li><li>是否存在某些对于变量始终不变的属性（不变量），例如“此列表始终包含至少一个条目”？</li></ul><p>通过检查使用该变量的所有代码，可以潜在地了解某些信息。但是，这很耗时且容易出错。声明的注释应清晰，完整，以免不必要。当我说声明的注释应描述代码中不明显的内容时，“代码”是指注释（声明）旁边的代码，而不是“应用程序中的所有代码”。</p><p>变量注释最常见的问题是注释太模糊。这是两个不够精确的注释示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current offset in resp Buffer</span></span><br><span class="line">uint32_t offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains all line-widths inside the document and</span></span><br><span class="line"><span class="comment">// number of appearances.</span></span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Integer, Integer&gt; lineWidths;</span><br></pre></td></tr></table></figure></p><p>在第一个示例中，尚不清楚“当前”的含义。在第二个示例中，尚不清楚 TreeMap 中的键是线宽，值是出现次数。另外，宽度是以像素或字符为单位测量的吗？以下修订后的注释提供了更多详细信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Position in this buffer of the first object that hasn't</span></span><br><span class="line"><span class="comment">//  been returned to the client.</span></span><br><span class="line">uint32_t offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Holds statistics about line lengths of the form &lt;length, count&gt;</span></span><br><span class="line"><span class="comment">//  where length is the number of characters in a line (including</span></span><br><span class="line"><span class="comment">//  the newline), and count is the number of lines with</span></span><br><span class="line"><span class="comment">//  exactly that many characters. If there are no lines with</span></span><br><span class="line"><span class="comment">//  a particular length, then there is no entry for that length.</span></span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Integer, Integer&gt; numLinesWithLength;</span><br></pre></td></tr></table></figure><p>第二个声明使用一个较长的名称来传达更多信息。它还将“宽度”更改为“长度”，因为该术语更可能使人们认为单位是字符而不是像素。请注意，第二条注释不仅记录了每个条目的详细信息，还记录了缺少条目的含义。</p><p>在记录变量时，请考虑名词而不是动词。换句话说，关注变量代表什么，而不是如何操纵变量。考虑以下注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and the</span></span><br><span class="line"><span class="comment"> * PeriodicTasks thread to communicate about whether a heartbeat has been</span></span><br><span class="line"><span class="comment"> * received within the follower's election timeout window.</span></span><br><span class="line"><span class="comment"> * Toggled to TRUE when a valid heartbeat is received.</span></span><br><span class="line"><span class="comment"> * Toggled to FALSE when the election timeout window is reset.  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure></p><p>本文档描述了如何通过类中的几段代码来修改变量。如果注释描述变量代表什么而不是镜像代码结构，则注释将更短且更有用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* True means that a heartbeat has been received since the last time</span></span><br><span class="line"><span class="comment"> * the election timer was reset. Used for communication between the</span></span><br><span class="line"><span class="comment"> * Receiver and PeriodicTasks threads.  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure></p><p>根据本文档，很容易推断出，当接收到心跳信号时，变量必须设置为 true；而当重置选举计时器时，则必须将变量设置为 false。</p><h3 id="Higher-level-comments-enhance-intuition-高级注释可增强直觉"><a href="#Higher-level-comments-enhance-intuition-高级注释可增强直觉" class="headerlink" title="Higher-level comments enhance intuition 高级注释可增强直觉"></a>Higher-level comments enhance intuition 高级注释可增强直觉</h3><p>注释可以增加代码的第二种方法是提供直觉。这些注释是在比代码更高的级别上编写的。它们忽略了细节，并帮助读者理解了代码的整体意图和结构。此方法通常用于方法内部的注释以及接口注释。例如，考虑以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If there is a LOADING readRpc using the same session</span></span><br><span class="line"><span class="comment">// as PKHash pointed to by assignPos, and the last PKHash</span></span><br><span class="line"><span class="comment">// in that readRPC is smaller than current assigning</span></span><br><span class="line"><span class="comment">// PKHash, then we put assigning PKHash into that readRPC.</span></span><br><span class="line"><span class="keyword">int</span> readActiveRpcId = RPC_ID_NOT_ASSIGNED;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_READ_RPC; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (session == readRpc[i].session</span><br><span class="line">            &amp;&amp; readRpc[i].status == LOADING</span><br><span class="line">            &amp;&amp; readRpc[i].maxPos &lt; assignPos</span><br><span class="line">            &amp;&amp; readRpc[i].numHashes &lt; MAX_PKHASHES_PERRPC) &#123;</span><br><span class="line">        readActiveRpcId = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注释太底层和太详细。一方面，它部分重复了代码：“如果有 LOADING readRPC”仅重复测试 <code>readRpc[i].status == LOADING</code>。另一方面，注释不能解释此代码的总体目的，也不能解释其如何适合包含此代码的方法。如此一来注释不能帮助读者理解代码。</p><p>这是一个更好的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to append the current key hash onto an existing</span></span><br><span class="line"><span class="comment">// RPC to the desired server that hasn't been sent yet.</span></span><br></pre></td></tr></table></figure><p>此注释不包含任何详细信息。相反，它在更高级别上描述了代码的整体功能。有了这些高级信息，读者就可以解释代码中几乎发生的所有事情：循环必须遍历所有现有的远程过程调用（RPC）；会话测试可能用于查看特定的 RPC 是否发往正确的服务器；LOADING 测试表明 RPC 可以具有多个状态，在某些状态下添加更多的哈希值是不安全的；MAX-PKHASHES_PERRPC 测试表明在单个 RPC 中可以发送多少个哈希值是有限制的。注释中唯一没有解释的是 maxPos 测试。此外，新注释为读者判断代码提供了基础：它可以完成将密钥哈希添加到现有 RPC 所需的一切吗？原始注释并未描述代码的整体意图，因此，读者很难确定代码是否行为正确。</p><p>高级别的注释比低级别的注释更难编写，因为你必须以不同的方式考虑代码。问问自己：这段代码要做什么？你能以何种最简单方式来解释代码中的所有内容？这段代码最重要的是什么？</p><p>工程师往往非常注重细节。我们喜欢细节，善于管理其中的许多细节；这对于成为一名优秀的工程师至关重要。但是，<strong>优秀的软件设计师也可以从细节退后一步，从更高层次考虑系统。这意味着要确定系统的哪些方面最重要，并且能够忽略底层细节，仅根据系统的最基本特征来考虑系统。</strong>这是抽象的本质（找到一种思考复杂实体的简单方法），这也是编写高级注释时必须执行的操作。一个好的高层注释表达了一个或几个简单的想法，这些想法提供了一个概念框架，例如“附加到现有的 RPC”。使用该框架，可以很容易地看到特定的代码语句与总体目标之间的关系。</p><p>这是另一个代码示例，具有较高层次的注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (numProcessedPKHashes &lt; readRpc[i].numHashes) &#123;</span><br><span class="line">    <span class="comment">// Some of the key hashes couldn't be looked up in</span></span><br><span class="line">    <span class="comment">// this request (either because they aren't stored</span></span><br><span class="line">    <span class="comment">// on the server, the server crashed, or there</span></span><br><span class="line">    <span class="comment">// wasn't enough space in the response message).</span></span><br><span class="line">    <span class="comment">// Mark the unprocessed hashes so they will get</span></span><br><span class="line">    <span class="comment">// reassigned to new RPCs.</span></span><br><span class="line">    <span class="keyword">for</span> (size_t p = removePos; p &lt; insertPos; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeRpcId[p] == i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numProcessedPKHashes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                numProcessedPKHashes--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p &lt; assignPos)</span><br><span class="line">                    assignPos = p;</span><br><span class="line">                activeRpcId[p] = RPC_ID_NOT_ASSIGNED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此注释有两件事。第二句话提供了代码功能的抽象描述。第一句话是不同的：它以高级的方式解释了为什么执行代码。“如何到达这里”形式的注释对于帮助人们理解代码非常有用。例如，在记录方法时，描述最有可能在什么情况下调用该方法的条件（特别是仅在异常情况下调用该方法的情况）会非常有帮助。</p><h3 id="Interface-documentation-接口文档"><a href="#Interface-documentation-接口文档" class="headerlink" title="Interface documentation 接口文档"></a>Interface documentation 接口文档</h3><p>注释最重要的作用之一就是定义抽象。抽象是实体的简化视图，它保留了基本信息，但省略了可以安全忽略的细节。代码不适合描述抽象；它的级别太低，它包含实现细节，这些细节在抽象中不应该看到。描述抽象的唯一方法是使用注释。如果你想要呈现良好抽象的代码，则必须用注释记录这些抽象。</p><p><strong>记录抽象的第一步是将接口注释与实现注释分开。</strong>接口注释提供了使用类或方法时需要知道的信息。他们定义了抽象。实现注释描述了类或方法如何在内部工作以实现抽象。区分这两种注释很重要，这样接口的用户就不会暴露于实现细节。此外，这两种形式最好有所不同。如果接口注释也必须描述实现，则该类或方法很浅。这意味着撰写注释的行为可以提供有关设计质量的线索。</p><p>类的接口注释提供了该类提供的抽象的高级描述，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class implements a simple server-side interface to the HTTP</span></span><br><span class="line"><span class="comment"> * protocol: by using this class, an application can receive HTTP</span></span><br><span class="line"><span class="comment"> * requests, process them, and return responses. Each instance of</span></span><br><span class="line"><span class="comment"> * this class corresponds to a particular socket used to receive</span></span><br><span class="line"><span class="comment"> * requests. The current implementation is single-threaded and</span></span><br><span class="line"><span class="comment"> * processes one request at a time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>该注释描述了类的整体功能，没有任何实现细节，甚至没有特定方法的细节。它还描述了该类的每个实例代表什么。最后，注释描述了该类的限制（它不支持从多个线程的并发访问），这对于考虑是否使用它的开发人员可能很重要。</p><p>方法的接口注释既包括用于抽象的高层信息，又包括用于精度的低层细节：</p><ul><li>注释通常以一两个句子开头，描述调用者感知到的方法的行为。这是更高层次的抽象。</li><li>注释必须描述每个参数和返回值（如果有）。这些注释必须非常精确，并且必须描述对参数值的任何约束以及参数之间的依赖关系。</li><li>如果该方法有任何副作用，则必须在接口注释中记录这些副作用。副作用是该方法的任何结果都会影响系统的未来行为，但不属于结果的一部分。例如，如果该方法将一个值添加到内部数据结构中，可以通过将来的方法调用来检索该值，则这是副作用。写入文件系统也是一个副作用。</li><li>方法的接口注释必须描述该方法可能产生的任何异常。</li><li>如果在调用某个方法之前必须满足任何前提条件，则必须对其进行描述（也许必须先调用其他方法；对于二进制搜索方法，必须对要搜索的列表进行排序）。尽量减少前提条件是一个好主意，但是任何保留的条件都必须记录在案。</li></ul><p>这是从 Buffer 对象复制数据的方法的接口注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy a range of bytes from a buffer to an external location.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param offset</span></span><br><span class="line"><span class="comment"> *        Index within the buffer of the first byte to copy.</span></span><br><span class="line"><span class="comment"> * \param length</span></span><br><span class="line"><span class="comment"> *        Number of bytes to copy.</span></span><br><span class="line"><span class="comment"> * \param dest</span></span><br><span class="line"><span class="comment"> *        Where to copy the bytes: must have room for at least</span></span><br><span class="line"><span class="comment"> *        length bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return</span></span><br><span class="line"><span class="comment"> *        The return value is the actual number of bytes copied,</span></span><br><span class="line"><span class="comment"> *        which may be less than length if the requested range of</span></span><br><span class="line"><span class="comment"> *        bytes extends past the end of the buffer. 0 is returned</span></span><br><span class="line"><span class="comment"> *        if there is no overlap between the requested range and</span></span><br><span class="line"><span class="comment"> *        the actual buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">uint32_t</span><br><span class="line">Buffer::copy(uint32_t offset, uint32_t length, <span class="keyword">void</span>* dest)</span><br></pre></td></tr></table></figure></p><p>此注释的语法（例如\ return）遵循 Doxygen 的约定，该程序从 C / C ++代码中提取注释并将其编译为 Web。注释的目的是提供开发人员调用该方法所需的所有信息，包括特殊情况的处理方式（请注意，此方法如何遵循第 10 章的建议并定义与范围规范相关的任何错误。 ）。开发人员不必为了调用它而阅读方法的主体，并且接口注释不提供有关如何实现该方法的信息，例如它如何扫描其内部数据结构以查找所需的数据。</p><p>对于更扩展的示例，让我们考虑一个称为 IndexLookup 的类，该类是分布式存储系统的一部分。存储系统拥有一个表集合，每个表包含许多对象。另外，每个表可以具有一个或多个索引；每个索引都基于对象的特定字段提供对表中对象的有效访问。例如，一个索引可以用于根据对象的名称字段查找对象，而另一个索引可以用于根据对象的年龄字段查找对象。使用这些索引，应用程序可以快速提取具有特定名称的所有对象，或具有给定范围内的年龄的所有对象。</p><p>IndexLookup 类为执行索引查找提供了一个方便的接口。这是一个如何在应用程序中使用的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="keyword">new</span> IndexLookup(table, index, key1, key2);</span><br><span class="line"><span class="keyword">while</span>  (<span class="keyword">true</span>) &#123;</span><br><span class="line">    object = query.getNext();</span><br><span class="line">    <span class="keyword">if</span>  (object == NULL) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... process object ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>应用程序首先构造一个类型为 IndexLookup 的对象，并提供用于选择表，索引和索引内范围的参数（例如，如果索引基于年龄字段，则 key1 和 key2 可以指定为 21 和 65 选择年龄介于这些值之间的所有对象）。然后，应用程序重复调用 getNext 方法。每次调用都返回一个位于所需范围内的对象。一旦返回所有匹配的对象，getNext 将返回 NULL。因为存储系统是分布式的，所以此类的实现有些复杂。表中的对象可以分布在多个服务器上，每个索引也可以分布在一组不同的服务器上。</p><p>现在，让我们考虑该类的接口注释中需要包含哪些信息。对于下面给出的每条信息，问自己一个开发人员是否需要知道该信息才能使用该类。</p><ul><li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。</li><li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。</li><li>用于在服务器上存储索引的数据结构。</li><li>IndexLookup 是否同时向多个服务器发出多个请求。</li><li>处理服务器崩溃的机制。</li></ul><p>这是 IndexLookup 类的接口注释的原始版本；摘录还包括类定义的几行内容，在注释中进行了引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This class implements the client side framework for index range</span></span><br><span class="line"><span class="comment"> * lookups. It manages a single LookupIndexKeys RPC and multiple</span></span><br><span class="line"><span class="comment"> * IndexedRead RPCs. Client side just includes "IndexLookup.h" in</span></span><br><span class="line"><span class="comment"> * its header to use IndexLookup class. Several parameters can be set</span></span><br><span class="line"><span class="comment"> * in the config below:</span></span><br><span class="line"><span class="comment"> * - The number of concurrent indexedRead RPCs</span></span><br><span class="line"><span class="comment"> * - The max number of PKHashes a indexedRead RPC can hold at a time</span></span><br><span class="line"><span class="comment"> * - The size of the active PKHashes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To use IndexLookup, the client creates an object of this class by</span></span><br><span class="line"><span class="comment"> * providing all necessary information. After construction of</span></span><br><span class="line"><span class="comment"> * IndexLookup, client can call getNext() function to move to next</span></span><br><span class="line"><span class="comment"> * available object. If getNext() returns NULL, it means we reached</span></span><br><span class="line"><span class="comment"> * the last object. Client can use getKey, getKeyLength, getValue,</span></span><br><span class="line"><span class="comment"> * and getValueLength to get object data of current object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">IndexLookup</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">/// Max number of concurrent indexedRead RPCs</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">const</span> uint8_t NUM_READ_RPC = <span class="number">10</span>;</span><br><span class="line">       <span class="comment">/// Max number of PKHashes that can be sent in one</span></span><br><span class="line">       <span class="comment">/// indexedRead RPC</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">const</span> uint32_t MAX_PKHASHES_PERRPC = <span class="number">256</span>;</span><br><span class="line">       <span class="comment">/// Max number of PKHashes that activeHashes can</span></span><br><span class="line">       <span class="comment">/// hold at once.</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">const</span> size_t MAX_NUM_PK = (<span class="number">1</span> &lt;&lt; LG_BUFFER_SIZE);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>在进一步阅读之前，请先查看你是否可以使用此注释确定问题所在。这是我发现的问题：</p><ul><li>第一段的大部分与实现有关，而不是接口。举一个例子，用户不需要知道用于与服务器通信的特定远程过程调用的名称。在第一段的后半部分中提到的配置参数都是所有私有变量，它们仅与类的维护者相关，而与类的用户无关。所有这些实现信息都应从注释中省略。</li><li>该评论还包括一些显而易见的事情。例如，不需要告诉用户包括 IndexLookup.h：任何编写 C ++代码的人都可以猜测这是必要的。另外，“通过提供所有必要的信息”一词毫无意义，因此可以省略。</li></ul><p>对此类的简短注释就足够了（并且更可取）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This class is used by client applications to make range queries</span></span><br><span class="line"><span class="comment"> * using indexes. Each instance represents a single range query.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To start a range query, a client creates an instance of this</span></span><br><span class="line"><span class="comment"> * class. The client can then call getNext() to retrieve the objects</span></span><br><span class="line"><span class="comment"> * in the desired range. For each object returned by getNext(), the</span></span><br><span class="line"><span class="comment"> * caller can invoke getKey(), getKeyLength(), getValue(), and</span></span><br><span class="line"><span class="comment"> * getValueLength() to get information about that object.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>此注释的最后一段不是严格必需的，因为它主要针对单个方法复制了注释中的信息。但是，在类文档中提供示例来说明其方法如何协同工作可能会有所帮助，特别是对于使用模式不明显的深层类尤其如此。注意，新注释未提及 getNext 的 NULL 返回值。此注释无意记录每种方法的每个细节；它只是提供高级信息，以帮助读者了解这些方法如何协同工作以及何时可以调用每种方法。有关详细信息，读者可以参考接口注释中的各个方法。此注释也没有提到服务器崩溃；这是因为此类服务器的用户看不到服务器崩溃（系统会自动从中恢复）。</p><p>当接口文档（例如方法的文档）描述了不需要使用要记录的事物的实现详细信息时，就会出现此红色标记。</p><p>现在考虑以下代码，该代码显示 IndexLookup 中 isReady 方法的文档的第一版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if the next object is RESULT_READY. This function is</span></span><br><span class="line"><span class="comment"> * implemented in a DCFT module, each execution of isReady() tries</span></span><br><span class="line"><span class="comment"> * to make small progress, and getNext() invokes isReady() in a</span></span><br><span class="line"><span class="comment"> * while loop, until isReady() returns true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * isReady() is implemented in a rule-based approach. We check</span></span><br><span class="line"><span class="comment"> * different rules by following a particular order, and perform</span></span><br><span class="line"><span class="comment"> * certain actions if some rule is satisfied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return</span></span><br><span class="line"><span class="comment"> *         True means the next Object is available. Otherwise, return</span></span><br><span class="line"><span class="comment"> *         false.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bool IndexLookup::isReady() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>再一次，本文档中的大多数内容，例如对 DCFT 的引用以及整个第二段，都与实现有关，因此不属于此处。这是接口注释中最常见的错误之一。某些实现文档很有用，但应放在方法内部，在该方法中应将其与接口文档明确分开。此外，文档的第一句话是含糊的（RESULT_READY 是什么意思？），并且缺少一些重要信息。最后，无需在此处描述 getNext 的实现。这是注释的更好版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Indicates whether an indexed read has made enough progress for</span></span><br><span class="line"><span class="comment"> * getNext to return immediately without blocking. In addition, this</span></span><br><span class="line"><span class="comment"> * method does most of the real work for indexed reads, so it must</span></span><br><span class="line"><span class="comment"> * be invoked (either directly, or indirectly by calling getNext) in</span></span><br><span class="line"><span class="comment"> * order for the indexed read to make progress.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return</span></span><br><span class="line"><span class="comment"> *         True means that the next invocation of getNext will not block</span></span><br><span class="line"><span class="comment"> *         (at least one object is available to return, or the end of the</span></span><br><span class="line"><span class="comment"> *         lookup has been reached); false means getNext may block.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>此注释版本提供了有关“就绪”含义的更精确信息，并且提供了重要信息，如果要继续进行索引检索，则必须最终调用此方法。</p><h3 id="Implementation-comments-what-and-why-not-how-实现注释：什么以及为什么，而不是如何"><a href="#Implementation-comments-what-and-why-not-how-实现注释：什么以及为什么，而不是如何" class="headerlink" title="Implementation comments: what and why, not how 实现注释：什么以及为什么，而不是如何"></a>Implementation comments: what and why, not how 实现注释：什么以及为什么，而不是如何</h3><p>实现注释是出现在方法内部的注释，以帮助读者了解它们在内部的工作方式。大多数方法是如此简短，简单，以至于它们不需要任何实现注释：有了代码和接口注释，就很容易弄清楚方法的工作原理。</p><p>实现注释的主要目的是帮助读者理解代码在做什么（而不是代码如何工作）。一旦读者知道了代码要做什么，通常就很容易理解代码的工作原理。对于简短的方法，代码只做一件事，该问题已在其接口注释中进行了描述，因此不需要实现注释。较长的方法具有多个代码块，这些代码块作为方法的整体任务的一部分执行不同的操作。在每个主要块之前添加注释，以提供对该块的作用的高级（更抽象）描述。这是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Phase 1: Scan active RPCs to see if any have completed.</span></span><br></pre></td></tr></table></figure><p>对于循环，在循环前加一个注释来描述每次迭代中发生的事情是有帮助的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each iteration of the following loop extracts one request from</span></span><br><span class="line"><span class="comment">// the request message, increments the corresponding object, and</span></span><br><span class="line"><span class="comment">// appends a response to the response message.</span></span><br></pre></td></tr></table></figure><p>请注意，此注释如何更抽象和直观地描述循环。它没有详细介绍如何从请求消息中提取请求或对象如何递增。仅对于更长或更复杂的循环才需要循环注释，在这种情况下，循环的作用可能并不明显。许多循环足够短且简单，以至于其行为已经很明显。</p><p>除了描述代码在做什么之外，实现注释还有助于解释原因。如果代码中有些棘手的方面从阅读中看不出来，则应将它们记录下来。例如，如果一个错误修复程序需要添加目的不是很明显的代码，请添加注释以说明为什么需要该代码。对于错误修复，其中有写得很好的错误报告来描述问题，该注释可以引用错误跟踪数据库中的问题，而不是重复其所有详细信息（“修复 RAM-436，与 Linux 2.4 中的设备驱动程序崩溃有关。” X”）。开发人员可以在 bug 数据库中查找更多详细信息（这是一个避免注释重复的示例，这将在第 16 章中进行讨论）。</p><p>对于更长的方法，为一些最重要的局部变量写注释会很有帮助。但是，如果大多数局部变量具有好名字，则不需要文档。如果变量的所有用法在几行之内都是可见的，则通常无需注释即可轻松理解变量的用途。在这种情况下，可以让读者阅读代码来弄清楚变量的含义。但是，如果在大量代码中使用了该变量，则应考虑添加注释以描述该变量。在记录变量时，应关注变量表示的内容，而不是代码中如何对其进行操作。</p><h3 id="Cross-module-design-decisions-跨模块设计决策"><a href="#Cross-module-design-decisions-跨模块设计决策" class="headerlink" title="Cross-module design decisions 跨模块设计决策"></a>Cross-module design decisions 跨模块设计决策</h3><p>在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p><p><strong>跨模块文档的最大挑战是找到一个放置它的位置，以便开发人员自然地发现它。</strong>有时，放置此类文档的中心位置很明显。例如，RAMCloud 存储系统定义一个状态值，每个请求均返回该状态值以指示成功或失败。为新的错误状况添加状态需要修改许多不同的文件（一个文件将状态值映射到异常，另一个文件为每个状态提供人类可读的消息，依此类推）。幸运的是，添加新的状态值（即 Status 枚举的声明）时，开发人员必须去一个明显的地方。<strong>我们通过在该枚举中添加注释来标识所有其他必须修改的地方，从而利用了这一点：在理想环境中，每个重要的设计决策都将封装在一个类中。</strong>不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">enum</span> Status &#123;</span><br><span class="line">    STATUS_OK = <span class="number">0</span>,</span><br><span class="line">    STATUS_UNKNOWN_TABLET                = <span class="number">1</span>,</span><br><span class="line">    STATUS_WRONG_VERSION                 = <span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">    STATUS_INDEX_DOESNT_EXIST            = <span class="number">29</span>,</span><br><span class="line">    STATUS_INVALID_PARAMETER             = <span class="number">30</span>,</span><br><span class="line">    STATUS_MAX_VALUE                     = <span class="number">30</span>,</span><br><span class="line">    <span class="comment">// Note: if you add a new status value you must make the following</span></span><br><span class="line">    <span class="comment">// additional updates:</span></span><br><span class="line">    <span class="comment">// (1)  Modify STATUS_MAX_VALUE to have a value equal to the</span></span><br><span class="line">    <span class="comment">//      largest defined status value, and make sure its definition</span></span><br><span class="line">    <span class="comment">//      is the last one in the list. STATUS_MAX_VALUE is used</span></span><br><span class="line">    <span class="comment">//      primarily for testing.</span></span><br><span class="line">    <span class="comment">// (2)  Add new entries in the tables "messages" and "symbols" in</span></span><br><span class="line">    <span class="comment">//      Status.cc.</span></span><br><span class="line">    <span class="comment">// (3)  Add a new exception class to ClientException.h</span></span><br><span class="line">    <span class="comment">// (4)  Add a new "case" to ClientException::throwException to map</span></span><br><span class="line">    <span class="comment">//      from the status value to a status-specific ClientException</span></span><br><span class="line">    <span class="comment">//      subclass.</span></span><br><span class="line">    <span class="comment">// (5)  In the Java bindings, add a static class for the exception</span></span><br><span class="line">    <span class="comment">//      to ClientException.java</span></span><br><span class="line">    <span class="comment">// (6)  Add a case for the status of the exception to throw the</span></span><br><span class="line">    <span class="comment">//      exception in ClientException.java</span></span><br><span class="line">    <span class="comment">// (7)  Add the exception to the Status enum in Status.java, making</span></span><br><span class="line">    <span class="comment">//      sure the status is in the correct position corresponding to</span></span><br><span class="line">    <span class="comment">//      its status code.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新状态值将添加到现有列表的末尾，因此注释也将放置在最有可能出现的末尾。</p><p>不幸的是，在许多情况下，并没有一个明显的中心位置来放置跨模块文档。RAMCloud 存储系统中的一个例子是处理僵尸服务器的代码，僵尸服务器是系统认为已经崩溃但实际上仍在运行的服务器。中和 zombie server 需要几个不同模块中的代码，这些代码都相互依赖。没有一段代码明显是放置文档的中心位置。一种可能性是在每个依赖文档的位置复制文档的部分。然而，这是令人尴尬的，并且随着系统的发展，很难使这样的文档保持最新。或者，文档可以位于需要它的位置之一，但是在这种情况下，开发人员不太可能看到文档或者知道在哪里查找它。</p><p>我最近一直在尝试一种方法，该方法将跨模块问题记录在一个名为 designNotes 的中央文件中。该文件分为清楚标记的部分，每个主要主题一个。例如，以下是该文件的摘录：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Zombies</span><br><span class="line">-------</span><br><span class="line">A zombie is a server that is considered dead by the rest of the</span><br><span class="line">cluster; any data stored on the server has been recovered and will</span><br><span class="line">be managed by other servers. However, if a zombie is not actually</span><br><span class="line">dead (e.g., it was just disconnected from the other servers for a</span><br><span class="line">while) two forms of inconsistency can arise:</span><br><span class="line"><span class="bullet">* </span>A zombie server must not serve read requests once replacement servers have taken over; otherwise it may return stale data that does not reflect writes accepted by the replacement servers.</span><br><span class="line"><span class="bullet">* </span>The zombie server must not accept write requests once replacement servers have begun replaying its log during recovery; if it does, these writes may be lost (the new values may not be stored on the replacement servers and thus will not be returned by reads).</span><br><span class="line"></span><br><span class="line">RAMCloud uses two techniques to neutralize zombies. First,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后，在与这些问题之一相关的任何代码段中，都有一条简短的注释引用了 designNotes 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See "Zombies" in designNotes.</span></span><br></pre></td></tr></table></figure><p>使用这种方法，文档只有一个副本，因此开发人员在需要时可以相对容易地找到它。但是，这样做的缺点是，文档离它依赖的任何代码段都不近，因此随着系统的发展，可能难以保持最新。</p><p>注释的目的是确保系统的结构和行为对读者来说是显而易见的，因此他们可以快速找到所需的信息，并有信心对其进行修改，以对系统进行修改。这些信息中的某些信息可以以对读者来说显而易见的方式表示在代码中，但是有大量信息无法从代码中轻易推导出。注释将填写此信息。</p><p>当遵循注释应描述代码中不明显的内容的规则时，“明显”是从第一次读取你的代码的人（不是你）的角度出发。在撰写注释时，请尝试使自己进入读者的心态，并问自己他或她需要知道哪些关键事项。如果你的代码正在接受审核，并且审核者告诉你某些不明显的内容，请不要与他们争论。如果读者认为它不明显，那么它就不明显。不用争论，而是尝试了解他们发现的令人困惑的地方，并查看是否可以通过更好的注释或更好的代码来澄清它们。</p><p>*开发人员是否需要了解以下每条信息才能使用 IndexLookup 类？</p><ul><li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。否：这是应隐藏在类中的实现细节。</li><li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。是：该课程的用户需要了解此信息。</li><li>用于在服务器上存储索引的数据结构。否：此信息应封装在服务器上；甚至 IndexLookup 的实现都不需要知道这一点。</li><li>IndexLookup 是否同时向多个服务器发出多个请求。可能：如果 IndexLookup 使用特殊技术来提高性能，则文档应提供有关此问题的一些高级信息，因为用户可能会在意性能。</li><li>处理服务器崩溃的机制。否：RAMCloud 可从服务器崩溃中自动恢复，因此崩溃对于应用程序级软件不可见；因此，在 IndexLookup 的接口文档中无需提及崩溃。如果崩溃反映到应用程序中，则接口文档将需要描述它们如何表现出来（而不是崩溃恢复如何工作的详细信息）。</li></ul><h2 id="选择的名字（Choosing-Names）"><a href="#选择的名字（Choosing-Names）" class="headerlink" title="选择的名字（Choosing Names）"></a>选择的名字（Choosing Names）</h2><p>为变量，方法和其他实体选择名称是软件设计中被低估的方面之一。良好的名字是一种文档形式：它们使代码更易于理解。它们减少了对其他文档的需求，并使检测错误更加容易。相反，名称选择不当会增加代码的复杂性，并造成可能导致错误的歧义和误解。名称选择是复杂度是递增的原理的一个示例。为特定变量选择一个平庸的名称，而不是最好的名称，这可能不会对系统的整体复杂性产生太大影响。但是，软件系统具有数千个变量。为所有这些选择好名字将对复杂性和可管理性产生重大影响。</p><h3 id="名称错误会导致错误"><a href="#名称错误会导致错误" class="headerlink" title="名称错误会导致错误"></a>名称错误会导致错误</h3><p>有时，即使是一个名称不正确的变量也会产生严重的后果。</p><p>如果对不同种类的块（例如 fileBlock 和 diskBlock）使用了不同的变量名，则错误不太可能发生；程序员会知道在那种情况下不能使用 fileBlock。不幸的是，大多数开发人员没有花太多时间在思考名字。他们倾向于使用想到的名字，只要它与匹配的名字相当接近即可。例如，块与磁盘上的物理块(physical block)和文件内的逻辑块( logical block)非常接近；这肯定不是一个可怕的名字。即使这样，它仍然要花费大量时间来查找一个细微的错误。因此，你不应该只选择“合理接近”的名称。花一些额外的时间来选择准确，明确且直观的好名字。额外的注意力将很快收回成本，随着时间的流逝，你将学会快速选择好名字。</p><h3 id="Create-an-image-创建图像"><a href="#Create-an-image-创建图像" class="headerlink" title="Create an image 创建图像"></a>Create an image 创建图像</h3><p><strong>选择名称时，目标是在读者的脑海中创建一幅关于被命名事物的性质的图像。</strong>一个好名字传达了很多有关底层实体是什么，以及同样重要的是，不是什么的信息。在考虑特定名称时，请问自己：“如果有人孤立地看到该名称，而没有看到其声明，文档或使用该名称的任何代码，他们将能够猜到该名称指的是什么？还有其他名称可以使画面更清晰吗？” 当然，一个名字可以输入多少信息是有限制的。如果名称包含两个或三个以上的单词，则会变得笨拙。因此，面临的挑战是仅找到捕获实体最重要方面的几个单词。</p><p>名称是一种抽象形式：名称提供了一种简化的方式来考虑更复杂的基础实体。像其他形式的抽象一样，最好的名字是那些将注意力集中在对底层实体最重要的东西上，而忽略那些次要的细节。</p><h3 id="Names-should-be-precise-名称应准确"><a href="#Names-should-be-precise-名称应准确" class="headerlink" title="Names should be precise 名称应准确"></a>Names should be precise 名称应准确</h3><p>良好名称具有两个属性：精度和一致性。让我们从精度开始。名称最常见的问题是名称太笼统或含糊不清。结果，读者很难说出这个名字指的是什么。读者可能会认为该名称所指的是与现实不符的事物，如上面的代码错误所示。考虑以下方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the total number of indexlets this object is managing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> IndexletManager::getCount() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>术语“计数”太笼统了：计数什么？如果有人看到此方法的调用，除非他们阅读了它的文档，否则他们不太可能知道它的作用。像 getActiveIndexlets 或 numIndexlets 这样的更精确的名称会更好：使用这些名称之一，读者可能无需查看其文档就能猜测该方法返回的内容。</p><p>以下是来自其他项目的一些名称不够精确的示例：</p><ul><li>建立 GUI 文本编辑器的项目使用名称 x 和 y 来引用字符在文件中的位置。这些名称太笼统了。他们可能意味着很多事情；例如，它们也可能代表屏幕上字符的坐标（以像素为单位）。单独看到名称 x 的人不太可能会认为它是指字符在一行文本中的位置。如果使用诸如 charIndex 和 lineIndex 之类的名称来反映代码实现的特定抽象，该代码将更加清晰。</li><li><p>另一个编辑器项目包含以下代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blink state: true when cursor visible.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> blinkStatus = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>  名称 blinkStatus 无法传达足够的信息。“状态”一词对于布尔值来说太含糊了：它不提供关于真值或假值含义的任何线索。“闪烁”一词也含糊不清，因为它并不表示闪烁的内容。以下替代方法更好：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controls cursor blinking: true means the cursor is visible,</span></span><br><span class="line"><span class="comment">// false means the cursor is not displayed.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cursorVisible = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li></ul><p>名称 cursorVisible 传达了更多信息；例如，它允许读者猜测一个真值的含义（通常，布尔变量的名称应始终为谓词）。名称中不再包含“ blink”一词，因此，如果读者想知道为什么光标不总是可见，则必须查阅文档。此信息不太重要。</p><ul><li><p>一个实施共识协议的项目包含以下代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value representing that the server has not voted (yet) for</span></span><br><span class="line"><span class="comment">// anyone for the current election term.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VOTED_FOR_SENTINEL_VALUE = <span class="string">"null"</span>;</span><br></pre></td></tr></table></figure><p>  此值的名称表示它是特殊的，但没有说明特殊含义是什么。使用更具体的名称（例如 NOT_YET_VOTED）会更好。<br>  在没有返回值的方法中使用了名为 result 的变量。这个名字有多个问题。首先，它会产生误导性的印象，即它将作为方法的返回值。其次，除了它是一些计算值外，它实际上不提供有关其实际持有内容的任何信息。该名称应提供有关实际结果是什么的信息，例如 mergedLine 或 totalChars。在实际上确实具有返回值的方法中，使用名称结果是合理的。该名称仍然有点通用，但是读者可以查看方法文档以了解其含义，这有助于知道该值最终将成为返回值。<br>  如果变量或方法的名称足够广泛，可以引用许多不同的事物，那么它不会向开发人员传达太多信息，因此底层实体很可能会被滥用。<br>  像所有规则一样，有关选择精确名称的规则也有一些例外。例如，只要循环仅跨越几行代码，就可以将通用名称（如 i 和 j）用作循环迭代变量。如果你可以看到一个变量的整个用法范围，那么该变量的含义在代码中就很明显了，因此你不需要长名称。例如，考虑以下代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  (i = <span class="number">0</span>; i &lt; numLines; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从这段代码中很明显，i 正被用来迭代某个实体中的每一行。如果循环太长，以至于你无法一次看到全部内容，或者如果很难从代码中找出迭代变量的含义，那么应该使用更具描述性的名称。<br>  名称也可能太具体，例如在此声明中删除一个文本范围的方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Range selection)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>  参数名称的选择过于具体，因为它建议始终在用户界面中选择要删除的文本。但是，可以在任意范围的文本（无论是否选中）上调用此方法。因此，参数名称应更通用，例如范围。<br>  如果你发现很难为精确，直观且时间不长的特定变量命名，那么这是一个危险信号。这表明该变量可能没有明确的定义或目的。发生这种情况时，请考虑其他因素。例如，也许你正在尝试使用单个变量来表示几件事；如果是这样，将表示形式分成多个变量可能会导致每个变量的定义更简单。选择好名字的过程可以通过识别弱点来改善你的设计。<br>  <strong>如果很难为创建基础对象清晰图像的变量或方法找到简单的名称，则表明基础对象可能没有简洁的设计。</strong></p></li></ul><h3 id="Use-names-consistently-一致使用名称"><a href="#Use-names-consistently-一致使用名称" class="headerlink" title="Use names consistently 一致使用名称"></a>Use names consistently 一致使用名称</h3><p>好的名称的第二个重要属性是一致性。在任何程序中，都会反复使用某些变量。例如，文件系统反复操作块号。对于每种常见用法，请选择一个用于该目的的名称，并在各处使用相同的名称。例如，文件系统可能总是使用 fileBlock 来保存文件中块的索引。一致的命名方式与重用普通类的方式一样，可以减轻认知负担：一旦读者在一个上下文中看到了该名称，他们就可以重用其知识并在不同上下文中看到该名称时立即做出假设。</p><p>一致性具有三个要求：</p><ul><li>首先，<strong>始终将通用名称用于给定目的</strong>；</li><li>第二，<strong>除了给定目的外，切勿使用通用名称</strong>；</li><li>第三，<strong>确保目的足够狭窄，以使所有具有名称的变量都具有相同的行为。</strong></li></ul><p>有时你将需要多个变量来引用相同的一般事物。例如，一种复制文件数据的方法将需要两个块号，一个为源，一个为目标。发生这种情况时，请对每个变量使用通用名称，但要添加一个可区分的前缀，例如 srcFileBlock 和 dstFileBlock。</p><p>循环是一致性命名可以提供帮助的另一个领域。如果将诸如 i 和 j 之类的名称用于循环变量，则始终在最外层循环中使用 i，而在嵌套循环中始终使用 j。这使读者可以在看到给定名称时对代码中发生的事情做出即时（安全）假设。</p><h3 id="A-different-opinion-Go-style-guide-不同的意见：Go-样式指南"><a href="#A-different-opinion-Go-style-guide-不同的意见：Go-样式指南" class="headerlink" title="A different opinion: Go style guide 不同的意见：Go 样式指南"></a>A different opinion: Go style guide 不同的意见：Go 样式指南</h3><p>并非所有人都同意我对命名的看法。一些使用 Go 语言的开发人员认为，名称应该非常简短，通常只能是一个字符。在关于 Go 的名称选择的演示中，Andrew Gerrand 指出“长名称模糊了代码的作用。” 1 他介绍了此代码示例，该示例使用单字母变量名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i, n := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span> b[i] &lt; RuneSelf &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _, size := DecodeRune(b[i:])</span><br><span class="line">            i += size</span><br><span class="line">        &#125;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并认为它比以下使用更长名称的版本更具可读性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(buffer []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    index, count := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; <span class="built_in">len</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> buffer[index] &lt; RuneSelf &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _, size := DecodeRune(buffer[index:])</span><br><span class="line">            index += size</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二版并不比第一版更难读。如果有的话，与 n 相比，名称计数为变量的行为提供了更好的线索。在第一个版本中，我最终通读了代码，试图弄清楚 n 的含义，而第二个版本中我并没有这种需要。但是，如果在整个系统中一致地使用 n 来引用计数（而没有其他内容），那么其他开发人员可能会清楚知道该短名称。</p><p>Go 文化鼓励在多个不同的事物上使用相同的短名称：ch 用于字符或通道，d 用于数据，差异或距离，等等。但是像这样的模棱两可的名称很可能导致混乱和错误，就像在示例中一样。</p><p>总的来说，我认为可读性必须由读者而不是作家来决定。如果你使用简短的变量名编写代码，并且阅读该代码的人很容易理解，那么很好。如果你开始抱怨代码很含糊，那么你应该考虑使用更长的名称（在网络上搜索“ go language short name”（使用语言简称）会识别出几种此类抱怨）。同样，如果我开始抱怨长变量名使我的代码难以阅读，那么我会考虑使用较短的变量名。</p><p>Gerrand 发表一个我同意的<a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="noopener">评论</a>：<strong>“名称声明与使用之间的距离越大，名称就应该越长。”</strong> 前面有关使用名为 i 和 j 的循环变量的讨论是此规则的示例。</p><p>精心选择的名称有助于使代码更明显。当某人第一次遇到该变量时，他们对行为的第一次猜测是正确的。选择好名字是第 3 章讨论的投资思维方式的一个示例：如果你花一些额外的时间来选择好名字，那么将来你将更容易处理代码。此外，你不太可能引入错误。培养命名技巧也是一项投资。当你第一次决定停止为平庸的名字定居时，你会发现想出好名字的过程既令人沮丧又耗时。但是，随着你获得更多的经验，你会发现它变得更加容易。最终，你将几乎不需要花费额外的时间来选择好名字，因此你几乎可以免费获得好处。</p><h2 id="先写注释Write-The-Comments-First-Use-Comments-As-Part-Of-The-Design-Process"><a href="#先写注释Write-The-Comments-First-Use-Comments-As-Part-Of-The-Design-Process" class="headerlink" title="先写注释Write The Comments First(Use Comments As Part Of The Design Process)"></a>先写注释Write The Comments First(Use Comments As Part Of The Design Process)</h2><p>在完成编码和单元测试之后，许多开发人员推迟编写文档，直到开发过程结束。这是产生质量差的文档的最直接方法之一。<strong>编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。</strong>这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。</p><h3 id="Delayed-comments-are-bad-comments-迟到的注释不是好注释"><a href="#Delayed-comments-are-bad-comments-迟到的注释不是好注释" class="headerlink" title="Delayed comments are bad comments 迟到的注释不是好注释"></a>Delayed comments are bad comments 迟到的注释不是好注释</h3><p>几乎每个开发人员都会推迟编写注释。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为繁琐的工作。因此，他们尽可能地推迟了。</p><p>不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，吸引力也越来越小。从来没有一个方便的时间可以停下来几天并填写所有遗漏的注释，并且很容易使该项目的最佳选择合理化，那就是继续并修复错误或编写下一个新功能。这将创建更多未记录的代码。</p><p>即使你有自律性回去写注释(不要欺骗你自己:你可能没有)，注释也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写注释是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，你可以快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，你已经有一段时间没有设计代码了，所以你对设计过程的记忆变得模糊了。你在编写注释时查看代码，因此注释重复了代码。即使你试图重构代码中不明显的设计思想，也会有你不记得的事情。因此，这些注释忽略了他们应该描述的一些最重要的事情。</p><h3 id="Write-the-comments-first-首先写注释"><a href="#Write-the-comments-first-首先写注释" class="headerlink" title="Write the comments first 首先写注释"></a>Write the comments first 首先写注释</h3><p>我使用一种不同的方法来编写注释，在开始时就写注释：</p><ul><li>对于新类，我首先编写类接口注释。</li><li>接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。</li><li>我对这些注释进行了迭代，直到基本结构感觉正确为止。</li><li>在这一点上，我为类中最重要的类实例变量编写了声明和注释。</li><li>最后，我填写方法的主体，并根据需要添加实现注释。</li><li>在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。例如变量，我在编写变量声明的同时填写了注释。</li></ul><p>代码完成后，注释也将完成。从来没有积压的书面注释。</p><p>注释优先的方法具有三个好处。首先，它会产生更好的注释。如果你在设计课程时写注释，那么关键的设计问题将在你的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样你就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，你会注意到并修复注释问题。结果，注释在开发过程中得到了改善。</p><h3 id="Comments-are-a-design-tool-注释是一种设计工具"><a href="#Comments-are-a-design-tool-注释是一种设计工具" class="headerlink" title="Comments are a design tool 注释是一种设计工具"></a>Comments are a design tool 注释是一种设计工具</h3><p>在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果你在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的注释，你必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，你只是在破解代码。</p><p>注释是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明你没有很好的抽象。请记住，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的注释中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。你可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明你可能没有选择正确的变量分解。总体而言，编写注释的行为使你可以及早评估设计决策，以便发现并解决问题。</p><p>描述方法或变量的注释应该简单而完整。如果你发现很难写这样的注释，则表明你所描述的内容的设计可能存在问题。</p><p>当然，如果注释完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释过于神秘以至于难以理解，则该注释不能很好地衡量该方法的深度。</p><h3 id="Early-comments-are-fun-comments-早期注释很有趣"><a href="#Early-comments-are-fun-comments-早期注释很有趣" class="headerlink" title="Early comments are fun comments 早期注释很有趣"></a>Early comments are fun comments 早期注释很有趣</h3><p>尽早编写注释的第三个也是最后一个好处是，它使编写注释更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，在那里，我将充实该类的抽象和结构。我的大部分注释都是在此阶段编写的，这些注释是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果你是策略性编程，而你的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是你确定最佳设计的方式。</p><h3 id="Are-early-comments-expensive-早期注释是否昂贵？"><a href="#Are-early-comments-expensive-早期注释是否昂贵？" class="headerlink" title="Are early comments expensive? 早期注释是否昂贵？"></a>Are early comments expensive? 早期注释是否昂贵？</h3><p>现在，让我们重新讨论延迟注释的参数，这是因为它避免了在代码演变时重新处理注释的开销。一个简单的信封计算将显示这并不能节省很多。首先，估算你一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使你的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将注释延迟到最后只会节省其中的一小部分，这不是很多。</p><p>首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果你首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当你考虑所有这些因素时，可能首先整体编写注释可能会更快。</p><blockquote><p>如果你从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响你的注释质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道你的经历是否与我的相符，以及为什么或为什么不这样。</p></blockquote><h2 id="修改现有的代码Modifying-Existing-Code"><a href="#修改现有的代码Modifying-Existing-Code" class="headerlink" title="修改现有的代码Modifying Existing Code"></a>修改现有的代码Modifying Existing Code</h2><h3 id="Stay-strategic-保持战略"><a href="#Stay-strategic-保持战略" class="headerlink" title="Stay strategic 保持战略"></a>Stay strategic 保持战略</h3><p>战术方法很快导致系统设计混乱。如果你想要一个易于维护和增强的系统，那么“工作”还不够高。你必须优先考虑设计并进行战略思考。当你修改现有代码时，此想法也适用。</p><p>不幸的是，当开发人员进入现有代码以进行更改（例如错误修复或新功能）时，他们通常不会从战略角度进行思考。一个典型的心态是“我能做出我需要做的最小的改变是什么？” 有时，开发人员证明这是合理的，因为他们对修改的代码不满意。他们担心较大的更改会带来更大的引入新错误的风险。但是，这导致了战术编程。这些最小的变化中的每一个都会引入一些特殊情况，依赖性或其他形式的复杂性。结果，系统设计变得更糟，并且问题随着系统发展的每个步骤而累积。</p><p>如果要维护系统的简洁设计，则在修改现有代码时必须采取战略性方法。理想情况下，当你完成每次更改时，如果你从一开始就考虑到更改就设计了系统，那么系统将具有它应该具有的结构。为了实现此目标，你必须抵制诱惑以快速解决问题。相反，请根据所需的更改来考虑当前的系统设计是否仍然是最佳的。如果不是，请重构系统，以便最终获得最佳设计。通过这种方法，每次修改都会改善系统设计。</p><p>如果你花费一些额外的时间来重构和改善系统设计，你将得到一个更干净的系统。这将加快开发速度，你将收回在重构方面投入的精力。即使你的特定更改不需要重构，你仍然应该注意在代码中可以修复的设计缺陷。每当你修改任何代码时，都尝试在该过程中至少找到一点方法来改进系统设计。如果你没有使设计更好，则可能会使它变得更糟。</p><p>如第 3 章所述，投资心态有时与商业软件开发的现实相冲突。如果“正确的方式”重构系统需要三个月，而快速且肮脏的修复仅需两个小时，则你可能必须采取快速而肮脏的方法，尤其是在紧迫的期限内工作时。或者，如果重构系统会造成影响许多其他人员和团队的不兼容性，则重构可能不切实际。</p><p>但是，你应尽可能抵制这些妥协。问问自己：“考虑到我目前的限制，这是否是我能做的最好的工作来创建一个干净的系统设计？” 也许有一种替代方法几乎可以像 3 个月的重构一样干净，但是可以在几天内完成？或者，如果你现在负担不起大型重构，请让你的老板为你分配时间，让你在当前截止日期之后恢复到原来的水平。每个开发组织都应计划将其全部工作的一小部分用于清理和重构；从长远来看，这项工作将收回成本。</p><h3 id="Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近"><a href="#Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近" class="headerlink" title="Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近"></a>Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近</h3><p>当你更改现有代码时，更改很有可能会使某些现有注释无效。修改代码时，很容易忘记更新注释，从而导致注释不再准确。不准确的注释使读者感到沮丧，如果注释太多，读者就会开始不信任所有注释。幸运的是，只要有一点纪律和一些指导规则，就可以在不付出巨大努力的情况下使注释保持最新。本节及随后的部分提出了一些特定的技术。</p><p><strong>确保注释更新的最佳方法是将注释放置在它们描述的代码附近</strong>，以便开发人员在更改代码时可以看到它们。注释离其关联的代码越远，正确更新的可能性就越小。例如，方法接口注释的最佳位置是在代码文件中，紧靠该方法主体的位置。对方法的任何更改都将涉及此代码，因此开发人员很可能会看到接口注释，并在需要时进行更新。</p><p>对于 C 和 C ++等具有单独的代码和头文件的语言，一种替代方法是将接口注释放在.h 文件中方法声明的旁边。但是，这距离代码还有很长的路要走。开发人员在修改方法的主体时将看不到这些注释，因此需要打开其他文件并查找接口注释来更新它们，这需要额外的工作。有人可能会争辩说接口注释应该放在头文件中，以便用户可以不必看代码文件就可以学习如何使用抽象。但是，用户无需读取代码或头文件；他们应该从由 Doxygen 或 Javadoc 等工具编译的文档中获取信息。此外，许多 IDE 都会提取文档并将其呈现给用户，例如在键入方法名称时显示方法的文档。给定诸如此类的工具，文档应位于对开发人员进行代码开发最方便的位置。</p><p>在编写实现注释时，不要将整个方法的所有注释放在方法的顶部。展开它们，将每个注释推到最狭窄的范围，其中包括该注释所引用的所有代码。例如，如果一种方法具有三个主要阶段，则不要在方法的顶部写一个详细描述所有阶段的注释。而是为每个阶段编写一个单独的注释，并将该注释放置在该阶段的第一行代码的正上方。另一方面，在描述总体策略的方法实现的顶部添加注释也可能会有所帮助，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  We proceed in three phases:</span></span><br><span class="line"><span class="comment">//  Phase 1: Find feasible candidates</span></span><br><span class="line"><span class="comment">//  Phase 2: Assign each candidate a score</span></span><br><span class="line"><span class="comment">//  Phase 3: Choose the best, and remove it</span></span><br></pre></td></tr></table></figure></p><p>每个阶段的代码上方都可以记录其他详细信息。<br>通常，注释离描述的代码越远，注释应该越抽象（这减少了注释因代码更改而无效的可能性）。</p><h3 id="Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志"><a href="#Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志" class="headerlink" title="Comments belong in the code, not the commit log 注释属于代码，而不是提交日志"></a>Comments belong in the code, not the commit log 注释属于代码，而不是提交日志</h3><p>修改代码时，常见的错误是将有关更改的详细信息放入源代码存储库的提交消息中，而不是将其记录在代码中。尽管将来可以通过扫描存储库的日志来浏览提交消息，但是需要该信息的开发人员不太可能考虑扫描存储库的日志。即使他们确实扫描了日志，也很难找到正确的日志消息。</p><p>在编写提交消息时，请问自己将来开发人员是否需要使用该信息。如果是这样，则在代码中记录此信息。一个示例是提交消息，描述了导致代码更改的细微问题。如果代码中未对此进行记录，则开发人员可能会稍后再提出并撤消更改，而不会意识到他们已经重新创建了错误。如果你也想在提交消息中包含此信息的副本，那很好，但是最重要的是在代码中获取它。这说明了将文档放置在开发人员最有可能看到它的地方的原理；提交日志很少在那个地方。</p><h3 id="Maintaining-comments-avoid-duplication-维护注释：避免重复"><a href="#Maintaining-comments-avoid-duplication-维护注释：避免重复" class="headerlink" title="Maintaining comments: avoid duplication 维护注释：避免重复"></a>Maintaining comments: avoid duplication 维护注释：避免重复</h3><p>保持注释最新的第二种技术是避免重复。如果文档重复，那么开发人员将很难找到并更新所有相关副本。相反，请尝试仅一次记录每个设计决策。如果代码中有多个地方受某个特定决定的影响，请不要在所有这些地方重复文档。相反，找到放置文档最明显的位置。例如，假设存在与变量相关的棘手行为，这会影响使用变量的几个不同位置。你可以在变量声明旁边的注释中记录该行为。这是很自然的地方，开发人员可能会检查他们是否在理解使用该变量的代码时遇到麻烦。</p><p>如果没有一个“明显的”地方来放置特定的文档，开发人员可以找到它，那么创建一个 designNotes 文件。或者，选择最好的地方，把文档放在那里。另外，在引用中心位置的其他地方添加简短的注释:“查看 xyz 中的注释以了解下面代码的解释。“如果引用因为主注释被移动或删除而变得过时，这种不一致性将是不言而喻的，因为开发人员将无法在指定的位置找到注释;他们可以使用修订控制历史记录来查找注释发生了什么，然后更新引用。相反，如果文档是重复的，并且一些副本没有得到更新，那么开发人员就不会知道他们使用的是陈旧的信息。</p><p>不要在另一个模块中记录一个模块的设计决策。例如，不要在方法调用前添加注释，以解释被调用方法中发生的情况。如果读者想知道，他们应该查看该方法的接口注释。好的开发工具通常会自动提供此信息，例如，如果你选择了方法的名称或将鼠标悬停在该方法的名称上，则将显示该方法的接口注释。尝试使开发人员容易找到合适的文档，但是不要重复文档。</p><p>如果信息已经在程序之外的某个地方记录了，不要在程序内部重复记录;只需参考外部文档。例如，如果你编写一个实现 HTTP 协议的类，那么就不需要在代码中描述 HTTP 协议。在网上已经有很多关于这个文档的来源;只需在你的代码中添加一个简短的注释，并为其中一个源添加一个 URL。另一个例子是已经在用户手册中记录的特性。假设你正在编写一个实现命令集合的程序，其中有一个负责实现每个命令的方法。如果有描述这些命令的用户手册，就不需要在代码中重复这些信息。相反，在每个命令方法的接口注释中包含如下简短说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implements the Foo command; see the user manual for details.</span></span><br></pre></td></tr></table></figure><p>读者可以轻松找到理解代码所需的所有文档，这一点很重要，但这并不意味着你必须编写所有这些文档。</p><h3 id="Maintaining-comments-check-the-diffs-维护注释：检查差异"><a href="#Maintaining-comments-check-the-diffs-维护注释：检查差异" class="headerlink" title="Maintaining comments: check the diffs 维护注释：检查差异"></a>Maintaining comments: check the diffs 维护注释：检查差异</h3><p>确保文档保持最新状态的一种好方法是，在将更改提交到修订控制系统之前需要花费几分钟，以扫描该提交的所有更改。确保文档中正确反映了每个更改。这些预先提交的扫描还将检测其他一些问题，例如意外地将调试代码留在系统中或无法修复 TODO 项目。</p><h3 id="Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护"><a href="#Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护" class="headerlink" title="Higher-level comments are easier to maintain 更高级的注释更易于维护"></a>Higher-level comments are easier to maintain 更高级的注释更易于维护</h3><p>关于维护文档的最后一个想法：如果注释比代码更高级，更抽象，则注释更易于维护。这些注释不反映代码的详细信息，因此它们不会受到代码更改的影响；只有整体行为的变化才会影响这些评论。当然，正如第 13 章所讨论的那样，某些注释的确需要详细和精确。但总的来说，最有用的注释（它们不只是重复代码）也最容易维护。</p><h2 id="一致性Consistency"><a href="#一致性Consistency" class="headerlink" title="一致性Consistency"></a>一致性Consistency</h2><p><strong>一致性是降低系统复杂性并使其行为更明显的强大工具。</strong>如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦你了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。</p><p>一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。</p><h3 id="Examples-of-consistency-一致性示例"><a href="#Examples-of-consistency-一致性示例" class="headerlink" title="Examples of consistency 一致性示例"></a>Examples of consistency 一致性示例</h3><ul><li>名字（Names）。此前已经讨论了以一致的方式使用名称的好处。</li><li>编码样式（Coding style）。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。</li><li>接口（Interfaces）。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为你已经知道它将必须提供的功能。</li><li>设计模式（Design patterns）。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果你可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且你的代码对读者来说也会更明显。</li><li>不变量（Invariants）。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。</li></ul><h3 id="Ensuring-consistency-确保一致性"><a href="#Ensuring-consistency-确保一致性" class="headerlink" title="Ensuring consistency 确保一致性"></a>Ensuring consistency 确保一致性</h3><p>一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：</p><ul><li>文档（Document）。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。<br>对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果你不写下约定，那么其他人不太可能会遵循它们。</li><li>执行（Enforce）。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。</li></ul><p>我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。</p><p>我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。</p><p>代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。</p><p>在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当你看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。</p><p>不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。你的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，你是否拥有大量的新信息来证明你的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果你的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，你仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。</p><h3 id="Taking-it-too-far-走得太远"><a href="#Taking-it-too-far-走得太远" class="headerlink" title="Taking it too far 走得太远"></a>Taking it too far 走得太远</h3><p>一致性不仅意味着相似的事情应该以相似的方式完成，而且不同的事情也应该以不同的方式完成。如果你对一致性过于热衷，并试图将不同的事物强制采用相同的方法，例如对确实不同的事物使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么会造成复杂性和混乱。一致性只有在开发人员确信“如果看起来像 x 时，它确实是 x”时才有好处。</p><blockquote><p>一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是你的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。</p></blockquote><h2 id="代码应该是显而易见的Code-Should-be-Obvious"><a href="#代码应该是显而易见的Code-Should-be-Obvious" class="headerlink" title="代码应该是显而易见的Code Should be Obvious"></a>代码应该是显而易见的Code Should be Obvious</h2><p>晦涩难懂是此前（第二章）中描述的导致复杂性的两个主要原因之一。当有关系统的重要信息对于新开发人员而言并不明显时，就会发生模糊。解决晦涩问题的方法是以显而易见的方式编写代码。本章讨论使代码或多或少变得显而易见的一些因素。</p><p>如果代码很明显，则意味着某人可以不加思索地快速阅读该代码，并且他们对代码的行为或含义的最初猜测将是正确的。如果代码很明显，那么读者就不需要花费很多时间或精力来收集他们使用代码所需的所有信息。如果代码不明显，那么读者必须花费大量时间和精力来理解它。这不仅降低了它们的效率，而且还增加了误解和错误的可能性。明显的代码比不明显的代码需要更少的注释。</p><p>读者的想法是“显而易见”：注意到别人的代码不明显比发现自己的代码有问题要容易得多。因此，确定代码是否显而易见的最佳方法是通过代码审查。如果有人在阅读你的代码时说它并不明显，那么无论你看起来多么清晰，它也不是显而易见。通过尝试理解什么使代码变得不明显，你将学习如何在将来编写更好的代码。</p><h3 id="Things-that-make-code-more-obvious让代码更明显的事情"><a href="#Things-that-make-code-more-obvious让代码更明显的事情" class="headerlink" title="Things that make code more obvious让代码更明显的事情"></a>Things that make code more obvious让代码更明显的事情</h3><p>在前面的章节中已经讨论了使代码显而易见的两种最重要的技术。首先是选择好名字（第 14 章）。精确而有意义的名称可以阐明代码的行为，并减少对文档的需求。如果名称含糊不清或含糊不清，那么读者将通读代码以推论命名实体的含义；这既费时又容易出错。第二种技术是一致性（第 17 章）。如果总是以相似的方式完成相似的事情，那么读者可以识别出他们以前所见过的模式，并立即得出（安全）结论，而无需详细分析代码。</p><p>以下是使代码更明显的其他一些通用技术：</p><ul><li><p>明智地使用空白（Judicious use of white space）。代码格式化的方式会影响其理解的容易程度。考虑以下参数文档，其中空格已被压缩：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> numThreads The number of threads that this manager should</span></span><br><span class="line"><span class="comment"> *  spin up in order to manage ongoing connections. The MessageManager</span></span><br><span class="line"><span class="comment"> *  spins up at least one thread for every open connection, so this</span></span><br><span class="line"><span class="comment"> *  should be at least equal to the number of connections you expect</span></span><br><span class="line"><span class="comment"> *  to be open at once. This should be a multiple of that number if</span></span><br><span class="line"><span class="comment"> *  you expect to send a lot of messages in a short amount of time.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> handler Used as a callback in order to handle incoming</span></span><br><span class="line"><span class="comment"> *  messages on this MessageManager's open connections. See</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@code</span> MessageHandler&#125; and &#123;<span class="doctag">@code</span> handleMessage&#125; for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>  很难看到一个参数的文档在哪里结束而下一个参数的文档在哪里开始。甚至不知道有多少个参数或它们的名称是什么。如果添加了一些空白，结构会突然变得清晰，文档也更容易浏览：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> numThreads</span></span><br><span class="line"><span class="comment"> *           The number of threads that this manager should spin up in</span></span><br><span class="line"><span class="comment"> *           order to manage ongoing connections. The MessageManager spins</span></span><br><span class="line"><span class="comment"> *           up at least one thread for every open connection, so this</span></span><br><span class="line"><span class="comment"> *           should be at least equal to the number of connections you</span></span><br><span class="line"><span class="comment"> *           expect to be open at once. This should be a multiple of that</span></span><br><span class="line"><span class="comment"> *           number if you expect to send a lot of messages in a short</span></span><br><span class="line"><span class="comment"> *           amount of time.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> *           Used as a callback in order to handle incoming messages on</span></span><br><span class="line"><span class="comment"> *           this MessageManager's open connections. See</span></span><br><span class="line"><span class="comment"> *           &#123;<span class="doctag">@code</span> MessageHandler&#125; and &#123;<span class="doctag">@code</span> handleMessage&#125; for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>  空行也可用于分隔方法中的主要代码块，例如以下示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* Buffer::allocAux(size_t numBytes) &#123;</span><br><span class="line">    <span class="comment">//  Round up the length to a multiple of 8 bytes, to ensure alignment.</span></span><br><span class="line">    uint32_t numBytes32 =  (downCast&lt;uint32_t&gt;(numBytes) + <span class="number">7</span>) &amp; ~<span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">assert</span>(numBytes32 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  If there is enough memory at firstAvailable, use that. Work down</span></span><br><span class="line">    <span class="comment">//  from the top, because this memory is guaranteed to be aligned</span></span><br><span class="line">    <span class="comment">//  (memory at the bottom may have been used for variable-size chunks).</span></span><br><span class="line">    <span class="keyword">if</span>  (availableLength &gt;= numBytes32) &#123;</span><br><span class="line">        availableLength -= numBytes32;</span><br><span class="line">        <span class="keyword">return</span> firstAvailable + availableLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Next, see if there is extra space at the end of the last chunk.</span></span><br><span class="line">    <span class="keyword">if</span>  (extraAppendBytes &gt;= numBytes32) &#123;</span><br><span class="line">        extraAppendBytes -= numBytes32;</span><br><span class="line">        <span class="keyword">return</span> lastChunk-&gt;data + lastChunk-&gt;length + extraAppendBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Must create a new space allocation; allocate space within it.</span></span><br><span class="line">    uint32_t allocatedLength;</span><br><span class="line">    firstAvailable = getNewAllocation(numBytes32, &amp;allocatedLength);</span><br><span class="line">    availableLength = allocatedLength numBytes32;</span><br><span class="line">    <span class="keyword">return</span> firstAvailable + availableLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果每个空白行之后的第一行是描述下一个代码块的注释，则此方法特别有效：空白行使注释更可见。<br>  语句中的空白有助于阐明语句的结构。比较以下两个语句，其中之一具有空格，而其中一个没有空格：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pass=<span class="number">1</span>;pass&gt;=<span class="number">0</span>&amp;&amp;!empty;pass--) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pass = <span class="number">1</span>; pass &gt;= <span class="number">0</span> &amp;&amp; !empty; pass--) &#123;</span><br></pre></td></tr></table></figure></li><li><p>注释（Comments）。有时无法避免非显而易见的代码。发生这种情况时，重要的是使用注释来提供缺少的信息以进行补偿。要做到这一点，你必须使自己处于读者的位置，弄清楚什么可能会使他们感到困惑，以及哪些信息可以消除这种混乱。下一部分显示了一些示例。</p></li></ul><h3 id="Things-that-make-code-less-obvious-使代码不那么明显的事情"><a href="#Things-that-make-code-less-obvious-使代码不那么明显的事情" class="headerlink" title="Things that make code less obvious 使代码不那么明显的事情"></a>Things that make code less obvious 使代码不那么明显的事情</h3><p>有很多事情可以使代码变得不明显。本节提供了一些示例。其中某些功能（例如事件驱动的编程）在某些情况下很有用，因此你可能最终还是要使用它们。发生这种情况时，额外的文档可以帮助最大程度地减少读者的困惑。</p><p>事件驱动的编程。在事件驱动的编程中，应用程序对外部事件做出响应，例如网络数据包的到来或按下鼠标按钮。一个模块负责报告传入事件。应用程序的其他部分通过在事件发生时要求事件模块调用给定的函数或方法来注册对某些事件的兴趣。</p><p>事件驱动的编程使其很难遵循控制流程。永远不要直接调用事件处理函数。它们是由事件模块间接调用的，通常使用函数指针或接口。即使你在事件模块中找到了调用点，也仍然无法确定将调用哪个特定功能：这将取决于在运行时注册了哪些处理程序。因此，很难推理事件驱动的代码或说服自己相信它是可行的。</p><p>为了弥补这种模糊性，请为每个处理程序函数使用接口注释，以指示何时调用该函数，如以下示例所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is invoked in the dispatch thread by a transport if a</span></span><br><span class="line"><span class="comment"> * transport-level error prevents an RPC from completing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Transport::RpcNotifier::failed() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果无法通过快速阅读来理解代码的含义和行为，则它是一个危险标记。通常，这意味着有些重要的信息对于阅读代码的人来说并不能立即清除。</p><ul><li>通用容器（Generic containers.）。许多语言提供了用于将两个或多个项目组合到一个对象中的通用类，例如 Java 中的 Pair 或 C ++中的 std :: pair。这些类很诱人，因为它们使使用单个变量轻松传递多个对象变得容易。最常见的用途之一是从一个方法返回多个值，如以下 Java 示例所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;Integer, Boolean&gt;(currentTerm, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>不幸的是，通用容器导致代码不清晰，因为分组后的元素的通用名称模糊了它们的含义。在上面的示例中，调用者必须使用 result.getKey（）和 result.getValue（）引用两个返回的值，而这两个值都不提供这些值的实际含义。</p><p>因此，最好不要使用通用容器。如果需要容器，请定义专门用于特定用途的新类或结构。然后，你可以为元素使用有意义的名称，并且可以在声明中提供其他文档，而对于常规容器而言，这是不可能的。</p><p>此示例说明了一条通用规则：软件应设计为易于阅读而不是易于编写。通用容器对于编写代码的人来说是很方便的，但是它们会使随后的所有读者感到困惑。对于编写代码的人来说，花一些额外的时间来定义特定的容器结构是更好的选择，以便使生成的代码更加明显。</p><p>不同类型的声明和分配。考虑以下 Java 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Message&gt; incomingMessageList;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">incomingMessageList = <span class="keyword">new</span> ArrayList&lt;Message&gt;();</span><br></pre></td></tr></table></figure><p>将该变量声明为 List，但实际值为 ArrayList。这段代码是合法的，因为 List 是 ArrayList 的超类，但是它会误导看到声明但不是实际分配的读者。实际类型可能会影响变量的使用方式（ArrayList 与 List 的其他子类相比，具有不同的性能和线程安全属性），因此最好将声明与分配匹配。</p><p>违反读者期望的代码。考虑以下代码，这是 Java 应用程序的主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> RaftClient(myAddress, serverAddresses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数应用程序在其主程序返回时退出，因此读者可能会认为这将在此处发生。但是，事实并非如此。RaftClient 的构造函数创建其他线程，即使应用程序的主线程完成，该线程仍可继续运行。应该在 RaftClient 构造函数的接口注释中记录此行为，但是该行为不够明显，因此值得在 main 末尾添加简短注释。该注释应指示该应用程序将继续在其他线程中执行。如果代码符合读者期望的惯例，那么它是最明显的。如果没有，那么记录该行为很重要，以免使读者感到困惑。</p><blockquote><p>关于显而易见性的另一种思考方式是信息。如果代码不是显而易见的，则通常意味着存在有关读者所不具备的代码的重要信息：在 RaftClient 示例中，读者可能不知道 RaftClient 构造函数创建了新线程；在“配对”示例中，读者可能不知道 result.getKey（）返回当前项的编号。为了使代码清晰可见，你必须确保读者始终拥有理解它们所需的信息。你可以通过三种方式执行此操作。最好的方法是使用抽象等设计技术并消除特殊情况，以减少所需的信息量。其次，你可以利用读者在其他情况下已经获得的信息（例如，通过遵循约定并符合期望），从而使读者不必为代码学习新的信息。第三，你可以使用诸如好名和战略注释之类的技术在代码中向他们提供重要信息。</p></blockquote><h2 id="软件发展趋势Software-Trends"><a href="#软件发展趋势Software-Trends" class="headerlink" title="软件发展趋势Software Trends"></a>软件发展趋势Software Trends</h2><h3 id="Object-oriented-programming-and-inheritance-面向对象的编程和继承"><a href="#Object-oriented-programming-and-inheritance-面向对象的编程和继承" class="headerlink" title="Object-oriented programming and inheritance 面向对象的编程和继承"></a>Object-oriented programming and inheritance 面向对象的编程和继承</h3><p>在过去的 30-40 年中，面向对象编程是软件开发中最重要的新思想之一。它引入了诸如类，继承，私有方法和实例变量之类的概念。如果仔细使用，这些机制可以帮助产生更好的软件设计。例如，私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。</p><p>面向对象编程的关键要素之一是继承（inheritance）。继承有两种形式，它们对软件复杂性有不同的含义。继承的第一种形式是接口继承，其中父类定义一个或多个方法的签名，但不实现这些方法。每个子类都必须实现签名，但是不同的子类可以以不同的方式实现相同的方法。例如，该接口可能定义用于执行 I/O 的方法。一个子类可能对磁盘文件实现 I/O 操作，而另一个子类可能对网络套接字实现相同的操作。</p><p>接口继承通过出于多种目的重用同一接口，从而提供了针对复杂性的杠杆作用。它使解决一个问题（例如如何使用 I/O 接口读取和写入磁盘文件）中获得的知识可以用于解决其他问题（例如通过网络套接字进行通信）。关于深度的另一种思考方式是：接口的实现越不同，接口就越深入。为了使接口具有许多实现，它必须捕获所有基础实现的基本功能，同时避免实现之间的差异。这个概念是抽象的核心。</p><p>继承的第二种形式是实现继承（implementation inheritance）。以这种形式，父类不仅定义了一个或多个方法的签名，而且还定义了默认实现。子类可以选择继承方法的父类实现，也可以通过定义具有相同签名的新方法来覆盖它。如果没有实现继承，则可能需要在几个子类中复制相同的方法实现，这将在这些子类之间创建依赖关系（修改需要在方法的所有副本中复制）。因此，实现继承减少了随着系统的发展而需要修改的代码量。换句话说，它减少了此前（第 2 章）中描述的变化放大问题。</p><p>但是，实现继承会在父类及其每个子类之间创建依赖关系。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。</p><p>因此，应谨慎使用实现继承。在使用实现继承之前，请考虑基于组合的方法是否可以提供相同的好处。例如，可以使用小型帮助程序类来实现共享功能。原始类可以从辅助类的功能构建，而不是从父类继承函数。</p><p>如果没有实现继承的可行选择，请尝试将父类管理的状态与子类管理的状态分开。一种方法是，某些实例变量完全由父类中的方法管理，子类仅以只读方式或通过父类中的其他方法使用它们。这适用于隐藏在类层次结构中的信息的概念，以减少依赖性。</p><p>尽管面向对象编程提供的机制可以帮助实现干净的设计，但是它们本身不能保证良好的设计。例如，如果类很浅，或者具有复杂的接口，或者允许外部访问其内部状态，那么它们仍将导致很高的复杂性。</p><h3 id="Agile-development-敏捷开发"><a href="#Agile-development-敏捷开发" class="headerlink" title="Agile development 敏捷开发"></a>Agile development 敏捷开发</h3><p>敏捷开发是一种软件开发方法，它是在 1990 年代末期出现的，其思想涉及如何使软件开发更加轻量，灵活和增量。它是在 2001 年的一次从业者会议上正式定义的。敏捷开发主要是关于软件开发的过程（组织团队，管理进度表，单元测试的角色，与客户交互等），而不是软件设计。但是，它与本书中的某些设计原则有关。</p><p>敏捷开发中最重要的元素之一是<strong>开发应该是渐进的和迭代的概念</strong>。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。通常，这类似于此处提倡的增量方法。如第 1 章所述，在项目开始时就不可能对复杂的系统进行充分的可视化以决定最佳设计。最终获得良好设计的最佳方法是逐步开发一个系统，其中每个增量都会添加一些新的抽象，并根据经验重构现有的抽象。这类似于敏捷开发方法。</p><p><strong>敏捷开发的风险之一是它可能导致战术编程。</strong>敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。例如，一些敏捷的从业者认为，你不应该立即实施通用机制。实现一个最小的特殊用途机制，从此开始，并在以后知道需要时重构为更通用的东西。尽管这些论点在一定程度上是合理的，但它们反对投资方法，并鼓励采用更具战术性的编程风格。这可以导致复杂性的快速累积。</p><p><strong>渐进式开发通常是一个好主意，但是渐进式开发应该是抽象的（abstractions），而不是功能的（features）。</strong>可以推迟对特定抽象的所有想法，直到功能需要它为止。一旦需要抽象，就要花一些时间进行简洁的设计。</p><h3 id="Unit-tests-单元测试"><a href="#Unit-tests-单元测试" class="headerlink" title="Unit tests 单元测试"></a>Unit tests 单元测试</h3><p>过去，开发人员很少编写测试。如果测试是由一个独立的 QA 团队编写的，那么它们就是由一个独立的 QA 团队编写的。然而，敏捷开发的原则之一是测试应该与开发紧密集成，程序员应该为他们自己的代码编写测试。这种做法现在已经很普遍了。测试通常分为两类: <strong>单元测试和系统测试。</strong>单元测试是开发人员最常编写的测试。它们很小，而且重点突出:每个测试通常在单个方法中验证一小段代码。</p><p>单元测试可以独立运行，而不需要为系统设置生产环境。单元测试通常与测试覆盖工具一起运行，以确保应用程序中的每一行代码都经过了测试。每当开发人员编写新代码或修改现有代码时，他们都要负责更新单元测试以保持适当的测试覆盖率。</p><p>第二种测试包括系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。系统测试更有可能由独立的质量检查或测试小组编写。</p><p>测试，尤其是单元测试，在软件设计中起着重要作用，因为它们有助于重构。没有测试套件，对系统进行重大结构更改很危险。没有容易找到错误的方法，因此在部署新代码之前，很可能将无法检测到错误，因为在新代码中查找和修复它们的成本要高得多。结果，开发人员避免在没有良好测试套件的系统中进行重构。他们尝试将每个新功能或错误修复的代码更改次数减至最少，这意味着复杂性会累积，而设计错误不会得到纠正。</p><p>有了一套很好的测试，开发人员可以在重构时更有信心，因为测试套件将发现大多数引入的错误。这鼓励开发人员对系统进行结构改进，从而获得更好的设计。单元测试特别有价值：与系统测试相比，它们提供更高的代码覆盖率，因此它们更有可能发现任何错误。</p><p>例如，在开发 Tcl 脚本语言期间，我们决定通过用字节码编译器替换 Tcl 的解释器来提高性能。这是一个巨大的变化，几乎影响了核心 Tcl 引擎的每个部分。幸运的是，Tcl 有一个出色的单元测试套件，我们在新的字节码引擎上运行了该套件。现有测试在发现新引擎中的错误方面是如此有效，以至于在字节码编译器的 alpha 版本发布之后仅出现了一个错误。</p><h3 id="Test-driven-development-测试驱动的开发"><a href="#Test-driven-development-测试驱动的开发" class="headerlink" title="Test-driven development 测试驱动的开发"></a>Test-driven development 测试驱动的开发</h3><p>测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。创建新类时，开发人员首先根据其预期行为为该类编写单元测试。没有测试通过，因为该类没有代码。然后，开发人员一次完成一个测试，编写足够的代码以使该测试通过。所有测试通过后，该类结束。</p><p>测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。</p><p>开发单位应该是抽象的，而不是功能。一旦发现需要抽象，就不要随着时间的流逝而逐步创建抽象。一次设计所有功能（或至少足以提供一组合理全面的核心功能）。这样更有可能产生干净的设计，使各个部分很好地契合在一起。</p><p>首先编写测试的地方是修复错误。修复错误之前，请编写由于该错误而失败的单元测试。然后修复该错误，并确保现在可以通过单元测试。这是确保你已真正修复该错误的最佳方法。如果你在编写测试之前就已修复了该错误，则新的单元测试很可能实际上不会触发该错误，在这种情况下，它不会告诉你是否确实修复了该问题。</p><h3 id="Design-patterns-设计模式"><a href="#Design-patterns-设计模式" class="headerlink" title="Design patterns 设计模式"></a>Design patterns 设计模式</h3><p>设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。设计模式的概念在 Gamma，Helm，Johnson 和 Vlissides 的《设计模式：可重用的面向对象软件的元素》一书中得到了普及，现在设计模式已广泛用于面向对象的软件开发中。</p><p><strong>设计模式代表了设计的替代方法：与其从头设计新的机制，不如应用一种众所周知的设计模式</strong>。在大多数情况下，这是件好事：出现设计模式是因为它们解决了常见的问题，并且因为它们被普遍同意提供干净的解决方案。如果设计模式在特定情况下运作良好，那么你可能很难想出另一种更好的方法。</p><p><strong>设计模式的最大风险是过度使用</strong>。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。使用设计模式并不能自动改善软件系统。只有在设计模式合适的情况下才这样做。与软件设计中的许多想法一样，设计模式良好的概念并不一定意味着更多的设计模式会更好。</p><h3 id="Getters-and-setters-Getter-和-Setters"><a href="#Getters-and-setters-Getter-和-Setters" class="headerlink" title="Getters and setters Getter 和 Setters"></a>Getters and setters Getter 和 Setters</h3><p>在 Java 编程社区中，getter 和 setter 方法是一种流行的设计模式。一个 getter 和一个 setter 与一个类的实例变量相关联。它们具有类似 getFoo 和 setFoo 的名称，其中 Foo 是变量的名称。getter 方法返回变量的当前值，setter 方法修改该值。</p><p>由于实例变量可以公开，因此不一定必须使用 getter 和 setter 方法。getter 和 setter 的论点是，它们允许在获取和设置时执行其他功能，例如在变量更改时更新相关值，通知更改的侦听器或对值实施约束。即使最初不需要这些功能，也可以稍后添加它们而无需更改界面。</p><p>尽管如果必须公开实例变量，则可以使用 getter 和 setter 方法，但最好不要首先公开实例变量。暴露的实例变量意味着类的实现的一部分在外部是可见的，这违反了信息隐藏的思想，并增加了类接口的复杂性。Getter 和 Setter 是浅层方法（通常只有一行），因此它们在不提供太多功能的情况下为类的接口增加了混乱。最好避免使用 getter 和 setter（或任何暴露的实现数据）。</p><p>建立设计模式的风险之一是，开发人员认为该模式是好的，并尝试尽可能多地使用它。这导致 Java 中的 getter 和 setter 的过度使用。</p><blockquote><p>每当你遇到有关新软件开发范例的提案时，就必须从复杂性的角度对其进行挑战：该提案确实有助于最大程度地降低大型软件系统的复杂性吗？从表面上看，许多建议听起来不错，但是如果你深入研究，你会发现其中一些会使复杂性恶化，而不是更好。</p></blockquote><h2 id="设计性能Designing-for-Performance"><a href="#设计性能Designing-for-Performance" class="headerlink" title="设计性能Designing for Performance"></a>设计性能Designing for Performance</h2><p>到目前为止，关于软件设计的讨论都集中在复杂性上。目标是使软件尽可能简单易懂。但是，如果你在需要快速的系统上工作，该怎么办？性能方面的考虑应如何影响设计过程？本章讨论如何在不牺牲简洁设计的情况下实现高性能。最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。</p><h3 id="How-to-think-about-performance-如何考虑性能"><a href="#How-to-think-about-performance-如何考虑性能" class="headerlink" title="How to think about performance 如何考虑性能"></a>How to think about performance 如何考虑性能</h3><p>要解决的第一个问题是“你在正常的开发过程中应该为性能多少担心？” 如果你尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果你完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。</p><p><strong>最好的方法是介于这两种极端之间</strong>，在这种极端情况下，你可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：</p><ul><li>网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。</li><li>I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。</li><li>动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。</li><li>高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。</li></ul><p>了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。</p><p>一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要映射提供的排序属性，否则应始终使用哈希表。</p><p>作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，你必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此你只为所有内容分配一个大块。</p><p>如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果你有明确的证据表明性能在特定情况下很重要，那么你最好立即实施更快的方法。</p><blockquote><p>“在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。”</p></blockquote><p>通常，较简单的代码往往比复杂的代码运行更快。如果你定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。</p><h3 id="Measure-before-modifying-修改前的度量"><a href="#Measure-before-modifying-修改前的度量" class="headerlink" title="Measure before modifying 修改前的度量"></a>Measure before modifying 修改前的度量</h3><p>但是，即使你如上所述进行设计，也请假设你的系统仍然太慢。根据你对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果你开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。</p><p><strong>进行任何更改之前，请测量系统的现有行为。</strong>这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉你系统速度太慢，但不会告诉你原因。你需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及你有改进想法的地方。测量的第二个目的是提供基线，以便你可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。</p><h3 id="Design-around-the-critical-path-围绕关键路径进行设计"><a href="#Design-around-the-critical-path-围绕关键路径进行设计" class="headerlink" title="Design around the critical path 围绕关键路径进行设计"></a>Design around the critical path 围绕关键路径进行设计</h3><p>在这一点上，我们假设你已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果你可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。</p><p>不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是你的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。</p><p>首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下你正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，你可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设你可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。</p><p>理想的代码可能会与你现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。你可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。你可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。</p><p>在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此你可以为简化而不是性能来构造特殊情况的代码。</p><blockquote><p><strong>干净的设计和高性能是兼容的。</strong>重写 Buffer 类可将其性能提高 2 倍，同时简化其设计并将代码大小减少 20％。复杂的代码通常会很慢，因为它会执行多余或多余的工作。另一方面，如果你编写干净，简单的代码，则系统可能会足够快，因此你一开始就不必担心性能。在少数需要优化性能的情况下，关键再次是简单性：找到对性能最重要的关键路径并使它们尽可能简单。</p></blockquote><h2 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论 Conclusion"></a>结论 Conclusion</h2><p>复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助你识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。</p><p>所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果你不习惯于思考设计问题，那么当你学习良好的设计技巧时，你甚至会放慢脚步。如果对你而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了你实现真正的目标。</p><p>另一方面，如果良好的设计对你来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。</p><p>此外，你对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为你节省时间，因为你一遍又一遍地重复使用它们。你六个月前编写的清晰文档将为你节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，你会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。</p><p>成为优秀设计师的好处是，你可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。</p><h3 id="Summary-of-Design-Principles-设计原则摘要"><a href="#Summary-of-Design-Principles-设计原则摘要" class="headerlink" title="Summary of Design Principles 设计原则摘要"></a>Summary of Design Principles 设计原则摘要</h3><ul><li>复杂性是逐步增加的：您必须关注一些小东西（Complexity is incremental: you have to sweat the small stuff）</li><li>工作代码还不够（Working code isn’t enough）</li><li>持续进行少量投资以改善系统设计（Make continual small investments to improve system design）</li><li>模块应较深（Modules should be deep）</li><li>接口的设计应尽可能简化最常见的用法（Interfaces should be designed to make the most common usage as simple as possible）</li><li>一个模块具有一个简单的接口比一个简单的实现更重要（It’s more important for a module to have a simple interface than a simple implementation）</li><li>通用模块更深入（General-purpose modules are deeper）</li><li>通用和专用代码分开（Separate general-purpose and special-purpose code）</li><li>不同的层应具有不同的抽象（Different layers should have different abstractions）</li><li>降低复杂度（Pull complexity downward）</li><li>定义不存在的错误（和特殊情况）（Define errors (and special cases) out of existence）</li><li>设计两次（Design it twice）</li><li>注释应描述代码中不明显的内容（Comments should describe things that are not obvious from the code）</li><li>软件的设计应易于阅读而不是易于编写（Software should be designed for ease of reading, not ease of writing）</li><li>软件开发的增量应该是抽象而不是功能（The increments of software development should be abstractions, not features）</li></ul><hr><ul><li><a href="https://book.douban.com/subject/30218046/" target="_blank" rel="noopener">豆瓣《A Philosophy of Software Design》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《A-Philosophy-of-Software-Design》软件设计哲学（下）&quot;&gt;&lt;a href=&quot;#《A-Philosophy-of-Software-Design》软件设计哲学（下）&quot; class=&quot;headerlink&quot; title=&quot;《A Philo
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码规范" scheme="http://blog.michealwayne.cn/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《A Philosophy of Software Design》软件设计哲学（上）</title>
    <link href="http://blog.michealwayne.cn/2021/08/21/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AA%20Philosophy%20of%20Software%20Design%E3%80%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2021/08/21/notes/【笔记】《A Philosophy of Software Design》软件设计哲学（上）/</id>
    <published>2021-08-21T12:34:56.000Z</published>
    <updated>2021-09-14T07:02:30.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《A-Philosophy-of-Software-Design》软件设计哲学（上）"><a href="#《A-Philosophy-of-Software-Design》软件设计哲学（上）" class="headerlink" title="《A Philosophy of Software Design》软件设计哲学（上）"></a>《A Philosophy of Software Design》软件设计哲学（上）</h1><p>作者：John Ousterhout（斯坦福大学的 Bosack Lerner 计算机科学教授。他是 Tcl 脚本语言的创建者，并且以在分布式操作系统和存储系统中的工作而闻名。Ousterhout 在耶鲁大学获得了物理学学士学位，并在卡内基梅隆大学获得了计算机科学博士学位。他是美国国家工程院院士，并获得了无数奖项，包括 ACM 软件系统奖，ACM Grace Murray Hopper 奖，美国国家科学基金会总统年轻研究者奖和 UC Berkeley 杰出教学奖。）</p><p>这本书是关于如何使用复杂性来指导软件设计的整个生命周期。本文为 1 ～ 10 章笔记，后续会调整内容，给予更贴近前端的案例。</p><p>todo：案例替换；文案优化。</p><h2 id="介绍-Introduction-It’s-All-About-Complexity"><a href="#介绍-Introduction-It’s-All-About-Complexity" class="headerlink" title="介绍 Introduction(It’s All About Complexity)"></a>介绍 Introduction(It’s All About Complexity)</h2><p>编写软件的最大限制是我们了解所创建系统的能力。随着程序的发展和获得更多功能，它变得复杂，其组件之间具有微妙的依赖性。随着时间的流逝，复杂性不断累积，程序员在修改系统时将所有相关因素牢记在心中变得越来越难。这会减慢开发速度并导致错误，从而进一步延缓开发速度并增加成本。在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。</p><p>好的开发工具可以帮助我们应对复杂性。但是，仅凭工具我们只能做一部分事情。如果我们想简化编写软件的过程，从而可以更简便地构建功能，实现更强大的系统，则必须找到简化软件的方法。尽管我们尽了最大努力，但复杂度仍会随着时间的推移而增加，这时候更简单的设计使我们能够在复杂性压倒性优势之前构建更多、功能更强的系统。</p><p>有两种解决复杂性的通用方法，这会在后续说明：</p><ul><li>1.通过使代码更简单和更清晰来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性。</li><li>2.封装它，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为模块化设计。在模块化设计中，软件系统分为模块，例如面向对象语言的类。这些模块被设计为彼此相对独立，以便程序员可以在一个模块上工作而不必了解其他模块的细节。</li></ul><p>由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式来看待软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。</p><p>不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分可视化大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。</p><p>由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计、实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。</p><p>增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。</p><p>增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断地重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。</p><p>软件开发人员应始终考虑设计问题，从而降低复杂性是软件设计中最重要的要素，因此软件开发人员应始终考虑复杂性。</p><h2 id="复杂性地本质-The-Nature-of-Complexity"><a href="#复杂性地本质-The-Nature-of-Complexity" class="headerlink" title="复杂性地本质 The Nature of Complexity"></a>复杂性地本质 The Nature of Complexity</h2><p>识别复杂性的能力是至关重要的设计技能。它使你可以先找出问题，然后再付出大量努力，并可以在其他选择中做出正确的选择。判断一个设计是否简单比创建一个简单的设计要容易得多，但是一旦你认识到一个系统过于复杂，就可以使用该功能指导你的设计哲学走向简单。如果设计看起来很复杂，请尝试其他方法，看看是否更简单。随着时间的流逝，你会注意到某些技术往往会导致设计更简单，而其他技术则与复杂性相关。这将使你更快地制作更简单的设计。</p><p>复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂。<strong>如果很容易理解和修改，那就很简单。</strong></p><p>您还<strong>可以考虑成本和收益方面的复杂性</strong>。在复杂的系统中，要实施甚至很小的改进都需要大量的工作。在一个简单的系统中，可以用更少的精力实现更大的改进。</p><p>复杂性是开发人员在特定时间点在尝试实现特定目标时所经历的。它不一定与系统的整体大小或功能有关。人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，它并不复杂。当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。</p><p>复杂性取决于最常见的活动。如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。公式：<br><img src="/images/20210821/p-1.jpg" alt="p-1.jpg"></p><p>即：系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。</p><p>在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。</p><p><strong>读者比作家更容易理解复杂性。</strong>如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。当您遇到这种情况时，有必要对其他开发人员进行调查，以找出为什么代码对他们而言似乎很复杂；从您的观点与观点之间的脱节中可能可以学习一些有趣的课程。作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码。</p><p>复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。</p><ul><li><strong>变更放大</strong>：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站将横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。</li><li><strong>认知负荷</strong>：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。</li><li><strong>未知的未知</strong>：复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。下图说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。</li></ul><p><img src="/images/20210821/p-2.jpg" alt="p-2.jpg"></p><p>良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。</p><p>复杂性是由两件事引起的：<strong>依赖性和模糊性</strong>。</p><p>当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。在上图的网站示例中，背景色在所有页面之间创建了依赖关系。所有页面都必须具有相同的背景，因此，如果更改一页的背景，则必须更改所有背景。依赖关系的另一个示例发生在网络协议中。通常，协议的发送方和接收方有单独的代码，但是它们必须分别符合协议。更改发送方的代码几乎总是需要在接收方进行相应的更改，反之亦然。</p><p><strong>依赖关系是软件的基本组成部分，不能完全消除。实际上，我们在软件设计过程中有意引入了依赖性。每次编写新类时，都会围绕该类的 API 创建依赖关系。但是，软件设计的目标之一是减少依赖关系的数量，并使依赖关系保持尽可能简单和明显。</strong></p><p>考虑网站示例。在每个页面分别指定背景的旧网站中，所有网页都是相互依赖的。新的网站通过在中心位置指定背景色并提供一个 API，供各个页面在呈现它们时检索该颜色，从而解决了该问题。新的网站消除了页面之间的依赖关系，但是它围绕 API 创建了一个新的依赖关系以检索背景色。幸运的是，新的依赖性更加明显：很明显，每个单独的网页都取决于 bannerBg 颜色，并且开发人员可以通过搜索其名称轻松找到使用该变量的所有位置。此外，编译器还有助于管理 API 依赖性：如果共享变量的名称发生变化，任何仍使用旧名称的代码都将发生编译错误。新的网站用一种更简单，更明显的方式代替了一种不明显且难以管理的依赖性。</p><p>复杂性的第二个原因是晦涩（模糊性）。当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找使用该变量的位置。晦涩常常与依赖项相关联，在这种情况下，依赖项的存在并不明显。例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。不一致性也是造成不透明性的一个主要原因:如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道某个特定变量的目的是什么。</p><p>在许多情况下，由于文档不足而导致模糊不清。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是一个警告，即设计不正确。减少模糊性的最佳方法是简化系统设计。</p><p>依赖性导致变化放大和高认知负荷。晦涩会产生未知的未知数，还会增加认知负担。如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。</p><p><strong>复杂度是递增的（Complexity is incremental ）</strong>。复杂性不是由单个灾难性错误引起的；它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。</p><p>复杂性的增量性质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。为了减缓复杂性的增长。</p><blockquote><p>复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且冒险。</p></blockquote><h2 id="只写代码是不够的-Working-Code-Isn’t-Enough"><a href="#只写代码是不够的-Working-Code-Isn’t-Enough" class="headerlink" title="只写代码是不够的 Working Code Isn’t Enough"></a>只写代码是不够的 Working Code Isn’t Enough</h2><p>好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。</p><h3 id="Tactical-programming-战术编程"><a href="#Tactical-programming-战术编程" class="headerlink" title="Tactical programming 战术编程"></a>Tactical programming 战术编程</h3><p>大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。</p><p><strong>战术编程的问题是它是短视的</strong>。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。</p><p>这就是系统变得复杂的方式，如之前所说复杂度是递增的。不是使系统复杂的特定事物，而是数十或数百个小事物的积累。如果您进行战术编程，则每个编程任务都会带来一些此类复杂性。为了快速完成当前任务，他们每个人似乎都是一个合理的折衷方案。但是，复杂性迅速累积，尤其是如果每个人都在战术上进行编程的时候。<br>不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。</p><p><strong>几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风（tactical tornado）</strong>。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。</p><h3 id="Strategic-programming-战略规划-战略编程"><a href="#Strategic-programming-战略规划-战略编程" class="headerlink" title="Strategic programming 战略规划/战略编程"></a>Strategic programming 战略规划/战略编程</h3><p>成为一名优秀的软件设计师的第一步是要意识到仅写代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。</p><p>战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度。</p><p>一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。</p><p>其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。</p><p>那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。下图说明了这种现象。</p><p><img src="/images/20210821/p-3.jpg" alt="p-3.jpg"></p><blockquote><p>图解：一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时节省的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。</p></blockquote><h3 id="创业与投资"><a href="#创业与投资" class="headerlink" title="创业与投资"></a>创业与投资</h3><p>在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。</p><p>如果是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。</p><p>要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库很残酷，那么单词会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。</p><p>Facebook 是一个鼓励战术编程的创业公司的例子。多年来，公司的座右铭是“快速行动并打破困境”。鼓励刚大学毕业的新工程师立即深入公司的代码库；工程师在工作的第一周将承诺投入生产是很正常的。从积极的一面来看，Facebook 作为一家赋予员工权力的公司而享有声誉。工程师拥有极大的自由度，并且几乎没有任何规则和限制。</p><p>Facebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。</p><p>幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。</p><p>这些例子表明，一家公司可以成功使用任何一种方法。但是，在一家关心软件设计并拥有清晰代码基础的公司中工作会有趣得多。</p><blockquote><p>好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。</p></blockquote><blockquote><p>始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。</p></blockquote><h2 id="模块应该有深度的-Modules-Should-Be-Deep"><a href="#模块应该有深度的-Modules-Should-Be-Deep" class="headerlink" title="模块应该有深度的 Modules Should Be Deep"></a>模块应该有深度的 Modules Should Be Deep</h2><p>管理软件复杂性最重要的技术之一就是设计系统，以便开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为模块化设计。</p><h3 id="Modular-design-模块化设计"><a href="#Modular-design-模块化设计" class="headerlink" title="Modular design 模块化设计"></a>Modular design 模块化设计</h3><p>在模块化设计中，软件系统被分解为相对独立的模块集合。模块可以采用多种形式，例如类，子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界上，系统的复杂性就是最糟糕的模块的复杂性。</p><p>不幸的是，这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在依赖关系：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。例如，方法的参数在方法与调用该方法的任何代码之间创建依赖关系。如果必需的参数更改，则必须修改该方法的所有调用以符合新的签名。依赖关系可以采用许多其他形式，并且它们可能非常微妙。<strong>模块化设计的目标是最大程度地减少模块之间的依赖性。</strong></p><p>为了管理依赖关系，我们将每个模块分为两个部分：<strong>接口</strong>和<strong>实现</strong>。接口包含使用其他模块的开发人员必须知道的所有内容，才能使用给定的模块。通常，接口描述模块做什么，而不描述模块如何做。该实现由执行接口所承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及由给定模块调用的任何其他模块的接口。除了正在使用的模块以外，开发人员无需了解其他模块的实现。</p><p>考虑一个实现平衡树的模块。该模块可能包含复杂的代码，以确保树保持平衡。但是，此复杂性对于模块用户而言是不可见的。用户可以看到一个相对简单的接口，用于调用在树中插入，删除和获取节点的操作。要调用插入操作，调用者只需提供新节点的键和值即可。遍历树和拆分节点的机制在接口中不可见。</p><p>模块是具有接口和实现的任何代码单元。面向对象编程语言中的每个类都是一个模块。类中的方法或非面向对象语言中的函数也可以视为模块：每个模块都有一个接口和一个实现，并且可以将模块化设计技术应用于它们。更高级别的子系统和服务也是模块。它们的接口可能采用不同的形式，例如内核调用或 HTTP 请求。这本书中有关模块化设计的许多讨论都集中在设计类上，但是技术和概念也适用于其他种类的模块。</p><p>最好的模块是那些其接口比其实现简单得多的模块。这样的模块具有两个优点。首先，一个简单的接口可以将模块强加于系统其余部分的复杂性降至最低。其次，如果以不更改其接口的方式修改了一个模块，则该修改不会影响其他模块。如果模块的接口比其实现简单得多，则可以在不影响其他模块的情况下更改模块的许多方面。</p><h3 id="接口中有什么？"><a href="#接口中有什么？" class="headerlink" title="接口中有什么？"></a>接口中有什么？</h3><p>模块的接口包含两种信息：<strong>正式信息和非正式信息（formal and informal）</strong>。接口的形式部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。例如，方法的形式接口是其签名，其中包括其参数的名称和类型，其返回值的类型以及有关该方法引发的异常的信息。大多数编程语言都确保对方法的每次调用都提供正确数量和类型的参数以匹配其签名。类的形式接口包括其所有公共方法的签名以及任何公共变量的名称和类型。</p><p>每个接口还包括非正式元素。这些没有以编程语言可以理解或执行的方式指定。接口的非正式部分包括其高级行为，例如，函数删除由其参数之一命名的文件的事实。如果对类的使用存在限制（也许必须先调用一种方法），则这些约束也是类接口的一部分。通常，如果开发人员需要了解特定信息才能使用模块，则该信息是模块接口的一部分。接口的非正式方面只能使用注释来描述，而编程语言不能确保描述是完整或准确的。对于大多数接口，非正式方面比正式方面更大，更复杂。</p><p>明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。这有助于消除之前描述的“未知的未知”问题。</p><h3 id="Abstractions-抽象"><a href="#Abstractions-抽象" class="headerlink" title="Abstractions 抽象"></a>Abstractions 抽象</h3><p>术语抽象与模块化设计的思想紧密相关。抽象是实体的简化视图，其中省略了不重要的细节。抽象是有用的，因为它们使我们更容易思考和操纵复杂的事物。</p><p>在模块化编程中，每个模块以其接口的形式提供抽象。该接口提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。</p><p>在抽象的定义中，“无关紧要”（unimportant）一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，如果细节不重要，则只能将其从抽象中省略。抽象可以通过两种方式出错。首先，它可以包含并非真正重要的细节。当这种情况发生时，它会使抽象变得不必要的复杂，从而增加了使用抽象的开发人员的认知负担。第二个错误是抽象忽略了真正重要的细节。这导致模糊不清：仅查看抽象的开发人员将不会获得正确使用抽象所需的全部信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并非如此。</p><p>例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，因此它们可以确保在系统崩溃后将保留数据。因此，将数据刷新到辅助存储的规则必须在文件系统的接口中可见。</p><p>我们不仅依靠抽象来管理复杂性，而且不仅在编程中，而且在日常生活中无处不在。微波炉包含复杂的电子设备，可将交流电转换为微波辐射并将该辐射分布到整个烹饪腔中。幸运的是，用户看到了一个简单得多的抽象，它由几个按钮控制微波的定时和强度。汽车提供了一种简单的抽象概念，使我们可以在不了解电动机，电池电源管理，防抱死制动，巡航控制等机制的情况下驾驶它们。</p><h3 id="Deep-modules-深度模块"><a href="#Deep-modules-深度模块" class="headerlink" title="Deep modules 深度模块"></a>Deep modules 深度模块</h3><p><strong>最好的模块是那些提供强大功能但具有简单接口的模块</strong>。用“深入”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如下图所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的接口；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的接口后隐藏了许多功能。深度模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见。</p><p><img src="/images/20210821/p-4.jpg" alt="p-4.jpg"></p><blockquote><p>图解：深浅模块。最好的模块很深：它们允许通过简单的接口访问许多功能。浅层模块是具有相对复杂的接口的模块，但功能不多：它不会掩盖太多的复杂性。</p></blockquote><p>模块深度是考虑成本与收益的一种方式。<strong>模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口</strong>。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。最好的模块是那些收益最大，成本最低的模块。接口不错，但更多或更大的接口不一定更好！</p><p>Unix 操作系统及其后代（例如 Linux）提供的文件 I/O 机制是深层接口的一个很好的例子。I/O 只有五个基本系统调用，带有简单签名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> permissions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> referencePosition)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>开放系统调用采用分层文件名，例如<code>/a/b/c</code>，并返回一个整数文件描述符，该描述符用于引用打开文件。open 的其他自变量提供可选信息，例如是否正在打开文件以进行读取或写入，如果不存在现有文件则是否应创建新文件，以及如果创建新文件则具有文件的访问权限。读写系统调用在应用程序内存和文件的缓冲区之间传输信息。close 结束对文件的访问。大多数文件是按顺序访问的，因此这是默认设置。但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。</p><ul><li>Unix I/O 接口的现代实现需要成千上万行代码，这些代码可以解决诸如以下的复杂问题：</li><li>如何在磁盘上表示文件以便有效访问？</li><li>如何存储目录，以及如何处理分层路径名以查找它们所引用的文件？</li><li>如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？</li><li>如何实现文件访问？例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信？</li><li>在同时访问多个文件时使用什么调度策略？</li><li>如何将最近访问的文件数据缓存在内存中以减少磁盘访问次数？</li><li>如何将各种不同的辅助存储设备（例如磁盘和闪存驱动器）合并到单个文件系统中？</li></ul><p>所有这些问题，以及更多的问题，都由 Unix 文件系统实现来解决。对于调用系统调用的程序员来说，它们是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的发展，但是五个基本内核调用并没有改变。</p><p>深度模块的另一个示例是诸如 Go 或 Java 之类的语言中的垃圾收集器。这个模块根本没有接口。它在后台进行隐形操作以回收未使用的内存。由于将垃圾收集消除了用于释放对象的接口，因此向系统中添加垃圾回收实际上会缩小其总体接口。垃圾收集器的实现非常复杂，但是使用该语言的程序员无法发现这种复杂性。</p><blockquote><p>诸如 Unix I/O 和垃圾收集器之类的深层模块提供了强大的抽象，因为它们易于使用，但隐藏了巨大的实现复杂性。</p></blockquote><h3 id="Shallow-modules-浅模块"><a href="#Shallow-modules-浅模块" class="headerlink" title="Shallow modules 浅模块"></a>Shallow modules 浅模块</h3><p>另一方面，浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链表的类很浅。操作链表不需要太多代码（插入或删除元素仅需几行），因此链表抽象不会隐藏很多细节。链表接口的复杂度几乎与其实现的复杂度一样高。浅类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。</p><p>这是一个浅层方法的极端示例，该浅层方法来自软件设计类的项目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNullValueForAttribute</span><span class="params">(String attribute)</span> </span>&#123;</span><br><span class="line">    data.put(attribute, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从管理复杂性的角度来看，此方法会使情况变得更糟，而不是更好。该方法不提供任何抽象，因为其所有功能都可以通过其接口看到。例如，调用者可能需要知道该属性将存储在 data 变量中。考虑接口并不比考虑完整实现简单。如果正确记录了该方法，则文档将比该方法的代码长。与调用方直接操作数据变量相比，调用该方法所花费的击键甚至更多。该方法增加了复杂性（以供开发人员学习的新接口的形式），但没有提供任何补偿。</p><p>浅层模块是一个接口相对于其提供的功能而言复杂的模块。浅层模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。</p><h3 id="Classitis（-）"><a href="#Classitis（-）" class="headerlink" title="Classitis（?）"></a>Classitis（?）</h3><p>不幸的是，深度类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该小而不是深。经常告诉学生，类设计中最重要的事情是将较大的类分成较小的类。对于方法，通常会给出相同的建议：<strong>“任何长于 N 行的方法都应分为多种方法”（N 可以低至 10）</strong>。这种方法导致了大量的浅类和方法，这增加了整体系统的复杂性。</p><p>“类应该小”的极端做法是作者称之为“类炎”的综合症，这是由于错误地认为“类是好的，所以类越多越好”。在遭受类炎的系统中，鼓励开发人员最小化每个新类的功能：如果您想要更多的功能，请引入更多的类。分类炎可能导致个别地简单的分类，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，每个小类都有自己的接口。这些接口的累积会在系统级别产生巨大的复杂性。小类也导致冗长的编程风格，这是由于每个类都需要样板。</p><blockquote><p>通过将模块的接口与其实现分开，我们可以将实现的复杂性从系统的其余部分中隐藏出来。模块的用户只需要了解其接口提供的抽象。设计类和其他模块时，最重要的问题是使它们更深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这使隐藏的复杂性最大化。</p></blockquote><h2 id="信息隐藏-和泄漏-Information-Hiding-and-Leakage"><a href="#信息隐藏-和泄漏-Information-Hiding-and-Leakage" class="headerlink" title="信息隐藏(和泄漏)Information Hiding (and Leakage)"></a>信息隐藏(和泄漏)Information Hiding (and Leakage)</h2><h3 id="Information-hiding-信息隐藏"><a href="#Information-hiding-信息隐藏" class="headerlink" title="Information hiding 信息隐藏"></a>Information hiding 信息隐藏</h3><p>实现深层模块最重要的技术是信息隐藏。该技术最早由 David Parnas 描述。基本思想是每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其界面中，因此其他模块不可见。</p><p>隐藏在模块中的信息通常包含有关如何实现某种机制的详细信息。以下是一些可能隐藏在模块中的信息示例：</p><ul><li>如何在 B 树中存储信息，以及如何有效地访问它。</li><li>如何识别与文件中每个逻辑块相对应的物理磁盘块。</li><li>如何实现 TCP 网络协议。</li><li>如何在多核处理器上调度线程。</li><li>如何解析 JSON 文档。</li></ul><p>隐藏的信息包括与该机制有关的数据结构和算法。它还可以包含较低级别的详细信息（例如页面大小），还可以包含更抽象的较高级别的概念，例如大多数文件较小的假设。</p><p>信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。例如，使用 B-tree 类的开发人员不需要考虑树中节点的理想扇出，也不需要考虑如何保持树的平衡。其次，信息隐藏使系统更容易演化。如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖，因此与该信息相关的设计更改将只影响一个模块。例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改。</p><p><strong>设计新模块时，应仔细考虑可以在该模块中隐藏哪些信息。</strong>如果您可以隐藏更多信息，则还应该能够简化模块的界面，这会使模块更深。</p><blockquote><p>注意：通过声明变量和方法为私有来隐藏类中的变量和方法与信息隐藏不是同一回事。私有元素可以帮助隐藏信息，因为它们使无法从类外部直接访问项目。但是，有关私人物品的信息仍可以通过公共方法（如 getter 和 setter 方法）公开。发生这种情况时，变量的性质和用法就如同变量是公开的一样暴露。</p></blockquote><p>信息隐藏的最佳形式是将信息完全隐藏在模块中，从而使该信息对模块的用户无关且不可见。但是，部分信息隐藏也具有价值。例如，如果某个类的某些用户仅需要特定的功能或信息，并且可以通过单独的方法对其进行访问，以使其在最常见的用例中不可见，则该信息通常会被隐藏。与类的每个用户可见的信息相比，此类信息将创建更少的依赖项。</p><h3 id="Information-leakage-信息泄漏"><a href="#Information-leakage-信息泄漏" class="headerlink" title="Information leakage 信息泄漏"></a>Information leakage 信息泄漏</h3><p>信息隐藏的反面是信息泄漏。当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了依赖关系：对该设计决策的任何更改都将要求对所有涉及的模块进行更改。如果一条信息反映在模块的界面中，则根据定义，该信息已经泄漏；因此，更简单的界面往往与更好的信息隐藏相关。但是，即使信息未出现在模块的界面中，也可能会泄漏信息。假设两个类都具有特定文件格式的知识（也许一个类读取该格式的文件，而另一个类写入它们）。即使两个类都不在其接口中公开该信息，它们都取决于文件格式：如果格式更改，则两个类都将需要修改。</p><p>信息泄漏是软件设计中最重要的危险信号之一。作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类?”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)。</p><p>当在多个地方使用相同的知识时，例如两个都理解特定类型文件格式的不同类，就会发生信息泄漏。</p><h3 id="Temporal-decomposition-时间分解"><a href="#Temporal-decomposition-时间分解" class="headerlink" title="Temporal decomposition 时间分解"></a>Temporal decomposition 时间分解</h3><p>信息泄漏的一个常见原因是我称为时间分解的设计风格。在时间分解中，系统的结构对应于操作将发生的时间顺序。考虑一个应用程序，该应用程序以特定格式读取文件，修改文件内容，然后再次将文件写出。通过时间分解，该应用程序可以分为三类：一类用于读取文件，另一类用于执行修改，第三类用于写出新版本。文件读取和文件写入步骤都具有有关文件格式的知识，这会导致信息泄漏。解决方案是将用于读写文件的核心机制结合到一个类中。该类将在应用程序的读取和写入阶段使用。很容易陷入时间分解的陷阱，因为在编写代码时通常会想到必须执行操作的顺序。但是，大多数设计决策会在应用程序的整个生命周期中的多个不同时刻表现出来。结果，时间分解常常导致信息泄漏。</p><p>顺序通常很重要，因此它将反映在应用程序中的某个位置。但是，除非该结构与信息隐藏保持一致（也许不同阶段使用完全不同的信息），否则不应将其反映在模块结构中。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。</p><p>在时间分解中，执行顺序反映在代码结构中：在不同时间发生的操作在不同的方法或类中。如果在执行的不同点使用相同的知识，则会在多个位置对其进行编码，从而导致信息泄漏。</p><blockquote><p>信息隐藏和深层模块密切相关。如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。相反，如果一个模块没有隐藏太多信息，则它要么功能不多，要么接口复杂。无论哪种方式，模块都是浅的。<br>将系统分解为模块时，请尽量不要受运行时操作顺序的影响。这将使您沿着时间分解的路径前进，这将导致信息泄漏和模块浅。相反，请考虑执行应用程序任务所需的不同知识，并设计每个模块以封装这些知识中的一个或几个。这将产生带有深色模块的干净简单的设计。</p></blockquote><h2 id="通用模块更深入-General-Purpose-Modules-are-Deeper"><a href="#通用模块更深入-General-Purpose-Modules-are-Deeper" class="headerlink" title="通用模块更深入 General-Purpose Modules are Deeper"></a>通用模块更深入 General-Purpose Modules are Deeper</h2><p>设计新模块时，面临的最普遍的决定之一就是是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方法，在这种方法中，您将实现一种可用于解决广泛问题的机制，而不仅是当今重要的问题。在这种情况下，新机制可能会在将来发现意外用途，从而节省时间。通用方法似乎与之前讨论的投资思路一致，在这里您花了更多时间在前面，以节省以后的时间。</p><p>另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用特殊用途的方法并在以后发现更多用途，则始终可以对其进行重构以使其通用。专用方法似乎与软件开发的增量方法一致。</p><h3 id="Make-classes-somewhat-general-purpose-使类变得通用"><a href="#Make-classes-somewhat-general-purpose-使类变得通用" class="headerlink" title="Make classes somewhat general-purpose 使类变得通用"></a>Make classes somewhat general-purpose 使类变得通用</h3><p>有效的方法是以某种通用的方式实现新模块。短语“有点通用”（somewhat general-purpose）表示该模块的功能应反映您当前的需求，但其接口则不应。相反，该接口应该足够通用以支持多种用途。该界面应易于使用，以满足当今的需求，而不必专门与它们联系在一起。“有点”这个词很重要：不要被带走并建造通用的东西，以致于很难满足当前的需求。<br>通用方法最重要的（也许是令人惊讶的）好处是，与专用方法相比，它导致更简单，更深入的界面。如果您将该类用于其他目的，则通用方法还可以节省将来的时间。但是，即使该模块仅用于其原始用途，由于其简单性，通用方法仍然更好。</p><h3 id="A-more-general-purpose-API-更通用的-API"><a href="#A-more-general-purpose-API-更通用的-API" class="headerlink" title="A more general-purpose API 更通用的 API"></a>A more general-purpose API 更通用的 API</h3><p>更好的方法是使文本类更通用。仅应根据基本文本功能定义其 API，而不应反映将用其实现的更高级别的操作。</p><h3 id="Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息"><a href="#Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息" class="headerlink" title="Generality leads to better information hiding 通用性可以更好地隐藏信息"></a>Generality leads to better information hiding 通用性可以更好地隐藏信息</h3><p>通用方法在文本和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。可以添加新的用户界面功能，而无需在文本类中创建新的支持功能。通用界面还减轻了认知负担：使用用户界面的开发人员只需要学习一些简单的方法，就可以将其重复用于各种目的。</p><p>文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会阅读退格方法的代码，以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的 Backspace 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。</p><h3 id="Questions-to-ask-yourself-问自己的问题"><a href="#Questions-to-ask-yourself-问自己的问题" class="headerlink" title="Questions to ask yourself 问自己的问题"></a>Questions to ask yourself 问自己的问题</h3><p>识别干净的通用类设计要比创建一个简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。</p><p>满足我当前所有需求的最简单的界面是什么？如果减少 API 中的方法数量而不降低其整体功能，则可能正在创建更多通用的方法。专用文本 API 至少具有三种删除文本的方法：退格，删除和 deleteSelection。通用性更强的 API 只有一种删除文本的方法，可同时满足所有三个目的。仅在每种方法的 API 保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多其他参数以减少方法数量，那么您可能并没有真正简化事情。</p><p>在多少情况下会使用此方法？如果一种方法是为特定用途而设计的，例如退格方法，那是一个危险信号，它可能太特殊了。看看是否可以用一个通用方法替换几种专用方法。</p><p>这个 API 是否易于使用以满足我当前的需求？这个问题可以帮助您确定何时使 API 变得简单而通用。如果您必须编写许多其他代码才能将类用于当前用途，那么这是一个危险信号，即该接口未提供正确的功能。例如，针对文本类的一种方法是围绕单字符操作进行设计：insert 插入单个字符，而 delete 删除单个字符。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高级别的代码将包含许多循环，用于插入或删除字符范围。单字符方法对于大型操作也将是低效的。</p><blockquote><p>通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。它们还提供了类之间的更清晰的分隔，而专用接口则倾向于在类之间泄漏信息。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一。</p></blockquote><h2 id="不同的层，不同的抽象（Different-Layer-Different-Abstraction）"><a href="#不同的层，不同的抽象（Different-Layer-Different-Abstraction）" class="headerlink" title="不同的层，不同的抽象（Different Layer, Different Abstraction）"></a>不同的层，不同的抽象（Different Layer, Different Abstraction）</h2><p>软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。如果您通过调用方法遵循单个操作在层中上下移动，则每个方法调用的抽象都会改变。例如：</p><ul><li>在文件系统中，最上层实现文件抽象。文件由可变长度的字节数组组成，可以通过读写可变长度的字节范围来更新该字节。文件系统的下一个下一层在固定大小的磁盘块的内存中实现了高速缓存。调用者可以假定经常使用的块将保留在内存中，以便可以快速访问它们。最低层由设备驱动程序组成，它们在辅助存储设备和内存之间移动块。</li><li>在诸如 TCP 的网络传输协议中，最顶层提供的抽象是从一台机器可靠地传递到另一台机器的字节流。此级别在较低级别上构建，该级别可以尽最大努力在计算机之间传输有限大小的数据包：大多数数据包将成功交付，但某些数据包可能会丢失或乱序交付。</li></ul><p>如果系统包含具有相似抽象的相邻层，则这是一个红色标记，表明类分解存在问题。</p><h3 id="Pass-through-methods-直通方法"><a href="#Pass-through-methods-直通方法" class="headerlink" title="Pass-through methods 直通方法"></a>Pass-through methods 直通方法</h3><p>当相邻的层具有相似的抽象时，问题通常以直通方法的形式表现出来。直通方法是一种很少执行的方法，除了调用另一个方法（其签名与调用方法的签名相似或相同）之外。</p><p>直通方法是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与直通方法相同的 API。这通常表示各类之间没有明确的职责划分。</p><p>直通方法使类变浅：它们增加了类的接口复杂性，从而增加了复杂性，但是并没有增加系统的整体功能。</p><p>直通方法表明类之间的责任划分存在混淆。</p><p><strong>解决方案是重构类，以使每个类都有各自不同且连贯的职责</strong>。</p><p><img src="/images/20210821/p-5.jpg" alt="p-5.jpg"></p><blockquote><p>图解：直通方法。在（a）中，类 C1 包含三个直通方法，这些方法只调用 C2 中具有相同签名的方法（每个符号代表一个特定的方法签名）。可以通过使 C1 的调用方像在（b）中那样直接调用 C2，通过在 C1 和 C2 之间重新分配功能以避免在（c）中的类之间进行调用，或者通过组合在（d）中的类来消除直通方法。 。</p></blockquote><h3 id="When-is-interface-duplication-OK-接口复制何时可以？"><a href="#When-is-interface-duplication-OK-接口复制何时可以？" class="headerlink" title="When is interface duplication OK? 接口复制何时可以？"></a>When is interface duplication OK? 接口复制何时可以？</h3><p>具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。直通方法很糟糕，因为它们不提供任何新功能。</p><p>分派器是一个示例，该示例对于一种方法调用具有相同签名的另一种方法很有用。调度程序是一种使用其参数选择要调用的其他方法之一的方法。然后将其大部分或所有参数传递给所选方法。调度程序的签名通常与其调用的方法的签名相同。即便如此，调度程序仍提供有用的功能：它可以选择其他几种方法中的哪一种来执行每个任务。</p><p>例如，当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度程序，该调度程序检查传入请求中的 URL 并选择一种特定的方法来处理该请求。某些 URL 可以通过返回磁盘上文件的内容来处理。其他人则可以通过调用诸如 PHP 或 JavaScript 之类的语言的过程来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。</p><p>只要每种方法都提供有用且独特的功能，几种方法都应具有相同的签名。调度程序调用的方法具有此属性。另一个示例是具有多种实现方式的接口，例如操作系统中的磁盘驱动程序。每个驱动程序都支持不同类型的磁盘，但是它们都有相同的接口。当几种方法提供同一接口的不同实现时，它将减少认知负担。使用其中一种方法后，与其他方法一起使用会更容易，因为您无需学习新的接口。像这样的方法通常位于同一层，并且它们不会相互调用。</p><h3 id="Decorators-装饰器"><a href="#Decorators-装饰器" class="headerlink" title="Decorators 装饰器"></a>Decorators 装饰器</h3><p>装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。</p><p>装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多直通方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。</p><p>创建装饰器类之前，请考虑以下替代方法：</p><ul><li>您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。</li><li>如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？</li><li>您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。</li><li>最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。</li></ul><blockquote><p>有时装饰者很有意义，但通常有更好的选择。Sometimes decorators make sense, but there is usually a better alternative.</p></blockquote><h3 id="Interface-versus-implementation-接口与实现"><a href="#Interface-versus-implementation-接口与实现" class="headerlink" title="Interface versus implementation 接口与实现"></a>Interface versus implementation 接口与实现</h3><p>“不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。</p><p>文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能。</p><h3 id="Pass-through-variables-传递变量"><a href="#Pass-through-variables-传递变量" class="headerlink" title="Pass-through variables 传递变量"></a>Pass-through variables 传递变量</h3><p>跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。下图显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。</p><p>传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。</p><p>消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在下图的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。</p><p>另一种方法是将信息存储在全局变量中，如下图所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。</p><p>常使用的解决方案是引入一个上下文对象，如下图所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。</p><p>不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在下图的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。</p><p><img src="/images/20210821/p-6.jpg" alt="p-6.jpg"></p><blockquote><p>图解：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。</p></blockquote><p>上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。</p><blockquote><p>上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。</p></blockquote><blockquote><p>接口，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。</p></blockquote><blockquote><p>“不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如直通方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能</p></blockquote><h2 id="降低复杂性-Pull-Complexity-Downwards"><a href="#降低复杂性-Pull-Complexity-Downwards" class="headerlink" title="降低复杂性 Pull Complexity Downwards"></a>降低复杂性 Pull Complexity Downwards</h2><p>假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。哪个更好：应该让模块用户处理复杂性，还是应该在模块内部处理复杂性？如果复杂度与模块提供的功能有关，则第二个答案通常是正确的答案。大多数模块拥有的用户多于开发人员，因此开发人员遭受的苦难要大于用户。作为模块开发人员，您应该努力使模块用户的生活尽可能轻松，即使这对您来说意味着额外的工作。表达此想法的另一种方法是，模块具有简单的接口比简单的实现更为重要。</p><p>作为开发人员，很容易以相反的方式行事：解决简单的问题，然后将困难的问题推给其他人。如果出现不确定如何处理的条件，最简单的方法是引发异常并让调用方处理它。如果不确定要实施什么策略，则可以定义一些配置参数来控制该策略，然后由系统管理员自行确定最佳策略。</p><p>这样的方法短期内会使您的生活更轻松，但它们会加剧复杂性，因此许多人必须处理一个问题，而不仅仅是一个人。例如，如果一个类抛出异常，则该类的每个调用者都必须处理该异常。如果一个类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。</p><p>降低复杂性时要谨慎处理；这个想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能归为一个类，这显然没有意义。如果（a）被降低的复杂度与该类的现有功能密切相关，（b）降低复杂度将导致应用程序中其他地方的许多简化，则降低复杂度最有意义。简化了类的界面。请记住，目标是最大程度地降低整体系统复杂性。</p><blockquote><p>在开发模块时，请寻找机会减轻自己的痛苦，以减轻用户的痛苦。When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.</p></blockquote><h2 id="在一起更好还是分开更好？Better-Together-Or-Better-Apart"><a href="#在一起更好还是分开更好？Better-Together-Or-Better-Apart" class="headerlink" title="在一起更好还是分开更好？Better Together Or Better Apart?"></a>在一起更好还是分开更好？Better Together Or Better Apart?</h2><p>软件设计中最基本的问题之一是：给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？这个问题适用于系统中的所有级别，例如功能，方法，类和服务。例如，应该在提供面向流的文件 I/O 的类中包括缓冲，还是应该在单独的类中？HTTP 请求的解析应该完全在一种方法中实现，还是应该在多个方法（甚至多个类）之间划分？本章讨论做出这些决定时要考虑的因素。这些因素中的一些已经在前面的章节中进行了讨论，但是为了完整起见，这里将对其进行重新讨论。</p><p>在决定是合并还是分开时，目标是降低整个系统的复杂性并改善其模块化。看来实现此目标的最佳方法是将系统划分为大量的小组件：组件越小，每个单独的组件可能越简单。但是，细分的行为会带来额外的复杂性，而这在细分之前是不存在的：</p><ul><li>一些组件的复杂性仅来自组件的数量：组件越多，就越难以追踪所有组件，也就越难在大型集合中找到所需的组件。细分通常会导致更多接口，并且每个新接口都会增加复杂性。</li><li>细分可能会导致附加代码来管理组件。例如，在细分之前使用单个对象的一段代码现在可能必须管理多个对象。</li><li>细分产生分离：细分后的组件将比细分前的组件相距更远。例如，在细分之前位于单个类中的方法可能在细分之后位于不同的类中，并且可能在不同的文件中。分离使开发人员更难于同时查看这些组件，甚至很难知道它们的存在。如果组件真正独立，那么分离是好的：它使开发人员可以一次- 专注于单个组件，而不会被其他组件分散注意力。另一方面，如果组件之间存在依赖性，则分离是不好的：开发人员最终将在组件之间来回翻转。更糟糕的是，他们可能不了解依赖关系，这可能导致错误。</li><li>细分可能导致重复：细分之前的单个实例中存在的代码可能需要存在于每个细分的组件中。</li></ul><p>如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开。以下是两个代码相关的一些提示：</p><ul><li>他们共享信息；例如，这两段代码都可能取决于特定类型文档的语法。</li><li>它们一起使用：任何使用其中一段代码的人都可能同时使用另一段代码。这种关系形式只有在双向关系中才具有吸引力。作为反例，磁盘块高速缓存几乎总是包含哈希表，但是哈希表可以在许多不涉及块高速缓存的情况下使用。因此，这些模块应该分开。</li><li>它们在概念上重叠，因为存在一个简单的更高级别的类别，其中包括这两段代码。例如，搜索子字符串和大小写转换都属于字符串操作类别。流控制和可靠的交付都属于网络通信的范畴。</li><li>不看其中的一段代码就很难理解。</li></ul><h3 id="Bring-together-to-eliminate-duplication-消除重复"><a href="#Bring-together-to-eliminate-duplication-消除重复" class="headerlink" title="Bring together to eliminate duplication 消除重复"></a>Bring together to eliminate duplication 消除重复</h3><p>如果发现反复重复相同的代码模式，请查看是否可以重新组织代码以消除重复。一种方法是将重复的代码分解为一个单独的方法，并用对该方法的调用替换重复的代码段。如果重复的代码段很长并且替换方法具有简单的签名，则此方法最有效。如果代码段只有一两行，那么用方法调用替换它可能不会有太多好处。如果代码段与其环境以复杂的方式进行交互（例如，通过访问多个局部变量），则替换方法可能需要复杂的签名（例如，许多“按引用传递”参数），这会降低其价值。<br>消除重复的另一种方法是重构代码，使相关代码段仅需要在一个地方执行。</p><h3 id="Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码"><a href="#Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码" class="headerlink" title="Separate general-purpose and special-purpose code 单独的通用代码和专用代码"></a>Separate general-purpose and special-purpose code 单独的通用代码和专用代码</h3><p>如果模块包含可用于多种不同目的的机制，则它应仅提供一种通用机制。它不应包含专门针对特定用途的机制的代码，也不应包含其他通用机制。与通用机制关联的专用代码通常应放在不同的模块中（通常是与特定用途关联的模块）。</p><p>如果相同的代码（或几乎相同的代码）一遍又一遍地出现，那是一个危险信号，您没有找到正确的抽象。</p><p>通常，系统的下层倾向于更通用，而上层则更专用。例如，应用程序的最顶层包含完全特定于该应用程序的功能。将专用代码与通用代码分开的方法是将专用代码向上拉到较高的层，而将较低的层保留为通用。当您遇到同时包含通用功能和专用功能的同一类的类时，请查看该类是否可以分为两个类，一个包含通用功能，另一个在其上分层以提供特殊功能</p><h3 id="Splitting-and-joining-methods-拆分和合并方法"><a href="#Splitting-and-joining-methods-拆分和合并方法" class="headerlink" title="Splitting and joining methods 拆分和合并方法"></a>Splitting and joining methods 拆分和合并方法</h3><p>何时细分的问题不仅适用于类，而且还适用于方法：是否有时最好将现有方法分为多个较小的方法？还是应该将两种较小的方法合并为一种较大的方法？长方法比短方法更难于理解，因此许多人认为仅长度是分解方法的一个很好的理由。课堂上的学生通常会获得严格的标准，例如“拆分超过 20 行的任何方法！”</p><p>但是，长度本身很少是拆分方法的一个很好的理由。通常，开发人员倾向于过多地分解方法。拆分方法会引入其他接口，从而增加了复杂性。它还将原始方法的各个部分分开，如果这些部分实际上是相关的，则使代码更难阅读。您不应该分解一种方法，除非它使整个系统更加简单；我将在下面讨论这种情况。</p><p>长方法并不总是坏的。例如，假设一个方法包含按顺序执行的五个 20 行代码块。如果这些块是相对独立的，则可以一次读取并理解该方法的一个块。将每个块移动到单独的方法中并没有太大的好处。如果这些块具有复杂的交互作用，则将它们保持在一起就显得尤为重要，这样读者就可以一次看到所有代码。如果每个块使用单独的方法，则读者将不得不在这些扩展方法之间来回切换，以了解它们如何协同工作。如果方法具有简单的签名并且易于阅读，则包含数百行代码的方法就可以了。这些方法很深入（很多功能，简单的接口），很好。</p><p><img src="/images/20210821/p-7.jpg" alt="p-7.jpg"></p><blockquote><p>图解：方法（a）可以通过提取子任务（b）或将其功能划分为两个单独的方法（c）进行拆分。如果方法导致浅层方法，则不应拆分该方法，如（d）所示。</p></blockquote><p><strong>设计方法时，最重要的目标是提供简洁的抽象</strong>。每种方法都应该做一件事并且完全做到这一点。该方法应该具有简洁的接口，以便用户无需费神就可以正确使用它。该方法应该很深：其接口应该比其实现简单得多。如果一个方法具有所有这些属性，那么它的长短与否可能无关紧要。总体而言，拆分方法只有在其导致更抽象的抽象时才有意义。</p><p>应该有可能独立地理解每种方法。如果您不能不理解另一种方法的实现而无法理解一种方法的实现，那就是一个危险信号。该危险信号也可以在其他情况下发生：如果两段代码在物理上是分开的，但是只有通过查看另一段代码才能理解它们，这就是危险信号。</p><blockquote><p>拆分或加入模块的决定应基于复杂性。选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口。</p></blockquote><h2 id="定义不存在的错误-Define-Errors-Out-Of-Existence"><a href="#定义不存在的错误-Define-Errors-Out-Of-Existence" class="headerlink" title="定义不存在的错误 Define Errors Out Of Existence"></a>定义不存在的错误 Define Errors Out Of Existence</h2><p>异常处理是软件系统中最糟糕的复杂性来源之一。处理特殊情况的代码在本质上比处理正常情况的代码更难编写，并且开发人员经常在定义异常时不考虑异常的处理方式。本章讨论了为什么异常对复杂性的贡献不成比例，然后说明了如何简化异常处理。本章总的主要教训是减少必须处理异常的地方的数量。在许多情况下，可以修改操作的语义，以便正常行为可以处理所有情况，并且没有要报告的特殊条件。</p><h3 id="Why-exceptions-add-complexity-为什么异常会增加复杂性"><a href="#Why-exceptions-add-complexity-为什么异常会增加复杂性" class="headerlink" title="Why exceptions add complexity 为什么异常会增加复杂性"></a>Why exceptions add complexity 为什么异常会增加复杂性</h3><p>许多编程语言都包含一种正式的异常机制，该机制允许异常由低级代码引发并由封闭代码捕获。但是，即使不使用正式的异常报告机制，异常也可能发生，例如，当某个方法返回一个特殊值指示其未完成其正常行为时。所有这些形式的异常都会增加复杂性。</p><p>一段特定的代码可能会以几种不同的方式遇到异常：</p><ul><li>调用方可能会提供错误的参数或配置信息。</li><li>调用的方法可能无法完成请求的操作。例如，I/O 操作可能失败，或者所需的资源可能不可用。</li><li>在分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或者对等方可能会以意想不到的方式进行通信。</li><li>该代码可能会检测到错误，内部不一致或未准备处理的情况。</li></ul><p>大型系统必须应对许多特殊情况，特别是在它们是分布式的或需要容错的情况下。异常处理可以占系统中所有代码的很大一部分。</p><p>异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流;它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复数据。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化);异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。</p><p>此外，异常处理代码为更多异常创造了机会。考虑重新发送丢失的网络数据包的情况。也许该数据包实际上并没有丢失，但是只是被延迟了。在这种情况下，重新发送数据包将导致重复的数据包到达对等方；这引入了对等方必须处理的新的例外条件。或者，考虑从冗余副本恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更加微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用方。为了防止无休止的异常级联，开发人员最终必须找到一种在不引入更多异常的情况下处理异常的方法。</p><p>语言对异常的支持往往是冗长而笨拙的，这使得异常处理代码难以阅读。例如，考虑以下代码，该代码使用 Java 对对象序列化和反序列化的支持从文件中读取 tweet 的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    FileInputStream fileStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    BufferedInputStream bufferedStream = <span class="keyword">new</span> BufferedInputStream(fileStream);</span><br><span class="line">    ObjectInputStream objectStream = <span class="keyword">new</span> ObjectInputStream(bufferedStream);</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tweetsPerFile; i++) &#123;</span><br><span class="line">        tweets.add((Tweet) objectStream.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    <span class="comment">// Not a problem: not all tweet files have full</span></span><br><span class="line">    <span class="comment">// set of tweets.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是基本的 try-catch 样板代码比正常情况下的操作代码所占的代码行更多，甚至没有考虑实际处理异常的代码。很难将异常处理代码与普通情况代码相关联：例如，每个异常的生成位置都不明显。另一种方法是将代码分解为许多不同的 try 块。在极端情况下，可能会尝试尝试每行可能产生异常的代码。这样可以清楚地说明异常发生的位置，但是 try 块本身会破坏代码流，并使代码难以阅读。此外，某些异常处理代码可能最终会在多个 try 块中重复。</p><p>确保异常处理代码真正起作用是困难的。某些异常（例如 I/O 错误）在测试环境中不易生成，因此很难测试处理它们的代码。异常在运行的系统中很少发生，因此异常处理代码很少执行。错误可能会长时间未被发现，并且当最终需要异常处理代码时，它很有可能无法正常工作（我最喜欢的一句话是：“未执行的代码无效”） 。最近的一项研究发现，分布式数据密集型系统中超过 90％的灾难性故障是由错误的错误处理引起的 1。当异常处理代码失败时，很难调试该问题，因为它很少发生。</p><h3 id="Too-many-exceptions-异常过多"><a href="#Too-many-exceptions-异常过多" class="headerlink" title="Too many exceptions 异常过多"></a>Too many exceptions 异常过多</h3><p>程序员通过定义不必要的异常加剧了与异常处理有关的问题。告诉大多数程序员，检测和报告错误很重要。他们通常将其解释为“检测到的错误越多越好”。这导致了一种过分防御的风格，其中任何看起来甚至有点可疑的东西都被拒绝，并带有异常，这导致了不必要的异常的泛滥，从而增加了系统的复杂性。</p><p>试图使用异常来避免处理困难的情况很诱人：与其想出一种干净的方法来处理它，不如抛出一个异常并将问题平移给调用者。有人可能会争辩说，这种方法可以赋予调用者权力，因为它允许每个调用者以不同的方式处理异常。但是，如果您在确定特定情况下该怎么做时遇到困难，则呼叫者很可能都不知道该怎么办。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。</p><p>类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且比具有较少异常的类浅。异常是接口中特别复杂的元素。它可以在被捕获之前通过多个堆栈级别向上传播，因此它不仅影响方法的调用者，而且还可能影响更高级别的调用者（及其接口）。</p><p>抛出异常很容易；处理它们很困难。因此，异常的复杂性来自异常处理代码。减少由异常处理引起的复杂性破坏的最佳方法是减少必须处理异常的位置的数量。本章的其余部分将讨论减少异常处理程序数量的四种技术。</p><h3 id="Define-errors-out-of-existence-定义错误不存在"><a href="#Define-errors-out-of-existence-定义错误不存在" class="headerlink" title="Define errors out of existence 定义错误不存在"></a>Define errors out of existence 定义错误不存在</h3><p><strong>消除异常处理复杂性的最好方法是定义您的 API，以便没有异常要处理</strong>：定义错误而已。这似乎是牺牲品，但在实践中非常有效。</p><h3 id="Mask-exceptions-掩码异常"><a href="#Mask-exceptions-掩码异常" class="headerlink" title="Mask exceptions 掩码异常"></a>Mask exceptions 掩码异常</h3><p><strong>减少必须处理异常的地方数量的第二种技术是异常屏蔽</strong>。使用这种方法，可以在系统的较低级别上检测和处理异常情况，因此，更高级别的软件无需知道该情况。异常屏蔽在分布式系统中尤其常见。例如，在诸如 TCP 的网络传输协议中，由于各种原因（例如损坏和拥塞），可能会丢弃数据包。TCP 通过在其实现中重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将通过，并且客户端不知道丢失的数据包。</p><p>异常屏蔽并非在所有情况下都有效，但是在它起作用的情况下它是一个强大的工具。它导致了更深的类，因为它减少了类的界面（用户需要注意的异常更少）并以掩盖异常的代码形式添加了功能。异常屏蔽是降低复杂性的一个例子。</p><h3 id="Exception-aggregation-异常聚集"><a href="#Exception-aggregation-异常聚集" class="headerlink" title="Exception aggregation 异常聚集"></a>Exception aggregation 异常聚集</h3><p>减少与异常相关的复杂性的第三种技术是异常聚合。异常聚合的思想是用一个代码段处理许多异常。与其为多个单独的异常编写不同的处理程序，不如用一个处理程序将它们全部处理在一个地方。</p><p>考虑如何处理 Web 服务器中缺少的参数。Web 服务器实现 URL 的集合。服务器收到传入的 URL 时，将分派到特定于 URL 的服务方法来处理该 URL 并生成响应。该 URL 包含用于生成响应的各种参数。每个服务方法都将调用一个较低层的方法（将其称为 getParameter）以从 URL 中提取所需的参数。如果 URL 不包含所需的参数，则 getParameter 会引发异常。</p><p>当参加软件设计课程的学生实现这样的服务器时，他们中的许多人将对 getParameter 的每个不同调用包装在单独的异常处理程序中以捕获 NoSuchParameter 异常，如下图所示。这导致大量的处理程序，所有这些处理程序基本上都执行相同的操作（生成错误响应）。</p><p><img src="/images/20210821/p-8.jpg" alt="p-8.jpg"></p><blockquote><p>图解：顶部的代码将分派给 Web 服务器中的几种方法之一，每种方法都处理一个特定的 URL。每个方法（底部）都使用传入 HTTP 请求中的参数。在此图中，每个对 getParameter 的调用都有一个单独的异常处理程序。这导致重复的代码。</p></blockquote><p>更好的方法是汇总异常。让它们传播到 Web 服务器的顶级调度方法，而不是在单个服务方法中捕获异常，如下图所示。此方法中的单个处理程序可以捕获所有异常，并为丢失的参数生成适当的错误响应。</p><p>在 Web 示例中甚至可以采用聚合方法。处理网页时，除了缺少参数外，还有许多其他错误；例如，参数可能没有正确的语法（服务方法应为整数，但值为“ xyz”），或者用户可能无权执行所请求的操作。在每种情况下，错误都应导致错误响应。错误仅在响应中包含的错误消息中有所不同（“ URL 中不存在参数’数量’”或“’数量’参数的错误值’xyz’；必须为正整数”）。因此，所有导致错误响应的条件都可以使用单个顶级异常处理程序进行处理。错误消息可以在引发异常时生成，并作为变量包含在异常记录中。例如，getParameter 将生成“ URL 中不存在的参数’数量’”消息。顶级处理程序从异常中提取消息，并将其合并到错误响应中。</p><p><img src="/images/20210821/p-9.jpg" alt="p-9.jpg"></p><blockquote><p>图解：此代码在功能上等效于前一张图，但是异常处理已聚合：分派器中的单个异常处理程序从所有特定于 URL 的方法中捕获所有 NoSuchParameter 异常。</p></blockquote><p>从封装和信息隐藏的角度来看，上一段中描述的聚合具有良好的属性。顶级异常处理程序封装了有关如何生成错误响应的知识，但对特定错误一无所知。它仅使用异常中提供的错误消息。getParameter 方法封装了有关如何从 URL 提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两个信息密切相关，因此将它们放在同一位置是很有意义的。但是，getParameter 对 HTTP 错误响应的语法一无所知。随着向 Web 服务器中添加了新功能，可能会创建具有类似自身错误的新方法，如 getParameter。</p><p>此示例说明了用于异常处理的通用设计模式。如果系统处理一系列请求，则定义一个异常以中止当前请求，清除系统状态并继续下一个请求非常有用。异常被捕获在系统请求处理循环顶部附近的单个位置。在处理中止请求的任何时候都可以抛出该异常。可以为不同的条件定义异常的不同子类。应该将这种类型的异常与对整个系统致命的异常区分开来。</p><p>如果异常在处理之前在堆栈中传播了多个级别，则异常聚集最有效。这样可以在同一位置处理更多方法的更多异常。这与异常屏蔽相反：如果使用低级方法处理异常，则屏蔽通常效果最好。对于屏蔽，低级方法通常是许多其他方法使用的库方法，因此，允许传播异常会增加处理该异常的位置数。掩码和聚合的相似之处在于，这两种方法都将异常处理程序置于可以捕获最多异常的位置，从而消除了许多本来需要创建的处理程序。</p><p>考虑异常聚合的一种方法是，它用可以处理多种情况的单个通用机制替换了几种针对特定情况而量身定制的特殊用途的机制。这再次说明了通用机制的好处。</p><h3 id="Just-crash-崩溃了吗？"><a href="#Just-crash-崩溃了吗？" class="headerlink" title="Just crash? 崩溃了吗？"></a>Just crash? 崩溃了吗？</h3><p>减少与异常处理相关的复杂性的第四种技术是使应用程序崩溃。在大多数应用程序中，有些错误是不值得尝试的。通常，这些错误很难或不可能处理，而且很少发生。针对这些错误的最简单的操作是打印诊断信息，然后中止应用程序。</p><p>一个示例是在存储分配期间发生的“内存不足”错误。考虑一下 C 语言中的 malloc 函数，如果它无法分配所需的内存块，则该函数将返回 NULL。这是一个不幸的行为，因为它假定 malloc 的每个调用者都将检查返回值并在没有内存的情况下采取适当的措施。应用程序包含许多对 malloc 的调用，因此在每次调用后检查结果将增加相当大的复杂性。如果程序员忘记了检查（这很有可能），那么如果内存用完，应用程序将取消引用空指针，从而导致崩溃，从而掩盖了实际问题。</p><p>此外，当应用程序发现内存已用完时，它无能为力。原则上，应用程序可以寻找不需要的内存以释放它，但是如果应用程序有不需要的内存，它可以已经释放它，这首先可以防止内存不足错误。当今的系统具有如此大的内存，以至于内存几乎永远不会耗尽。如果是这样，通常表明应用程序中存在错误。因此，尝试处理内存不足错误几乎没有道理。这会带来太多的复杂性，而带来的收益却太少。</p><p>更好的方法是定义一个新的 ckalloc 方法，该方法调用 malloc，检查结果，并在内存耗尽时通过错误消息中止应用程序。该应用程序从不直接调用 malloc。它总是调用 ckalloc。</p><p>在较新的语言（例如 C ++和 Java）中，如果内存耗尽，则 new 运算符将引发异常。捕获此异常没有什么意义，因为异常处理程序很有可能还会尝试分配内存，这也会失败。动态分配的内存是任何现代应用程序中的基本元素，如果内存耗尽，则继续应用程序是没有意义的。最好在检测到错误后立即崩溃。</p><p>还有许多其他错误示例，这些错误会使应用程序崩溃很有意义。对于大多数程序，如果在读取或写入打开的文件时发生 I/O 错误（例如磁盘硬错误），或者无法打开网络套接字，则应用程序无济于事，因此中止了操作。清除错误消息是一种明智的方法。这些错误很少发生，因此它们不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误（如数据结构不一致），则错误消息中止也是合适的。这样的条件可能表明程序中存在错误。</p><p>在特定错误上崩溃是否可以接受取决于应用程序。对于复制的存储系统，不适合因 I/O 错误而中止。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将给程序增加相当大的复杂性，但是恢复丢失的数据是系统为用户提供的价值的重要组成部分。</p><h3 id="Design-special-cases-out-of-existence-设计特殊情况不存在"><a href="#Design-special-cases-out-of-existence-设计特殊情况不存在" class="headerlink" title="Design special cases out of existence 设计特殊情况不存在"></a>Design special cases out of existence 设计特殊情况不存在</h3><p>出于同样的原因，定义不存在的错误是有意义的，而定义其他不存在的特殊情况也是有意义的。特殊情况可能导致代码中混入 if 语句，这使代码难以理解并导致错误。因此，应尽可能消除特殊情况。做到这一点的最佳方法是设计一种普通情况，这种方式可以自动处理特殊情况而无需任何额外的代码。</p><p>通过消除“不选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，可以编写选择管理代码，而无需对“不选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节（如果正确实现，则在特殊情况下无需检查 0 字节）。同样，应该有可能设计用于删除选择的代码，以便无需任何特殊情况检查就可以处理空情况。在一行上考虑所有选择。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。</p><h3 id="Taking-it-too-far-走得太远"><a href="#Taking-it-too-far-走得太远" class="headerlink" title="Taking it too far 走得太远"></a>Taking it too far 走得太远</h3><p>定义异常或将其屏蔽在模块内部，仅在模块外部不需要异常信息时才有意义。对于本章中的示例，例如 Tcl unset 命令和 Java 子字符串方法，都是如此。在极少数情况下，呼叫者关心异常检测到的特殊情况，还有其他方法可以获取此信息。</p><p>但是，有可能使这个想法太过分。在用于网络通信的模块中，一个学生团队掩盖了所有网络异常：如果发生网络错误，则模块将其捕获，丢弃并继续进行，就好像没有问题一样。这意味着使用该模块的应用程序无法确定消息是否丢失或对等服务器是否发生故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，模块必须公开异常，即使它们增加了模块接口的复杂性。</p><p>与软件设计中的许多其他领域一样，您必须确定哪些是重要的，哪些是不重要的。不重要的事物应该被隐藏起来，它们越多越好。但是，当某件事很重要时，必须将其暴露出来。</p><blockquote><p>任何形式的特殊情况都使代码更难以理解，并增加了发生错误的可能性。本章重点讨论异常，异常是特殊情况代码的最重要来源之一，并讨论了如何减少必须处理异常的地方的数量。做到这一点的最佳方法是重新定义语义以消除错误条件。对于无法定义的异常，您应该寻找机会将它们掩盖到较低的水平，以免影响有限，或者将多个特殊情况的处理程序聚合到一个更通用的处理程序中。总之，这些技术可能会对整体系统复杂性产生重大影响。</p></blockquote><hr><ul><li><a href="https://book.douban.com/subject/30218046/" target="_blank" rel="noopener">豆瓣《A Philosophy of Software Design》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《A-Philosophy-of-Software-Design》软件设计哲学（上）&quot;&gt;&lt;a href=&quot;#《A-Philosophy-of-Software-Design》软件设计哲学（上）&quot; class=&quot;headerlink&quot; title=&quot;《A Philo
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码规范" scheme="http://blog.michealwayne.cn/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《简约之美，软件设计之道》</title>
    <link href="http://blog.michealwayne.cn/2021/08/15/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%AE%80%E7%BA%A6%E4%B9%8B%E7%BE%8E%EF%BC%8C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2021/08/15/notes/【笔记】《简约之美，软件设计之道》/</id>
    <published>2021-08-15T11:10:10.000Z</published>
    <updated>2021-08-17T08:17:06.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《简约之美，软件设计之道》笔记"><a href="#《简约之美，软件设计之道》笔记" class="headerlink" title="《简约之美，软件设计之道》笔记"></a>《简约之美，软件设计之道》笔记</h1><blockquote><p>Quality is not an act, it is a habit. ——Aristotle</p></blockquote><p>整本书看下来，全书并没有像预想一样讲解具体的软件设计，而是从软件目标出发，讲解一个优秀软件具备的素质以及基本的实现思路。不过这样更加激发了深层次的思考：软件开发者需要具备同理心，无论是面向用户还是面向其他开发者。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件设计的科学就是为软件做计划、制定决策的科学，它帮助大家做出这类决定：</p><ul><li>程序的代码应当采用什么结构？</li><li>是程序的速度重要，还是代码容易阅读重要？</li><li>为满足需求，应该选择哪种编程语言？</li></ul><p>软考系统中任何与架构有关的技术决策，以及在开发系统中所做的技术决策，都可以归到“软件设计”的范畴里。</p><p>软件的质量完全取决于<strong>机器的质量</strong>、<strong>我们想法的质量</strong>、<strong>代码的质量</strong>。（重点是代码的质量）</p><h3 id="程序员也是设计师"><a href="#程序员也是设计师" class="headerlink" title="程序员也是设计师"></a>程序员也是设计师</h3><p>每个写代码的人都是设计师，团队里的每个人都有责任保证自己的代码有着良好的设计。任何软件项目里，任何写代码的人，在任何层面上，都不能忽略软件设计。</p><p>所有开发人员都应有权在自己的工作中做出良好的设计决策。如果某位开发人员做了糟糕或者平庸的决策，资深开发人员或者首席程序员就应当推翻这些决策，重新来过。不过，软件设计的责任应当落实在真正写代码的人身上。</p><p>身为设计师，必须时时聆听建议和反馈，但是考虑了所有这些建议和反馈之后，<strong>任何决策都必须由单独的个人而不是一群人来做出。</strong></p><h3 id="软件设计的科学"><a href="#软件设计的科学" class="headerlink" title="软件设计的科学"></a>软件设计的科学</h3><p>软件设计是有章（规则）可循的，它们可以被认识，可以被理解。规则是永恒不变的，是基本的事实，而且确实可行。</p><ul><li><strong>定义（Definition）</strong>：告诉你事物是什么，应当如何使用；</li><li><strong>事实（Fact）</strong>：是关于事物的真实陈述。每一点真实的信息都是事实；</li><li><strong>条例（Rule）</strong>：是给你的确切建议，它包含某些具体的信息，用于制订决策。但是条例并不能帮你绝对准确地预测未来，也不能帮你发现其他真理。它们通常会告诉你是否需要采取某些行动；</li><li><strong>规则（Law）</strong>：<strong>最重要</strong>，是永远为真的事实，它涵盖了很多领域的知识。它们帮你发现其他重要的真理，帮你预测未来要发生的事情。</li></ul><h2 id="软件设计的推动力"><a href="#软件设计的推动力" class="headerlink" title="软件设计的推动力"></a>软件设计的推动力</h2><p>全部软件都有一个相同的目标：<strong>帮助其他人</strong>。根据具体的软件我们可以得到更加具体的目标，比如文字处理软件帮助大家编辑文档，浏览器帮助大家浏览网页。</p><p>软件要帮助的不是计算机，而是人。即便你写的是程序库，它们也是为程序员服务的，程序员也是人。</p><p>软件的目标不是“赚钱”或者“炫耀智商”。相比为帮助别人而设计的、满足其他人需求的软件，仅仅考虑狭隘目标的设计，很可能收获糟糕的软件。</p><p>一个人写出优秀软件的潜力，完全取决于他在多大程度上理解了“帮助其他人”的思想。因此在做与软件有关的决策时，指导法则就是判断能提供什么样的帮助。各项需求也可以照这个标准排出先后顺序。哪项需求能为人们提供最大的帮助，就应当赋予最高的优先级。</p><p>在评估开发或维护软件系统的建议时，<strong>“它能给用户帮多少忙”</strong>绝对是一个重要而且基础的问题。</p><blockquote><p>当然可以把赚钱当成自己或者公司的目标，这无可厚非，但它不应该是你的软件的目标。任何情况下，你所赚的钱都直接维系于你的软件能为他人提供多少帮助。事实上，决定软件公司收入的两个主要因素基本就是组织水平（包括行政、管理、推广、销售等），以及软件对他人的帮助。</p></blockquote><h3 id="软件设计科学的目标"><a href="#软件设计科学的目标" class="headerlink" title="软件设计科学的目标"></a>软件设计科学的目标</h3><p>从目标看，我们知道开发软件是为了帮助其他人。所以，软件设计科学的目标应该是：<strong>确保软件能提供尽可能多的帮助。</strong>其次，我们通常希望软件可以给大家提供持续的帮助，所以，第二个目标是：<strong>确保软件能持续提供尽可能多的帮助。</strong></p><p>实际上，<strong>编写和维护有帮助的软件的主要障碍在于设计和编程。</strong><br>如果软件很难开发或修改，程序员的主要精力就花在软件“能用”上，而没有精力去帮助用户。如果系统易于修改，程序员就会有更多的余力去帮助用户，不必费心于编程细节。同样道理，软件的维护难度越低，程序员确保软件能持续提供帮助的难度也越低。</p><p>于是，我们得到了第三个目标：<strong>设计程序员能尽可能简单地开发和维护的软件系统，这样的系统才能为用户提供尽可能多的帮助，而且能持续提供尽可能多的帮助。</strong></p><p>有时候，第一个目标（确保有帮助）和第三个目标（维护简单）是有点冲突的，为了确保有帮助，维护难度就会增加。不过纵观历史，这两个目标冲突的原因往往并不是如此。开发出完全可维护、对用户极为有用的软件，有绝对的事实依据。其实，如果你不能确保软件的可维护性，就很难实现第二个目标，也就不能持续提供帮助。这样看来，第三个目标是非常重要的，否则我们就没办法完成前两个目标。</p><blockquote><p>“尽可能简单”的意思是软件的开发和维护都应当简单，要避免困难或复杂。</p></blockquote><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>软件设计师面对的主要问题是：在设计软件时，应该做怎样的决定？哪一个才是“最”好的</p><h3 id="软件设计的方程式"><a href="#软件设计的方程式" class="headerlink" title="软件设计的方程式"></a>软件设计的方程式</h3><p>上面的问题，还包括软件设计的本质中的所有问题，都可以用下面的方程式来解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = V / E</span><br></pre></td></tr></table></figure><p>意思：<strong>任何一点改变，其合意程度与其价值成正比，与付出的成本成反比。</strong></p><p>其中：</p><ul><li>D：表示这个变化的合意程度（可取程度）。我们对此项工作的需求有多么迫切？</li><li>V：表示它的价值。该变化价值几何？一般来说，你可以问自己“这个变化对用户有多少用”；当然，还有很多其他方法来判断其价值。</li><li>E：表示完成这个变化的成本，也就是完成它需要付出的代价。</li></ul><h3 id="计算机出了什么问题？"><a href="#计算机出了什么问题？" class="headerlink" title="计算机出了什么问题？"></a>计算机出了什么问题？</h3><p>如果是软件的问题，那么有且只有一个原因：<strong>程序写得太糟糕</strong>。有些人怪罪管理，有些人怪罪客户，但调查发现问题的根源通常都在于编程。这一切都与<strong>复杂性</strong>有关。</p><h4 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h4><p>方程式中的“价值”指什么？价值最简单的定义是：<br><strong>这个变化能带给人多大帮助。</strong></p><p>所有需要帮助的人里面，最重要的是你的用户。判断每一点可能的变化的价值，基本的依据是开发人员的开发经验，还包括对用户做恰当的研究，找到对他们帮助最大的工作。</p><h5 id="价值可能性和潜在价值"><a href="#价值可能性和潜在价值" class="headerlink" title="价值可能性和潜在价值"></a>价值可能性和潜在价值</h5><p>价值由两部分组成：</p><ul><li><strong>可能价值</strong>：这个变化有多大可能帮助到用户；</li><li><strong>潜在价值</strong>：这个变化在对用户提供帮助的时候，将为用户提供多大的帮助。</li></ul><p>举个例子，比如对电子表格程序添加功能，以便盲人输入数字。盲人只占用户的很小一部分，但如果没有这个功能，他们就根本没法使用你的程序。这个功能是有价值的，因为其潜在价值很高，尽管它只对一部分有用（可能价值很低）</p><blockquote><p>能够让所有用户都微笑的功能确实是有价值的，其潜在价值很低（只能让人微笑），但是它能影响到很多人，所以它的可能价值非常高。反过来，如果某项功能只有百万分之一的可能性让某人微笑，那么它并没多少价值，这项功能的潜在价值和可能价值都很低。</p></blockquote><p>所以在判断价值时，应该考虑：</p><ul><li>多少用户（占多大比例）会从此项工作中收益？</li><li>此功能对用户有价值的可能性有多大？活着换个说法：此功能发挥价值的频率有多高？</li><li>在它发挥价值的时候，它能发挥出多大的价值？</li></ul><h5 id="平衡危害"><a href="#平衡危害" class="headerlink" title="平衡危害"></a>平衡危害</h5><p>有些改变在带来帮助的同时也会带来麻烦。比如程序要展示广告，能带来资金但会让某些人觉得麻烦。</p><p>所以需要权衡改变的价值，需要衡量它可能造成的危害，并权衡利弊。</p><h5 id="赢得用户的价值"><a href="#赢得用户的价值" class="headerlink" title="赢得用户的价值"></a>赢得用户的价值</h5><p>如果某个功能找不到用户，就不存在实际的价值。比如用户找不到活着很难使用，甚至更不就帮不上任何人。或许在将来它可能有价值，但目前没有。在多数情况下，为了确保你的软件有价值，<strong>就必须真正发布它。</strong></p><p>如果某个变化话费的时间太长，最后可能就没有任何价值，因为它不能及时发布，无法给人提供切实的帮助。在判断某项工作合意程度时，评估其发布计划是非常重要的。</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><p>成本更容易量化，但是落实起来却相当复杂。有些变化包含隐形成本，难以预测，比如花在修复开发某项功能造成的 bug 上的时间就很难预测。不过，经验丰富的软件开发人员仍然可以在不需要知道确切数值的情况下，根据可能成本来预测。</p><p>预测某个变化的成本时，重要的是要考虑牵涉到的所有投入，而不仅仅是编程的时间。研究要花多少时间？开发人员之间的沟通要花多少时间？所做的思考要花多少时间？</p><p>简单说，<strong>与这个变化有关的每一点时间，都是成本的一部分。</strong></p><h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>人们往往容易忽略时间的因素，你不但需要完成这个变化，还需要一致维护它。所有的变化都需要维护。有些工作显而易见要做维护，比如政策规则的变化。即使这项工作暂时看不到长期的维护成本，即使维护成本只是你下一年必须再做一次测试，维护成本仍然存在。<br>我们还必须考虑现在价值和未来价值。修改现有的系统时，受益的是现在的用户，但是它也可能帮助到未来的用户，甚至可能影响到未来的用户数目，进而影响到现有系统究竟总共能帮助到多少人。</p><p>有些功能的价值会随时间而变化。比如 2019 年税收计算软件在 2019 和 2020 年是有价值的，但到了 2021 年就要打折扣了。这就是随时间变化而贬值的功能。还有些功能会随时间变化而增值。</p><p><strong>成本包含实现成本和维护成本，价值也包括当前价值和未来价值。</strong>用方程式来表示就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E = Ei + Em</span><br><span class="line">V = Vn + Vf</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Ei：实现成本</li><li>Em：维护成本</li><li>Vn：当前价值</li><li>Vf：未来价值</li></ul><h4 id="完整的方程式"><a href="#完整的方程式" class="headerlink" title="完整的方程式"></a>完整的方程式</h4><p>考虑所有因素，完整的方程式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = (Vn + Vf) / (Ei + Em)</span><br></pre></td></tr></table></figure><p>用文字说明：<strong>改变的合意程度（可行性），正比于软件当前价值与未来价值之和，反比于实现成本和维护成本之和。</strong></p><h4 id="化简方程式"><a href="#化简方程式" class="headerlink" title="化简方程式"></a>化简方程式</h4><p>“未来价值”和“维护成本”都取决于时间，如果把这个方程式应用到现实中，随着时间的改变就会出现有意思的现象。</p><p>假设价值和成本都可以用金钱来衡量。“价值”指能赚多少前，“成本”指需要投入多少钱。（虽然在真实世界中不应当这样处理，但这样可以起到简化作用）。</p><p>假设要完成工作对应的方程式是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = (10000元 + 1000元/天) / (1000元 + 100元/天)</span><br></pre></td></tr></table></figure><p>即这项工作要花 1000 元完成，能马上带来 10000 元的受益。之后每一天，它都能带来 1000 元收益，而且需要花费 100 元来维护。<br>这样在 1000 天后，未来收益总计 100w 元，维护成本总计 10w 元。这时候最开始说的“当前价值”和维护成本看来就微不足道了。随着时间的流逝，它会越来越不重要，甚至完全无足轻重。于是随着时间流逝，这个方程式变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = Vf / Em</span><br></pre></td></tr></table></figure><p>其实，几乎所有软件设计的决策都完全忽略了未来价值与维护成本的对比。有时候当前价值和实现成本足够大，始终在决策中占有决定性地位，但这种情况很少见。一般来说，软件系统都需要维护很长时间，大多数情况下，未来长期收益和维护成本才是真正需要考虑的，与之相比，当前价值和实现成本变得无足轻重。</p><blockquote><p>从成本角度考虑软件成功的唯一途径：保证维护成本随时间降低，最终降到零。<strong>相比降低实现成本，降低维护成本更加重要</strong>。只要能做到这点，就无所谓未来收益是大是小。</p></blockquote><blockquote><p>理想情况下，只要未来收益高于维护成本，工作就是值得做的。所以哪怕维护成本和未来收益都增加，只要未来收益超过维护成本，也是值得做的。</p></blockquote><p>通常来说，如果要设计一个系统，其维护成本能逐渐降低，需要在实现上花很高的成本，做相当多的设计和规划。</p><h3 id="设计的质量"><a href="#设计的质量" class="headerlink" title="设计的质量"></a>设计的质量</h3><p>相比现在，将来有多得多的编程工作要做，也有更多的用户要帮助。在未来，你的软件必须保持竞争力，才能继续存在。同时，维护成本和用户数量也会增加。</p><p><strong>设计的质量好坏，正比于该系统在未来能持续帮助他人时间的长度。</strong></p><p>如果你的软件只能在未来几个小时内提供帮助，就不需要花太多的工夫去设计；如果需要在未来 10 年内都派上用场，就需要花很多精力去设计；如果举棋不定，不妨设想它要使用很长时间，然后按照这个设想去设计。<strong>不要把自己禁锢在某种工作定势里，要保持灵活；不要做任何以后无法改变的决策；在设计时要慎重，慎重，再慎重。</strong></p><blockquote><p>要做多少设计，应当正比于未来软件能够持续为人们提供帮助的时间的长度。</p></blockquote><h3 id="不可预测的结果"><a href="#不可预测的结果" class="headerlink" title="不可预测的结果"></a>不可预测的结果</h3><p>关于任何工程，都有一点极为重要：<strong>未来的某些事情，是我们所不知道的。</strong></p><p>软件设计也是如此，关于未来，大多数事情都是未知的。</p><blockquote><p>程序员犯的最常见也是最严重的错误，就是在其实不知道未来的时候去预测未来。</p></blockquote><p>预测短期未来是可能的，但长期未来基本是未知的。可是，相比短期，长期的未来对我们来说更重要，因为我们的设计决策会在未来更长的时间里产生更大的影响。</p><p>“如果完全不考虑未来，只根据当前已知的确切信息确定所有设计决策，那就百分百安全了。”这个说法听起来与之前相矛盾，但其实并非如此。在进行决策时，未来才是最重要的事情。但在进行决策时，<strong>考虑未来的变数和尝试预测未来</strong>，是有区别的。</p><p>比如做出“吃东西”还是“饿死”的决定，这并不需要预测未来才可以决策。未来是重要的，在做决策时需要考虑它，但我们不需要知道确切的未来，只要选择吃饭，不选择饿死，无论明天发生什么，都比饿死要好。</p><p>同样道理，在软件设计时，可以根据已知的信息做某些决策，目的是为了创造更好的未来（提升价值，降低维护成本），而不必预测未来究竟会发生什么具体的事情。<br>当前如果你确切知道未来短期内会发生什么，便可以据此决策。如果这么做，必须对未来有相当的把握，而且这种未来必须触手可及。</p><p>编程是把复杂问题化解为简单问题的劳动。否则一旦程序达到某种复杂程度，就没有人可以理解了。程序中复杂的不妨必须以某种简单方式组织起来。这样，不需要神那样强大的思维，普通程序员也可以开发出来。这就是编程所要用到的艺术和才能——<strong>化繁为简</strong>。</p><p>很多程序员没做到化繁为简，项目完工之后，他们把结果交给其他程序员，其他程序员又会在这之上继续增添复杂性，完成自己的工作。程序员对化解复杂性考虑得越少，程序就越难懂。</p><blockquote><p>最安全的情况是，完全不尝试预测未来，所有的设计决策都应当根据当前确切知道的信息来做。</p></blockquote><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>关于未来有哪些东西是我们能确定的呢？可以确定的一点是，随着时间的流逝，软件所处的环境会变化。软件必须随环境变化而变化，才能适应所处的环境。</p><p>于是，我们得到了变化定律（Law of Change）：<br><strong>程序存在的时间越久，它的某个部分需要变化的可能就越高。</strong></p><p>未来是无穷无尽的，所以可以百分百地肯定，最终，程序的每个部分都必须变化。<br>哪些部分会发生变化很难预测，为什么要变化也很难预测。关键在于，你并不需要去预测什么会变化，你需要知道的是，变化必然会发生。程序应该保证尽可能合理的灵活性。这样，不管未来发生什么变化，都可以应付得了。</p><p>最好的设计，就是能适应外界尽可能多的变化，而软件资深的变化要尽可能少。</p><h3 id="真实世界中程序的变化"><a href="#真实世界中程序的变化" class="headerlink" title="真实世界中程序的变化"></a>真实世界中程序的变化</h3><p>“好程序员”应当竭尽全力，把程序写得让其他程序员容易理解。因为他写的东西都很好懂，所以要找出 bug 是相当容易的。</p><p>但这个关于简单性的想法有时被误解为，程序不应当包含太多代码，或者是不应当使用先进技术。这么想是不对的。有时候大量的代码也可以带来简单，只不过增加了阅读和编写的工作量而已。你只要保证，那些大段的代码提供了化解复杂性所必须的简短注释，就足够了。同样，通常来说，更先进的技术只会让事情更简单，只是一开始得学习。</p><p>把程序写得简单所花的时间，要比写“能用就好”的程序更多。但其实花更多的时间把程序写简单，相比一开始就随意拼凑些代码再花大量的时间去理解，要快得多。</p><p>在一个软件项目中，随着时间的流逝，代码的每一行都需要修改的概率越来越大；然而你并不能精确预测要修改什么，什么时候要修改，活着要修改多少。</p><p>可参考书中变化图：</p><p><img src="/images/20210815/p-1.png" alt="p-1.png"></p><p>回顾某个特定文件修改历史。如果某个文件存在了很长时间，而且你有程序记录每个文件的修改历史，请回顾整个过程中的每次修改。问问自己最初写这个文件时，能预测到这些变化吗。要尝试理解每次修改，看看是否能从中得到一些关于软件开发的新的收获。</p><blockquote><p>好程序员和差程序员的差别就在于理解能力。差劲的程序员不理解自己做的事情，优秀的程序员则相反。好程序员应当竭尽全力把程序写得让其他程序员容易理解。</p></blockquote><h3 id="软件设计的三大误区"><a href="#软件设计的三大误区" class="headerlink" title="软件设计的三大误区"></a>软件设计的三大误区</h3><p>在落实变化法则时，软件设计师容易犯的三个错误（“三大缺陷”）：</p><ul><li>编写不必要的代码：YAGNI，You Ain’t Gonna Need It，不应该在真正的需求来临之前编写那些代码。问题：<ul><li>1.将来你可能真的需要这些代码，但是既然不能预测未来，就不知道现在该怎么使用这些代码。如果现在就编写这些代码，却不知道该怎么用，那么真的需要使用的时候就要重新设计。因此应该省下重新设计的时间，等到真正需要的时候再编写那些代码。</li><li>2.当前用不到的代码很可能会导致“劣化”。因为代码从来没有用到，它很可能与系统的其他部分脱节，继而产生 bug。<strong>不要编写不是必需的代码，并且要删除没有用到的代码。</strong></li></ul></li><li><p>代码难以修改：“僵化设计”，rigid design。也就是说程序员写出来的代码很难修改。僵化设计有两大原因：</p><ul><li>对未来做太多假设</li><li>不仔细设计就编写代码</li></ul></li></ul><p>要避免僵化设计，就应当做到：<strong>设计程序时，应当根据你现在确切知道的需求，而不是你认为未来会出现的需求。</strong></p><ul><li>过分追求通用（如果设计让事情更复杂，而不是更简单，就犯了过度工程的错误）：“过度工程”，overengineering。问题：<ul><li>1.因为不能预测未来，所以无论你做得多么通用，其实都不够满足未来要面对的真实需求。</li><li>2.如果代码很难通用，那么它通常不能从用户的角度很好地满足规格/需求。</li><li>3.太过通用就必须写很多不需要的代码，这样又回到了第一条规律。</li></ul></li></ul><p>在追求通用时，应当选择正确的事情，选择正确的方法，这是成功的软件设计的基础。然而，太过通用，会带来说不完的复杂和混乱，也会大大抬高维护成本。避免的方法和避免僵化设计的一样：<strong>仅仅根据目前确知的需求来考虑通用。</strong></p><blockquote><p>bit not，技术术语，意指随时间推移，软件劣化或丢失数据的现象。</p></blockquote><p>解决：</p><ul><li>直到真正要用了才编写代码，清理掉用不到的代码</li><li>代码的设计基础，应当是目前所知的信息，而不是你认为未来要发生的情况</li><li>在考虑通用时，只需要考虑当前的通用需求</li><li>采用渐进式开发和设计，可以避免三大缺陷。</li></ul><h3 id="渐进式开发及设计"><a href="#渐进式开发及设计" class="headerlink" title="渐进式开发及设计"></a>渐进式开发及设计</h3><p>从根本上避免这三大误区。</p><p>比如计算器程序，先实现加法，然后实现减法，再实现乘除。相比开始就建立完整的系统，一次性构建出来，这种开发方法需要时间更少，也不用考虑过多。</p><p>这个方法的精妙之处就在于，它是根据实现的顺序来决策的。总的来说，在其中的每个阶段，下一步都只做最容易的事情。</p><p>有些时候，你甚至需要把某个单独的功能拆为一系列小的、简单的逻辑步骤，然后才可以很方便地实现。显然这里混合了两种做法：一种叫做“渐进开发”，一种叫做“渐进设计”。<br>渐进开发是一种通过小步骤构建整个系统的方法。渐进设计是一种类似的方法，它也通过一系列小步骤用来创建和改进系统的设计。</p><h2 id="缺陷与设计"><a href="#缺陷与设计" class="headerlink" title="缺陷与设计"></a>缺陷与设计</h2><p>无论程序员的水平是高还是低，有一条是不变的：写的代码越多，引入的缺陷就越多。</p><p>缺陷概率法则：<strong>在程序新增缺陷的可能性与代码修改量成正比。</strong></p><p>既然存在这条规则，又无法预测未来，我们很快就会发现，相比大的变化，小的变化维护成本更低。小的变化=更少的缺陷=更少的维护。</p><p>有时候，该规则也会被飞正式地表述为：“如果不新加代码，也不修改代码，就不会产生新缺陷”。</p><p>这条规则的有趣之处在于它似乎与“变化定律”相矛盾——软件必须要变化，但是变化又会引入缺陷。这种矛盾确实存在，如何在两者间取得平衡，取决于软件设计师的聪明才智。实际上，这种矛盾恰恰说明了为什么需要设计，而且告诉我们，理想的设计是怎样的：<br><strong>最好的设计，就是能适应外界尽可能多的变化，而软件自身的变化要尽可能少。</strong></p><h3 id="如果这不是问题"><a href="#如果这不是问题" class="headerlink" title="如果这不是问题"></a>如果这不是问题</h3><p>永远不要“修正”任何东西，除非它真的有问题，而且有证据表明问题确实存在。</p><p><strong>在动手修正问题之前，获得证据是很重要的。</strong></p><p>假设有 5 名用户反馈一点按钮 app 就崩溃，那这就是足够充分的证据。但是如果只有一个用户报告错误，这不能说明就是问题，这时候需要重复实现。确实会存在用户没弄清楚到底要干什么的情况。（如果收到很多这样的请求，说明用户很难在你的程序弄清楚怎么使用，这也是要改进的地方）。</p><p>有时候用户会报告某个 bug，但程序其实是完全按照预期来运行的。果真如此的话，就应该少数服从多数，如果相当多的用户认为某个行为是 bug，它就是 bug；如果只是少数用户认为，则不算。</p><p>在这类问题上，最有名的错误就是所谓的“提前优化”，也就是说，有些开发人员想让速度尽可能快，然后在还没弄清楚速度到底慢不慢，就开始花时间来优化程序。这样很有可能是在解决根本不存在的问题。在你的程序中，真正需要关注速度的部分，应该局限于你可以证明的、真正让用户体会到有性能的那些部分，对于程序的其他部分，最主要关心的还是灵活和简洁，而不是速度。</p><h3 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h3><p><strong>理想情况下，任何系统里的任何信息，都应当只存在一次。</strong></p><p>我们不应该复制粘贴代码端；相反应该使用各种编程技巧来处理，让各处的代码可以使用（use）、调用（call）、包含（include）已有的其他代码。</p><p>遵守这条规则的一个强有力的理由，就是缺陷概率定律。如果新增功能时可以重用代码，就不需要写太多代码，引入错误的可能性也就随之减少了。这同样有益于设计的灵活性。如果我们需要更改程序的运行结构，就可以修改某一部分，而不是查遍整个程序再各处修修补补。</p><h2 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h2><p>如果希望避免代码出现新错误，可行的方法之一就是把变化的规模限定在小范围内。不过如果既要做很多修改，有希望这些变化不要引入错误，还可以增加简洁定律</p><blockquote><p>简洁定律：Law of Simplicity。<strong>软件任何一部分的维护难度，反比于该部分的简洁程度。</strong></p></blockquote><p>它不仅仅用来消除错误，还可以保持程序的可维护性，降低新增功能的难度，让代码更容易理解。</p><p>换句话说，某一部分的代码越简洁，未来进行变化的难度就越低。可能注意到了，这条法则并不关心整个系统的简洁性，只是谈到了各个部分的简洁性。原因在于：一般的计算机程序已经足够复杂了，没有人可以一次性全面理解它，大家都只能分部分逐步了解。虽然程序里大都有些庞大繁杂的结构，但这不要紧；要紧的是，在我们阅读代码时，应该可以理解这些庞大繁杂的结构。这些部分越简洁，就越容易被普通人理解。这一点非常重要。</p><p>在软件第一次编写时，采用大模块表面上可以节省下相当多的时间。如果使用众多小模块，就必须花很多时间来组合。不过由大模块构成的系统，质量要差得多。而且将来得花很多时间去修正错误，结果就是维护的难度越来越高。长期来看，能保证效率的恰恰是简单的系统。</p><p><strong>核心思想就是要让代码中各个部分都尽可能简洁，并且尽力已知保持这种简洁性。</strong></p><p>落实这条法则的一个好办法，就是渐进式开发和设计方法。因为每次添加功能之前都有个“重新设计”的过程，所以系统能持续简化。即便不用这种方法，你也可以在增添新功能之前，花点时间去化简任何让你或你的同事觉得不够简洁的代码。</p><h3 id="简洁与软件设计方程式"><a href="#简洁与软件设计方程式" class="headerlink" title="简洁与软件设计方程式"></a>简洁与软件设计方程式</h3><p>目前可行的、能够降低软件设计方程式中维护成本的最重要的事情，就是把代码变简洁。我们不必预测未来，完全可以只审视自己的代码，如果它足够复杂，就立刻动手简化它，这就是随时间推移降低维护成本的方法——持续不断地让代码变得更简洁。</p><h3 id="简洁是相对的"><a href="#简洁是相对的" class="headerlink" title="简洁是相对的"></a>简洁是相对的</h3><p>如何定义简洁取决于你的目标受众。如果你希望知道第一次看你代码的人有什么看法，不妨找些从没接触过的人来看看。所以一个不错的做法就是在自己的代码注释中加上类似“头一次看这段代码？那么。。。”这样的注释，在其中给出一些概略的解释，帮助其他人理解。写注释时应当考虑到，读者完全不了解这段程序，因为如果是你初次接触某些东西，你恐怕也对它一无所知。</p><p>繁杂的文档：只能看到大堆的链接，而没有任何头绪。这种文档对于新手来说非常复杂。</p><p>比起繁杂的文档，更糟糕的是没有文档，开发软件的人认为其他人可以自己找出问题。</p><p><strong>应用场合（上下文）</strong>也是非常重要的。在程序代码中，先进技术如果使用得当，通常会让代码简洁。但是，如果程序的复杂内部结构只有通过某个 web 网页才能看到，其他方式都不可行，这就算不上简洁了。</p><h3 id="简洁到什么程度？"><a href="#简洁到什么程度？" class="headerlink" title="简洁到什么程度？"></a>简洁到什么程度？</h3><p><strong>简单到傻子也能懂。</strong></p><p>许多程序员认为别人都愿意花很多时间来学子自己的代码，毕竟这是自己花很多时间写出来的。但这个看法是不对的，这个问题与智商无关，而与背景知识有关。第一次接触你代码的程序员完全没有任何背景知识，他必须学习。学习的难度越低，找出问题的速度就越快，使用起来也就越容易。</p><p>降低代码学习难度的方法有很多：简单的注释，简单的设计，循序渐进的引导等到。</p><p>简单仍然是相对的，你的代码的目标受众不是家人，而是其他程序员。</p><h3 id="保持一致"><a href="#保持一致" class="headerlink" title="保持一致"></a>保持一致</h3><p>如果代码不能保持一致，程序员理解和阅读起来都要更加困难。</p><p>就像以下两句话：</p><p><img src="/images/20210815/p-2.png" alt="p-2.png"></p><p>在编程时，有时候你做什么并不重要，只要一直保持相同的方式去做即可。</p><ul><li>命名一致</li><li>行为一致。</li></ul><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>代码被阅读的次数远多余编写和修改的次数。所以保证代码容易阅读很重要。</p><p><strong>代码可读性主要取决于字母和符号之间的空白排布。</strong></p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><strong>名字应当足够长，能够完整表达其意义或描述其功能，但不能太长，以免影响阅读。</strong><br>同时还应当考虑函数、变量等的使用频率。在代码中使用这些名字是否会导致代码过长而影响阅读。比如某个函数会经常在复杂表达式用到，大概就该去一个稍微短一点的名字。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>代码的意图通常不应该用注释来说明，直接阅读代码就应当能够理解。如果发现意图不够明显，那么就说明这段代码还可以变得更简单。如果实现不能更简单，才应该写注释来说明。</p><p>注释的真实目的，是在理由不够清晰明显时加以解释。如果不解释，其他程序员在修改这段代码时可能胡很困惑。</p><h3 id="简洁离不开设计"><a href="#简洁离不开设计" class="headerlink" title="简洁离不开设计"></a>简洁离不开设计</h3><p>设计中的缺陷是大家都看得到的，但逐步演变为良好设计的改进过长，却是不熟悉代码的人看不到的。</p><h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><p>两个典型的例子：<br><img src="/images/20210815/p-3.png" alt="p-3.png"></p><p>这些问题的根源都在复杂性。开始的时候项目是简单的，只要一个月就能完成；然后复杂性就增加了，于是需要三个月时间；再然后就更复杂了。</p><p>复杂性是会叠加的，而且不是简单的线性叠加。原有功能越多，新增功能的成本就越高。优秀的设计可以尽量避免此类问题，但每项新功能仍然会有单独但成本。</p><p>有些项目从一启动就设定了繁多的需求，所以永远无法发布第一版。如果遇到这种情况，就应当删减功能。初次发布不应当设定过高的目标，而应当先让程序跑起来，再持续改进。</p><p>除了新增功能外，还有一些做法会增加复杂性：</p><ul><li>扩展软件的用途</li><li>新增程序员：可见人月神话</li><li>做无谓的改变</li><li>困于糟糕的技术</li><li>理解错误</li><li>糟糕的设计或不做设计</li><li>重复发明轮子。只有满足以下任何一个条件的前提下，发明轮子才有价值：<ul><li>你需要的东西不存在；</li><li>现有各种“轮子”都很糟糕，会把你困住；</li><li>现有的各种“轮子”根本无法满足你的需求；</li><li>现有的“轮子”缺乏良好的维护，而你也不能接过维护的任务（比如没有源码）</li></ul></li></ul><h3 id="复杂性与软件的用途"><a href="#复杂性与软件的用途" class="headerlink" title="复杂性与软件的用途"></a>复杂性与软件的用途</h3><p>如果你给系统添加新功能去满足其他目标，事情就立刻变复杂了。<br>同样重要的是要思考用户的需求。用户之所以要使用软件，总是有自己的需求。理想情况下，软件的用途应当接近用户的需求。</p><p>有时候，运营人员活着经理会给软件设定一些目标，但是这些目标其实并不符合程序的基本用途，比如“要好玩一些”、“设计要有冲击感”、“要受新媒体欢迎”、“要使用最新的技术”等。身为软件设计师或是技术经理，你的职责是保证软件的基本用途，防止它偏离正规。有时候，你可能需要为此据理力争，但从长期来看，这肯定是值得的。</p><p>没有必要玩太多花样，做太复杂，尝试用单个软件瞬间完成 500 个任务。<strong>最受用户喜欢的软件是专注而简洁的，而且始终执着于基本用户。</strong></p><h3 id="糟糕的技术"><a href="#糟糕的技术" class="headerlink" title="糟糕的技术"></a>糟糕的技术</h3><p>可以通过三个因素来判断技术是否糟糕：</p><ul><li>生存潜力：就是技术持续获得维护的可能性。要了解生存潜力，可以查阅其最近的发布记录。开发者是否频繁地发布真正解决了客户问题的新版本？开发者对 bug 报告的响应有多积极？他们是否有活跃的邮件列表或支持团队？是否有足够的人在线谈论这项技术？</li><li>互通性：如果需要，从一种技术切换到另一种技术有多难。要了解技术的互通性，就得问问自己，能不能以某种标准方式来交互，这样是否能更容易得切换到遵循同样标准的系统中。</li><li>对品质的重视：更主观的衡量，其思想是考察最近的发布中，产品是否更加完善了。</li></ul><h3 id="复杂性及错误的解决方案"><a href="#复杂性及错误的解决方案" class="headerlink" title="复杂性及错误的解决方案"></a>复杂性及错误的解决方案</h3><p>比如有人问你：如果让马飞上月球。这时候就要返回：要解决的究竟是什么问题。有可能这个人真正需要的其实是收集一些石头，那么解决方案就很简单：去室外找一找就好。</p><p>所以，如果事情变复杂，不妨回过头去看看真正要解决的是什么问题。你可以退上一大步，也可以质疑任何问题，真正要做的就是找出自己所处环境中最好的办法。<br>要做到这一点，不应当依靠猜测，而必须亲眼去看要解决的问题。确认你真正理解了问题的方方面面，找到最简单的解决办法。</p><h3 id="复杂问题"><a href="#复杂问题" class="headerlink" title="复杂问题"></a>复杂问题</h3><p>在复杂性面前，问问自己“真正要解决的问题是什么”。大多数麻烦的设计问题，都可以用在纸上画图或写出来的办法找到答案。</p><h3 id="应对复杂性"><a href="#应对复杂性" class="headerlink" title="应对复杂性"></a>应对复杂性</h3><p>要应付系统中的复杂性，如果系统中某个部分太过复杂，可以将系统分解成为独立的小部分，逐步重新设计。<br>不过这个过程中最大的危险是：新作的修改有可能会引入更多的复杂性。<br>如果所有的代码都包含在一个巨大的文件里，改进的第一步就是把某个部分保存到单独的文件里。之后改进这个小部分的设计，然后把另一个部分保存到新的文件，再改进这个部分的设计。如此重复下去，最终得到的就是可靠的、可理解的、可维护的系统。<br>所有可行的简化，其核心问题都是：怎么做，才可以让事情处理或是理解起来更容易。</p><p>平衡开发新功能和应对复杂性最好的一个办法是，重新设计时只考虑让新功能更容易实现，然后实现这个功能。这样，你就可以在重新设计和开发新功能直接定期切换。</p><h4 id="把某个部分变简单"><a href="#把某个部分变简单" class="headerlink" title="把某个部分变简单"></a>把某个部分变简单</h4><p>学习设计模式和设计方法来处理遗留代码，学习软件工程师普遍使用的工具，都可以帮上大忙，尤其是掌握多门编程语言，熟悉多种不同的类库。</p><h4 id="不可解决的复杂性"><a href="#不可解决的复杂性" class="headerlink" title="不可解决的复杂性"></a>不可解决的复杂性</h4><blockquote><p>如果遇到不可解决的复杂性，<strong>在程序外面妥善包装上一层</strong>，让其他程序员更容易使用和理解。</p></blockquote><h3 id="推倒重来"><a href="#推倒重来" class="headerlink" title="推倒重来"></a>推倒重来</h3><p>把系统推倒重来，几乎就是设计师承认失败。<br>推倒重来只有在一些非常有限的情况下才是可以接受的。</p><ul><li>已经完成了准确评估，证明重写系统会比重新设计现有系统更有效率。</li><li>有足够的时间</li><li>要比原有系统的设计师更高明，活着原有设计是你，现在设计能力已经大大提升</li><li>完全打算好了通过一系列简单的步骤设计整个新系统，每一步都有用户提供反馈</li><li>有足够的资源，可坚固维护原有系统和重新设计系统。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>测试定律：Law of Testing，你对软件行为的了解程度，等于你真正测试它的程序。除非亲自测试过，否则你不知道软件是否能正常运行。</p></blockquote><p>除非亲自测试过，否则你不知道软件是否能正常运行。<br>针对每项测试，你必须问一个具体的问题，得到一个具体的答案。如果还有其他的答案，那么软件就是不能正常运行的。</p><p>无论程序员多么聪明，也无论有多少理论数据来证明你的代码是正确的，在没有切实测试过之前，你都不知道它能不能正常工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《简约之美，软件设计之道》笔记&quot;&gt;&lt;a href=&quot;#《简约之美，软件设计之道》笔记&quot; class=&quot;headerlink&quot; title=&quot;《简约之美，软件设计之道》笔记&quot;&gt;&lt;/a&gt;《简约之美，软件设计之道》笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Quali
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
</feed>
