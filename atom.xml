<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wayne的博客</title>
  
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.michealwayne.cn/"/>
  <updated>2023-02-14T07:29:10.795Z</updated>
  <id>http://blog.michealwayne.cn/</id>
  
  <author>
    <name>Micheal Wayne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【笔记】2022 跨端及小程序的一些文章书籍等整理</title>
    <link href="http://blog.michealwayne.cn/2023/02/11/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%912022%E8%B7%A8%E7%AB%AF%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E7%AB%A0%E4%B9%A6%E7%B1%8D%E7%AD%89%E6%95%B4%E7%90%86/"/>
    <id>http://blog.michealwayne.cn/2023/02/11/notes/【笔记】2022跨端及小程序的一些文章书籍等整理/</id>
    <published>2023-02-11T08:34:21.000Z</published>
    <updated>2023-02-14T07:29:10.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】2022-跨端及小程序的一些文章书籍等整理"><a href="#【笔记】2022-跨端及小程序的一些文章书籍等整理" class="headerlink" title="【笔记】2022 跨端及小程序的一些文章书籍等整理"></a>【笔记】2022 跨端及小程序的一些文章书籍等整理</h1><p>*借近期 QCon 大会上华为卡片分享的图：</p><p><img src="/images/20230211/p-timeline.png" alt="p-timeline"></p><h2 id="一-文章"><a href="#一-文章" class="headerlink" title="一.文章"></a>一.文章</h2><h3 id="跨端主题"><a href="#跨端主题" class="headerlink" title="跨端主题"></a>跨端主题</h3><ul><li><strong>《语雀 App 跨端技术架构实践》</strong>：“支付宝体验科技”团队<ul><li>地址：<a href="https://juejin.cn/post/7166549441066106917" target="_blank" rel="noopener">https://juejin.cn/post/7166549441066106917</a></li><li>个人短评：较全面的应用级架构介绍；跨移动、PC、服务端，移动端依赖蚂蚁集团 mPaaS 框架。</li></ul></li><li><strong>《优酷卡片跨端解决方案》</strong>：“阿里文娱技术”团队<ul><li>地址：<a href="https://juejin.cn/post/7159035261295263758/" target="_blank" rel="noopener">https://juejin.cn/post/7159035261295263758/</a>、<a href="https://youku-gaiax.github.io/" target="_blank" rel="noopener">https://youku-gaiax.github.io/</a></li><li>个人短评：面向卡片业务的一种解决方案；跨 iOS、Android，性能优灵活性存在短板；</li></ul></li><li><strong>《支付宝动态化卡片技术研发工具 ACT 的演进之路 | Cube 卡片技术栈》</strong>：“支付宝体验科技”团队<ul><li>地址：<a href="https://mp.weixin.qq.com/s/KJOOEMGOPxqCiVYdFfM3mw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KJOOEMGOPxqCiVYdFfM3mw</a></li><li>个人短评：面向卡片业务的一种解决方案；跨 iOS、Android，生态完备性能还可以</li></ul></li><li><strong>《Flutter for Web 首次首屏优化——JS 分片优化》</strong>：“阿里巴巴终端技术”团队<ul><li>地址：<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247498513&amp;idx=1&amp;sn=0173c8f1447cedf1d4c79fb1dd5fd62a&amp;chksm=cf58e48df82f6d9bab9fd2ff39a8ef37e3923b199bce246b2562366022fb631ab3acc589b832&amp;scene=178&amp;cur_album_id=1803248897750827020#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247498513&amp;idx=1&amp;sn=0173c8f1447cedf1d4c79fb1dd5fd62a&amp;chksm=cf58e48df82f6d9bab9fd2ff39a8ef37e3923b199bce246b2562366022fb631ab3acc589b832&amp;scene=178&amp;cur_album_id=1803248897750827020#rd</a></li><li>个人短评：Flutter Web 的性能优化实践，面向的域比较窄。</li></ul></li><li><strong>《跨端开发浪潮中的变与不变》</strong>：“阿里巴巴终端技术”团队<ul><li>地址：<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247498409&amp;idx=1&amp;sn=02a5d9a2ebc41e75b4526e9ddcbeacfe&amp;chksm=cf58e535f82f6c230a01cedcc7bbf5d578ab850cfd38e971513f69d4332943e33b5e40eb234e&amp;scene=178&amp;cur_album_id=1803248897750827020#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247498409&amp;idx=1&amp;sn=02a5d9a2ebc41e75b4526e9ddcbeacfe&amp;chksm=cf58e535f82f6c230a01cedcc7bbf5d578ab850cfd38e971513f69d4332943e33b5e40eb234e&amp;scene=178&amp;cur_album_id=1803248897750827020#rd</a></li><li>个人短评：跨端技术方案的选型分析，比较粗。</li></ul></li><li><strong>《如何持续突破性能表现？DX 性能优化策略详解》</strong>：“阿里巴巴终端技术”团队<ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247494878&amp;idx=1&amp;sn=5a27f946bf49a5532dc130a3c5db9a9b&amp;chksm=cf58f342f82f7a54743327bc6bccc27cbc9edcd9da93e61aa1fd8c2def1183e8b27e4d6cd6e5&amp;scene=178&amp;cur_album_id=1803248897750827020#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247494878&amp;idx=1&amp;sn=5a27f946bf49a5532dc130a3c5db9a9b&amp;chksm=cf58f342f82f7a54743327bc6bccc27cbc9edcd9da93e61aa1fd8c2def1183e8b27e4d6cd6e5&amp;scene=178&amp;cur_album_id=1803248897750827020#rd</a></li><li>个人短评：淘宝 Dx 跨端容器的性能优化方案，偏端侧。</li></ul></li><li><strong>《Dutter | 钉钉 Flutter 跨四端方案设计与技术实践》</strong>：“阿里巴巴终端技术”团队<ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247494871&amp;idx=1&amp;sn=a8a79267010cb3aeecd76bbc0eb6569e&amp;chksm=cf58f34bf82f7a5dfb32c4b38dbab57efd153b7c40e3b40f1fdd9fe639eba8833ec5d9f8bfef&amp;scene=178&amp;cur_album_id=1803248897750827020#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247494871&amp;idx=1&amp;sn=a8a79267010cb3aeecd76bbc0eb6569e&amp;chksm=cf58f34bf82f7a5dfb32c4b38dbab57efd153b7c40e3b40f1fdd9fe639eba8833ec5d9f8bfef&amp;scene=178&amp;cur_album_id=1803248897750827020#rd</a></li><li>个人短评：Flutter 的跨端架构实践，比较全面。</li></ul></li><li><strong>《使用跨端解决方案 Rax 编写鸿蒙应用》</strong>：“阿里巴巴终端技术”团队<ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247490116&amp;idx=1&amp;sn=29efb8e1cd9b56653145ecba1f9362ca&amp;chksm=cf5b05d8f82c8cce6c58d0f8841dc54e7e6c04e2ba8677d3a5674b3cb3ea41d1638071187a93&amp;scene=178&amp;cur_album_id=1803248897750827020#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&amp;mid=2247490116&amp;idx=1&amp;sn=29efb8e1cd9b56653145ecba1f9362ca&amp;chksm=cf5b05d8f82c8cce6c58d0f8841dc54e7e6c04e2ba8677d3a5674b3cb3ea41d1638071187a93&amp;scene=178&amp;cur_album_id=1803248897750827020#rd</a></li><li>个人短评：Rax 对 HarmonyOS 的跨端适配方案，不过没有适配 OpenHarmony。</li></ul></li><li><strong>《从大前端“穿越”到终端，开发者应该必备什么技能？ | 解读终端的 2022》</strong>：InfoQ<ul><li><a href="https://mp.weixin.qq.com/s/OIcMaMxZwTMiLTNLS7rqMg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OIcMaMxZwTMiLTNLS7rqMg</a></li><li>比较杂，不仅是跨端、也提了低代码、3D 等。</li></ul></li><li><strong>《Hybrid 远程调试的前世今生》</strong>：字节“西瓜前端技术团队”<ul><li><a href="https://mp.weixin.qq.com/s/rm_7vNNhd4WukjHRW0cl0w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rm_7vNNhd4WukjHRW0cl0w</a></li><li>个人短评：hybrid web 的相关调试方案，较全面。</li></ul></li><li><strong>《雪球跨端架构建设之跨端容器篇》</strong>：“雪球大前端团队”<ul><li><a href="https://mp.weixin.qq.com/s/7WU1DDoMYQzXnlstz16QJA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7WU1DDoMYQzXnlstz16QJA</a></li><li>个人短评：雪球 app 的移动跨端架构，RN。</li></ul></li><li><strong>《解决页面间体验问题的纯前端容器 Lath》</strong>：“大淘宝技术”团队<ul><li><a href="https://mp.weixin.qq.com/s/tMVSOHi7tH_c6NEVsbMVSQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tMVSOHi7tH_c6NEVsbMVSQ</a></li><li>个人短评：hybrid 的容器层面优化，解决性能及体验问题。</li></ul></li><li><strong>《跨端技术的本质与现状》</strong>：“前端大全”<ul><li><a href="https://mp.weixin.qq.com/s/8RWhpGIG469Mq43UMxcsqw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8RWhpGIG469Mq43UMxcsqw</a></li><li>个人短评：各类移动跨端技术的浅层次分析整理。</li></ul></li><li><strong>《APP 常用跨端技术栈深入分析》</strong>：“京东技术”<ul><li><a href="https://mp.weixin.qq.com/s/-IoiOSSMOORzZXLUiZsGtw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-IoiOSSMOORzZXLUiZsGtw</a></li><li>个人短评：Flutter、RN、Hybrid、Weex 移动跨端方案的对比分析，附加了点性能优化。</li></ul></li><li><strong>《跨端技术的本质是什么？现状如何？》</strong>：Tecvan<ul><li><a href="https://mp.weixin.qq.com/s/VGZVnoTGT6BTS101jOPiQw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VGZVnoTGT6BTS101jOPiQw</a></li><li>个人短评：主要讲了 RN 和小程序技术的跨端原理和现状，有一定深度的</li></ul></li><li><strong>《19 条跨端 cpp 开发有效经验总结》</strong>：“大淘宝技术”团队<ul><li><a href="https://mp.weixin.qq.com/s/tPN06K8Srjhx_k6Uyj5RLQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tPN06K8Srjhx_k6Uyj5RLQ</a></li><li>个人短评：端侧的编码经验。</li></ul></li><li><strong>《Flutter 3.0 发布啦～快来看看有什么新功能-2022 Google I/O》</strong>：<ul><li><a href="https://juejin.cn/post/7096617842023333925" target="_blank" rel="noopener">https://juejin.cn/post/7096617842023333925</a></li><li>个人短评：Flutter 3.0 主要包括 macOS 和 Linux 的稳定版发布，以及相关的性能改进等。</li></ul></li><li><strong>《如何打造高质量的 Electron 应用？》</strong>：“蚂蚁集团语雀”<ul><li><a href="https://www.yuque.com/seeconf/2022/kr8mdw" target="_blank" rel="noopener">https://www.yuque.com/seeconf/2022/kr8mdw</a></li><li>个人短评：语雀 PC 跨端 Electron 架构的分享。</li></ul></li></ul><h3 id="小程序主题"><a href="#小程序主题" class="headerlink" title="小程序主题"></a>小程序主题</h3><ul><li><strong>《阿拉丁：2022 上半年小程序互联网发展白皮书》</strong>：<ul><li><a href="http://www.199it.com/archives/1475227.html" target="_blank" rel="noopener">http://www.199it.com/archives/1475227.html</a></li><li>个人短评：小程序 2022 上半年行业生态的分析，非技术。</li></ul></li><li><strong>Antmove</strong> - 小程序转换器，基于支付宝/微信小程序转换为多端小程序：<ul><li><a href="https://ant-move.github.io/" target="_blank" rel="noopener">https://ant-move.github.io/</a></li><li>个人短评：一项各类小程序相互转化的工具。</li></ul></li><li><strong>微信小程序新渲染引擎 Skyline</strong>：<ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html</a></li><li>个人短评：小程序性能一大痛点就是 webview，微信在 22 年开启了自绘的模式，估计也是小程序技术趋势的象征。</li></ul></li><li><strong>《Svelte 不支持小程序开发？我不允许！》</strong>：“Taro 社区”<ul><li><a href="https://mp.weixin.qq.com/s/KGaBqTrO4PUp3JZXyx5wzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KGaBqTrO4PUp3JZXyx5wzg</a></li><li>个人短评：得益于 Taro3 运行时的跨端原理，多技术语言的适配变得容易。</li></ul></li><li><strong>《京东快递小程序分包优化实践》</strong>：“Taro 社区”<ul><li><a href="https://mp.weixin.qq.com/s/7In3QTzXEBcAPtYp3bk5Eg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7In3QTzXEBcAPtYp3bk5Eg</a></li><li>个人短评：小程序分包实践的一个案例。</li></ul></li><li><strong>《飞猪微信小程序建设总结》</strong>：“阿里巴巴终端技术”团队<ul><li><a href="https://mp.weixin.qq.com/s/5JNCkBDfCNlO-eZMp8pvqw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5JNCkBDfCNlO-eZMp8pvqw</a></li><li>个人短评：飞猪业务小程序建设的实践分享，偏项目级。</li></ul></li><li><strong>《2022.07.01 w3c 小程序规范白皮书》</strong>：w3c<ul><li><a href="https://www.w3.org/TR/2022/DNOTE-mini-app-white-paper-20220701/#abstract" target="_blank" rel="noopener">https://www.w3.org/TR/2022/DNOTE-mini-app-white-paper-20220701/#abstract</a></li><li>个人短评：共同推进小程序规范的标准文档。</li></ul></li><li><strong>《我把微信小程序转为 App 上架到了 App Store》</strong>：FinClip<ul><li><a href="https://juejin.cn/post/7135253044270202893" target="_blank" rel="noopener">https://juejin.cn/post/7135253044270202893</a></li><li>个人短评：FinClip 小程序容器技术能力的体现。</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>《端智能在大众点评搜索重排序的应用实践》</strong>：“美团技术”团队<ul><li><a href="https://tech.meituan.com/2022/06/16/edge-search-rerank.html" target="_blank" rel="noopener">https://tech.meituan.com/2022/06/16/edge-search-rerank.html</a></li><li>个人短评：大众点评搜索在边缘计算方向的一次实践，端智能重排序。</li></ul></li><li><strong>《跨端智能在蚂蚁的应用》</strong>：“蚂蚁集团前端”<ul><li><a href="https://www.yuque.com/seeconf/2022/yclyag" target="_blank" rel="noopener">https://www.yuque.com/seeconf/2022/yclyag</a></li><li>个人短评：端侧图像识别分析算法的一个实践。</li></ul></li><li><strong>《终端新玩法：技术栈无关的剧本式引导》</strong>：“美团技术”团队<ul><li><a href="https://tech.meituan.com/2022/04/07/waimai-application-scripted-guidance.html" target="_blank" rel="noopener">https://tech.meituan.com/2022/04/07/waimai-application-scripted-guidance.html</a></li><li>个人短评：美团外卖终端团队在用户心智建设领域的探索与实践，通过识别算法产生用户引导能力。</li></ul></li><li><strong>《2023 年大淘宝 Web 端技术概览》</strong>：“大淘宝技术”团队<ul><li><a href="https://mp.weixin.qq.com/s/KjYfGqKPjaq6bWTFiys1Jg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KjYfGqKPjaq6bWTFiys1Jg</a></li><li>个人短评：淘宝前端整体技术框架能力讲解。</li></ul></li></ul><hr><h2 id="二-书籍"><a href="#二-书籍" class="headerlink" title="二.书籍"></a>二.书籍</h2><h3 id="《闲鱼技术-2022-年度白皮书》"><a href="#《闲鱼技术-2022-年度白皮书》" class="headerlink" title="《闲鱼技术 2022 年度白皮书》"></a>《闲鱼技术 2022 年度白皮书》</h3><blockquote><p>“这本技术精选系统化地阐述了闲鱼技术过去一年对以上问题的思考，以及落地的演进路线和探索实践。对于越来越年轻化的闲鱼，适逢新消费趋势与新技术爆发的拐点，这些也是闲鱼技术身处时代洪流、承前启后进一步突破的阶段性回顾与小结，希望能给更多年轻的技术人和创新者带去些许启发。 电子书包含 flutter 专题、kun 专题、服务端专题以及技术质量专题。”</p></blockquote><p>下载地址：<a href="https://developer.aliyun.com/ebook/7885?spm=a2c6h.20345107.ebook-index.25.44557863bfCm4O" target="_blank" rel="noopener">https://developer.aliyun.com/ebook/7885?spm=a2c6h.20345107.ebook-index.25.44557863bfCm4O</a></p><p>主要跨端相关文章：</p><ul><li>Flutter 主题系列<ul><li>《节日献礼：Flutter 图片库重磅开源！》 Page7</li><li>《打造 Flutter 高性能富文本编辑器——协议篇》 Page19</li><li>《打造 Flutter 高性能富文本编辑器——渲染篇》 Page28</li><li>《Flutter 富文本编辑器系列文章 3——交互篇》 Page41</li><li>《Flutter 知识小报》 Page54</li></ul></li><li>KUN 容器主题系列<ul><li>《这一年，我对终端组织与技术架构的思考》【专家讲技术】 Page65</li><li>《大终端领域的新物种-KUN》 Page77</li><li>《三代终端容器 KUN 的首次大考》【架构演进】 Page94</li></ul></li></ul><h3 id="《2022-技术人的百宝黑皮书》"><a href="#《2022-技术人的百宝黑皮书》" class="headerlink" title="《2022 技术人的百宝黑皮书》"></a>《2022 技术人的百宝黑皮书》</h3><blockquote><p>“大淘宝技术 2022 一年干货内容合集。过去一年，我们尝试在分享的过程中，对自己做过的工作进行系统性的总结和提炼，升华自己对技术深度的理解；更希望能够与同行交流互动，共同关注业务的差异性、技术思考的不同路径、技术的困难挑战以及对未来的思考。本书内容包含【大淘宝最新实战经验&amp;技术解决方案】、【技术人推荐学习的 github 项目、大淘宝最新 paper】、【工程师成长经验总结&amp;金句回顾】。”</p></blockquote><p>下载地址：<a href="https://developer.aliyun.com/ebook/7875?spm=a2c6h.20345107.ebook-index.20.2dcc5b32XrhYmN" target="_blank" rel="noopener">https://developer.aliyun.com/ebook/7875?spm=a2c6h.20345107.ebook-index.20.2dcc5b32XrhYmN</a></p><p>主要跨端相关文章：</p><ul><li>终端系列文章-技术经典总结<ul><li>《内存优化: 纹理压缩技术》 Page02</li><li>《移动域全链路可观测架构和关键技术》 Page13</li><li>《性能优化之接口优化》 Page34</li><li>《APM 页面加载耗时校准》 Page43</li><li>《19 条跨端 cpp 开发有效经验总结》 Page58</li><li>《下一代响应式 Web 设计：组件驱动式 Web 设计》 Page67</li><li>《Flutter 新一代图形渲染器 Impeller》 Page126</li><li>《HTTPS 的原理浅析与本地开发实践》 Page139</li><li>《无代码生产新模式探索》 Page158</li><li>《HTTP3 RFC 标准正式发布，QUIC 会成为传输技术的新一代颠覆者吗？》 Page167</li></ul></li><li>相关业务实践<ul><li>《淘宝购物车 5 年客户端技术升级与沉淀》 Page173</li><li>《淘宝长辈模式客户端技术实践万字总结》 Page209</li><li>《打造淘宝极简包的轻量化框架》 Page229</li><li>《我在淘宝做弹窗，2022 年初的回顾与展望》 Page239</li></ul></li><li>年度经典专题<ul><li>《跨全端 SDK 技术演进》 Page269</li><li>《跨桌面端 Web 容器演进》 Page281</li><li>《跨桌面端之组件化实践》 Page291</li></ul></li></ul><p>*其他技术、设计模式、架构及职业发展相关也有不少亮点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】2022-跨端及小程序的一些文章书籍等整理&quot;&gt;&lt;a href=&quot;#【笔记】2022-跨端及小程序的一些文章书籍等整理&quot; class=&quot;headerlink&quot; title=&quot;【笔记】2022 跨端及小程序的一些文章书籍等整理&quot;&gt;&lt;/a&gt;【笔记】2022 跨端
      
    
    </summary>
    
    
      <category term="跨端" scheme="http://blog.michealwayne.cn/tags/%E8%B7%A8%E7%AB%AF/"/>
    
      <category term="小程序" scheme="http://blog.michealwayne.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】State Of Js2022中的ES语言特性</title>
    <link href="http://blog.michealwayne.cn/2023/01/15/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91StateOfJs2022%E4%B8%AD%E7%9A%84ES%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.michealwayne.cn/2023/01/15/notes/【笔记】StateOfJs2022中的ES语言特性/</id>
    <published>2023-01-15T12:12:12.000Z</published>
    <updated>2023-01-24T06:00:09.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="State-Of-Js-2022-中的-ES-语言特性"><a href="#State-Of-Js-2022-中的-ES-语言特性" class="headerlink" title="State Of Js 2022 中的 ES 语言特性"></a>State Of Js 2022 中的 ES 语言特性</h1><p>报告地址：<a href="https://2022.stateofjs.com/en-US/" target="_blank" rel="noopener">https://2022.stateofjs.com/en-US/</a></p><h2 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a><a href="https://2022.stateofjs.com/en-US/features/language/#proxies" target="_blank" rel="noopener">Proxies</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">mdn</a></p><p>用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><p>Proxy 现在还是挺常用的，比如 Vue3、和 Reflect 配合使用<a href="http://blog.michealwayne.cn/2020/05/16/paradigm/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%9C%E7%8E%84%E5%B9%BB%E2%80%9D%E7%9A%84js%E5%85%83%E7%BC%96%E7%A8%8B/">元编程</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">42</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b); <span class="comment">// 1, 42</span></span><br></pre></td></tr></table></figure><h3 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-proxies.png" alt="p-proxies.png"></p><p>趋势有点奇怪，2021 年及之前了解人数/使用人数比例还在逐年上升，2022 年居然有所减少。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#promise_all_settled" target="_blank" rel="noopener">Promise.allSettled()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" target="_blank" rel="noopener">mdn</a></p><p><code>Promise.allSettled()</code> 方法以 promise 组成的可迭代对象作为输入，并且返回一个 Promise 实例。当输入的所有 promise 都已敲定时（包括传递空的可迭代类型），返回的 promise 将兑现，并带有描述每个 promsie 结果的对象数组。</p><p>看起来感觉跟<code>Promise.all()</code>很像，但<code>Promise.allSettled()</code> 的最大不同点在于<code>Promise.allSettled()</code> 永远不会被 reject。</p><p>在使用 <code>Promise.all()</code>时，如果有一个 promise 出现了异常，被 reject 了，就不会走到<code>.then</code>，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="built_in">Promise</span>.resolve(<span class="number">1</span>), <span class="built_in">Promise</span>.resolve(<span class="number">2</span>), <span class="built_in">Promise</span>.reject(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">values</span> =&gt;</span> <span class="built_in">console</span>.log(values));</span><br><span class="line"><span class="comment">// 最终输出(Error)： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then(<span class="function"><span class="params">values</span> =&gt;</span> <span class="built_in">console</span>.log(values))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure><p>这种情况下，<code>Promise.all()</code>的关键问题在于：尽管能用 <code>catch</code> 捕获其中的异常，但你会发现其他执行成功的 promise 的消息都丢失了。</p><p>而<code>Promise.allSettled</code>不一样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="built_in">Promise</span>.resolve(<span class="number">1</span>), <span class="built_in">Promise</span>.resolve(<span class="number">2</span>), <span class="built_in">Promise</span>.reject(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">values</span> =&gt;</span> <span class="built_in">console</span>.log(values));</span><br><span class="line"><span class="comment">// 最终输出：</span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: "fulfilled", value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: "fulfilled", value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: "rejected", value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure><p>可以看到所有 promise 的数据都被包含在 <code>then</code> 语句中，且每个 promise 的返回值多了一个 <code>status</code> 字段</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-promise_com.png" alt="p-promise_com.png"></p><p>polyfill：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Promise</span> &amp;&amp; !<span class="built_in">Promise</span>.allSettled) &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      promises.map(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">state</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">state</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: reason &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="趋势-1"><a href="#趋势-1" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-promise.png" alt="p-promise"></p><p>总体来看这几年使用有所上升</p><h2 id="Dynamic-Import"><a href="#Dynamic-Import" class="headerlink" title="Dynamic Import"></a><a href="https://2022.stateofjs.com/en-US/features/language/#dynamic_import" target="_blank" rel="noopener">Dynamic Import</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">mdn</a></p><p>关键字 <code>import</code> 可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种使用方式也支持 <code>await</code> 关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-dimport_com.png" alt="p-dimport_com"></p><h3 id="趋势-2"><a href="#趋势-2" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-dimport.png" alt="p-dimport_com"></p><h2 id="Private-Fields"><a href="#Private-Fields" class="headerlink" title="Private Fields"></a><a href="https://2022.stateofjs.com/en-US/features/language/#private_fields" target="_blank" rel="noopener">Private Fields</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener">mdn</a></p><p>类属性在默认情况下是公有的，但可以使用增加哈希前缀 <code>#</code> 的方法来定义私有类字段，这一隐秘封装的类特性由 js 自身强制执行。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateField</span> </span>&#123;</span><br><span class="line">  #privateField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateMethod</span> </span>&#123;</span><br><span class="line">  #privateMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateStaticField</span> </span>&#123;</span><br><span class="line">  static #PRIVATE_STATIC_FIELD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateStaticMethod</span> </span>&#123;</span><br><span class="line">  static #privateStaticMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从作用域之外引用 <code>#</code> 名称、内部在未声明的情况下引用私有字段、或尝试使用 delete 移除声明的字段都会抛出语法错误。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateField</span> </span>&#123;</span><br><span class="line">  #privateField;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    this.#privateField = 42;</span><br><span class="line">    delete this.#privateField;   // 语法错误</span><br><span class="line">    this.#undeclaredField = 444; // 语法错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> ClassWithPrivateField()</span><br><span class="line">instance.#privateField === 42;   // 语法错误</span><br></pre></td></tr></table></figure><p>并且类似于公有字段，私有字段在构造（construction）基类或调用子类的 <code>super()</code> 方法时被添加到类实例中。</p><h3 id="私有实例方法"><a href="#私有实例方法" class="headerlink" title="私有实例方法"></a>私有实例方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithPrivateMethod</span> </span>&#123;</span><br><span class="line">  #privateMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPrivateMessage() &#123;</span><br><span class="line">    return this.#privateMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> ClassWithPrivateMethod();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getPrivateMessage());</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h3><p>私有性还是比较好做 polyfill 的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  #num = 1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> setNum(num) &#123;</span><br><span class="line">    this.#num = num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> getNum() &#123;</span><br><span class="line">    return this.#num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classPrivateFieldInitSpec</span>(<span class="params">obj, privateMap, value</span>) </span>&#123;</span><br><span class="line">  _checkPrivateRedeclaration(obj, privateMap);</span><br><span class="line">  privateMap.set(obj, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_checkPrivateRedeclaration</span>(<span class="params">obj, privateCollection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (privateCollection.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot initialize the same private elements twice on an object'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classPrivateFieldGet</span>(<span class="params">receiver, privateMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> descriptor = _classExtractFieldDescriptor(receiver, privateMap, <span class="string">'get'</span>);</span><br><span class="line">  <span class="keyword">return</span> _classApplyDescriptorGet(receiver, descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classApplyDescriptorGet</span>(<span class="params">receiver, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (descriptor.get) &#123;</span><br><span class="line">    <span class="keyword">return</span> descriptor.get.call(receiver);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classPrivateFieldSet</span>(<span class="params">receiver, privateMap, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> descriptor = _classExtractFieldDescriptor(receiver, privateMap, <span class="string">'set'</span>);</span><br><span class="line">  _classApplyDescriptorSet(receiver, descriptor, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classExtractFieldDescriptor</span>(<span class="params">receiver, privateMap, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!privateMap.has(receiver)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'attempted to '</span> + action + <span class="string">' private field on non-instance'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> privateMap.get(receiver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classApplyDescriptorSet</span>(<span class="params">receiver, descriptor, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (descriptor.set) &#123;</span><br><span class="line">    descriptor.set.call(receiver, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!descriptor.writable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'attempted to set read only private field'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    descriptor.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _num = <span class="comment">/*#__PURE__*/</span> <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    _classPrivateFieldInitSpec(<span class="keyword">this</span>, _num, &#123;</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      value: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> setNum(num) &#123;</span><br><span class="line">    _classPrivateFieldSet(<span class="keyword">this</span>, _num, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> getNum() &#123;</span><br><span class="line">    <span class="keyword">return</span> _classPrivateFieldGet(<span class="keyword">this</span>, _num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="趋势-3"><a href="#趋势-3" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-private.png" alt="p-private"></p><p>逐渐上升。</p><h2 id="Nullish-Coalescing"><a href="#Nullish-Coalescing" class="headerlink" title="Nullish Coalescing"></a><a href="https://2022.stateofjs.com/en-US/features/language/#nullish_coalescing" target="_blank" rel="noopener">Nullish Coalescing</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing" target="_blank" rel="noopener">mdn</a></p><p>空值合并运算符（<code>??</code>）是一个逻辑运算符，当左侧的操作数为 <code>null</code> 或者 <code>undefined</code> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与逻辑或运算符（<code>||</code>）不同，逻辑或运算符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>&#39;&#39;</code> 或 <code>0</code>）时。见下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">null</span> ?? <span class="string">'default string'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="comment">// Expected output: "default string"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">0</span> ?? <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz);</span><br><span class="line"><span class="comment">// Expected output: 0</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-3"><a href="#兼容性-3" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-nullish_com.png" alt="p-nullish_com"></p><p>兼容处理也很简单，polyfill 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num ?? <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num !== <span class="literal">null</span> &amp;&amp; num !== <span class="keyword">void</span> <span class="number">0</span> ? num : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="趋势-4"><a href="#趋势-4" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-nullish.png" alt="p-nullish"></p><p>还算是在上升。</p><h2 id="Numeric-Separators"><a href="#Numeric-Separators" class="headerlink" title="Numeric Separators"></a><a href="https://2022.stateofjs.com/en-US/features/language/#numeric_separators" target="_blank" rel="noopener">Numeric Separators</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar" target="_blank" rel="noopener">mdn</a></p><p>增强数字可读性的分隔符<code>_</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>_000_000_000_000;</span><br><span class="line"><span class="number">1</span>_050<span class="number">.95</span>;</span><br><span class="line"><span class="number">0b1010</span>_0001_1000_0101;</span><br><span class="line"><span class="number">0o2</span>_2_5_6;</span><br><span class="line"><span class="number">0xa0</span>_b0_c0;</span><br><span class="line"><span class="number">1</span>_000_000_000_000_000_000_000n;</span><br></pre></td></tr></table></figure><h3 id="兼容性-4"><a href="#兼容性-4" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-number_com.png" alt="p-number_com.png"></p><p>babel 处理时去掉分隔符就好了。</p><h3 id="趋势-5"><a href="#趋势-5" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-number.png" alt="p-number"></p><p>有所上升。</p><h2 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#string_replace_all" target="_blank" rel="noopener">String.prototype.replaceAll()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll" target="_blank" rel="noopener">mdn</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="string">'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.replaceAll(<span class="string">'dog'</span>, <span class="string">'monkey'</span>));</span><br><span class="line"><span class="comment">// Expected output: "The quick brown fox jumps over the lazy monkey. If the monkey reacted, was it really lazy?"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global flag required when calling replaceAll with regex</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/Dog/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.replaceAll(regex, <span class="string">'ferret'</span>));</span><br><span class="line"><span class="comment">// Expected output: "The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?"</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-5"><a href="#兼容性-5" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-replaceAll_com.png" alt="p-replaceAll_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.replace-all.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.replace-all.js</a></p><h3 id="趋势-6"><a href="#趋势-6" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-replaceAll.png" alt="p-replaceAll"></p><p>有所上升。</p><h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#string_match_all" target="_blank" rel="noopener">String.prototype.matchAll()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll" target="_blank" rel="noopener">mdn</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'test1test2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [...str.matchAll(regexp)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Expected output: Array ["test1", "e", "st1", "1"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// Expected output: Array ["test2", "e", "st2", "2"]</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-6"><a href="#兼容性-6" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-matchAll_com.png" alt="p-matchAll_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.match-all.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.match-all.js</a></p><h3 id="趋势-7"><a href="#趋势-7" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-matchAll.png" alt="p-matchAll"></p><p>有所上升。</p><h2 id="Logical-Assignment"><a href="#Logical-Assignment" class="headerlink" title="Logical Assignment"></a><a href="https://2022.stateofjs.com/en-US/features/language/#logical_assignment" target="_blank" rel="noopener">Logical Assignment</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment" target="_blank" rel="noopener">mdn</a></p><ul><li>Logical OR assignment: <code>(x ||= y)</code></li><li>Logical AND assignment: <code>(x &amp;&amp;= y)</code></li></ul><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// Expected output: 2</span></span><br><span class="line"></span><br><span class="line">b &amp;&amp;= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// Expected output: 0</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x &amp;&amp;= <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">x &amp;&amp;= <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line">y &amp;&amp;= <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">y &amp;&amp;= <span class="number">0</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-7"><a href="#兼容性-7" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-logical_com.png" alt="p-logical_com"></p><h3 id="趋势-8"><a href="#趋势-8" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-logical.png" alt="p-logical"></p><p>有所上升。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#promise_any" target="_blank" rel="noopener">Promise.any()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" target="_blank" rel="noopener">mdn</a></p><p><code>Promise.any()</code> 接收一个由 Promise 所组成的可迭代对象，该方法会返回一个新的 promise，一旦可迭代对象内的任意一个 promise 变成了兑现状态，那么由该方法所返回的 promise 就会变成兑现状态，并且它的兑现值就是可迭代对象内的首先兑现的 promise 的兑现值。如果可迭代对象内的 promise 最终都没有兑现（即所有 promise 都被拒绝了），那么该方法所返回的 promise 就会变成拒绝状态，并且它的拒因会是一个 <code>AggregateError</code> 实例，这是 <code>Error</code> 的子类，用于把单一的错误集合在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.reject(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">100</span>, <span class="string">'quick'</span>));</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">500</span>, <span class="string">'slow'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2, promise3];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any(promises).then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expected output: "quick"</span></span><br></pre></td></tr></table></figure><p>返回值</p><ul><li>如果传入了一个空的可迭代对象，那么就会返回一个已经被拒的 promise</li><li>如果传入了一个不含有 promise 的可迭代对象，那么就会返回一个异步兑现的 promise</li><li>其余情况下都会返回一个处于等待状态的 promise。如果可迭代对象中的任意一个 promise 兑现了，那么这个处于等待状态的 promise 就会异步地（调用栈为空时）切换至兑现状态。如果可迭代对象中的所有 promise 都被拒绝了，那么这个处于等待状态的 promise 就会异步地切换至被拒状态。</li></ul><h3 id="兼容性-8"><a href="#兼容性-8" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-promiseAny_com.png" alt="p-promiseAny_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.promise.any.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.promise.any.js</a></p><h3 id="趋势-9"><a href="#趋势-9" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-promiseAny.png" alt="p-promiseAny"></p><p>居然有所降低。</p><h2 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#array_at" target="_blank" rel="noopener">Array.prototype.at()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at" target="_blank" rel="noopener">mdn</a></p><p><code>at()</code> 方法接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> the item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Expected output: "Using an index of 2 the item returned is 8"</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Using an index of <span class="subst">$&#123;index&#125;</span> item returned is <span class="subst">$&#123;array1.at(index)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Expected output: "Using an index of -2 item returned is 130"</span></span><br></pre></td></tr></table></figure><p>参数: <code>index</code>, <code>{String}</code></p><ul><li>要返回的数组元素的索引（位置）。当传递负数时，支持从数组末端开始的相对索引；也就是说，如果使用负数，返回的元素将从数组的末端开始倒数。</li></ul><p>返回值</p><ul><li>匹配给定索引的数组中的元素。如果找不到指定的索引，则返回 <code>undefined</code>。</li></ul><h3 id="兼容性-9"><a href="#兼容性-9" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-arrayAt_com.png" alt="p-arrayAt_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.array.at.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.array.at.js</a></p><h3 id="趋势-10"><a href="#趋势-10" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-arrayAt.png" alt="p-arrayAt"></p><p>呈上升趋势。</p><h2 id="Top-Level-await"><a href="#Top-Level-await" class="headerlink" title="Top Level await()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#top_level_await" target="_blank" rel="noopener">Top Level await()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">mdn</a></p><p>在模块的顶层，你可以单独使用关键字 <code>await</code>（异步函数的外面）。也就是说一个模块如果包含用了 <code>await</code> 的子模块，该模块就会等待该子模块，这一过程并不会阻塞其它子模块。</p><p>下面是一个在 <code>export</code> 表达式中使用了 <code>Fetch API</code> 的例子。任何文件只要导入这个模块，后面的代码就会等待，直到 <code>fetch</code> 完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch request</span></span><br><span class="line"><span class="keyword">const</span> colors = fetch(<span class="string">'../data/colors.json'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">await</span> colors;</span><br></pre></td></tr></table></figure><h3 id="兼容性-10"><a href="#兼容性-10" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-topAwait_com.png" alt="p-topAwait_com"></p><h3 id="趋势-11"><a href="#趋势-11" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-topAwait.png" alt="p-topAwait"></p><p>呈上升趋势。</p><h2 id="Temporal"><a href="#Temporal" class="headerlink" title="Temporal"></a><a href="https://2022.stateofjs.com/en-US/features/language/#temporal" target="_blank" rel="noopener">Temporal</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">mdn</a></p><p>一个新的日期/时间 API，具体使用<a href="https://tc39.es/proposal-temporal/docs/index.html" target="_blank" rel="noopener">https://tc39.es/proposal-temporal/docs/index.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Initialization complete'</span>, Temporal.Now.instant());</span><br></pre></td></tr></table></figure><h3 id="兼容性-11"><a href="#兼容性-11" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-temporal_com.png" alt="p-temporal_com"></p><p>不兼容</p><h3 id="趋势-12"><a href="#趋势-12" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-temporal.png" alt="p-temporal"></p><p>新 APi，也没呈现出趋势</p><h2 id="Array-prototype-findLast"><a href="#Array-prototype-findLast" class="headerlink" title="Array.prototype.findLast()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#array_findlast" target="_blank" rel="noopener">Array.prototype.findLast()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast" target="_blank" rel="noopener">mdn</a></p><p><code>findLast()</code> 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inventory = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">quantity</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'bananas'</span>, <span class="attr">quantity</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'fish'</span>, <span class="attr">quantity</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'cherries'</span>, <span class="attr">quantity</span>: <span class="number">5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// return true inventory stock is low</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNotEnough</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.quantity &lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(inventory.findLast(isNotEnough));</span><br><span class="line"><span class="comment">// &#123; name: "fish", quantity: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-12"><a href="#兼容性-12" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-findLast_com.png" alt="p-findLast_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.array.find-last.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.array.find-last.js</a></p><h3 id="趋势-13"><a href="#趋势-13" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-findLast.png" alt="p-findLast"></p><h2 id="Error-prototype-cause"><a href="#Error-prototype-cause" class="headerlink" title="Error.prototype.cause"></a><a href="https://2022.stateofjs.com/en-US/features/language/#error_cause" target="_blank" rel="noopener">Error.prototype.cause</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause" target="_blank" rel="noopener">mdn</a></p><p>导致一个错误的数据属性实例表明错误的具体的原始致因。<br>使用它当捕获和抛出收到一个错误更具体的或有用的错误信息仍然为了获得最初的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  connectToDatabase();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Connecting to database failed.'</span>, &#123; <span class="attr">cause</span>: err &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="兼容性-13"><a href="#兼容性-13" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-errorcause_com.png" alt="p-errorcause_com"></p><h3 id="趋势-14"><a href="#趋势-14" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-errorcause.png" alt="p-errorcause"></p><h2 id="Object-hasOwn"><a href="#Object-hasOwn" class="headerlink" title="Object.hasOwn()"></a><a href="https://2022.stateofjs.com/en-US/features/language/#object_hasown" target="_blank" rel="noopener">Object.hasOwn()</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn" target="_blank" rel="noopener">mdn</a></p><p><code>Object.hasOwn()</code> 用来代替 <code>Object.prototype.hasOwnProperty()</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  prop: <span class="string">'exists'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.hasOwn(object1, <span class="string">'prop'</span>));</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.hasOwn(object1, <span class="string">'toString'</span>));</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.hasOwn(object1, <span class="string">'undeclaredPropertyValue'</span>));</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-14"><a href="#兼容性-14" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-hasown_com.png" alt="p-hasown_com"></p><p>Corejs 的 polyfill 可见<a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.object.has-own.js" target="_blank" rel="noopener">https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.object.has-own.js</a></p><h3 id="趋势-15"><a href="#趋势-15" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-hasown.png" alt="p-hasown"></p><h2 id="Regexp-Match-Indices"><a href="#Regexp-Match-Indices" class="headerlink" title="Regexp Match Indices"></a><a href="https://2022.stateofjs.com/en-US/features/language/#regexp_match_indices" target="_blank" rel="noopener">Regexp Match Indices</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices" target="_blank" rel="noopener">mdn</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'foo'</span>, <span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex1.hasIndices);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex2.hasIndices);</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'foo bar foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex1 = <span class="regexp">/foo/</span>dg;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex1.hasIndices); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex1.exec(str1).indices[<span class="number">0</span>]); <span class="comment">// Output: Array [0, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(regex1.exec(str1).indices[<span class="number">0</span>]); <span class="comment">// Output: Array [8, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'foo bar foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex2 = <span class="regexp">/foo/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex2.hasIndices); <span class="comment">// Output: false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regex2.exec(str2).indices); <span class="comment">// Output: undefined</span></span><br></pre></td></tr></table></figure><h3 id="兼容性-15"><a href="#兼容性-15" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="/images/2022stateofjs/p-indices_com.png" alt="p-indices_com"></p><h3 id="趋势-16"><a href="#趋势-16" class="headerlink" title="趋势"></a>趋势</h3><p><img src="/images/2022stateofjs/p-indices.png" alt="p-indices"><br>å</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;State-Of-Js-2022-中的-ES-语言特性&quot;&gt;&lt;a href=&quot;#State-Of-Js-2022-中的-ES-语言特性&quot; class=&quot;headerlink&quot; title=&quot;State Of Js 2022 中的 ES 语言特性&quot;&gt;&lt;/a&gt;State
      
    
    </summary>
    
    
      <category term="js" scheme="http://blog.michealwayne.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《演进式架构》学习笔记（三）</title>
    <link href="http://blog.michealwayne.cn/2023/01/02/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2023/01/02/notes/【笔记】《演进式架构》（三）/</id>
    <published>2023-01-02T14:39:49.000Z</published>
    <updated>2023-01-03T02:56:18.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《演进式架构》学习笔记（三）"><a href="#《演进式架构》学习笔记（三）" class="headerlink" title="《演进式架构》学习笔记（三）"></a>《演进式架构》学习笔记（三）</h1><p>（此书写得有点杂，但部分内容还可以，以此几篇记录下笔记。）</p><h2 id="六、构建可演进的架构"><a href="#六、构建可演进的架构" class="headerlink" title="六、构建可演进的架构"></a>六、构建可演进的架构</h2><h3 id="演进机制"><a href="#演进机制" class="headerlink" title="演进机制"></a>演进机制</h3><p>架构师可以通过下面 3 步来构建演进式架构：</p><ul><li><strong>1.识别受演进影响的架构维度</strong>：其中一定包含技术架构，通常还有数据设计、安全、可伸缩性和其他一些他们认为重要的特征。该过程会涉及组织内部其他相关团队，包括业务、运营、安全和其他受影响的团队。逆康威时刻对此很有帮助，因为它鼓励组织多角色团队。基本上，这是架构师在项目初期确定需要支持的架构特征的常规工作。</li><li><strong>2.为每个维度定义适应度函数</strong>：单个架构维度通常包括多个适应度函数。例如，为了保证代码的架构特征，架构师通常将一系列代码衡量指标构建到部署流水线中，例如避免组件循环依赖。架构师通过轻量级的方式记录那些需要持续关注的架构维度，例如 wiki。接着，针对每个维度，他们确定在演进过程中可能出现错误行为的部分，最终定义出适应度函数。适应度函数可以自动运行或手动触发，并且在某些情况下需要设计得更加巧妙。</li><li><strong>3.使用部署流水线自动化适应度函数</strong>：最后，架构师必须在项目中推进增量变更，在部署流水线中定义不同阶段来执行适应度函数并管理部署实践，例如环境准备、测试和其他 DevOps 问题。增量变更是演进式架构的引擎，它让我们可以通过部署流水线主动验证适应度函数，并通过高度自动化隐藏一些单调的任务，例如无感知部署。生产周期是在持续交付中衡量工程效率的指标。在支持演进式架构的项目中，开发人员的职责之一就是保持良好的生产周期。生产周期是增量变更的重要部分，因为其他很多度量指标亦来源于此。例如某架构中新版本的发布速度和其生产周期成正比。换句话说，一旦项目的生产周期延长，那么它将使项目交付新版本的速度减慢，进而影响演进能力。</li></ul><p>开发人员无法预料所有事情，因此软件会受到未知的未知问题的困扰。在构建软件的过程中，架构的某些部分有时会显露出不好的迹象，构建适应度函数能阻止问题进一步恶化。虽然有些适应度函数会在项目初期自然显现，但还有一些适应度函数在架构经受压力时才会显现。架构师尤其需要注意那些非功能性需求被破坏的情况，并通过适应度函数更新架构来避免可能出现的问题。</p><h3 id="全新的项目"><a href="#全新的项目" class="headerlink" title="全新的项目"></a>全新的项目</h3><p>为新项目构建演进能力远比改造已有项目容易。<br>新项目在处理意外变更时会更容易。</p><h3 id="改良现有架构"><a href="#改良现有架构" class="headerlink" title="改良现有架构"></a>改良现有架构</h3><p>赋予现有架构演进能力取决于三个因素：<strong>组件耦合度</strong>、<strong>工程实践成熟度</strong>，以及<strong>开发人员构建适应度函数的难易程度</strong>。</p><h4 id="适当的耦合和内聚"><a href="#适当的耦合和内聚" class="headerlink" title="适当的耦合和内聚"></a>适当的耦合和内聚</h4><p>组件间的耦合很大程度上决定了技术架构的演进能力。清晰解耦的系统易于演进，充满耦合的系统则会妨碍演进。想构建出真正可演进的系统，架构师必须考虑架构中所有受影响的维度。</p><p>除了技术层面的耦合，架构师还必须考虑和保护系统中组件的功能内聚。<strong>当从一种架构迁移到另一种架构时，功能内聚性决定了组件重构后的最终粒度</strong>。</p><p>这并不意味架构师可以随心所欲地分解组件，而是说基于特定的问题上下文，组件的大小应该是适当的。</p><blockquote><p>选择架构前，需要理解面临的业务问题。</p></blockquote><h4 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h4><p>工程实践对定义架构的可演进性至关重要。虽然持续交付实践无法保证架构能实现演进，但它依然不可或缺。</p><p>虽然这些手工测试会延长生产周期，但在部署流水线中包含一些手动阶段很重要。第一，这样会将应用构建的每个阶段都置入部署流水线中。第二，随着团队逐步将更多部署工作自动化，手动阶段也会实现自动化，不再中断部署过程。第三，阐明每个阶段有助于我们更好地理解构建的各个手工部分，创造更好的反馈环并推动改进。</p><p>通常，构建演进式架构的最大障碍是棘手的运维工作。如果开发人员无法轻松地部署变更，反馈环的各个部分都会受阻。</p><h4 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h4><p>适应度函数是演进式架构的保护层。如果架构师围绕特定的架构特征构建系统，那么这些特征可能和可测试性形成正交关系。</p><p>希望架构师将各种架构验证机制视为适应度函数，包括那些临时考虑的事情。</p><h4 id="关于商业成品软件"><a href="#关于商业成品软件" class="headerlink" title="关于商业成品软件"></a>关于商业成品软件</h4><p><a href="https://en.wikipedia.org/wiki/Commercial_off-the-shelf" target="_blank" rel="noopener">COTS</a>（商业成品软件）和套装软件在大型企业中非常普遍，它们给架构师构建可演进的系统带来了挑战。</p><p>COTS 必须随着企业中的其他应用一同演进，然而这些系统没有很好地支持演进。</p><ul><li><strong>增量变更</strong>: 可悲的是，大多数商用软件的自动化和测试都落后于行业标准。架构师和开发人员必须经常隔离集成点并尽可能地构建测试，并将整个系统视为黑盒。在实施敏捷性时，COTS 在部署流水线、DevOps 及其他现代实践方面给开发团队带来了很多挑战。</li><li><strong>适当的耦合</strong>: 套装软件经常在耦合上出错。通常，这类系统是不透明的，开发者使用预定义的 API 进行集成。这些 API 不可避免地会遭遇反模式的问题，它们给开发人员些许（但不太够的）灵活性来完成重要的工作。</li><li><strong>适应度函数</strong>: 在赋予系统演进能力的征途上，最大的障碍可能是为套装软件添加适应度函数。通常，这类软件不会暴露太多内部细节，因此难以进行单元测试和组件测试，只能诉诸于基于行为的集成测试。但这类测试并不理想，因为它们粒度太大，必须在复杂的环境中运行并覆盖大部分系统行为。</li></ul><p>如果不可避免地受到套装软件的困扰，架构师应该尽可能地构建强大的适应度函数，并使其自动化地运行。</p><h3 id="架构迁移"><a href="#架构迁移" class="headerlink" title="架构迁移"></a>架构迁移</h3><p>当架构师想迁移架构时，通常会考虑类和组件间的耦合特征，但可能忽略其他很多影响演进的维度，例如数据。和类之间的耦合一样，也存在事务性耦合，而且在重建架构时难以消除。当尝试将现有模块分解得更小时，这些额外的耦合点带来了巨大的负担。</p><p>很多资深开发人员年复一年地构建相同类型的应用，因单调而厌倦。于是，很多开发人员倾向于编写框架，而不是使用现成的框架来构建应用，这便是所谓的“元工作比工作更有趣”。工作是无趣、平凡且重复的，而构建新事物则令人兴奋。</p><p>当开源工具可以提供这些能力时，他们已经拥有了钟爱的自研基础设施。由于方法上存在细微差别，他们决定坚持使用自研的工具，而不是标准技术。十年后，他们最优秀的开发人员忙于维护这些工具、修复应用服务器、为 Web 框架添加新特性和其他杂事。他们长期困于维护，无暇创新以构建更好的应用。</p><p>架构师无法对“元工作比工作更有趣”综合征免疫，这种综合征表现为采用时髦但并不合适的架构，例如微服务。</p><blockquote><p>不要仅仅因为元工作有趣而构建架构。</p></blockquote><h4 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="　迁移步骤"></a>　迁移步骤</h4><p>在分解代码时，首要任务便是理解它们之间的联系。当分解单体应用时，架构师必须考虑耦合和内聚，寻求两者间的平衡。</p><p>在重建架构时，需要考虑<strong>所有</strong>受影响的维度。</p><p>架构师必须清楚实施该迁移的原因，并且确保不是盲目地赶时髦。将架构划分为领域，加上更好的团队结构和运维的隔离，会使增量变更更容易，这是演进式架构的关键组成之一，因为工作的重点和实际的产出是相互匹配的。</p><p>在分解单体架构时，确定正确的服务粒度是关键。</p><p>开发人员要定义新的服务边界。团队可以通过多种划分方式将单体应用分解成服务:</p><ul><li><strong>业务功能分组</strong>: 企业可能有清晰的业务划分直接对应于 IT 能力。模仿当前业务沟通层级构建的软件无疑应验了康威定律。</li><li><strong>事务边界</strong>: 许多业务需要依附于大量事务边界。当分解单体应用时，架构师经常发现事务耦合是最难解开的。</li><li><strong>部署目标</strong>: 增量变更使得开发人员可以按照不同的计划有选择地发布代码。例如，相比库存部门，市场部门可能希望更新频率更高。如果运维准则非常重要，例如发布速度，那么围绕运维问题划分服务是合理的。类似地，系统的某个部分可能对运维特征有极致的要求（例如伸缩性）。围绕运维目标划分需求使得开发人员能够（通过适应度函数）跟踪服务的健康状态和其他运维服务指标。</li></ul><p>较大的服务粒度意味着微服务中许多固有的协调问题都不会存在，因为服务越大，单个服务所包含的业务上下文就越多，但同时操作难度也越大。</p><h4 id="演进模块间的交互"><a href="#演进模块间的交互" class="headerlink" title="演进模块间的交互"></a>演进模块间的交互</h4><p>共享就是耦合的一种形式，在微服务架构中这是非常不可取的。</p><p>在分布式环境中，开发人员可以使用消息或服务调用来实现相同形式的共享。</p><p>当开发人员确定了正确的服务划分，下一步便是分离业务层和 UI。</p><p>开发人员通常会在迁移早期分离 UI，在界面组件和后端服务间构建映射代理层。在分离 UI 时，还会构建防腐层来将户界面的变更和架构变更隔离开。</p><p>服务发现让服务能够相互查找和调用。最终，架构将由必须相互协调的服务所组成。通过尽早地构建服务发现机制，开发人员可以从容地迁移系统中需要变更的部分。开发人员经常将服务发现构建成一个简单的代理层，每个组件调用代理，然后代理再将请求映射到指定的实现。</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，除非该问题是由间接层太多导致的。 ——Dave Wheeler 和 Kevlin Henney</p></blockquote><p>当然，开发人员增加的间接层越多，服务间的导航就会变得越复杂。</p><p>在将应用从单体架构迁移到基于服务的架构时，架构师必须注意现有系统中模块的连接方式。不成熟的划分方式会带来严重的性能问题。</p><blockquote><p>当从单体应用迁移时，首先构建少量大型服务。 ——Sam Newman，《微服务设计》</p></blockquote><p>接下来，开发人员从单体应用中分离选中的服务并修复集成点。适应度函数在这里能起到关键作用，开发人员应构建适应度函数以确保新引入的集成点不会改变已有行为，并添加消费者驱动的契约。</p><h3 id="演进式架构构建指南"><a href="#演进式架构构建指南" class="headerlink" title="演进式架构构建指南"></a>演进式架构构建指南</h3><p>与其重建各项能力，大多数企业会努力适应现有的一切。尽管我们喜欢在纯净的理想环境中讨论架构，但现实世界往往展现出相反的混乱状态，技术债、优先级冲突和有限的预算很常见。在大型企业中，架构正如人脑一样：底层系统依旧处理着关键的业务细节，但也伴随着过去的包袱。企业不愿意放弃还在工作的系统，这导致集成架构的挑战不断升级。</p><p>赋予现有架构演进能力极具挑战。这是因为，如果开发人员从未将架构构建得易于变更，那么演进能力便不太可能自然地出现。架构师无法轻松地将大泥团转变成现代微服务架构，无论他多么有天赋。然而通过为项目增添一些灵活性，便能在不改变其整体架构的情况下改善项目。</p><h4 id="1-去除不必要的可变性"><a href="#1-去除不必要的可变性" class="headerlink" title="1.去除不必要的可变性"></a>1.去除不必要的可变性</h4><p>通过用不可变的基础设施取代<a href="https://blog.crazytaxii.com/posts/snowflake_and_phoenix_server/" target="_blank" rel="noopener">雪花服务器</a>，现代 DevOps 在其领域内解决了动态平衡的问题。</p><p>虽然不可变性听起来与演进性背道而驰，但恰恰相反。软件系统由成千上万个动态部分组成，它们相互依赖、紧密联系在一起。然而当某个部分发生变化时，开发人员仍然努力应对各种意外。通过锁定意外变更的可能性，能更有效减少使系统变得脆弱的因素。</p><p>不可变的基础设施遵循了我们所提倡的去除不必要的可变性这一思路。构建可演进的软件系统意味着尽可能地控制未知因素。</p><p>架构师能通过各种途径将可变的事务变成常量。</p><p>构建不可变的开发环境还能让我们在项目中使用有用的工具。</p><p>复用旧的功能开关是鲁莽的行为，功能开关的最佳实践是在其目的达成后尽快主动地将其删除。在现代 DevOps 环境中，手动将关键软件部署到服务器也同样被视为鲁莽的行为。</p><h4 id="2-让决策可逆"><a href="#2-让决策可逆" class="headerlink" title="2.让决策可逆"></a>2.让决策可逆</h4><p>当失败发生时，开发人员需要构建新的适应度函数来防止再次失败。</p><p>很多 DevOps 实践可以使那些需要被撤销的决策变得可逆，例如蓝绿部署。功能开关是开发人员使决策可逆的另一种常见方式。</p><h4 id="3-演进优于预测"><a href="#3-演进优于预测" class="headerlink" title="3.演进优于预测"></a>3.演进优于预测</h4><p>未知的未知问题是软件系统的大敌。很多项目始于一系列已知的未知问题，例如开发人员知道他们需要学习领域知识和新技术。然而，项目也会受到未知的未知问题的影响。</p><blockquote><p>由于未知的未知问题，所有架构都将是迭代式的，敏捷实践只是较早地意识到了这一点。 ——Mark Richards</p></blockquote><p>我们知道动态平衡导致了软件开发领域的不可预见性。架构并不是孤立的前期设计活动，项目在其整个生命周期里持续变化着，一些变化是明确的，另一些则不是。使用<strong>防腐层</strong>是开发人员隔离变化的常用技术。</p><h4 id="4-构建防腐层"><a href="#4-构建防腐层" class="headerlink" title="4.构建防腐层"></a>4.构建防腐层</h4><p>抽象干扰反模式描述了这样的场景，项目与某个外部依赖库（商业的或开源的）建立了太多连接。一旦开发人员要升级或更换该库，他们会发现调用该库的很多代码会带有基于该库的抽象假设。领域驱动设计中包含了针对这一现象的保护措施，叫作防腐层。</p><p>头脑灵活的架构师在做决定时会遵循<strong><a href="https://bbs.huaweicloud.com/blogs/124144" target="_blank" rel="noopener">最后责任时刻（The Last Responsible Moment）原则</a></strong>，架构师以该原则避免项目中的常见隐患——过早引入复杂度。</p><p>所谓技术债就是项目中本不应该存在的部分，它会导致项目缺失理应存在的部分。很多开发人员将复杂的遗留代码视为唯一的技术债，但项目还会因为早期的复杂度而在无意中引入技术债。</p><p>构建即时防腐层来隔离库的更新。</p><p>控制应用中的耦合点，特别是外部资源，是架构师的关键职责之一。在需要的时候添加依赖。作为架构师，需要记住<strong>依赖在提供好处的同时，还会施加约束。确保从中获得的好处多过更新和管理依赖所带来的成本。</strong></p><blockquote><p>开发人员熟悉工具的好处，却忽视所要做出的权衡！ ——Rich Hickey，Clojure 之父</p></blockquote><p>使用防腐层有助于系统的演进性。虽然架构师无法预测未来，但至少可以降低变更的成本，以免受到太多负面影响。</p><p>使用服务模板仅将合适的架构部分耦合在一起，例如基础设施组件，团队可以从耦合中获益。</p><p><strong>服务模板体现了适应性</strong>。不把技术架构作为系统的主要结构，使得我们能更容易地将变更和架构维度准确对应起来。当开发人员构建分层架构时，每一层的变更很容易，但跨层的变更会高度耦合。</p><h4 id="5-构建可牺牲架构"><a href="#5-构建可牺牲架构" class="headerlink" title="5.构建可牺牲架构"></a>5.构建可牺牲架构</h4><blockquote><p>因此，在管理上，不应该询问是否该构建一个试验性的系统然后将其抛弃。因为你一定会那样做。因此，做好抛弃它的计划，因为你终将如此。 ——Fred Brooks</p></blockquote><p>在架构层面，开发人员努力预测迅速变化的需求和特征。进行<strong>概念验证</strong>是在选择架构时获取足够信息的一种方式。</p><p>为了证明市场的存在，很多企业构建可牺牲架构来实现最小可行性产品。虽然这个策略很好，但最终，团队仍会投入时间和资源来构建更强大的架构。</p><p>在 Fred Brooks 提到<strong>第二系统综合症</strong>（<a href="https://www.infoq.cn/article/1v6x4hsvwhsw8jmgmcld" target="_blank" rel="noopener">第二系统效应</a>，Second system effect）时，他指出技术债会影响很多在初期很成功的项目。由于期望膨胀，小的、优雅的、成功的系统往往会演进成为塞满各种功能的庞然大物。业务人员不愿抛弃还在运行的代码，因此架构走向了一直做加法，但从不做减法的不归路。</p><p>作为某种隐喻，技术债发挥着有效的作用，因为它与项目经历共鸣，代表着设计中的缺陷，无论其背后的驱动力如何。技术债加重了项目中不当的耦合——糟糕的设计经常表现为病态耦合和其他反模式，使重建代码变得困难。在开发人员重建架构时，第一步应该清除那些以往的设计妥协，即技术债。</p><h4 id="6-应对外部变化"><a href="#6-应对外部变化" class="headerlink" title="6.应对外部变化"></a>6.应对外部变化</h4><p><strong>外部依赖</strong>是所有开发平台的一个共同特征，其中包括工具、框架、库和其他来自互联网并（更重要的）通过互联网进行更新的资产。软件开发处在高耸的层层抽象之上，每一层抽象都建立在下层抽象之上。</p><p>经由构建工具，大多数项目会依赖于繁多的第三方组件。开发人员喜欢外部依赖，因为它们能带来好处，但是很多开发人员忽略了随之而来的代价。<strong>当我们依赖第三方代码时，开发人员必须采取防御措施来预防可能的意外，例如破坏性的变更、未经通知的删除等。</strong>管理项目的这些外部组件是构建演进式架构的关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">破坏了整个互联网的 11 行代码</span><br><span class="line"></span><br><span class="line">2016 年年初，JavaScript 的开发人员在某个不起眼的依赖上栽了大跟头。</span><br><span class="line">某个创建了很多实用小工具的开发人员，他的模块与某个商业软件重名了，而后者要求他更名，因此他有些恼火。</span><br><span class="line">但他并没有照做，而是删除了 250 多个模块，包括一个名为 leftpad.io 的库，它通过 11 行代码来为字符串左边添加零或空格（如果 11 行代码也称得上“库”）。</span><br><span class="line">不幸的是，很多主要的 JavaScript 项目（包括 Node.js）都依赖该库。</span><br><span class="line">在它消失后，所有人的 JavaScript 部署都无法进行。</span><br><span class="line">JavaScript 的仓库管理员通过恢复代码恢复了整个体系，这是前所未有的，但它引发了社区对于如何更好地管理依赖的更明智的深层次讨论。</span><br><span class="line"></span><br><span class="line">这个故事教给架构师两点教训。</span><br><span class="line">第一，铭记外部依赖在带来好处的同时还需要付出成本。我们需要确保收益大于成本。</span><br><span class="line">第二，不要让外部力量影响构建的稳定性。如果某个上游需要的依赖突然消失，那么应该拒绝该变更。</span><br></pre></td></tr></table></figure><blockquote><p>传递依赖管理被视为有害的。 —— Chris Ford（和 Neal 没有关系）</p></blockquote><p>Chris 认为，我们只有意识到问题的严重性才能找到解决方案。有时我们无法找出问题的解决方案，但我们需要格外留意它，因为它会严重影响演进式架构。<strong>稳定性</strong>是持续交付和演进式架构的共同基础。开发人员无法基于不确定因素构建可重复的工程实践。而允许第三方修改核心依赖背离了这一原则。</p><p>以<strong>拉取</strong>的方式获取外部依赖是开启依赖管理的良好开端。例如拉取，设置一个内部版本控制仓库作为第三方的组件商店，然后将外部的变更视为对仓库的拉取请求。如果变更是有益的，那么将其纳入体系中。如果某个核心依赖突然消失，那么就应该将该拉取请求视为破坏稳定的因素并将其拒绝。</p><p>秉持<strong>持续交付思维</strong>，第三方组件库使用自己的部署流水线。当组件发生变更时，部署流水线合并修改，接着执行构建并对受影响的应用进行冒烟测试。如果成功，则保留变更。因此，第三方依赖使用与内部应用相同的工程实践和内部开发机制，有效地模糊了自研代码和第三方依赖之间通常不重要的区别，因为它们终将成为项目中的代码。</p><h4 id="7-更新库与更新框架"><a href="#7-更新库与更新框架" class="headerlink" title="7.更新库与更新框架"></a>7.更新库与更新框架</h4><p>架构师在库和框架之间做出了一般区分，简单地将其描述为“<strong>开发人员的代码会调用库，而框架会调用开发人员的代码</strong>”。通常，开发人员从框架中派生出子类（框架反过来调用这些派生出的类），这便是框架调用代码的原因。相反，库代码通常是一系列相关的类或函数，开发人员按需调用它们。由于框架调用开发人员的代码，导致了框架的高度耦合。相反，库通常更为实用，耦合度也更低，例如 XML 解析器、网络库等。</p><p>我们青睐库，因为它们引入应用的耦合更少，使得在技术架构演进时易于置换。</p><p>工程实践是我们区别对待库和框架的另一个原因。由于应用基于框架搭建，所以应用的所有代码都会受到框架变更的影响。很多人都真切地感受过这样的痛苦——当基础框架因两个主要版本而过时，那么升级框架需要极大的付出。</p><p><strong>由于框架属于应用的基础部分，团队必须积极地将其更新</strong>。库所形成的脆弱集成点比框架更少，团队更新库时会更自由。一种非正式的管理模式将框架的更新视为推动式更新，将库的更新视为拉动式更新。<br>当基础框架更新时（其输入 / 输出耦合数量高于某个特定阈值），只要新版本稳定，并且团队能分配出时间，那么就应该应用该更新。尽管这会花费时间和精力，但如果团队无限期地拖延该更新，最终所花费的时间将远不止这些。</p><p>积极地更新框架依赖，“消极”地更新库。</p><h4 id="8-持续交付优于快照"><a href="#8-持续交付优于快照" class="headerlink" title="8.持续交付优于快照"></a>8.持续交付优于快照</h4><p>很多依赖管理工具通过快照机制支持持续开发。构建快照最初是为了标明那些差不多准备好发布但仍在开发中的组件，它暗示着代码还可能定期更新。一旦带上了版本号，那么“快照”（-SNAPSHOT）的标记将被移除。</p><p>开发人员使用快照是因为过去大家认为测试困难且耗时，这导致开发人员尝试区分变化的内容和没变化的内容。</p><p>在演进式架构中，所有事务都在不断变化，需要通过构建工程实践和适应度函数来适应变化。例如，当项目有着出色的测试覆盖率和部署流水线时，开发人员可以通过自动的部署流水线测试每个组件的每次变更。开发人员没有理由为项目的每个部分保留某个特殊的仓库。</p><p>快照是某个开发时期的产物，当时全面测试还不普遍，存储成本很高，验证也很困难。</p><p>持续交付建议以更细致的方式思考依赖，开发人员应该为外部依赖引入两个新定义：<strong>流动的依赖</strong>和<strong>被守护的依赖</strong>。通过部署流水线机制，流动的依赖尝试自动地将自己更新到新版本。</p><p>目前流行的构建工具都未支持该级别的功能，开发人员必须基于现有的工具构建这种智能功能。然而在演进式架构中，这种依赖模型表现得相当不错，其中生产周期作为关键的基础值，和其他很多关键指标成正比。</p><h4 id="9-服务内部版本化"><a href="#9-服务内部版本化" class="headerlink" title="9.服务内部版本化"></a>9.服务内部版本化</h4><p>版本化端点有两种常用的方式：<strong>版本号</strong>或<strong>内部版本化</strong>。对于版本号，当破坏性的变更发生时，开发人员会创建新的、通常包含版本号的端点名。这使得旧的集成点继续调用旧的服务，而新的集成点则调用新的版本。另一种替代方案是内部版本化，调用方无须修改端点，相反，开发人员在服务端构建逻辑来确定调用方的上下文，从而返回正确的版本。相比调用应用时指定版本号，使用固定名称的好处是耦合更少。</p><p>无论是哪种情况，都应该严格限制所支持的版本数量。更多的版本会增加测试和其他工程的负担。建议一次只支持两个版本，并且只是暂时支持。</p><p>在版本化服务时，我们倾向于内部版本化，一次只支持两个版本，而不是用版本号。</p><h2 id="七、演进式架构的陷阱和反模式"><a href="#七、演进式架构的陷阱和反模式" class="headerlink" title="七、演进式架构的陷阱和反模式"></a>七、演进式架构的陷阱和反模式</h2><p>项目中有两种错误的工程实践——<strong>陷阱</strong>和<strong>反模式</strong>。</p><p>软件的反模式包含两层含义。首先，反模式是一种实践，开始看起来不错，但结果证明是错的。其次，大多数反模式都有更好的替代方案。很多反模式只有在事后才被架构师注意到，因此很难避免。陷阱表面上像是个好主意，但很快便显露出缺点。</p><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="反模式：供应商为王"><a href="#反模式：供应商为王" class="headerlink" title="反模式：供应商为王"></a>反模式：供应商为王</h4><p>一种完全围绕供应商产品构建的架构，将组织和工具病态地耦合。购买了供应商软件的公司计划通过插件扩充软件包，以丰富供应商软件的核心功能来匹配其业务。然而，很多时候无法将 ERP 定制到满足所有需求，开发人员发现他们受到了 ERP 的制约，这一方面来自于工具的限制，另一方面来自于 ERP 是事实上的架构核心。换句话说，架构师让供应商成为了架构的王者，左右了未来的决策。</p><p>想要规避这种反模式，需要将所有软件都视为<strong>集成点</strong>，即便起初它具有广泛的职责。如果在一开始便假设集成，开发人员可以更容易地替换掉那些对其他集成点无用的行为，废除“王者”。</p><p>无论从技术还是从业务流程的角度来看，将外部工具或框架置于架构的核心会严重限制架构的演进能力。开发人员在技术上受到了供应商选择的制约，例如持久层、基础设施以及其他限制。</p><p>从业务流程的角度来看，这种工具无法支持最佳的工作流，这也是其副作用。大多数公司最终屈服于这种框架，不再尝试定制这类工具，而是修改自己的流程。越多公司这样做，公司间的差异变得越小，当然，如果差异化不是竞争优势，这或许是可以接受的。</p><p>与其沦为供应商为王反模式的受害者，我们不如将供应商产品视为集成点。开发人员可以在集成点间构建防腐层，从而避免架构受到供应商工具变更的影响。</p><h4 id="陷阱：抽象泄漏"><a href="#陷阱：抽象泄漏" class="headerlink" title="陷阱：抽象泄漏"></a>陷阱：抽象泄漏</h4><blockquote><p>所有重大的抽象在某种程度上都会泄漏。 —— Joel Spolsky</p></blockquote><p>现代软件构建于层层抽象之上：操作系统、框架、依赖等。开发人员构建抽象来摆脱在最底层无尽的思考。如果开发人员需要将来自硬件驱动的二进制数字转换为文本来进行编程，他们将无法完成任何工作。现代软件成功的原因之一在于我们能建立有效的抽象。</p><p>但是抽象也是有代价的，因为<strong>没有抽象是完美的</strong>，如果有，那么它将不再是抽象，而是实际存在。</p><p>底层抽象破坏会导致意外的灾难，即原始抽象泄漏，它是技术栈日渐复杂带来的副作用之一。</p><blockquote><p>始终保持对当前抽象层以下至少一个抽象层的完全理解。 ——许多软件专家</p></blockquote><p>技术栈复杂度的增长印证了动态平衡问题。不只是体系在变化，其组成部分随着时间推移也会变得更加复杂并交织在一起。适应度函数（保护演进式变更的机制）能够保护架构中脆弱的连接点。架构师将关键集成点上的不变量定义为适应度函数，并在部署流水线运行它们，确保抽象不会意外泄漏。</p><blockquote><p>了解复杂技术栈的脆弱部分，并通过适应度函数自动保护它们。</p></blockquote><h4 id="反模式：最后-10-的陷阱"><a href="#反模式：最后-10-的陷阱" class="headerlink" title="反模式：最后 10%的陷阱"></a>反模式：最后 10%的陷阱</h4><p>即所有项目都存在缺憾。<br>在抽象范围的另一端存在着另一种复用陷阱，它隐藏在套装软件、平台和框架中。</p><p>整洁的解决方案无法解决现实世界中一些混乱的事物，例如业务流程。<br>无论开发人员多么努力，他们都无法将事物提炼得足够精细，这便是无限回归问题的一部分：一些命题依赖于其他命题而成立，没有止境。在软件领域中，无限回归表现为人们想要用终级的细节详细描述任何事物，但在任何现有细节之下总是存在另一层更细粒度的细节。</p><h4 id="反模式：代码复用和滥用"><a href="#反模式：代码复用和滥用" class="headerlink" title="反模式：代码复用和滥用"></a>反模式：代码复用和滥用</h4><p>在软件行业中，我们从他人构建的可复用框架和库中受益匪浅，它们通常是开源软件，可以免费使用。复用代码显然很好，然而，任何美好事物都不能被滥用，很多公司因滥用代码给自己造成了麻烦。每个企业都希望复用代码，因为软件看起来模块分明，像电子元件一样。然而，尽管在真正模块化的软件中的确如此，但它却难以实现。</p><blockquote><p>复用软件更像是器官移植而不是拼装乐高积木。 ——John D. Cook</p></blockquote><p>复用软件很难并且不会自动出现。很多管理者乐观地认为开发者编写的任何代码都可复用，但事实并非总是如此。很多公司尝试并成功编写出真正可复用的代码，但这是有意为之并且困难重重。<strong>开发人员通常花费大量时间尝试构建可复用的模块，结果却几乎无法复用。</strong></p><p>架构师努力实现 SOA 中的终极规范——所有概念都只有一个（共享的）归属。</p><p>讽刺的是，开发人员为了代码复用所付出的努力往往适得其反。为了复用代码，需要引入额外的选项和决策点以适应不同的用途。开发人员为实现可复用所添加的钩子越多，对代码的基本可用性损害越大。</p><p><strong>代码复用性越高，其可用性越低。</strong>代码的易用性和复用性往往成反比。当开发人员构建可复用的代码时，他们必然会为了将来开发人员以各种方式使用该代码添加特性。所有针对未来的特性都使得开发人员更难将代码用于单一目的。</p><p>微服务避免代码复用，遵循重复优于耦合的理念。该理念认为复用意味着耦合，因此微服务架构是极度解耦的。然而，微服务的目标并不是追求重复，而是隔离领域内的实体。那些共享通用类的服务不再独立。</p><p>复用所带来的好处是虚幻的，除了其自身缺陷，它还会引入耦合。因此，虽然架构师了解重复的缺点，但他们利用重复抵消了耦合过多对架构的局部损害。</p><p>复用代码可以是资产，也可能是潜在的责任。我们要确保代码中引入的耦合点不会和其他架构目标产生冲突。</p><p><strong>当耦合点妨碍了演进或其他重要的架构特征时，通过分叉或重复来打破耦合点。</strong></p><p>架构师必须持续评估架构特征的适应度，保证它们仍在提供价值，避免沦为反模式。</p><p>架构师在当时做出的正确决定，随着时间推移，由于动态平衡等因素的变化，往往会变得不再正确。例如，架构师将系统设计为桌面应用，但随着用户习惯的改变，业界将其引向了网页应用。最初的决定并没有错，但环境意外地改变了。</p><h4 id="陷阱：简历驱动开发"><a href="#陷阱：简历驱动开发" class="headerlink" title="陷阱：简历驱动开发"></a>陷阱：简历驱动开发</h4><p>架构师迷恋软件开发领域的新发展，并迫不及待地想要尝试。然而，要选择出高效的架构，他们必须仔细了解对应的问题域并选择最合适的架构，这样才能提供最理想的能力并且破坏性约束最小。当然，除非架构师陷入了简历驱动开发的陷阱——为了用这些知识丰富自己的简历而选择框架和库。</p><p>不要为了架构而构建架构，构建架构是为了解决问题。在选择架构前，要始终理解问题域，不要本末倒置。</p><h3 id="增量变更"><a href="#增量变更" class="headerlink" title="增量变更"></a>增量变更</h3><p>几十年来，编写软件的目标没有考虑敏捷性，而是围绕着降低成本、共享资源和其他一些外部约束。因此，很多组织缺乏能够支持演进式架构的基础。</p><h4 id="反模式：管理不当"><a href="#反模式：管理不当" class="headerlink" title="反模式：管理不当"></a>反模式：管理不当</h4><p>软件架构并非处于真空之中，它通常反映了设计时所处的环境。</p><p>从开发的角度来看，由于无意的耦合，在同一台主机上打包多个资源并不可取。无论共享资源间隔离得多么好，资源竞争终将出现。</p><p>如今，开发人员可以构建组件高度隔离的架构（例如微服务），来消除因共享环境加剧的意外耦合。但是很多公司依然坚持着陈旧的管理手段。这类管理模式重视共享资源和同质化的环境。近来由于 DevOps 等运动的改进，使得这种管理模式不再适用。</p><p>软件能力是每个前沿公司的必备能力，对于想要保持竞争力的公司更是如此。其中便包括如何管理研发资产，例如软件运行环境。</p><p>当开发人员能够不费成本（金钱或时间）地创建虚拟机和容器资源时，看重单一解决方案的管理模式就变得不适用了。微服务领域出现了一种更好的方式。微服务架构的一个常见特征就是支持异构的环境，各个服务团队可以选择适合的技术栈来实现他们的服务，而不用按照企业标准进行统一。这与传统方式截然相反，因此当传统企业的架构师听到这个建议时会退缩。然而，大多数微服务项目的目标并不是武断地选择不同的技术，而是根据具体问题选择适当的技术。</p><p>在现代环境中，将不同技术栈统一成单一技术栈是不当的管理。这会无意将问题过度复杂化，管理决策使得实现解决方案所需的工作毫无意义地成倍增加。</p><p>在微服务架构中，由于服务间不存在技术架构或数据架构的耦合，不同的团队可以选择正确的复杂度来实现其服务。其终极目标是化繁为简，保持技术栈复杂度和技术需求的一致。当团队全权负责其服务（包括运维）时，这样的划分往往效果最佳。</p><p>微服务架构的目标之一是技术架构的极限解耦，使得更换服务不会产生任何副作用。</p><p>从大型组织的实用性管理的角度来看，我们发现<strong>金发姑娘管理模式</strong>效果不错：选择<strong>简单</strong>、<strong>中等</strong>和<strong>复杂</strong>三种技术栈作为标准，然后允许单个服务需求驱动技术栈的需求。这样就赋予了团队选择合适技术栈的灵活性，还能继续为企业保留标准化带来的好处。</p><h4 id="陷阱：发布过慢"><a href="#陷阱：发布过慢" class="headerlink" title="陷阱：发布过慢"></a>陷阱：发布过慢</h4><p>持续交付中的工程实践排除了拖慢软件发布速度的因素，这些实践应该作为演进式架构成功的前提。虽然持续交付的终极目标，持续部署，对于演进式架构来说不是必需的，但软件的演进能力与其发布能力息息相关。</p><p>如果企业围绕持续部署打造工程文化，期望所有变更在通过了部署流水线设置的挑战后便进入生产环境，那么开发人员就会习惯于持续变更。另一方面，如果发布是一个需要很多专业化工作的正式流程，那么利用演进式架构的机会就会减少。</p><p>持续交付追求数据驱动的结果，从指标数据中学习如何优化项目。开发人员必须衡量事物从而了解如何优化。生产周期是持续交付的一个关键指标，和交付周期相关。交付周期是指从一个想法开始到它在软件中实现所耗费的时间。然而，交付周期中包含很多主观活动，例如估算、排列优先级等，使其成为了一个糟糕的工程指标。因此持续交付跟踪生产周期，即启动和完成单位工作所用的时间，这里指软件开发。生产周期从开发人员着手开发某个新功能起开始计时，当该功能在生产环境中运行时停止计时。其目标是衡量工程效率，<strong>持续交付的关键目标之一便是缩短生产周期</strong>。</p><p>生产周期对于演进式架构也至关重要。在生物学中，果蝇常用于验证遗传特征，因为他们的生命周期短，新一代出现的速度足够让生物学家观察到明确的结果。这在演进式架构中也同样成立——更快的生产周期意味着架构可以更快地演进。因此，一个项目的生产周期决定了架构的演进速度。换句话说，演进速度和生产周期成正比。表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v ∝ c</span><br></pre></td></tr></table></figure><p><code>v</code> 代表变更速度，<code>c</code> 代表生产周期。开发人员无法在生产周期内完成系统的演进。换句话说，团队发布软件的速度越快，那么他们便能够越快地演进系统的各个部分。</p><p>因此，在演进式架构项目中，生产周期是重要指标，更快的发布速度意味着更快的演进能力。事实上，<strong>生产周期是基于过程的原子适应度函数的理想选择</strong>。例如，开发人员构建了具备自动化部署流水线的项目，其生产周期为 3 个小时。随着时间推移，由于开发人员向部署流水线添加了更多校验和集成点，生产周期逐渐延长。由于时间是该项目的重要指标，他们设置了适应度函数，当周期时间超过 4 个小时便发出警告。一旦达到阈值，开发人员可以决定调整部署流水线的工作方式，或者决定是否可以接受 4 小时的生产周期。适应度函数适用于开发人员想监控项目的任何行为，包括项目指标。将项目关注点统一成适应度函数使得开发人员可以设置未来决策点，即最后责任时刻，以重新评估决策。在前面的例子中，开发人员必须在当时决定哪一个更重要，是 3 小时的生产者周期，还是他们建立的测试。在大多数项目中，开发人员并不会注意到生产周期逐渐延长，因此也不会权衡冲突的目标，结果含糊地做出这些决定。借助适应度函数，他们可以围绕预期的未来决策点设置阈值。</p><p>演进的速度和生产周期成正比，生产周期越短，演进越快。</p><p>良好的工程、部署和发布实践是使演进式架构获得成功的关键，反过来又通过假设驱动开发为业务提供新能力。</p><h3 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h3><p>大多数时候，业务人员并非有意给开发人员制造麻烦，但他们的优先权会产生不当的架构决策，在无意间限制了将来的选择。</p><h4 id="陷阱：产品定制"><a href="#陷阱：产品定制" class="headerlink" title="陷阱：产品定制"></a>陷阱：产品定制</h4><p>销售人员需要卖点。</p><ul><li><strong>为每个客户定制</strong>: 在这个场景中，销售人员在紧迫的时间内承诺实现特定版本的功能，迫使开发人员使用版本控制分支或标签技术来跟踪版本。</li><li><strong>永久的功能开关</strong>: 有时将它战略性地用于构建永久的定制功能。开发人员可以使用功能开关来为不同客户创建不同的版本，或创建“免费”版产品，让用户付费解锁高级功能。</li><li><strong>产品驱动定制化</strong>: 有些产品甚至可以通过 UI 来完成定制。在这种情况下，定制功能是应用的永久部分，需要和其他所有产品功能受到同样的维护。</li></ul><p>功能开关和定制化的存在导致产品具有很多可能的路径排列，显著加重了测试负担。除了测试场景，为了保护可能的排列，开发人员可能需要构建更多的适应度函数。</p><p>定制也会妨碍演进能力，但我们并不是劝阻企业构建可定制的软件，企业应该实事求是地评估相关成本。</p><h4 id="反模式：报表"><a href="#反模式：报表" class="headerlink" title="反模式：报表"></a>反模式：报表</h4><p>大多数应用根据不同的业务功能有着不同的用途。<br>报表是单体架构中意外耦合的好例子。</p><p>在分层架构中，开发人员和报表设计人员会合谋创建一种常见的陷阱，它体现了不同业务问题之间的紧张关系。架构师构建分层架构来减少意外耦合，创建隔离层来分离关注点。然而，报表并不需要单独的层支持其功能，它只需要数据。另外，在不同层间路由请求还会使延时增加。因此，很多有着良好分层架构的公司允许报表设计人员将报表和数据库模式直接耦合起来，使得在不影响报表的情况下无法变更数据库模式。这个例子很好地展示了冲突的业务目标是如何破坏架构师的工作，并使演进变得极其困难的。虽然没有人开始就打算让系统难以演进，但这是决策的累积效应。</p><p>很多微服务架构通过分离行为来解决报表问题，而微服务的隔离有利于分离但不利于整合。通常构建这类架构时，架构师使用事件流或消息队列来向领域“记录系统”数据库填充数据，每个记录系统嵌在服务架构量子中，使用最终一致性而不是事务行为。一些报表服务也会监听事件流，向针对报表优化过的非规范化数据库中填充数据。从架构的角度来看，协调也是一种耦合，使用最终一致性能让架构师免于协调，为应用程序的不同用途做出不同的抽象。</p><p>消除因混合领域和报表引起的不当耦合，使得每个团队可以专注于更加具体且简单的任务。</p><h4 id="陷阱：规划视野"><a href="#陷阱：规划视野" class="headerlink" title="陷阱：规划视野"></a>陷阱：规划视野</h4><p>预算和规划流程通常决定了对假设和早期决策（假设的基础）的需求。在开发人员为最终用户编写任何代码或发布软件之前，他们所学到的“最佳实践”或“同类最佳”构成了基础假设的一部分。投入到假设中的努力越多，即便在六个月内证明它们是错误的，仍会导致对其强烈的依赖。沉没成本的误区描述了受情绪投入影响的决策。简而言之，<strong>人们对某件事情投入的时间和精力越多，就越难放弃它</strong>。在软件中，它表现为不合理的工件附件。例如，人们在规划和文档上投入的时间和精力越多，就越可能保护其中的内容，即便有证据表明它们不准确或过时了。</p><p>谨防长期规划，因为它会迫使架构师做出的决策不可逆转，同时找到方法来保证多个可选方案。<strong>将大型项目分解成更小的早期可交付物，以测试架构选型和开发基础设施的可行性</strong>。在通过最终用户反馈验证所用技术确实适用他们试图解决的问题之前，架构师应该避免在实际构建软件之前采用需要大量前期投入的技术，例如大型许可和支持合同。</p><h2 id="八、实践演进式架构"><a href="#八、实践演进式架构" class="headerlink" title="八、实践演进式架构"></a>八、实践演进式架构</h2><h3 id="组织因素"><a href="#组织因素" class="headerlink" title="组织因素"></a>组织因素</h3><p>软件架构广泛地影响着看似与软件无关的各种因素，包括团队影响、预算等许多方面。<br>在构建演进式架构时，围绕<strong>领域</strong>而不是技术能力组建团队具有许多优势和一些共同特征。</p><h4 id="全功能团队"><a href="#全功能团队" class="headerlink" title="全功能团队"></a>全功能团队</h4><p>以领域为中心的团队应该是全功能的，这意味着每个项目角色都由该项目组成员承担。以领域为中心的团队，其目标是消除运营摩擦。换句话说，团队拥有负责设计、实现和部署其服务的所有角色，其中还包括传统上单独的角色，例如运维。但是这些角色必须改变以适应新的结构，这些角色如下所示。</p><ul><li><strong>业务分析师</strong>: 业务分析师必须与其他服务协调该服务的目标，包括其他服务团队。</li><li><strong>架构师</strong>: 架构师设计架构来消除不当耦合，以简化增量变更。请注意，这里不需要像微服务那样独特的架构。一个精心设计的模块化单体应用也能以相同的能力适应增量变更（虽然架构师必须明确设计应用程序来支持这种程度的变更）。</li><li><strong>测试人员</strong>: 测试人员必须习惯于跨领域集成测试带来的挑战，例如构建集成环境、创建和维护契约等。</li><li><strong>运维人员</strong>: 对于 IT 结构相对传统的组织而言，划分服务并分别进行部署（通常与现有服务一同持续部署）是一项艰巨的挑战。保守派架构师天真地认为组件和运维模块化是一回事，但事实通常并非如此。自动化的 DevOps 任务是成功的关键，例如自动化的服务器配置和部署。</li><li><strong>数据人员</strong>: DBA 必须应对新的数据粒度、事务和记录系统问题。</li></ul><p>全功能团队的目标之一便是<strong>消除协调摩擦</strong>。传统的团队彼此独立，开发人员通常需要等 DBA 做出变更或等运维人员提供资源。同一个团队包含各种角色能消除不同团队协调所产生的偶然摩擦。</p><p>项目间可以尝试共享受限的资源。</p><p>通过围绕领域组建架构和团队，现在可以由同一个团队处理常见的变更单元，从而减少了团队间的摩擦。以领域为中心的架构仍然使用分层架构来发挥其优势，例如关注点分离。举个例子，某个微服务的实现或许依赖于分层架构的框架，使得团队可以轻松替换某个技术层。微服务将技术架构封装在领域范围内，颠覆了传统的关系。</p><h4 id="围绕业务能力组织团队"><a href="#围绕业务能力组织团队" class="headerlink" title="　围绕业务能力组织团队"></a>　围绕业务能力组织团队</h4><p>在大多数组织中，通过采用开源软件，架构师渐渐摆脱了商业软件的束缚。共享资源架构存在固有的问题，它会引起系统各部分间无意的干扰。现在开发人员可以创建定制的环境和功能，更容易将重点从技术架构上转移到以领域为中心的架构，进而更好地匹配大多数软件项目中的常见变更单元。</p><h4 id="产品高于项目"><a href="#产品高于项目" class="headerlink" title="产品高于项目"></a>产品高于项目</h4><p>在大多数组织中，软件项目的工作流程是通用的。确定一个问题，组建开发团队，然后着手解决问题，直至“完成”，紧接着将软件移交给运维团队进行后续的管理、升级和维护工作。随后项目团队转向下一个问题。</p><p>这导致了许多常见问题。首先，由于团队转向了其他问题，通常很难进行漏洞修复和其他维护工作。其次，由于开发人员不参与代码运维的相关工作，因此他们不太关心质量等问题。通常，开发人员和他们运行的代码的间接层越多，他们与代码之间的联系就越少。有时这会导致在不同团队间产生对立心态，这并不奇怪，因为很多组织结构催生了员工间的冲突。通过将软件视为产品，公司能在三个方面实现转变。第一，与项目的生命周期不同，产品的生命更长久。全功能团队（通常基于康威逆定律）与产品保持联系。第二，每个产品都有一个负责人，他会主张在体系中使用该产品，并管理其需求。第三，由于是全功能团队，团队拥有产品所需的各种角色，例如业务分析师、开发人员、质量保障人员、DBA、运维人员等。</p><p>从项目心态转变为产品心态的真正目标是得到公司的长期支持。</p><blockquote><p>亚马逊以其产品团队的组织方式而闻名，他们称之为“两个比萨团队”。其理论是，两个大的比萨就够任何一个团队吃了。这种划分方式背后的动机更多是为了沟通方便而不是控制团队大小，因为在更大的团队中，成员必须和更多的人沟通。每个团队都是全功能团队，并且都奉行着“谁构建，谁运行”的理念，这意味着每个团队全权负责其服务，包括运维工作。</p></blockquote><p>小的全功能团队还充分利用了人性。</p><p>根据人们与生俱来的社会行为构建高度负责的团队，能使团队成员更加负责。</p><p>构建全功能团队可以防止不同团队间的相互指责，并让团队产生主人翁意识，激励团队成员做到最好。</p><h4 id="应对外部变化"><a href="#应对外部变化" class="headerlink" title="应对外部变化"></a>应对外部变化</h4><p>我们提倡在技术架构、团队结构等各方面都构建高度解耦的组件，从而将演进能力最大化，但在现实世界中，为了能协同解决领域问题，组件必须交互来共享信息。</p><p>我们构建适应度函数来保护架构中的维度免于演进副作用的影响。微服务架构中的一个常见实践便是采用消费者驱动的契约，即原子集成架构适应度函数。</p><p>演进式架构的增量变更默认开发团队具备一定的工程成熟度。例如，如果团队正在采用消费者驱动的契约，但他们的构建偶尔会损坏几天，那么他们无法得知集成点是否仍然有效。采用工程实践通过适应度函数来监督实践可以为开发人员减轻做大量手动工作的痛苦，但这需要一定的成熟度才能成功。</p><h4 id="团队成员间的连接数"><a href="#团队成员间的连接数" class="headerlink" title="团队成员间的连接数"></a>团队成员间的连接数</h4><p>很多公司意识到，大型开发团队的效果不佳，J. Richard Hackman（知名团队动力专家）解释了该现象的原因:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人与人之间的连接数 = n(n-1) / 2</span><br></pre></td></tr></table></figure><p>因此，构建小型团队是为了减少沟通连接。并且，为了消除不同团队间协作所产生的人为摩擦，这些小型团队需要是全功能团队。每个团队无须了解其他团队所做的事情，除非团队之间存在集成点。即便如此，也应该使用适应度函数保证集成点的完整性。</p><h3 id="团队的耦合特征"><a href="#团队的耦合特征" class="headerlink" title="团队的耦合特征"></a>团队的耦合特征</h3><h4 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h4><p>架构师应该关注工程师构建系统的方式并注意组织所奖励的行为。架构师选择工具和进行设计的活动和决策过程会影响软件的演进能力。好的架构师会担任领导角色，为开发人员构建系统确立技术文化和设计方法。他们教授和支持工程师构建演进式架构所需的技能。<br>架构师能通过提下列问题了解团队的工程文化：</p><ul><li>• 是否团队所有人都知道什么是适应度函数，并考虑了新工具或产品选型对演进新适应度函数的影响？</li><li>• 团队是否衡量了系统与所定义的适应度函数的匹配程度？</li><li>• 工程师是否理解内聚和耦合？</li><li>• 是否讨论了什么领域和技术概念该整合到一起？</li><li>• 团队是基于变更能力还是基于他们想学习的技术来选择解决方案的？</li><li>• 团队对业务变更如何做出反应？他们是否难于完成小的变更，或在小的业务变更上花费了太多时间？</li></ul><blockquote><p>告诉我你的衡量标准，我就告诉你我会如何行动。 ——Eliyahu M. Goldratt 博士，The Haystack Syndrome</p></blockquote><p>如果团队不习惯改变，那么架构师可以引入实践来优先应对这一点。例如，当团队考虑采用某个新的库或框架时，架构师可以让团队通过快速试验来进行明确的评估，看看新的库或框架会引入多少额外的耦合。工程师是否可以轻松地在该库或框架之外编写和测试代码，又或者新的库或框架是否需要配备额外的运行环境，而拖慢开发周期。</p><p>除了选择新的库和框架以外，审查代码需要考虑代码变更对未来变更的支持。如果系统某处突然需要一个额外的集成点，并且该集成点将会变化，那么需要涉及多少处更新呢？当然，开发人员必须留意过度设计，避免因为变更而永久地增加额外的复杂度或抽象。《重构》一书提供了相关建议。</p><p>交付新功能是驱动和奖励团队最常见的原因，但对于代码质量和演进性方面，只有在团队重视时才会予以考虑。负责演进式架构的架构师需要注意团队的行为，优先考虑那些有助于或支持演进能力的设计决策。</p><h4 id="试验文化"><a href="#试验文化" class="headerlink" title="　试验文化"></a>　试验文化</h4><p>成功的演进离不开试验，但有些公司因为忙于交付而无暇进行试验。成功的试验是经常进行一些小型活动来尝试新的想法（从技术和产品角度）并将成功的试验集成到现有系统中。</p><blockquote><p>衡量成功的真正标准是在 24 小时内能完成的试验数量。 ——Thomas Alva Edison</p></blockquote><p>组织可以通过如下几种方式鼓励试验。</p><ul><li><strong>从外部吸收想法</strong>: 很多公司派员工参加展会，并鼓励他们寻求新的技术、工具和能更好地解决问题的方法。还有公司将外部建议或顾问作为新想法的来源。</li><li><strong>鼓励明确的改进</strong>: 丰田公司因其持续改善（kaizen）文化而闻名。期望每个人能不断地寻求持续改善，特别是那些最了解问题并负责解决问题的人。</li><li><strong>进行探针试验并稳定下来</strong>: 探针试验是极限编程实践，让团队构建一个临时方案以快速了解某个棘手的技术问题、探索某个不熟悉的领域，或者提升估算的信心。使用探针试验会牺牲软件质量来提升学习速度。没人会把探针试验得到的方案直接用于生产环境，因为它缺少必要的考量和时间来使其切实可行。它是为学习而生的，不是精心设计的方案。</li><li><strong>创造创新时间</strong>: 谷歌因其“20% 的时间”闻名于世，其员工可以将其 20% 的工作时间用于任意项目。<br>其他公司组织黑客马拉松并允许团队探索新产品或改进现有产品。Atlassian 定期召开 24 小时会议，并称其为 ShipIt。</li><li><strong>采用基于集合的开发方式</strong>: 基于集合的开发专注于探索多种方法。乍一看，由于额外的工作，多个可选项很费功夫，但在探索多个选项的同时，团队最终能更好地理解问题，并通过工具和方法找到真正的约束。令该方法有效的关键是在短时间（几天）内构建多个原型，从而获取更具体的数据和体验。在综合考虑多个竞选方案后，往往才能得出更好的方案。</li><li><strong>连接工程师和最终用户</strong>: 只有当团队清楚试验的影响，试验才会成功。在许多具有试验思维的企业里，团队和产品人员能直接看到决策对最终用户的影响，并被鼓励通过试验来探索这种影响。A/B 测试是企业应用这种试验思维的实践。企业的另一种实践是派团队和工程师观察用户是如何与软件交互来完成某项任务的。这种实践源于可用性社区的文章，让工程师了解最终用户的感受，以更好地理解用户需求，并通过新的想法来更好地满足他们。</li></ul><h3 id="首席财务官和预算"><a href="#首席财务官和预算" class="headerlink" title="首席财务官和预算"></a>首席财务官和预算</h3><p>在演进式架构中，企业架构的一些传统功能必须反映不断变化的优先级，例如预算。过去，在软件开发领域，预测长期趋势的能力是预算的基础。</p><p>事实上，在架构量子和架构成本之间存在着有趣的联系。随着架构量子数量的增加，每个架构量子的成本降低，直到达到最佳点</p><p><img src="/images/notes/20221210/p-20.png" alt="p-20.png"></p><p>首先，由于架构由较小的部分组成，问题需要分离得更加离散和明确。其次，物理量子数量的增加需要运维方面的自动化，因为当量子数量超过某个点后，人们将无法再手动处理这类事务。</p><p>然而，过小的架构量子有可能使绝对数量的成本高昂。例如，在微服务架构中，构建服务的粒度可以细到表单中的每个字段。在这样的粒度下，各个细小部分间的协调成本开始主导架构中的其他因素。因此，在图中的极端情况下，架构量子的绝对数量导致每个架构量子能获得的好处减少。</p><p>在演进式架构中，<strong>架构师追求合适的量子大小和对应成本之间的最佳点</strong>。每个公司情况各异。例如，市场迅猛发展，公司可能需要更快的变更速度，因此需要更小的架构量子。记住，新一代架构的出现速度与生产周期成正比，架构量子越小，生产周期越短。</p><h3 id="构建企业适应度函数"><a href="#构建企业适应度函数" class="headerlink" title="构建企业适应度函数"></a>构建企业适应度函数</h3><p>在演进式架构中，企业架构师的工作主要围绕着<strong>架构指导</strong>和<strong>企业级适应度函数</strong>展开。微服务架构反映了这一模式转变。由于在运维上各个服务彼此分离，所以不再需要考虑资源共享。相反，架构师指导架构中有明确目标的耦合点（例如服务模板）和平台选择。企业架构师通常负责共享基础设施功能，以及为了企业内部的一致性，将平台选择限制在一定范围内。</p><p>演进式架构赋予企业架构师的另一个新职责是定义企业级适应度函数。企业架构师通常负责企业级非功能需求，例如伸缩性和安全性。很多组织缺乏自动评估能力来评估在单个项目和总体上这些架构特征的表现。一旦项目采用了适应度函数来保护架构的各个部分，企业架构师可以利用相同的机制验证这些企业级的特征保持不变。<br>如果每个项目都使用部署流水线来将适应度函数应用于其构建中，企业架构师也可以在其中插入一些自己的适应度函数。这使得每个项目可以持续校验横切关注点，例如伸缩性、安全性及其他企业级问题，尽早发现缺陷。正如微服务项目共享服务模板可以统一技术架构，企业架构师可以使用部署流水线来推动跨项目的一致性测试。</p><h3 id="从何开始"><a href="#从何开始" class="headerlink" title="从何开始"></a>从何开始</h3><h4 id="容易实现的目标"><a href="#容易实现的目标" class="headerlink" title="容易实现的目标"></a>容易实现的目标</h4><p>如果组织需要早期成功来证明这种方法，架构师可以选择最简单的问题来凸显演进式架构方法。通常，这是系统中在很大程度上已经解耦的一部分，而且最好不在任何依赖的关键路径上。团队可以通过<strong>增强模块性</strong>和<strong>降低耦合</strong>来展示演进式架构的其他方面，如适应度函数和增量变更。构建更好的隔离可以使测试和适应度函数更具针对性。更好地隔离可部署单元使得构建部署流水线更容易，并为构建更强大的测试提供了平台。<br>在采取增量变更的环境中，衡量指标常附属于部署流水线。如果团队通过指标数据进行概念验证，开发人员应该在验证前后收集适当的指标数据。收集具体数据是开发人员审查其方法的最佳方式，记住实证胜于雄辩。<br>这种“<strong>最简单者优先</strong>”的方法将风险降到了最低，但可能牺牲价值，除非团队有幸找到既容易解决、价值也高的问题。对于那些持怀疑态度并想试水演进式架构的公司来说，这是很好的策略。</p><h4 id="最高价值优先"><a href="#最高价值优先" class="headerlink" title="最高价值优先"></a>最高价值优先</h4><p>除了“最简单者优先”外，另一种方法“<strong>最高价值优先</strong>”找到系统中最关键的部分，围绕它构建演进行为。公司可能出于以下几个原因采取该方法。第一，如果架构师确信要实现演进式架构，那么选择价值最高的部分就表明了决心。第二，对于那些仍在评估想法的公司，他们的架构师可能对这些技术在体系中的适用性感兴趣。因此优先选择价值最高的部分，便能明确演进式架构的长远价值。第三，如果架构师怀疑这些方法的适用性，那么用系统中最有价值的部分来审查这些概念，能够为是否继续提供了可行的数据。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>很多公司苦于系统缺乏测试。如果开发人员发现他们的代码库缺乏测试，在向演进式架构做出更具大胆的行动前，他们会添加一些关键测试。</p><p>通常，管理层不赞成开发人员进行只为代码库添加测试的项目。他们对这类活动持怀疑态度，特别是新功能无法如期实现时。于是，架构师应该将模块化增强和高级功能测试结合起来。用单元测试封装功能来为测试驱动开发（TDD）等工程实践提供更好的基础。但更新代码库需要时间，因而在重建代码之前，开发人员应该对一些行为添加粗粒度的功能测试，以验证系统的总体行为不会因为重建而改变。<br>对演进式架构的增量变更而言，测试是关键的组件，并且适应度函数也在积极地利用测试。因此，至少在某种程度上，测试使这些技术成为可能，而且实现演进式架构的难易程度和测试的综合性密切相关。</p><h4 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h4><p>对一些公司而言，构建新能力需要时间，而运维团队常受困于缺乏创新。对那些基础设施功能失调的公司来说，构建演进式架构之前可能需要先解决这些问题。基础设施问题通常有很多形式。例如，有些公司将所有的运维工作外包给别的公司，因此无法控制其体系的关键部分。当需要承担跨公司协调的额外开销时，DevOps 的难度呈级数式上升。<br>另一个常见的基础设施功能失调是开发和运维之间无法穿透的防火墙，因为开发人员根本不了解代码最终将如何运行。这种结构在部门间充斥着权力博弈的公司里很常见，因为每个团队都各行其是。<br>最后，在某些组织中，架构师和开发人员都忽视好的实践，而不断引入大量技术债，这些技术债体现在基础设施中。一些公司甚至连运行环境和运行主体都不清楚，也不了解架构和基础设施之间交互的基本知识。</p><h3 id="演进式架构的未来"><a href="#演进式架构的未来" class="headerlink" title="演进式架构的未来"></a>演进式架构的未来</h3><h4 id="基于-AI-的适应度函数"><a href="#基于-AI-的适应度函数" class="headerlink" title="基于 AI 的适应度函数"></a>基于 AI 的适应度函数</h4><h4 id="生成式测试"><a href="#生成式测试" class="headerlink" title="生成式测试"></a>生成式测试</h4><p>在很多函数式编程社区中，<strong>生成测试</strong>是广受欢迎的常见实践。传统单元测试包含对每个测试用例结果正确与否的判断。然而，通过生成测试，开发人员运行大量测试并抓取结果，然后对结果进行统计分析来查找反常的行为。例如最常用的边界值检查，传统单元测试检查已知的数字临界点（负数、不断增加的数字等），但无法覆盖意外的少数情况。生成测试检查每一个可能的数值并报告失败的少数情况。</p><h3 id="为什么（不）呢"><a href="#为什么（不）呢" class="headerlink" title="为什么（不）呢"></a>为什么（不）呢</h3><p>架构中没有灵丹妙药。如果无法从演进性中获益，我们不建议在项目中为其付出额外的成本和精力。</p><h4 id="公司为何决定构建演进式架构"><a href="#公司为何决定构建演进式架构" class="headerlink" title="公司为何决定构建演进式架构"></a>公司为何决定构建演进式架构</h4><ul><li><ol><li>可预测性与可演进性</li></ol></li><li><ol start="2"><li>规模</li></ol></li><li><ol start="3"><li>高级业务能力</li></ol></li><li><ol start="4"><li>以生产周期为业务指标</li></ol></li><li><ol start="5"><li>在量子级别隔离架构特征</li></ol></li></ul><h4 id="企业为何选择不构建演进式架构"><a href="#企业为何选择不构建演进式架构" class="headerlink" title="企业为何选择不构建演进式架构"></a>企业为何选择不构建演进式架构</h4><ul><li><ol><li>大泥团无法演进</li></ol></li><li><ol start="2"><li>其他架构特征占主导地位</li></ol></li><li><ol start="3"><li>牺牲架构</li></ol></li><li><ol start="4"><li>计划即将停止业务</li></ol></li></ul><h4 id="说服他人"><a href="#说服他人" class="headerlink" title="说服他人"></a>说服他人</h4><p>架构师和开发人员希望非技术人员和管理层理解演进式架构的好处。当组织的某些部分被必要的变更扰乱时尤为如此。例如，当开发人员指出运维部门工作不当时，通常会遇到阻力。</p><p>与其尝试说服组织中的保守人群，不如展示这些想法对其实践的改进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《演进式架构》学习笔记（三）&quot;&gt;&lt;a href=&quot;#《演进式架构》学习笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;《演进式架构》学习笔记（三）&quot;&gt;&lt;/a&gt;《演进式架构》学习笔记（三）&lt;/h1&gt;&lt;p&gt;（此书写得有点杂，但部分内容还可以，以此几篇
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《演进式架构》学习笔记（二）</title>
    <link href="http://blog.michealwayne.cn/2022/12/17/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2022/12/17/notes/【笔记】《演进式架构》（二）/</id>
    <published>2022-12-17T08:20:01.000Z</published>
    <updated>2022-12-20T06:14:56.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《演进式架构》学习笔记（二）"><a href="#《演进式架构》学习笔记（二）" class="headerlink" title="《演进式架构》学习笔记（二）"></a>《演进式架构》学习笔记（二）</h1><p>（此书写得有点杂，但部分内容还可以，以此几篇记录下笔记。）</p><h2 id="四、架构耦合"><a href="#四、架构耦合" class="headerlink" title="四、架构耦合"></a>四、架构耦合</h2><p>演进式架构注重<strong>适当的耦合</strong>，即如何确定哪些架构维度间应该相互耦合来以最小的开销和成本最大程度地获益。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>平台不同，代码复用机制也不同，但它们都支持将相关代码组成<strong>模块</strong>。模块化描述了相关代码的逻辑分组。<br>可以以不同的物理方式封装模块。<strong>组件就是模块的物理封装</strong>。模块意味着逻辑分组，而组件意味着物理划分。</p><p><strong>库</strong>是其中一类组件，它往往和调用代码在相同的内存地址内运行，通过编程语言的函数调用机制进行通信。库常用作编译时的依赖。由于大多数复杂应用是由各式各样的组件构成的，因此在应用程序架构中存在很多和库相关的问题。<br>另一类组件被称为<strong>服务</strong>，倾向于在自己的地址空间中运行，通过低级网络协议（比如 TCP/IP）、更高级的网络协议（比如简单对象访问协议，SOAP），或表述性状态转移（REST）进行通信。服务相关问题往往在集成架构中出现，因为它造成了运行时的依赖。</p><h3 id="架构的量子和粒度"><a href="#架构的量子和粒度" class="headerlink" title="架构的量子和粒度"></a>架构的量子和粒度</h3><p>组件级的耦合并不是联接软件的唯一方式。许多业务概念在语义上联接系统的各个部分，这便产生了功能<strong>内聚</strong>。</p><p>正如物理学所定义的，量子是物理实体相互作用时所涉及的最小单位。<strong>架构量子则是具有高功能内聚并可以独立部署的组件</strong>，它包括了支持系统正常工作的所有结构性元素。<br>在单体架构中，量子就是整个应用程序，每个部分都高度耦合，因此开发人员必须对其进行整体部署。</p><p>微服务架构在架构元素之间定义了物理限界上下文，封装了所有可能变化的部分。这种架构就是为了<strong>增量变更</strong>而设计的。在微服务架构中，限界上下文作为量子边界，包含了服务所依赖的组件，比如数据库服务器。它还包含一些架构组件，例如搜索引擎、报表工具及任何有助于交付功能的组件。</p><p><strong>架构师都应该显式定义架构量子的大小。</strong>小的架构量子意味着更快的变更速度，因为其影响范围更小。通常小组件比大组件更易于使用。量子的大小决定了架构中进行增量变更的可能性（量子越小，可能性越大）。</p><p>构建演进式架构的关键之一在于决定自然组件的粒度以及它们之间的耦合，以此来适应那些通过软件架构支持的能力。</p><h3 id="不同类型架构的演进能力"><a href="#不同类型架构的演进能力" class="headerlink" title="不同类型架构的演进能力"></a>不同类型架构的演进能力</h3><p>软件架构之所以存在，部分原因是为了实现跨特定维度的某种演进——<strong>便于变更</strong>是架构模式的原因之一。架构模式不同，架构量子大小也不同，这影响着架构的演进能力。</p><blockquote><p>需要注意的是，虽然<strong>架构模式</strong>对于成功演进至关重要，但是它并不是唯一的决定性因素。必须结合架构模式固有的特征和系统定义的<strong>附加特征</strong>才能完整定义演进性的各个维度。</p></blockquote><h4 id="“大泥团”架构"><a href="#“大泥团”架构" class="headerlink" title="“大泥团”架构"></a>“大泥团”架构</h4><p>某个无法识别架构的混乱系统，俗称“大泥团反模式”。这些系统高度耦合，当发生变更时会产生连锁副作用。开发人员创建了高度耦合且模块化很差的类。</p><p>如图某个大泥团架构中类的耦合情况，图中每个节点代表一个类，每条线（向内或向外）代表耦合，线的粗细程度表示连接的数量：<br><img src="/images/notes/20221210/p-9.png" alt="p-9"></p><p>站在演进能力的角度来看，这个架构表现极差。</p><ul><li><strong>增量变更</strong>：对这种架构难以做任何变更。相关的代码散布于系统各个角落，这意味着修改其中一个组件将意外地破坏其他组件。修复这些破损会导致更多的破损发生，从而产生无尽的连锁反应。</li><li><strong>通过适应度函数引导变更</strong>：由于没有明确定义分区，我们很难为这种架构构建适应度函数。为了构建保护功能，开发人员必须确定需要保护的部分，但是在这种架构中，除了低级的函数或类之外不存在任何结构。</li><li><strong>适当的耦合</strong>：这种架构是不当耦合的典型。构建这样的软件没有任何架构优势。</li></ul><p>在这样的糟糕状态下，变更困难且成本高。本质上，由于系统各部分间高度耦合，架构量子就是整个系统本身，没有哪个部分可以轻易改变，因为牵一发而动全身。</p><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><p>单体架构的大量代码通常高度耦合。</p><h5 id="1-非结构化的单体架构"><a href="#1-非结构化的单体架构" class="headerlink" title="1. 非结构化的单体架构"></a>1. 非结构化的单体架构</h5><p>这种架构模式包含几种不同的变体，其中包括实质上由相互独立的类互相协调而构成的系统：</p><p><img src="/images/notes/20221210/p-10.png" alt="p-10"></p><p>不同的模块各自处理不同的任务，通过共用的类实现通用功能。在这种架构中，由于缺乏一致的总体结构而阻碍了变更。</p><ul><li><strong>增量变更</strong>：巨大的架构量子阻碍了增量变更，因为高度耦合要求部署大块应用。组件之间存在高度耦合，这导致很难单独部署某个组件，因为需要变更其他组件。</li><li><strong>通过适应度函数引导性变更</strong>：为单体架构构建适应度函数很难，但并非不可能。因为这种架构模式存在了很长时间，可以用随之发展而来的很多工具和测试实践来构建适应度函数。然而，<strong>常见的引导性变更对象通常会成为单体架构的致命弱点，例如性能和伸缩性</strong>。虽然开发人员很容易理解单体架构，但难以构建良好的伸缩性和性能，这很大程度上源于它固有的耦合。</li><li><strong>适当的耦合</strong>：单体架构除了简单的类之外几乎没有内部结构，其耦合程度类似于大泥团架构。因此代码某处的变更可能对其中某个较远的部分产生意想不到的副作用。</li></ul><p>尽管这种架构的演进能力略好于大泥团架构，但是这种架构很容易退化，因为几乎没有结构限制来防止其退化。</p><h5 id="2-分层架构"><a href="#2-分层架构" class="headerlink" title="2.分层架构"></a>2.分层架构</h5><p>其他单体架构以更加结构化的方式创造出了分层架构，其中一个变体如：</p><p><img src="/images/notes/20221210/p-11.png" alt="p-11"></p><p>每层代表一种技术能力，使得开发者能够轻易地置换技术架构功能。分层架<br>构的主要设计准则是<strong>将不同的技术能力分隔到不同的层，每层职责各异</strong>。这种架构的主要优点是关注点独立且分离。每一层相对于其他层都是独立的，但能通过明确定义的接口互相访问。这使得对某一层的变更不会影响其他层，同时将相似的代码组织到一起，为该层的专业化和分离提供了空间。</p><p>无论哪种单体架构，架构量子本身就是应用，包括一些独立组件，例如数据库服务器。量子较大的系统是难以演进的。</p><ul><li><strong>增量变更</strong>：开发人员发现变更这种架构很容易，特别是在将变更隔离到现有层的情况下。跨不同层的变更则会带来协调上的挑战，特别是在组织人员结构和架构分层类似的情况下（这反映了“康威定律”）。例如，某个团队能在不打扰其他团队的情况下替换整个持久层框架，因为他们可以在明确定义的接口背后完成这项工作。但是，当业务要求变更 ShipToCustomer（送货服务）时，该变更则会影响所有层，于是协调在所难免。</li><li><strong>通过适应度函数引导性变更</strong>：在一个更加结构化的单体应用中编写适应度函数更为容易，因为这种架构的结构更明显。同时，将关注点分离到不同层使得开发人员能对更多部分进行隔离测试，便于构建适应度函数。</li><li><strong>适当的耦合</strong>：单体架构的一个优点是易于理解。了解设计模式等概念的开发人员能轻易将这些知识应用于分层架构中。这种易理解性很大程度上是因为开发者能轻松地访问所有代码。分层架构使得由层定义的技术架构划分更易于演进。例如，一个设计（并实现）良好的分层架构能让我们很容易地替换掉数据库、业务规则或其他任何层，并将副作用减至最小。</li></ul><p>无论有意或无意，单体架构往往都高度耦合。当开发人员使用分层架构来分离关注点时（例如使用持久层去简化数据访问），该层通常会表现出内部高度耦合和外部低耦合。在层内，各组件为相同的目标合作，因此它们趋向于高度耦合。相反，开发人员通常会更仔细地定义各层之间的接口，在各层之间创建更低的耦合。</p><h5 id="3-模块化的单体架构"><a href="#3-模块化的单体架构" class="headerlink" title="3. 模块化的单体架构"></a>3. 模块化的单体架构</h5><p>架构师们所赞赏的微服务的许多的优点也能在单体架构中实现，例如隔离性、独立性和小变更单元等，但前提是开发人员极其严格地处理耦合。需要注意的是，这个原则必须拓展到技术架构之外，囊括其他维度（特别是数据）。现代工具让代码易于复用，这使得开发人员很难在容易产生耦合的环境中实现适当的耦合。</p><p>大部分现代编程语言都支持构建严格的可见性和连接规则。如果架构师和开发人员运用这些规则构建一个模块化的单体应用，那么构建出的架构会更具可塑性。</p><ul><li><strong>增量变更</strong>：由于开发人员能够执行模块化，因此在此类架构中很容易进行增量变更。尽管在逻辑上功能被划分为不同的模块，但如果难以单独部署包含模块的组件，那么架构量子依然会很大。在模块化单体架构中，组件的可部署程度决定了增量变更的速度。</li><li><strong>通过适应度函数进行引导性变更</strong>：测试、度量及其他适应度函数在这种架构中更容易设计和执行，因为合理划分了组件，使得测试模拟和其他依赖于隔离层的测试技术更容易实现。</li><li><strong>适当的耦合</strong>：一个设计良好的模块化单体架构是适当耦合的好例子。每个组件在功能上是内聚的，组件之间的接口设计良好且耦合度低。</li></ul><p><img src="/images/notes/20221210/p-12.png" alt="p-12"></p><p>在开始一个新项目时，单体架构，特别是分层架构是普遍的选择，因为它的结构容易理解。但是由于性能下降、代码库过大和其他一系列因素，很多单体最终被取代而走到生命尽头。当前微服务架构是单体架构常见的迁移目标，但相比于单体架构，它在很多方面都更复杂，例如服务、数据粒度、运维、协调、事务等。如果开发团队难以构建最简单的架构，那么转向更复杂的架构又如何能解决问题吗？</p><blockquote><p>如果无法构建单体应用，为什么你认为微服务能解决问题呢？ ——Simon Brown</p></blockquote><p>在重建昂贵的架构之前，提升现有架构的模块化程度能让架构师获益。如果已经没有可以提升的地方了，那么这便是开始重建更加复杂的架构的好时机。</p><h5 id="4-微内核架构"><a href="#4-微内核架构" class="headerlink" title="4. 微内核架构"></a>4. 微内核架构</h5><p>还有一种流行的单体架构——微内核架构，它通常出现在浏览器和集成开发环境（IDE）中，</p><p><img src="/images/notes/20221210/p-13.png" alt="p-13"></p><p>上图所示的微内核架构定义了一个核心系统，核心系统对外提供 API 来通过插件丰富其功能。<br>在这种架构中架构量子大小有两种：一种来自<strong>核心系统</strong>，另一种来自<strong>插件</strong>。架构师通常将核心系统设计成单体应用，并在一些熟知的扩展点为插件创建钩子（hook）。我们通常把插件设计成独立且可单独部署的组件。因此，这种架构支持积极的增量变更，开发人员可以针对可测试性进行设计，更容易定义适应度函数。从技术耦合的角度来看，架构师往往将此类系统设计成低耦合，以保持插件相互独立，从而简化它们。</p><p>微内核架构的主要挑战围绕着<strong>契约</strong>，它是某种形式的语义耦合。为了发挥作用，插件必须和核心系统进行双向信息传递。只要插件不需要互相协调，那么开发人员就可以专注于插件与核心系统间的信息和版本控制。例如，大多数浏览器插件只和浏览器交互，而不和其他插件交互。</p><p>通常，微内核架构包含一个注册表来跟踪安装的插件及其所支持的契约。在插件间建立明确的耦合加重了系统各部分间的语义耦合，进而导致架构量子变大。</p><p>微内核架构广泛应用于 IDE 工具，它也能应用于各种商业应用。</p><p>如果难以通过插件使技术架构演进，那么微内核架构是个不错的选择。由完全独立的插件组成的系统更易于演进，因为插件之间不存在耦合。但依赖彼此协作的插件会增加耦合，进而阻碍系统演进。如果使用彼此交互的插件来设计系统，那么你还应该通过消费者驱动的契约模型构建适应度函数来保护那些集成点。微内核架构的核心系统通常很庞大，但是很稳定，因为大部分的变更应该发生在插件上（除非架构师将应用划分得很差）。因此，增量变更很简单：部署流水线触发对插件的变更并对其进行验证。</p><p>架构师通常不会在微内核技术架构中包含数据依赖，因此开发人员和数据库管理员<strong>必须单独考虑数据的演进能力</strong>。将每个插件视为限界上下文可以提高该架构的演进能力，因为这样可以降低内部耦合。</p><p>从架构演进的角度来看，微内核架构的理想特征如下所示。</p><ul><li><strong>增量变更</strong>：一旦完成了核心系统，大多数行为应来自插件。如果插件都是独立的，那么增量变更会更容易。</li><li><strong>通过适应度函数进行引导性变更</strong>：通常在这种架构中构建适应度函数很简单，因为核心系统和插件是相对独立的。开发人员分别为核心系统和插件维护两套适应度函数。核心适应度函数守护核心系统的变更，包括伸缩性等部署问题。插件测试通常更简单，因为对领域行为的测试是隔离的。为了便于测试插件，开发人员需要很好地模拟核心系统。</li><li><strong>适当的耦合</strong>：微内核模式明确定义了这种架构的耦合特征。从耦合的角度来看，构建独立的插件使变更变得不重要。协调相互依赖的插件则更难。开发人员应该通过适应度函数来将相互依赖的组件正确地集成。</li></ul><p>此类架构还应包含一些整体适应度函数来确保开发人员维持关键的架构特征。例如，单独的插件可能影响某个系统属性，比如伸缩性。因此，开发人员应该计划构建一套<strong>集成测试</strong>，把它作为整体适应度函数。当系统中存在相互依赖的插件时，开发人员还应该构建整体适应度函数来确保契约和消息的一致性。</p><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><p>事件驱动架构（<a href="https://aws.amazon.com/tw/what-is/eda/" target="_blank" rel="noopener">EDA</a>）通常通过消息队列将几个不相关的系统集成在一起。此类架构常用的实现方式有两种：<strong>代理模式</strong>和<strong>中介模式</strong>。两种模式的核心能力不同。</p><h5 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h5><p>代理模式的事件驱动架构由如下架构组件构成。</p><ul><li><strong>消息队列</strong>：消息队列由多种技术实现。</li><li><strong>始发事件</strong>：启动业务流程的事件。</li><li><strong>流程内事件</strong>：为了满足业务流程，在事件处理器之间传递的事件。</li><li><strong>事件处理器</strong>：事件处理器是活跃的架构组件，执行实际的业务流程。当两个处理器间需要协调时，它们通过队列传递消息。</li></ul><p>代理模式的事件驱动架构在构建强大的异步系统时存在一些设计挑战。例如，由于缺少集中的中介，很难进行协调和错误处理。由于架构各部分高度分离，开发人员必须通过架构还原业务流程的功能内聚。因此，像事务这样的行为将更难实现。<br>尽管在实现上存在挑战，但它仍然是极具演进性的架构。开发人员可以通过向现有事件队列添加新的监听器来向系统添加新行为。</p><ul><li><strong>增量变更</strong>：代理模式的事件驱动架构允许多种形式的增量变更。通常开发人员将服务设计为松散耦合的，便于独立部署。解耦转而使开发人员更容易做出无须中断的架构变更。为代理模式的事件驱动架构构建部署流水线是一项挑战，因为架构的本质是<strong>异步通信</strong>，但它<strong>很难测试</strong>。</li><li><strong>通过适应度函数进行引导性变更</strong>：对开发人员来说，在这种架构中编写原子适应度函数很容易，因为事件处理器的个体行为很简单。然而，在这种架构中编写整体适应度函数是必要且复杂的。整个系统的很多行为都依赖于松散服务之间的通信，这导致我们难以测试多层面的工作流。</li><li><strong>适当的耦合</strong>：代理模式的事件驱动架构所展现的低耦合增强了其进行演进式变更的能力。例如，想为这种架构添加新的行为，只需要将新的监听器添加到现有端点，这样不会影响现有的监听器。在这种架构中，服务和它们所维持的消息契约之间存在耦合，这是功能内聚的一种形式。适应度函数运用消费者驱动的契约等技术来帮助管理集成点，避免其被破坏。</li></ul><p>在适合代理模式的 EDA 的业务流程中，事件处理器通常是无状态的、解耦的并且管理自身的数据。这使得演进更加容易，因为它的外部耦合更少，例如数据库耦合。</p><h5 id="2-中介模式"><a href="#2-中介模式" class="headerlink" title="2. 中介模式"></a>2. 中介模式</h5><p>另一个常见的 EDA 模式是中介模式，该模式包含一个额外的组件：作为中介的总线。</p><p><strong>事务性的协调是中介架构的主要优势。</strong>中介能保证流程的正确性，并生成一条单一状态消息发送给受保人。在代理事件驱动架构中，这样的协调更加困难。例如，要生成统一的通知消息，需要协调通知事件处理器或通过某个显式消息队列来处理这种聚合。虽然异步架构在协调和事务行为方面带来了挑战，但是它们的并行规模极佳。</p><ul><li><strong>增量变更</strong>：和代理模式类似，在中介模式中，服务通常很小并且是独立的。因此，这种架构在进行增量变更时具有和代理版本相同的优势。</li><li><strong>通过适应度函数进行引导性变更</strong>：开发人员发现，相比代理模式，为中介模式构建适应度函数更容易。两种模式在测试单个事件处理器上大致相同。然而，构建全系统适应度函数会更容易，因为开发人员可以依赖中介进行协调。例如，在保险工作流中，开发人员可以编写测试并能轻易知晓整个过程是否成功，因为中介在协调这一切。</li><li><strong>适当的耦合</strong>：虽然中介便利了很多测试场景，但也增加了耦合，妨碍了演进。中介包含了重要的领域逻辑，使得架构量子增大，导致了各个服务间的相互耦合。在这种架构中，当有开发人员进行变更时，其他开发人员必须考虑变更对工作流中其他服务产生的副作用、增加的耦合。</li></ul><p>从演进的角度来看，由于降低了耦合，代理架构具有明显优势。在中介模式中，中介充当了耦合点，它将所有受影响的服务绑定在一起。在代理模式中，行为可以通过向已有消息队列添加新的处理器来演进，而不影响其他消息队列。（除了通过流量使队列的负载过重的情况，这种情况可以通过多种架构模式或适应度函数来解决）。由于代理模式在本质上是解耦的，因此更易于演进。</p><p>这是权衡架构的典型例子。代理模式在演进能力、异步性、伸缩性及其他一些所期望的特征上具有优势，但不擅长协调事务等一些基本任务。</p><h4 id="服务导向架构"><a href="#服务导向架构" class="headerlink" title="服务导向架构"></a>服务导向架构</h4><p>现有的服务导向架构（<a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-service-oriented-architecture" target="_blank" rel="noopener">SOA</a>）有很多种类，包括一些混合架构。下面介绍一些常见的架构模式。</p><h5 id="1-企业服务总线驱动的-SOA"><a href="#1-企业服务总线驱动的-SOA" class="headerlink" title="1. 企业服务总线驱动的 SOA"></a>1. 企业服务总线驱动的 SOA</h5><p>有种构建 SOA 的特殊方式在几年前流行起来，那便是通过服务总线构建围绕服务和协调的架构，通常称为企业服务总线（<a href="https://www.ibm.com/cn-zh/cloud/learn/esb" target="_blank" rel="noopener">ESB</a>）。服务总线充当复杂事件交互的中介，并处理其他典型的集成架构中的各种琐事，例如消息转换、编排等。</p><p>虽然企业服务总线架构通常使用和事件驱动架构相同的构件，但服务的组织方式不同。企业服务总线架构<strong>基于严格定义的服务分类方法来组织服务</strong>。其样式因组织而异，但都是根据复用性、共享概念及服务范围划分服务。</p><p>一个典型的 ESB 驱动的 SOA：</p><p><img src="/images/notes/20221210/p-14.png" alt="p-14"></p><p>架构的每一层都有特殊的职责。业务服务抽象定义了业务的粗粒度功能，有时业务人员使用标准工具来定义业务服务。</p><p><strong>抽象的业务服务必须调用代码来执行行为</strong>，这便是企业服务。它由不同的服务团队负责，旨在实现共享。这些团队的目标是构建可复用的服务集成架构，架构师可以通过编排将服务“缝合”在一起形成业务实现。开发人员以高度复用为目标并设计相应的企业服务。</p><p>有些服务并不需要高度可用。例如，系统的某个部分可能需要地理位置，但是没有重要到需要投入资源将其构建成完整的企业服务的程度。</p><p>基础设施服务是共享的服务，由基础设施团队负责。它处理一些非功能需求，例如监控、日志、认证 / 授权等。<br>ESB 驱动的 SOA 的标志是消息总线，它负责以下各类任务。</p><ul><li><strong>中介和路由</strong>：消息总线能够定位服务并与服务通信。通常，消息总线会维护一张注册表，涵盖服务的物理地址、协议以及调用服务所需的其他信息。</li><li><strong>流程编排与编制</strong>：消息总线将企业服务组合到一起并管理任务，例如服务调用顺序。</li><li><strong>消息增强和转换</strong>：集成总线的优势之一是能够代表应用处理通信协议及其他信息的转换。例如，支持 HTTP 协议的服务 A（ServiceA）想调用仅支持 RMI/IIOP 协议的服务 B（ServiceB）。<br>当需要此类转换时，开发人员可以配置消息总线，在无形之中完成此类消息转换。</li></ul><p>ESB 驱动的 SOA 的架构量子很大。它基本包含了整个系统，和单体应用差不多，但由于它是分布式架构，因此更为复杂。在 ESB 驱动的 SOA 中进行演进式变更非常困难，因为在促进服务复用的同时，其服务分类方法会阻碍普通的变更。</p><p>ESB 驱动的 SOA 没有展现出任何演进式架构的特性，所以它在演进性的各个方面得分都不高就不足为奇了。</p><ul><li><strong>增量变更</strong>：虽然对复用和隔离资源有完善的技术服务分类方法，但这种架构却严重地阻碍了对业务领域进行最常规的变更。大多数 SOA 团队都是按照架构划分的，这导致进行常规的变更需要大量的协调工作。而且 ESB 驱动的 SOA 也是难以操作的。通常它由多个物理部署单元组成，这给协调和自动化带来了挑战。没人会为了敏捷性和操作的易用性而采用企业服务总线。</li><li><strong>通过适应度函数进行引导性变更</strong>：在 ESB 驱动的 SOA 中，通常很难进行测试。各部分都不完整，都是某个巨大工作流的一个环节，通常无法单独测试它们。例如，某个为了复用而设计的企业服务，测试其核心行为通常很困难，因为它可能只是各个工作流的一部分。为其构建原子适应度函数几乎不可能，这导致需要大规模的整体适应度函数进行端到端测试来完成大部分验证工作。</li><li><strong>适当的耦合</strong>：从潜在的企业级复用来看，这种奢侈的分类方法是合理的。如果开发人员可以准确地提炼出每个工作流中可复用的精华，那么最终他们就能够一劳永逸地构建出企业的所有行为，而将来的应用开发就变成了连接现有服务。构建 ESB 驱动的 SOA 的目标不是为了系统各部分能够独立演进，所以在这方面它表现得非常糟糕。针对分类复用的设计，损害了它在架构级别进行演进变更的能力。</li></ul><p>软件架构并不是在真空环境中构建的，它们始终反映其所处的环境。例如，当 SOA 还是流行的架构样式时，企业不会使用开源的操作系统，所有基础设施都需要付费获得使用许可，且非常昂贵。<br>虽然可能由于某些原因架构师选择了 ESB 驱动的 SOA，例如处理集成繁重的环境、规模、服务分类或其他合理的原因，但决不是为了演进能力，因为 ESB 驱动的 SOA 并不适合演进。</p><h5 id="2-微服务架构"><a href="#2-微服务架构" class="headerlink" title="2. 微服务架构"></a>2. 微服务架构</h5><p>将持续交付的工程实践和限界上下文的逻辑划分相结合，便形成了微服务的思想基础以及架构量子概念。</p><p>在分层架构中，关注点在技术层面，或者说在应用各部分的工作方式，例如持久性、UI、业务规则等。大部分软件架构都关注这些技术维度。然而，还有另一种视角。</p><p><img src="/images/notes/20221210/p-15.png" alt="p-15"></p><p>从领域的视角来看，分层架构不具有演进性。在高度耦合的架构中，由于各部分<br>之间的高耦合度，开发人员很难对其进行变更。然而，在大部分项目中，通常会围绕领域概念进行变更。</p><p>相反，设想一个主要通过领域维度进行划分的架构：</p><p><img src="/images/notes/20221210/p-16.png" alt="p-16"></p><p>每个服务都围绕 DDD 的领域概念定义，并将技术架构和所依赖的其他组件（例如数据库）封装到<strong>限界上下文</strong>中，构建了高度解耦的架构。每个服务包含其限界上下文的所有部分，并通过<strong>消息</strong>（例如 REST 或消息队列）和其他限界上下文进行通信。因此，服务不需要知道另一个服务的实现细节（例如数据库模式），从而避免了不当的耦合。<strong>该架构的运作目标是用一个服务取代另一个服务而不影响其他服务。</strong></p><p>微服务架构通常遵循以下七个原则：</p><ul><li><strong>围绕业务领域建模</strong>：微服务设计的重点是基于业务领域，而不是基于技术架构。因此，架构量子反映了限界上下文。一些开发人员错误地认为限界上下文代表某个单独的实体，例如客户。相反，它代表某个业务上下文或工作流，例如商品结账。微服务的目标是创建有用的限界上下文，而不是让开发人员构建更小的服务。</li><li><strong>隐藏实现细节</strong>：微服务的技术架构封装在基于业务领域的服务边界中。每个领域形成一个物理限界上下文。服务间通过传递消息或资源来集成，而不是通过暴露实现细节集成，例如数据库模式。</li><li><strong>自动化文化</strong>：微服务架构支持持续交付，它使用部署流水线严格地测试代码，并将一些任务自动化，例如服务器准备和部署。在高速变化的环境中，自动化测试能发挥巨大作用。</li><li><strong>高度去中心化</strong>：微服务形成了一种无共享架构，其目标是尽可能地减少耦合。通常重复好于耦合。</li><li><strong>独立部署</strong>：开发人员和运维人员希望可以独立部署每个服务（包括基础设施），反映了服务间的物理限界上下文。微服务架构的一个明显的优点是开发人员可以在不影响其他服务的情况下部署某个服务。而且，开发人员通常会自动化所有的部署和运维任务，例如并行的测试和持续交付。</li><li><strong>隔离失败</strong>：开发人员会在微服务上下文中和服务间的协调中隔离失败。每个服务都应该处理合理的错误场景并在可能的情况下将其恢复。很多 DevOps 的最佳实践通常在这种架构中出现，例如熔断器模式、舱壁模式等。很多微服务架构遵循着响应式宣言（reactive manifesto），它是一系列运作和协调原则，遵循这些原则可以构建出更加强大的系统。</li><li><strong>高度可观察</strong>：开发人员不能期望人工监控成百上千个服务（一个开发人员无法观察多个 SSH 终端会话）。因此，在微服务架构中监控和日志成了首要问题。如果运维人员无法监控某个服务，那么它相当于不存在了。</li></ul><p>微服务的主要目标是通过物理限界上下文来隔离领域及理解问题领域。因此，它的架构量子就是服务，这使得它成为了演进式架构的优秀示例。</p><ul><li><strong>增量变更</strong>：在微服务架构中，从各方面来看进行增量变更都很容易。每个服务围绕领域概念形成了限界上下文，使得变更只会影响服务所处的上下文。微服务架构强烈依赖于持续交付的自动化实践，利用部署流水线和现代 DevOps 实践。</li><li><strong>通过适应度函数进行引导性变更</strong>：开发人员可以很容易地为微服务架构构建原子适应度函数和整体适应度函数。每个服务有着明确定义的边界，开发人员可以在服务组件内进行各种级别的测试。服务间需要通过集成来相互协作，这些集成点也需要测试。幸运的是，随着微服务的发展，先进的测试技术也不断涌现。</li><li><strong>适当的耦合</strong>：微服务的耦合通常有两种：集成和服务模板。很明显，集成耦合的服务间需要互相调用来传递信息。另一种耦合，服务模板，用于防止有害的重复。如果各种设施能够在微服务内部管理并保持一致，开发人员和运维人员就能从中受益。例如，每个服务都需要包含监控、日志、认证 / 授权和其他一些基本能力。如果将它们交给各个服务团队负责，那么保证兼容性及生命周期管理（例如升级）将会非常困难。通过在服务模板中定义适当的技术架构耦合点，并让基础设施团队管理这些耦合，就能使各个服务团队免于这些苦恼。领域团队只需要扩展这些模板并编写自己的业务行为。基础设施升级后，在下一<br>次部署流水线执行时服务模板将自动采用新行为。</li></ul><p>微服务架构中的物理限界上下文正好与架构量子概念吻合，架构量子是一种具有高功能内聚性并在物理上解耦的可部署组件。<br>严格按照领域限界上下文进行服务划分是微服务架构的一个关键原则。微服务将技术架构内嵌到领域中，遵循 DDD 的限界上下文原则，对各个服务进行物理隔离，使得微服务在技术上成为无共享架构。每个服务在物理上都是分离的，可以轻松地替换和演进。由于每个微服务都在其限界上下文中内嵌了技术架构，它们都能以必要的方式演进。因此，微服务演进性的维度与其服务的数量相当，开发人员可以单独处理每个服务，因为每个服务都是高度解耦的。</p><blockquote><p>架构师通常将微服务称为“<strong>无共享</strong>”架构。这种架构的主要优势是在技术架构层面完全解耦。但是对耦合不满的人通常会提到“不当的耦合”。毕竟，一个没有耦合的软件系统也强不到哪里去。这里的“无共享”实际上是指“没有混乱的耦合点”。</p></blockquote><p>持续交付和 DevOps 的发展为软件开发的动态平衡增添了新的因素。如今，我们可以将主机的定义用于版本控制并将自动化运用到极致。部署流水线并行启动多个测试环境来支持安全的持续部署。由于大部分的软件栈都是开源的，所以软件使用许可等问题不再影响架构。社区对软件开发领域出现的新能力做出反应，产生了更加以领域为中心的架构样式。</p><p>在微服务架构中，领域中封装了技术架构和其他架构，使得跨领域维度的演进更容易。关于架构，没有所谓“正确”的观点，它只是反映了开发人员构建项目的目标。如果仅关注技术架构，那么跨该维度的变更将会更容易。然而，一旦忽略了领域视角，那么跨领域维度的演进将和大泥团架构差不多。</p><p>系统的各部分如何在无意间互相耦合，这是在架构层面影响应用程序演进能力的一个主要因素。例如，在分层架构中，架构师有意地将某些层耦合在一起。然而，无意地将领域维度耦合到了一起，导致在领域维度难以演进。这是由于架构师围绕技术架构分层来设计，而不是围绕领域。因此，演进式架构的一个重要方面就是跨维度的适当耦合。</p><h5 id="3-基于服务的架构"><a href="#3-基于服务的架构" class="headerlink" title="3. 基于服务的架构"></a>3. 基于服务的架构</h5><p>另一种常用于迁移的架构是基于服务的架构，它和微服务相似，但有三个明显的区别，分别是<strong>服务粒度</strong>、<strong>数据库范围</strong>和<strong>集成中间件</strong>。基于服务的架构同样以领域为中心，但当开发人员将现有应用重建为更具演进性的架构时，它能解决开发人员所面临的一些挑战。</p><ul><li><strong>更大的服务粒度</strong>：这种架构中的服务往往更大，相较于纯粹围绕领域概念的服务，其服务粒度更像一个“单体应用”。虽然它仍以领域为中心，但是更大的服务导致变更单元（开发、部署、耦合以及其他一系列因素）也更大，增加了变更的难度。当架构师评估一个单体应用时，他们通常会观察围绕常见领域概念的粗粒度进行划分。基于服务的架构在运维隔离上和微服务的目标相同，但是更难实现。由于服务变大，开发人员必须考虑更多的耦合点，并且更大的代码段本身就更为复杂。理想情况下，架构应该支持和微服务一样的部署流水线和小的变更单元。当开发人员修改某个服务时，它应该触发部署流水线来重建相关服务，包括应用。</li><li><strong>数据库作用域</strong>：无论服务的分解程度如何，基于服务的架构往往都使用单体数据库。在很多应用中，将多年（甚至十多年）难以管理的数据库模式重建为原子大小的微服务是不可行甚至不可能的。虽然在某些情况下无法分解数据可能造成不便，但在某些问题域中是不可能的。<br>事务完整性很强的系统不太适合微服务，因为在服务间进行事务行为协调的成本太高了。由于对数据库的要求更宽松，有着复杂事务需求的系统更适合基于服务的架构。<br>虽然数据库保持单一整体，但依赖于数据库的组件可能变得更为细化。因此，尽管服务和基础数据之间的映射可能改变，但这所需的重建较少。</li><li><strong>集成中间件</strong>：微服务和基于服务的架构之间的第三个区别涉及通过中介（如服务总线）来进行外部协调。开发人员在构建全新的微服务应用时不用担心老的集成点，然而很多环境中仍然有大量遗留系统在做着有价值的工作。集成总线（如企业服务总线）擅长将不同协议和消息格式的各种服务整合到一起。如果架构师发现开发环境中集成架构的优先级最高，可以使用集成总线添加和变更相关服务。<br>使用集成总线是一个典型的架构折中。使用集成总线，开发人员能够以更少的代码来将应用集成到一起，并能使用总线来模仿服务间的事务协调。然而使用总线增加了组件间的架构耦合，在不与其他团队协调的情况下，开发人员无法独立完成变更。适应度函数可以降低一些协调成本，但是开发者带来的耦合越高，系统演进就越难。</li></ul><p>演进评估：</p><ul><li><strong>增量变更</strong>：在这种架构中进行增量变更相对可行，因为每个服务都是以领域为中心的。软件项目中的大多数变更都是围绕领域发生的，在变更单元和部署量子之间保持了一致性。由于服务通常会更大，所以无法像微服务那样敏捷，但还是保留了微服务的很多优点。</li><li><strong>通过适应度函数引导变更</strong>：开发人员发现，在基于服务的架构中构建适应度函数通常比在微服务中构建更难，这是由于更高的耦合（通常是数据库耦合）和更大的限界上下文。高耦合的代码通常使编写测试更困难，同时数据耦合度的上升也会导致一系列问题。基于服务的架构中创建的限界上下文越大，系统内部的耦合点就越多，使得测试和其他一些诊断变得更复杂。</li><li><strong>适当的耦合</strong>：耦合通常是开发人员选择基于服务的架构而不是微服务架构的原因，例如，分解数据库模式的难度太大、重建单体应用时面临的高度耦合问题等。构建以领域为中心的服务有助于确保适当的耦合，同时服务模板有助于构建适当的技术架构耦合。</li></ul><p>基于服务的架构内在的演进能力肯定比 ESB 驱动的 SOA 架构要好。开发人员偏离限界上下文的程度决定了架构量子的大小和破坏性耦合的数量。<br>基于服务的架构在纯粹的微服务思想和很多项目的实现之间做出了很好的折中。通过放宽对服务大小、数据库独立性和偶然但有用的耦合的限制，该架构解决了微服务中最另人头疼的问题，同时还保留了许多长处。</p><h3 id="“无服务”架构"><a href="#“无服务”架构" class="headerlink" title="“无服务”架构"></a>“无服务”架构</h3><p>“无服务”架构是软件开发动态平衡中最近出现的变化，它的两大含义都适用于演进式架构。</p><p><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/backend-as-a-service-baas/" target="_blank" rel="noopener">BaaS</a>（后端即服务）是那些明显或从根本上依赖于第三方应用或云端服务的应用。其简单示例如图：</p><p><img src="/images/notes/20221210/p-17.png" alt="p-17"></p><p>开发人员编写少量代码甚至无须编写代码。架构由相连的服务组成，包<br>括认证、数据传输和其他集成架构组件。这种架构之所以吸引人是因为组织编写的代码越少，他们需要维护的代码就越少。然而，重度集成的架构有其自身的挑战。</p><p>另一类无服务架构是 <a href="https://www.ibm.com/se-en/cloud/learn/faas" target="_blank" rel="noopener">FaaS</a>（功能即服务），它对基础设施要求不高（至少是在开发人员看来），为每个请求提供基础设施，自动处理水平扩展，还承担环境准备和其他一系列管理职责。在 FaaS 中，功能由服务提供商所定义的事件类型触发。</p><p>通常假设 FaaS 功能是无状态的，因而调用者需要处理状态。</p><ul><li><strong>增量变更</strong>：在无服务架构中，增量变更需要重新部署代码，基础设施相关的所有问题都在“无服务”的抽象背后。这种架构非常适用于部署流水线，在开发人员开展变更时使用部署流水线进行测试和增量的部署。</li><li><strong>通过适应度函数引导变更</strong>：在此类架构中，为了使集成点保持一致，适应度函数至关重要。因为服务间的协调是关键，开发人员需要编写更高比例的整体适应度函数，并在多个集成点上下文中运行它们，以保第三方 API 不变。架构师频繁地在集成点之间构建防腐层，以避免“供应商为王”反模式。</li><li><strong>适当的耦合</strong>：从演进式架构的角度来看，FaaS 吸引人的原因是它消除了考虑因素中多个不同的维度，例如技术架构、运维和安全问题等。虽然这种架构可能易于演进，但在实际考虑方面受到了严重的限制，并将大量复杂问题转嫁给了调用方。例如，虽然 FaaS 能处理弹性的水平扩展，但是调用方必须处理所有的事务行为和其他复杂的协调工作。在传统应用中，通常由后端处理事务协调。然而，如果 BaaS 不支持该行为，那么协调工作就必然会转嫁给用户接口（服务请求者）。</li></ul><p>虽然无服务架构有很多吸引人的特性，但也存在限制。团队需要构建的大部分内容都很快捷，但有时构建完整的方案会令人很苦恼。</p><p>架构师选择架构前，必须针对需要解决的现实问题评估架构。<strong>确保架构与问题领域匹配。不要尝试强行使用不合适的架构。</strong></p><h3 id="控制架构量子大小"><a href="#控制架构量子大小" class="headerlink" title="控制架构量子大小"></a>控制架构量子大小</h3><p><strong>架构量子的大小很大程度上决定了开发人员进行演进式变更的难易程度。</strong>大的架构量子很难演进，例如单体架构和 ESB 驱动的 SOA 架构，因为每次变更都需要进行协调。低耦合的架构为轻松的演进提供了更多途径，例如代理模式的 EDA 和微服务。</p><p><strong>架构演进的结构限制取决于开发人员处理耦合和功能内聚的水平。</strong>如果开发人员构建出的模块化组件系统具有明确定义的集成点，那么演进会更容易。例如，如果开发人员构建了一个单体应用，但是致力于良好的模块化和组件分离，那么该架构将更易于演进，因为解耦使得它的架构量子更小。</p><p><strong>架构量子越小，架构的演进能力越强。</strong></p><hr><h2 id="五、演进式数据"><a href="#五、演进式数据" class="headerlink" title="五、演进式数据"></a>五、演进式数据</h2><p>当提到 <a href="https://en.wikipedia.org/wiki/Database_administration" target="_blank" rel="noopener">DBA</a> 时，我们指的是那些设计数据架构、编写代码访问数据并在应用中使用数据的人；编写在数据库中执行的代码，维护数据库并优化其性能的人；在故障发生时，确保数据库正常备份和恢复的人。通常 DBA 和开发人员是应用的核心构建者，他们应该紧密合作。</p><h3 id="演进式数据库设计"><a href="#演进式数据库设计" class="headerlink" title="演进式数据库设计"></a>演进式数据库设计</h3><p>数据库的演进式设计指<strong>开发人员能够根据需求的不断变化来构建数据库结构并使其演进。</strong>数据库模式是抽象的，和类的层次结构类似。当现实世界发生变化，这些变化需要反映在开发人员和 DBA 所建立的抽象当中。否则，抽象将逐渐脱离与现实世界的同步。</p><h4 id="数据库模式演进"><a href="#数据库模式演进" class="headerlink" title="数据库模式演进"></a>数据库模式演进</h4><p>数据库设计演进的关键在于<strong>数据库模式</strong>和<strong>代码演进</strong>。持续交付使得传统数据孤岛能够适应现代软件项目的持续反馈环。 开发人员必须以和代码变更相同的方式处理数据库结构的变更，它们必须是经过检验的、版本化的和增量的。</p><ul><li><strong>经过检验的</strong>：为了保证稳定性，DBA 和开发人员应该严格测试数据库模式的变更。如果开发人员使用了数据映射工具，例如对象关系映射器（ORM），那么为了使映射关系和数据库模式保持同步，他们应该考虑为此添加适应度函数。</li><li><strong>版本化的</strong>：开发人员和 DBA 应该对数据库模式和那些使用它的代码一同进行版本控制。源代码和数据库模式是共生的，缺一不可。人为分离这两种必然耦合的事物的工程实践将导致低效。</li><li><strong>增量的</strong>：和代码变更一样，变更数据库模式应该是渐进的，即随着系统的演进而增量地进行。现代工程实践往往使用自动化的迁移工具，从而避免手动更新数据库模式。</li></ul><p>利用数据库迁移工具使得开发人员（或 DBA）能够对数据库进行小的增量变更，这一过程将作为部署流水线的一部分自动完成。</p><h5 id="共享数据库集成"><a href="#共享数据库集成" class="headerlink" title="共享数据库集成"></a>共享数据库集成</h5><p>它以关系型数据库为数据共享机制，如</p><p><img src="/images/notes/20221210/p-18.png" alt="p-18"></p><p>使用数据库作为集成点僵化了所有共享项目的数据库模式。</p><p>常用扩展 / 收缩重构模式来化解这种耦合。很多数据库重构技术通过在重构的过程中创建过渡阶段来避免时间问题</p><p><img src="/images/notes/20221210/p-19.png" alt="p-19"></p><p>使用该模式，开发人员会设置开始状态和结束状态，它们会在转变过程中分别维持新、旧两种状态。这个过渡状态允许向下兼容，同时还给企业内的其他系统足够的时间来跟上变化。</p><h3 id="不当的数据耦合"><a href="#不当的数据耦合" class="headerlink" title="不当的数据耦合"></a>不当的数据耦合</h3><p>数据和数据库是大多数现代软件架构中不可或缺的部分，如果开发人员忽略这一关键因素，在尝试演进架构时将会遭遇挫折。</p><p>数据模式是宝贵的，因为它永久有效。</p><p>通常 DBA 通过添加另一张连接表来扩展数据库模式定义。与其冒着破坏现有系统的风险更改数据库模式，他们往往添加一张新的数据表，并通过关系型数据库原语将其与原始数据表关联起来。虽然这样做短期内有效，但是它混淆了真实的根本抽象，因为在现实世界中，一个实体是通过多个事物表现的。随着时间推移，那些几乎不懂重构数据库模式的 DBA 通过拜占庭分组和聚束策略构建出了日渐僵化的模式。</p><p>遗留的数据库模式和数据具有价值，但它们也妨碍了系统的演进能力。架构师、DBA 和业务代表需要展开坦诚的对话，讨论哪个对组织更有价值，是永久地保存遗留数据还是进行演进式变更的能力。我们应识别真正有用的数据并将其保留下来，将旧数据作为参考但不将其纳入演进式开发的主流。</p><p>拒绝重构数据库模式或删除旧数据会使架构耦合到过去，这将导致重构难以进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《演进式架构》学习笔记（二）&quot;&gt;&lt;a href=&quot;#《演进式架构》学习笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;《演进式架构》学习笔记（二）&quot;&gt;&lt;/a&gt;《演进式架构》学习笔记（二）&lt;/h1&gt;&lt;p&gt;（此书写得有点杂，但部分内容还可以，以此几篇
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《演进式架构》学习笔记（一）</title>
    <link href="http://blog.michealwayne.cn/2022/12/10/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2022/12/10/notes/【笔记】《演进式架构》（一）/</id>
    <published>2022-12-10T02:58:49.000Z</published>
    <updated>2022-12-13T08:11:10.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《演进式架构》学习笔记（一）"><a href="#《演进式架构》学习笔记（一）" class="headerlink" title="《演进式架构》学习笔记（一）"></a>《演进式架构》学习笔记（一）</h1><p>（此书写得有点杂，但部分内容还可以，以此几篇记录下笔记。）</p><h2 id="一、软件架构"><a href="#一、软件架构" class="headerlink" title="一、软件架构"></a>一、软件架构</h2><p>为了给出解决方案，架构师工作的第一步是<strong>理解业务需求</strong>，也即领域需求。这些需求是使用软件来解决问题的动机，但终究只是架构师在构建架构时需要考虑的因素之一。架构师还必须考虑其他很多因素，其中一些比较明确（比如清楚地写在性能服务水平协议里），还有一些则隐含在商业活动中不言自明（比如公司正着手并购重组，软件架构显然也要有变动）。</p><p>所以对于软件架构师来说，架构水平体现了他们在权衡业务需求和其他重要因素后找到最佳方案的能力。</p><p><img src="/images/notes/20221210/p-1.png" alt="p-1.png"></p><p>在构建软件时，架构师必须明确哪些特征最重要。然而，许多因素是互相矛盾的。</p><p><img src="/images/notes/20221210/p-2.png" alt="p-2.png"></p><p>在为架构设计做必要分析的同时，又要处理好各个因素之间不可避免的冲突，架构师在权衡每个架构设计方案的利弊时，常常需要做出非常艰难的折中。</p><h3 id="演进式架构"><a href="#演进式架构" class="headerlink" title="演进式架构"></a>演进式架构</h3><p>无论我们怎么努力，软件依然变得越来越难以改变。由于各种原因，软件的组成部分不容易变更，而且随着时间推移变得愈发脆弱和难以操作。</p><h4 id="一切都在变化，如何才能长期规划"><a href="#一切都在变化，如何才能长期规划" class="headerlink" title="一切都在变化，如何才能长期规划"></a>一切都在变化，如何才能长期规划</h4><p>软件开发体系由所有的工具、框架、库以及最佳实践（软件开发领域的技术积累）构成。软件开发体系实现了平衡，开发人员能够理解这个体系并为其添砖加瓦。然而，这种平衡是动态的，随着新事物不断出现，平衡不断被打破和重建。</p><p>在软件开发体系中，每一项创新或新实践都可能打破现状，迫使系统重新建立平衡。</p><p>无论是在软件开发的哪个方面，比如编程平台、编程语言、运维环境、持久化技术等，我们都知道改变会持续发生。虽然无法预测技术或领域格局何时会改变，或哪些变化会持续下去，但我们清楚改变是不可避免的。</p><p>如果易于改变是架构的基本原则，那么变更将不再困难。反过来，使架构具备演进能力会导致一组全新的行为出现，进而再次打破整个体系的平衡。</p><h4 id="完成架构构建后，如何防止它逐渐退化"><a href="#完成架构构建后，如何防止它逐渐退化" class="headerlink" title="完成架构构建后，如何防止它逐渐退化"></a>完成架构构建后，如何防止它逐渐退化</h4><p>有一种不幸的退化叫作架构比特衰减，架构师选择特定的架构模式来满足业务需求及让系统具备某些能力，但这些特征常常意外地随着时间推移而退化。</p><p>定义了那些重要的架构特征后，架构师如何保护这些特征不磨损呢？答案是<strong>添加演进能力</strong>。作为新的架构特征，使其在系统演进时保护其他特征。<br>演进能力是一种元特征和保护其他所有架构特征的架构封装器。</p><p>持续架构指构建架构的过程没有最终状态，它会随着软件开发体系的不断变化而演进，并保护重要的架构特征。我们不会尝试定义整个软件架<br>构，因为已经存在很多定义了。我们通过引入时间和变化作为头等架构元素来扩展当前的定义。</p><p>我们对演进式架构的定义如下：<strong>演进式架构支持跨多个维度的引导性增量变更。</strong></p><h3 id="增量变更"><a href="#增量变更" class="headerlink" title="增量变更"></a>增量变更</h3><p>增量变更描述了软件架构的两个方面：如何增量地构建软件和如何部署软件。</p><p>在开发阶段，允许小的增量变更的架构更易于演进，因为对于开发者来说，变更范围相对更小。对部署而言，增量变更指业务功能的模块化和解耦水平，以及它们是如何映射到架构中去的。</p><p>增量变更的成功需要一些持续交付实践的配合。并不是任何情况都需要所有这些实践，但通常它们会一起发生。</p><h3 id="引导性变更"><a href="#引导性变更" class="headerlink" title="引导性变更"></a>引导性变更</h3><p>一旦架构师选择了重要的架构特征，他们会把变更引导进入架构，以保护这些重要特征。为此，我们借用演化计算中的一个概念：<strong>适应度函数</strong>。该函数是一种目标函数，用于计算潜在的解决方案与既定目标的差距。在演化计算中，适应度函数决定一个算法是否在持续提升。换句话说，随着每个算法变体的产生，基于设计者对算法“适应度”的定义，适应度函数决定每个变体的“适应程度”。</p><p>对于演进式架构，随着架构的演进，我们有着类似的需求。我们需要评估机制，来评估变化对架构重要特征的影响，并防止这些特征随着时间的推移而退化。适应度函数的隐喻涵盖多种机制，包括度量、测试和其他检验工具。我们采用这些机制来确保架构不会以不良方式变更。当架构师确定了需要保护的架构特征时，他们会定义一个或多个适应度函数来提供保护。<br>以往，架构往往要划出一部分作为管理活动，最近架构师才接受了通过架构实现变更的思想。架构适应度函数允许在组织需求和业务功能的上下文中制定决策，并为明晰且可测试的决策奠定了基础。演进式架构并不是毫无约束或不负责任的软件开发方式。相反，它可以在高速变迁的业务、严谨的系统需求和架构特征间找到平衡。适应度函数驱动架构设计决策，并引导架构变更适应业务和技术环境的变化。</p><h3 id="多个架构维度"><a href="#多个架构维度" class="headerlink" title="多个架构维度"></a>多个架构维度</h3><p>为了构建可以不断演进的软件系统，架构师不能只考虑技术架构。</p><p>每个项目都有许多维度，架构师在考虑架构演进时必须要想到。下面是一些影响现代软件架构演进能力的常见维度。</p><p><img src="/images/notes/20221210/p-3.png" alt="p-3.png"></p><p>以上每个视角构成一个架构维度——为了支持特定视角而有意进行的划分。</p><p>从实用角度来看，不论如何对关注点进行分类，架构师都需要保证这些维度不磨损。不同的项目有不同的关注点，这导致每个项目都有特定的维度。对于新项目，以上任何技术都能提供有用的见解，但是对于现有的项目，我们必须处理眼前的实际情况。</p><p>按照架构的维度思考，通过评估重要维度对变化的响应，架构师可以分析不同架构的演进能力。随着系统与互相冲突的问题（伸缩性、安全性、分布式、事务性等）关联得越来越紧密，架构师必须跟踪更多的维度。只有结合所有这些重要维度，思考系统将如何演进，才能构建出可以不断演进的系统。</p><p>项目的整个架构范围由软件需求和其他维度构成。当架构和整个体系随着时间的推移一起演进时，我们可以使用适应度函数来保护架构特征，如</p><p><img src="/images/notes/20221210/p-4.png" alt="p-4.png"></p><p>在图 1-3 中，架构师确定了可审计性、数据、安全性、性能、合法性和伸缩性是该应用的关键架构特征。随着业务需求不断变化，每个架构特征都通过适应度函数来保护其完整性。<br>我们强调架构整体的重要性，但也应意识到，技术架构模式及相关议题也是架构演进的很大一部分，比如耦合和内聚。</p><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><p>康威描述道，在设计的最初阶段，人们首先需要高瞻远瞩地思考如何将职责划分为不同的模式。团队分解问题的方式会左右他们之后的选择，这便是康威定律。</p><blockquote><p>在设计系统时，组织所交付的方案结构将不可避免地与其沟通结构一致。 —— 梅尔文 • 康威</p></blockquote><p>正如康威所描述的，当技术人员将问题分解成更小的块，使其更易于委派时，就会产生协调问题。很多组织为了解决协调问题，会设置正式的沟通结构或是建立森严的等级制度，但这样的解决方案往往是僵化的。</p><p>在很多组织中，团队是根据职能来划分的。比如分为前端开发、后端开发、数据库开发。在这样的组织中，管理层从人力资源的角度简单地按照职能划分团队，没有充分考虑工程效率。虽然每个团队都有其擅长的领域（比如构建一个视图，增加一个后端 API 或服务，或者开发一个新的存储机制），但是当需要发布新的业务功能或特性时，三个团队都要参与其中。各个团队通常都会针对眼前的任务优化效率，而不是针对那些更抽象的战略业务目标（特别是有工期压力时）。这会导致各团队往往专注于交付各自的组件，而不关注端到端的特性价值，导致这些组件可能无法高效协作。<br>在这样的团队编制下，由于每个团队都在不同的时间忙于自己的组件，因此那些依赖所有团队的特性需要花费更长的时间。例如，修改目录页这样常见的业务变更涉及 UI、业务规则和数据库模式的变更。如果每个团队都各自为战，那么他们必须协调时间表，这将增加实现该特性所需的时间。</p><p>康威在论文里提到：“每当新的团队组建，其他团队的职责范围会缩小，能够有效执行的可选设计方案也会随之变少。”换句话说，<strong>人们很难改变其职责范围外的事情</strong>。软件架构师需要时刻关注团队的分工模式，从而使架构目标和团队结构保持一致。</p><p>很多构建架构（如微服务）的公司围绕服务边界构建团队，而不是按孤立的技术架构来划分。称之为“康威逆定律”。以这种方式组织团队是理想的，因为团队结构会影响软件开发的很多维度，并且会反映问题的大小和范围。<br><strong>构建与目标系统架构相仿的团队结构，这样项目会更容易实现</strong>。</p><h3 id="为何演进"><a href="#为何演进" class="headerlink" title="为何演进"></a>为何演进</h3><p>在演进式架构的定义中，引导的含义反映了我们想实现的架构，即我们的最终目标。</p><p>为了构建能实实在在演进的架构，架构师必须支持真正的变化，而不是权宜之计的考虑。</p><h2 id="二、适应度函数"><a href="#二、适应度函数" class="headerlink" title="二、适应度函数"></a>二、适应度函数</h2><p>架构的适应度函数的定义如下：架构的适应度函数为某些架构特征提供了客观的完整性评估。</p><p>适应度函数能够保护系统所需的各种架构特征。由于业务驱动、技术能力及其他诸多不同因素，系统和组织对架构的具体需求会有很大区别。有些系统要求很高的安全性，有些要求可观的吞吐量或低延迟，还有一些要求更好的故障恢复能力。这些对系统的考量形成了架构师所关心的架构特征。从概念上来讲，适应度函数体现了系统架构特征的保护机制。</p><p>我们也可以将全系统适应度函数看作适应度函数的集合，其中每个适应度函数对应架构的一个或多个维度。当适应度函数所对应的维度间存在冲突时，使用全系统适应度函数有助于我们做出必要的权衡。类似的问题在处理多功能优化时很常见，想同时优化所有值是不可能的，因此我们必须做出选择。处理架构适应度函数时也一样，架构师熟知的经典案例是：由于加密的开销巨大，性能和安全性可能冲突，因此架构师必须做出艰难的权衡。架构师在调和对立力量时，很多时候为权衡犯难，比如在伸缩性和性能之间做出权衡。然而，对架构师而言，比较这些不同的特征是永恒的难题，因为它们从根本上是不同的（就好像苹果和橙子那样），并且所有利益相关者都认为自己所关心的特征最为重要。全系统适应度函数允许架构师通过统一的机制思考不同的问题，捕捉和保留重要的架构特征。图 2-1 展示了较小的适应度函数和它们所构成的全系统适应度函数之间的关系。</p><p><img src="/images/notes/20221210/p-5.png" alt="p-5.png"></p><p>全系统适应度函数对于架构演进至关重要，它为架构师提供了比较和评估不同架构特征的基础。与对待那些更具针对性的适应度函数不同，架构师很可能不会评估全系统适应度函数，尽管它为日后确定架构决策的优先级提供了指导。</p><blockquote><p>系统绝不是其组成部分的总和，而是各部分相互作用的产物。 ——Russel Ackoff 博士</p></blockquote><h3 id="什么是适应度函数"><a href="#什么是适应度函数" class="headerlink" title="什么是适应度函数"></a>什么是适应度函数</h3><p>数学上，函数从有效输入值集合中获得输入，将其转换为有效输出值集合中的唯一元素。在软件中，我们也普遍使用“函数”来指代可实现的东西。</p><p>正如敏捷软件开发中的验收标准，适应度函数可能无法通过软件的方式实现（比如出于监管原因必须手动完成的某个过程），于是架构师还必须定义手动的适应度函数来指导系统演进。虽然我们倾向于实施自动化检查，但是有些项目无法自动化所有适应度函数。</p><p>也可以通过适应度函数保持代码规范。圈复杂度是常用的代码衡量指标，用来衡量函数或方法的复杂度。架构师可以设置一个阈值上限，然后在持续集成中运行单元测试来保护它，最后使用工具评估该衡量指标。在前面的例子里，架构师决定何时运行适应度函数来评估性能。对于代码规范而言，开发人员希望出现不规范的代码时构建立即停止，从而能积极地解决问题。</p><p>尽管很有必要，但是由于复杂性及其他约束，开发人员有时无法完整地执行所有适应度函数，比如对产生硬故障的数据库进行故障转移的时候。虽然自恢复的过程或许（也应该）是全自动的，但手动触发测试会更好。另外，尽管我们鼓励使用自动化脚本，但是手动确定测试成功与否或许更高效。</p><p>最终，所谓“适应度函数引导演进式架构”，指的是通过单独的适应度函数评估单个架构选择，同时通过全系统适应度函数确定变更的影响。适应度函数共同指出架构中对我们重要的部分，使我们能够在软件开发过程中做出各种关键又令人烦恼的权衡。</p><p>适应度函数将许多已有的概念统一为一个整体机制，让架构师可以统一思考许多现有的（往往是临时的）“非功能性需求”测试。收集重要的架构阈值和需求作为适应度函数，使得以前模糊又主观的评价标准变得更加具体。我们利用了大量现有机制来构建适应度函数，包括传统的测试、监控等工具。当然，并非所有测试都是适应度函数，只有当测试有助于验证架构问题的完整性时，它才是适应度函数。</p><h3 id="适应度函数分类"><a href="#适应度函数分类" class="headerlink" title="适应度函数分类"></a>适应度函数分类</h3><p>适应度函数有很多不同的分类方式，可以依据其范围、运行频率、动态性及其他因素对其进行分类，必要时还可以对不同分类进行组合。</p><h4 id="原子适应度函数与整体适应度函数"><a href="#原子适应度函数与整体适应度函数" class="headerlink" title="　原子适应度函数与整体适应度函数"></a>　原子适应度函数与整体适应度函数</h4><p>原子适应度函数针对单一的上下文执行，用来校验架构的某一维度，比如某个用来验证模块间耦合的单元测试。<br>对于某些架构特征，开发人员不能只是孤立地测试各个架构维度。整体适应度函数在共享的上下文中运行，综合检验架构的多个维度，比如安全性和伸缩性。开发人员设计整体适应度函数来保证原子级特性能够正常地协同工作。</p><p>显然，我们无法测试架构特征的所有组合，所以架构师需要使用整体适用度函数有选择性地测试那些重要的交互。在做出选择和确定优先级的过程中，架构师和开发人员会评估通过适应度函数实现特定测试场景的难度，从而评估该特征的价值。通常，架构关注点之间的交互决定架构的质量，而这正是整体适应度函数要解决的问题。</p><h4 id="触发式适应度函数与持续式适应度函数"><a href="#触发式适应度函数与持续式适应度函数" class="headerlink" title="触发式适应度函数与持续式适应度函数"></a>触发式适应度函数与持续式适应度函数</h4><p>适应度函数间的另一个区别是执行频率。触发式适应度函数基于特定的事件执行，比如开发人员执行单元测试、部署流水线执行单元测试或质量保障人员执行探索性测试。触发式测试包含了传统测试，比如单元测试、功能性测试、行为驱动开发（BDD），还涉及其他测试开发人员。</p><p>持续式测试不是按计划执行，而是持续不断地验证架构的某些方面，比如事务处理速度。监控驱动开发（MDD）是另一种日益普及的测试技术。它通过监控生产环境来评估技术和业务的健康程度，而不是仅仅依赖测试。这些持续式适应度函数比标准的触发式测试更为动态。</p><h4 id="静态适应度函数与动态适应度函数"><a href="#静态适应度函数与动态适应度函数" class="headerlink" title="静态适应度函数与动态适应度函数"></a>静态适应度函数与动态适应度函数</h4><p>静态适应度函数的结果是固定的，比如单元测试的二进制结果——成功或失败。该类型囊括了预定义期望值的适应度函数，比如二进制、数字区间、集合包含等。这类适应度函数通常会用到各种衡量指标。例如，架构师会为代码中的方法定义可接受的平均圈复杂度，并通过嵌在部署流水线的度量工具对其进行检查。<br>动态适应度函数依赖基于额外上下文变化的因素。某些值会视具体情况而定，比如在大规模运行的情况下，大多数架构师会采用较低的性能指标。例如，某公司可能基于伸缩性将性能指标设置为特定范围内的浮动值——在较大的规模下允许较低的性能。</p><h4 id="自动适应度函数与手动适应度函数"><a href="#自动适应度函数与手动适应度函数" class="headerlink" title="　自动适应度函数与手动适应度函数"></a>　自动适应度函数与手动适应度函数</h4><p>显然，架构师喜欢自动化，自动化也是增量变更的一部分。</p><p>然而，尽管我们希望软件开发中的每个部分都实现自动化，但某些部分却抗拒自动化。有时，系统的某些关键维度就无法自动化，例如对合法性的要求。在为某些问题域构建应用时，出于法律原因，开发人员必须手动认证来进行变更，这样的操作无法自动完成。类似地，某些团队可能希望项目变得更具演进性，但缺乏合适的工程实践。例如，在某些特定的项目上，大部分的质量保障工作仍然是手动的，并且这种情况在短期内不会改变。在以<br>上两种（及其他）情况下，我们需要人为操作验证的手动适应度函数。<br>由此可见，虽然尽可能地消除手动步骤可以提高效率，但许多项目仍依赖必要的手动过程。我们需要为这些特征定义适应度函数，在部署流水线时添加手动阶段对其进行验证。</p><h4 id="临时适应度函数"><a href="#临时适应度函数" class="headerlink" title="　临时适应度函数"></a>　临时适应度函数</h4><p>虽然大多数适应度函数在变更发生时被触发，但架构师可能想通过时间组件评估适应度。例如，当项目使用了某个加密库时，架构师或许想创建一个临时适应度函数，在该加密库发生重大更新时发出提醒。升级前破坏（break upon upgrade）测试是这类适应度函数的另一种常见用法。例如，在某些平台的项目（比如 Ruby on Rails）中，一些开发人员不想等到下个版本发布时才能使用那些吸引人的新特性，于是他们将这些新特性直接移植到当前版本。但是移植过来的特性往往与实际发布的版本不兼容，因此开发人员通过升级前破坏测试来封装移植特性，迫使升级时重新对其进行评估。</p><h4 id="预设式高于应急式"><a href="#预设式高于应急式" class="headerlink" title="预设式高于应急式"></a>预设式高于应急式</h4><p>虽然在项目初期，架构师会定义大多数适应度函数，因为它们阐明了架构的特征，但有些适应度函数在系统开发阶段才显现。架构师无法在开始时就知晓架构的所有重要部分。</p><h4 id="针对特定领域的适应度函数"><a href="#针对特定领域的适应度函数" class="headerlink" title="　针对特定领域的适应度函数"></a>　针对特定领域的适应度函数</h4><p>某些架构有着特定的关注点，比如特殊的安全或监管需求。</p><h3 id="尽早确定适应度函数"><a href="#尽早确定适应度函数" class="headerlink" title="尽早确定适应度函数"></a>尽早确定适应度函数</h3><p>团队应该尽早确定适应度函数，将其作为初步理解全局架构关注点的一部分。团队还应该尽早确定系统适应度函数，来帮助他们确定想实现的变更。比较实现不同架构特征（及其适应度函数）的价值和难度，有助于更早地设置高风险工作的优先级，从而做出能够应对变化的设计。</p><p>没能确定适应度函数的团队将面临如下风险：</p><ul><li>做出错误的设计选型，最终导致软件构建失败。</li><li>做出的设计选型在时间和成本上出现不必要的浪费。</li><li>系统无法轻松应对日后的环境变化。</li></ul><p>对于任何软件系统，团队都应该尽早确定最重要的适应度函数及其优先次序。这有助于架构师将大型系统拆解成更小的系统，使每个系统对应较少的适应度函数。</p><p>适应度函数可以简单分为三类。</p><p><img src="/images/notes/20221210/p-6.png" alt="p-6.png"></p><p>将适应度函数的执行结果可视化至明显的公共区域，能使开发人员记得在日常编码中考虑它们，保持关键部分和相关适应度函数的活力。</p><p>对适应度函数进行分类有助于确定设计决策的优先级。如果一个设计决策对某个关键适应度函数有特定影响，那么应该花费更多时间和精力进行探针试验（时间可控的试验性编码工作）来校验设计的架构。有些团队采取基于集合的开发方式，它是精益和敏捷流程中的开发实践，用于同时设计多个解决方案。它以构建多套方案为代价来换取未来决策的可选方案。</p><h3 id="审查适应度函数"><a href="#审查适应度函数" class="headerlink" title="审查适应度函数"></a>审查适应度函数</h3><p>适应度函数审查以会议的形式进行，会上主要业务和技术利益相关者会一起讨论如何修改适应度函数以满足设计目标。例如，当市场份额或用户数量显著增长时，或者引入新的功能或业务能力时，又或者大规模检修现有系统时，都必须审查适应度函数。</p><p>适应度函数审查大致涉及如下几点：</p><ul><li>审查已有的适应度函数。</li><li>审查当前适应度函数的相关性。</li><li>确定每个适应度函数的规模或大小的变化。</li><li>确定是否有更好的方法测量或测试系统的适应度函数。</li><li>发现系统可能需要支持的新的适应度函数。</li></ul><p>我们希望架构在引导下演进，所以我们在架构的不同方面设置约束来防止架构朝着错误的方向演进。</p><h2 id="实施增量变更"><a href="#实施增量变更" class="headerlink" title="实施增量变更"></a>实施增量变更</h2><blockquote><p>演进式架构支持跨维度进行引导式增量变更。</p></blockquote><p>演进式架构的定义暗含了增量变更，这意味着这种架构更容易实现小的增量变更。<br>论增量变更的两个方面：首先是开发方面，涵盖如何构建软件；然后是运维方面，涵盖如何部署软件。</p><h3 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h3><p>在持续交付及其工程实践的推动下，近年来很多能在架构级别提供灵活性的构件成为了主流。</p><p>软件架构师必须决定系统的构成方式，他们通常绘制不同规格的图表来完成此项工作。架构师常错误地将架构视为一个待解的方程。随着时间推移，业务和技术的不断变化要求架构师采用四维视图描绘架构，这使得演进成为重中之重。</p><p>软件中的一切都是动态的。</p><p>为了在现实世界中生存，现代架构必须是可部署和可变的。<br>只有成功完成了架构设计、实现、升级和无法避免的变更后，甚至当架构能够经受由前期未知的未知因素引起的反常事件带来的考验时，架构师才能评价架构的长期有效性。</p><h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><p>可测试性（架构特征是否能够通过自动化测试验证其正确性）是软件架构中一个被经常忽略的特性。但由于缺乏工具的支持，通常很难测试架构的各个部分。<br>但是，架构的某些方面确实可以轻松测试。<br>任何人都可以管理适应度函数，并且不同的团队和角色可以共同承担该职责。</p><p>一旦架构师确定了适应度函数，就应该确保及时地对其进行评估。自动化是持续评估的关键。部署流水线是进行此类评估的常用工具。使用部署流水线，架构师可以决定执行适应度函数的类别、时间和频率。</p><h4 id="部署流水线"><a href="#部署流水线" class="headerlink" title="部署流水线"></a>部署流水线</h4><p>持续交付描述了部署流水线机制。和持续集成服务器类似，部署流水线在“监听”到变化后执行一系列验证步骤，每一步都更加复杂。</p><p>部署流水线还提供了执行架构适应度函数的理想方式——它适用于任何验证标准，在多个阶段包含不同抽象程度和复杂程度的测试，并在系统发生任何变更时执行这些测试。</p><p>在部署流水线中执行适应度函数时，不同类型的适应度函数通常会发生交叉。</p><p><img src="/images/notes/20221210/p-7.png" alt="p-7.png"></p><p><img src="/images/notes/20221210/p-8.png" alt="p-8.png"></p><h4 id="目标冲突"><a href="#目标冲突" class="headerlink" title="目标冲突"></a>目标冲突</h4><p>敏捷软件开发流程告诉我们：开发人员越早发现问题，那么解决问题的成本将越低。考虑所有架构维度的一个副作用是早期针对不同维度的目标会互相冲突。例如开发人员所在的组织后续想追求最激进的变更频率来支持新功能。代码的快速变更意味着数据库结构的快速变更，但 DBA 更关心稳定性，因为他们构建的是数据仓库。这两个演进目标在技术架构和数据架构间相互冲突。</p><p>显然，考虑到影响根本业务的诸多因素，团队必须做出一些妥协。使用架构维度识别部分架构关注点（并通过适应度函数对其进行评估），让我们能对不同的关注点进行“苹果和苹果”（同类事物）的比较，使优先级更加明确。<br><strong>目标冲突无法避免</strong>。但是，尽早发现和量化这些冲突可以使架构师做出更明智的决定，制定出更清晰的目标和原则。</p><h3 id="假设驱动开发和数据驱动开发"><a href="#假设驱动开发和数据驱动开发" class="headerlink" title="假设驱动开发和数据驱动开发"></a>假设驱动开发和数据驱动开发</h3><p>数据驱动开发的例子——使用数据来驱动变更，并集中精力于技术变更。另一个类似的方法是假设驱动开发，该方法更关注业务<br>问题而非技术问题。</p><p>在《精益企业》这本书中，Barry O’Reilly 介绍了假设驱动开发的现代化过程。在这个过程中，团队应该利用科学手段，而不是收集正式的需求然后花费时间和资源将功能构建到系统中。一旦团队创建出应用的最小可行产品（无论是新产品还是维护现有产品），他们便能在构思新功能时建立假设，而不是需求。假设驱动开发的假设是根据假设来检验的，什么试验可以确定结果以及用什么验证假设意味着应用开发的走向。</p><p>驱动敏捷软件方法论的引擎是内置的<strong>反馈环</strong>，如测试、持续集成和迭代等。然而包含应用程序最终用户的反馈环已经脱离了团队的控制。使用假设驱动开发，我们能以一种前所未有的方式将最终用户纳入构建流程，从他们的行为中学习并构建出对其真正有价值的系统。</p><p>为了产生可观的结果，试验应该进行足够长的时间。通常最好找到某种可衡量的方式来确定更好的结果，而不是通过弹出窗口等形式的调查来打扰客户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《演进式架构》学习笔记（一）&quot;&gt;&lt;a href=&quot;#《演进式架构》学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;《演进式架构》学习笔记（一）&quot;&gt;&lt;/a&gt;《演进式架构》学习笔记（一）&lt;/h1&gt;&lt;p&gt;（此书写得有点杂，但部分内容还可以，以此几篇
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TypeScript的图灵完备性</title>
    <link href="http://blog.michealwayne.cn/2022/11/19/typescript/%E6%B5%85%E8%B0%88TypeScript%E7%9A%84%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%80%A7/"/>
    <id>http://blog.michealwayne.cn/2022/11/19/typescript/浅谈TypeScript的图灵完备性/</id>
    <published>2022-11-19T11:34:23.000Z</published>
    <updated>2023-02-28T03:17:51.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈-TypeScript-的图灵完备性"><a href="#浅谈-TypeScript-的图灵完备性" class="headerlink" title="浅谈 TypeScript 的图灵完备性"></a>浅谈 TypeScript 的图灵完备性</h1><h2 id="一、图灵完备"><a href="#一、图灵完备" class="headerlink" title="一、图灵完备"></a>一、图灵完备</h2><h3 id="1-图灵完备的概念"><a href="#1-图灵完备的概念" class="headerlink" title="1.图灵完备的概念"></a>1.图灵完备的概念</h3><p>首先从定义出发，什么是图灵完备：<strong>图灵完备指一系列操作数据的规则能够模拟任何图灵机</strong>。</p><blockquote><p><a href="https://zh.m.wikipedia.org/zh/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7" target="_blank" rel="noopener">WikiPedia-图灵完备</a>介绍，在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。这意味着这个系统也可以识别其他数据处理规则集，图灵完备性被用作表达这种数据处理规则集的一种属性。</p></blockquote><h4 id="1-1-图灵等价"><a href="#1-1-图灵等价" class="headerlink" title="1.1 图灵等价"></a>1.1 图灵等价</h4><p>还有一个相关概念是<strong>图灵等价</strong>： 如果 <code>P</code> 可以模拟 <code>Q</code> 并且 <code>Q</code> 可以模拟 <code>P</code>，则两台计算机 <code>P</code> 和 <code>Q</code> 称为等效计算机。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98" target="_blank" rel="noopener">邱奇－图灵论题</a>认为任何可以通过算法计算其值的函数都可以由图灵机计算，因此，如果任何真实世界的计算机都可以模拟图灵机，则其对图灵机是图灵等价的。 通用图灵机可用于模拟任何图灵机，且可以扩展现实世界计算机的计算方面。</p><p>如果某物是图灵完备的，则它可以用于模拟某些图灵完备的系统。</p><h3 id="2-图灵机和可计算函数"><a href="#2-图灵机和可计算函数" class="headerlink" title="2.图灵机和可计算函数"></a>2.图灵机和可计算函数</h3><h4 id="2-1-图灵机"><a href="#2-1-图灵机" class="headerlink" title="2.1 图灵机"></a>2.1 图灵机</h4><p><img src="/images/20221119/p-1.png" alt="p-1"></p><p>如上图，<strong>图灵机</strong>由<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">艾伦·麦席森·图灵</a>1936 年提出，它是一个虚拟机器，可模拟计算机的任何算法，无论算法多么复杂。</p><p>在 1928 年第八届国际数学家大会上，德国数学家<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%8D%AB%C2%B7%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener">希尔伯特（David Hilbert，1862 - 1943）</a>提出了关于数学的三个精辟问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First, was mathematics complete ...（数学是完备的吗？）</span><br><span class="line">Second, was mathematics consistent ...（数学是一致的吗？）</span><br><span class="line">And thirdly, was mathematics decidable ?（数学是可判定的吗？）</span><br></pre></td></tr></table></figure><p>希尔伯特的第三个问题又被称为判定性问题（<a href="https://en.wikipedia.org/wiki/Entscheidungsproblem" target="_blank" rel="noopener">Entscheidungsproblem</a>）。为了证否这个命题，1936 年，图灵发表了一篇论文，题为《论可计算数，及其在判定性问题上的应用》（<a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/plms/s2-42.1.230" target="_blank" rel="noopener">On Computable Numbers, with an Application to the Entscheidungsproblem</a>）。在这篇论文里，图灵提出了一种假设的计算装置，他称之为 A-Machine（Automatic Machine，自动机器），这就是图灵机（Turing Machine）。</p><p>关于图灵机具体运作及 Brainfuck 语言的内容本文不做整理，可以看<a href="https://zh.m.wikipedia.org/zh-hans/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="noopener">WikiPedia-图灵机介绍</a>，<a href="https://zh.m.wikipedia.org/zh-hans/Brainfuck" target="_blank" rel="noopener">WikiPedia-Brainfuck</a></p><h4 id="2-2-可计算函数"><a href="#2-2-可计算函数" class="headerlink" title="2.2 可计算函数"></a>2.2 可计算函数</h4><blockquote><p>A function is effectively calculable if its values can be found by some purely mechanical process.</p></blockquote><p>图灵定义了一类被称为“可计算函数”的数学函数，它们可以被图灵机计算。图灵机的计算模型被认为是一种形式化的计算模型，可以模拟所有的可计算函数，这意味着如果一个函数可以被计算，那么它一定可以被图灵机计算。</p><p>在作为特定计算模型的图灵机上产生的可计算函数，就被称为图灵可计算函数。</p><h3 id="3-图灵完备语言"><a href="#3-图灵完备语言" class="headerlink" title="3.图灵完备语言"></a>3.图灵完备语言</h3><p>具有图灵完备性的计算机语言，就被称为图灵完备语言。如今，<strong>几乎</strong>所有编程语言都具有图灵完备性。</p><p>一个语言被称为图灵完备语言，需要满足以下几个要求或特征：</p><ul><li>具有基本算数和逻辑运算功能，例如加减乘除、布尔运算、比较等。</li><li>可以实现条件判断和循环操作，例如 if-else 语句、while 循环等。</li><li>具备无限循环能力，以便模拟图灵机。</li><li>可以进行任意长度的计算和存储数据，以便模拟图灵机。</li><li>支持函数或过程调用和递归，以便模拟复杂计算。</li></ul><p>它意味着任何实现以下八条指令的机器都是一台计算机（因此可以执行任何种类的计算）。</p><ul><li><code>.</code> <code>,</code>: 输入或输出一个指令</li><li><code>+</code> <code>-</code>: 加或减内存中的值</li><li><code>&gt;</code> <code>&lt;</code>: 将当前的指针向左或向右移动。</li><li><code>[</code> <code>]</code>: 执行循环</li></ul><p>实际上，如果某种语言可以执行以上八种指令，就可以称为是图灵完备的。</p><p>证明我们可以（用这个程序语言）模拟一个图灵机是一个证明语言图灵完备性的好方法，但这不是唯一的方法，另一种方法是证明你的语言能够描述所有的<a href="https://en.wikipedia.org/wiki/General_recursive_function" target="_blank" rel="noopener">μ-recursive functions</a>。</p><p>广泛使用的所有通用语言：</p><ul><li>过程式语言，如 FORTRAN、Pascal 等。</li><li>面向对象语言，如 Java、Python、JavaScript 等。</li><li>多范式语言，如 Ada、C++ 等。</li></ul><p>使用不太常见范式的大多数语言：</p><ul><li>函数式语言，如 Haskell、Mercury 等。</li><li>逻辑式语言，如 Logtalk、Prolog 等。</li><li>声明式语言，如 SQL、XSLT 等。</li><li>深奥的语言（Esoteric Programming Language），一种奇特的数学娱乐形式，程序员用极其困难但数学上图灵等价的语言来实现基本的编程结构。</li></ul><blockquote><p>注意，一个语言的图灵完备性只与它的语法和语义相关，而与其具体实现或运行环境无关。因此，同一种语言在不同的平台上可能会有不同的图灵完备性。</p></blockquote><h3 id="4-非图灵完备语言"><a href="#4-非图灵完备语言" class="headerlink" title="4.非图灵完备语言"></a>4.非图灵完备语言</h3><p>并非所有的计算机语言都是图灵完备的，例如标记语言，或者更恰当地称为“容器语言”或“数据描述语言”，就不是图灵完备的。</p><p>非图灵完备语言（Non-Turing-Complete Language），包括 HTML、JSON、XML、YAML、正则表达式 等。</p><blockquote><p>需要注意的是，尽管这些语言不是图灵完备的，但它们仍然具有实际应用价值。</p></blockquote><h3 id="5-图灵完备的应用和意义"><a href="#5-图灵完备的应用和意义" class="headerlink" title="5.图灵完备的应用和意义"></a>5.图灵完备的应用和意义</h3><p>数学家们早已经提出了邱奇-图灵论题以概括图灵机的计算能力，<strong>任何可计算过程都可以用图灵机来模拟</strong>。这是一个论题而非定理，因为它实际上是对可计算过程的定义，而非证明。但迄今为止，人们尚未发现一个可以视为计算的过程是图灵机不能模拟的。</p><p>图灵完备性也可以用来描述计算机语言的计算能力，如果一门语言图灵完备，这就意味着这门语言可以做到能够用图灵机能做到的所有事情，可以解决所有的可计算问题。</p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><p>进行程序计算的一定是图灵完备的，图灵完备的不一定能进行程序计算。</p><hr><h2 id="二、TypeScript-的图灵完备性"><a href="#二、TypeScript-的图灵完备性" class="headerlink" title="二、TypeScript 的图灵完备性"></a>二、TypeScript 的图灵完备性</h2><p>TypeScript 是一种由微软开发的编程语言， 是 JavaScript 的超集，具有静态类型系统。</p><p>Typescript 空间分为<strong>类型空间</strong>和<strong>值空间</strong>。两个空间不互通，因此值不能当成类型，类型不能当成值，并且值和类型不能做运算等。因此我们需要分别考虑类型空间和值空间的图灵完备性：</p><h3 id="1-TypeScript-的图灵完备性验证"><a href="#1-TypeScript-的图灵完备性验证" class="headerlink" title="1.TypeScript 的图灵完备性验证"></a>1.TypeScript 的图灵完备性验证</h3><h4 id="1-1-Type-System-Encoding-方法"><a href="#1-1-Type-System-Encoding-方法" class="headerlink" title="1.1 Type System Encoding 方法"></a>1.1 Type System Encoding 方法</h4><p>Type System Encoding 是一种通过利用类型系统来实现计算的方法。它基于一个简单的思想，即使用类型来表示值的结构和意义。在 Type System Encoding 中，程序的行为是由类型的变化所驱动的。</p><p>以下是一个可能的 Type System Encoding 方法的实现步骤：</p><ul><li>1.定义类型系统。要实现 Type System Encoding，首先需要一个类型系统。可以选择现有的类型系统，如 lambda 演算，或者根据需要定义一个新的类型系统。</li><li>2.定义类型。定义类型是 Type System Encoding 的核心，因为它决定了如何表示值和如何执行操作。可以使用基本类型，如整数和布尔值，也可以使用自定义类型，如列表和树。</li><li>3.定义类型之间的转换。在 Type System Encoding 中，程序的执行通常涉及类型之间的转换。因此，需要定义如何将一个类型转换为另一个类型。可以使用类型转换函数，也可以使用类型转换规则。</li><li>4.定义类型操作。要实现 Type System Encoding，需要定义一组操作，这些操作涉及类型的创建、转换和组合。可以使用一些基本操作，如 lambda 抽象和应用，也可以使用自定义操作。</li><li>5.编写程序。完成上述步骤之后，可以开始编写程序。程序可以使用定义的类型和操作来实现所需的功能。在程序执行期间，类型之间的转换将驱动程序的行为。</li></ul><p>通过 Type System Encoding 方法，可以将程序的控制流与类型系统相结合，从而实现程序的计算。Type System Encoding 方法的一个优点是，它可以提供静态类型检查和类型推断，从而减少程序错误的可能性。此外，Type System Encoding 方法还可以提供一些有用的抽象和模块化机制，使得程序更易于维护和重用。</p><p>使用 Type System Encoding 方法，我们可以验证 TypeScript 是否具有图灵完备性。</p><h4 id="1-2-类型系统的图灵完备验证"><a href="#1-2-类型系统的图灵完备验证" class="headerlink" title="1.2 类型系统的图灵完备验证"></a>1.2 类型系统的图灵完备验证</h4><p>早在 2017 年，TypeScript 的 github 上就有人提出 ts2.2 类型系统是图灵完备的，楼主也给出了<a href="https://gist.github.com/hediet/63f4844acf5ac330804801084f87a6d4" target="_blank" rel="noopener">相关证明</a>，此 issue 也引发了大量讨论（<a href="https://github.com/Microsoft/TypeScript/issues/14833" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/14833</a>）。</p><p><img src="/images/20221119/p-2.png" alt="p-2"></p><p>我们知道，TypeScript 类型系统是“独立”于值系统的存在，我们可以通过映射类型、递归类型定义、索引访问成员类型以及可以创建任意数量的类型，来实现图灵完备。</p><p>如下，当 <code>TrueExpr</code>、<code>FalseExpr</code> 和 <code>Test</code> 定义为适合的类型，如下的实现将具备图灵完备性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFunc&lt;TArg&gt; = &#123;</span><br><span class="line">  <span class="literal">true</span>: TrueExpr&lt;MyFunction, TArg&gt;;</span><br><span class="line">  <span class="literal">false</span>: FalseExpr&lt;MyFunc, TArg&gt;;</span><br><span class="line">&#125;[Test&lt;MyFunc, TArg&gt;];</span><br></pre></td></tr></table></figure><p>TypeScript 包含了一套完整的类型层面编程能力，就像我们可以用 JavaScript、C++、Go 等编程语言解决各种实际问题一样，TypeScript 可以解决各种类型问题，因为本质上它们的内核都和图灵机等价。</p><p>由此 TypeScript 开发者可以自由发挥类型作用，比如开发判定素数的类型 <code>IsPrime&lt;T&gt;</code> 、将合集类型转换为元组的类型 <code>UnionToTuple&lt;T&gt;</code>、根据条件获取子集类型的类型 <code>ConditionalSubset&lt;T&gt;</code> 等等、即 TypeScript 类型编程。</p><p>比如<code>IsPrime</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params"><span class="built_in">number</span>: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isPrime = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">number</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    isPrime = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">number</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">Math</span>.sqrt(<span class="built_in">number</span>); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">number</span> % i == <span class="number">0</span>) &#123;</span><br><span class="line">        isPrime = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isPrime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型编程的花式操作"><a href="#2-类型编程的花式操作" class="headerlink" title="2.类型编程的花式操作"></a>2.类型编程的花式操作</h3><p>TypeScript 类型的图灵完备性证明意味着它具备了与其他图灵完备语言相同的计算能力，可以在理论上执行任何可计算的操作。</p><h4 id="2-1-用-ts-类型系统写象棋"><a href="#2-1-用-ts-类型系统写象棋" class="headerlink" title="2.1 用 ts 类型系统写象棋"></a>2.1 用 ts 类型系统写象棋</h4><p><img src="/images/20221119/p-3.png" alt="p-3"></p><p>效果体验：<a href="https://tsplay.dev/Nd4n0N" target="_blank" rel="noopener">https://tsplay.dev/Nd4n0N</a></p><p>具体实现可见：<a href="https://zhuanlan.zhihu.com/p/426966480" target="_blank" rel="noopener">《用 TypeScript 类型运算实现一个中国象棋程序》</a></p><h4 id="2-2-用-ts-类型系统写一个-Lisp-解释器"><a href="#2-2-用-ts-类型系统写一个-Lisp-解释器" class="headerlink" title="2.2 用 ts 类型系统写一个 Lisp 解释器"></a>2.2 用 ts 类型系统写一个 Lisp 解释器</h4><p>在 ts 写象棋的引领下，ts 花式操作越来越多，像扫雷等等，甚至有人用于写解释器。</p><p>见：<a href="https://zhuanlan.zhihu.com/p/427309936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/427309936</a></p><h3 id="type-challenges"><a href="#type-challenges" class="headerlink" title="*type-challenges"></a>*type-challenges</h3><p><img src="/images/20221119/p-4.png" alt="p-4"></p><p>要写出象棋这种花式操作、或者本质来说学好 ts 类型知识，我们需要大量的实践和理解，在这<a href="https://github.com/type-challenges/type-challenges" target="_blank" rel="noopener">type-challenges</a>就是一个很好的实践类学习项目，此项目通过刷题让你更好的了解 TS 的类型系统，编写你自己的类型工具。</p><h3 id="3-ts-值空间图灵完备验证"><a href="#3-ts-值空间图灵完备验证" class="headerlink" title="3.ts 值空间图灵完备验证"></a>3.ts 值空间图灵完备验证</h3><p>相比类型系统，ts 的值空间图灵完备验证就很容易，即 JavaScript 的图灵完备性验证。</p><p>正因为 js 具备图灵完备性，因此像微信无法从根本上禁止小程序代码的热更，因为我们可以根据宿主语言（js）实现任何其他图灵完备的编程语言。比如 用 js 实现 js 解释器、Python 解释器、PHP 解释器等等，甚至你还可以设计一个自己的比如本文的字节码虚拟机。</p><blockquote><p>对微信小程序禁止 eval 热更的讨论感兴趣可以看官方社区——<a href="https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801" target="_blank" rel="noopener">关于禁止小程序 JavaScript 解释器使用规范要求</a></p></blockquote><h2 id="三、最后"><a href="#三、最后" class="headerlink" title="三、最后"></a>三、最后</h2><p>ts 类型系统具备图灵完备，虽然用 ts 类型系统写复杂逻辑没有太大意义，但我们也能看到 ts 能做的事越来越多、对于 ts 开发者的使用也越来越灵活方便。</p><p>最后，致敬<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">艾伦·麦席森·图灵（Alan Mathison Turing，1912.6.23 - 1954.6.7）</a>，英国数学家、逻辑学家、密码学家和英国首位计算机科学家，被誉为计算机科学和人工智能之父。</p><p><img src="/images/20221119/p-5.png" alt="p-5"></p><p>另外，可以思考一下，现在的 CSS 是图灵完备的语言吗？</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://zh.m.wikipedia.org/zh-cn/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-cn/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7</a></li><li><a href="https://github.com/Microsoft/TypeScript/issues/14833" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/14833</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDAzNzY0MQ==&amp;mid=2247486711&amp;idx=3&amp;sn=45297f05551962f12863e34a0b1822ad&amp;chksm=fd39c711ca4e4e07258fc1109dd3f916ba5bc5cac7566de76c4244c184ad1e484b1e608bf3d0&amp;token=1222177772&amp;lang=zh_CN#rd" target="_blank" rel="noopener">《用 TypeScript 实现汉诺塔》</a></li><li><a href="https://zhuanlan.zhihu.com/p/426966480" target="_blank" rel="noopener">《用 TypeScript 类型运算实现一个中国象棋程序》</a></li><li><a href="https://zhuanlan.zhihu.com/p/427309936" target="_blank" rel="noopener">《TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器》</a></li><li><a href="https://juejin.cn/post/6927088564194770951" target="_blank" rel="noopener">《【🤦‍♂️ 工作无用】证明 JS 和 TS 类型编程是图灵完备的》</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5</a></li><li><a href="https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/minihome/doc/0000ae500e4fd0541f2ea33755b801</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈-TypeScript-的图灵完备性&quot;&gt;&lt;a href=&quot;#浅谈-TypeScript-的图灵完备性&quot; class=&quot;headerlink&quot; title=&quot;浅谈 TypeScript 的图灵完备性&quot;&gt;&lt;/a&gt;浅谈 TypeScript 的图灵完备性&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://blog.michealwayne.cn/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编三——架构原则，技艺、艺术与美</title>
    <link href="http://blog.michealwayne.cn/2022/10/23/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%B8%89/"/>
    <id>http://blog.michealwayne.cn/2022/10/23/notes/【笔记】《我的架构思想：基本模型、理论与原则》编三/</id>
    <published>2022-10-23T09:23:16.000Z</published>
    <updated>2022-10-25T03:32:32.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美"><a href="#《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美"></a>《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美</h1><h2 id="架构原则"><a href="#架构原则" class="headerlink" title="架构原则"></a>架构原则</h2><h3 id="架构第一原则：架构面向问题，但满足需求"><a href="#架构第一原则：架构面向问题，但满足需求" class="headerlink" title="架构第一原则：架构面向问题，但满足需求"></a>架构第一原则：架构面向问题，但满足需求</h3><h4 id="“我们已接受的许多东西是有着商业背景的”"><a href="#“我们已接受的许多东西是有着商业背景的”" class="headerlink" title="“我们已接受的许多东西是有着商业背景的”"></a>“我们已接受的许多东西是有着商业背景的”</h4><h4 id="“面向需求通常是不考虑系统的背景的”"><a href="#“面向需求通常是不考虑系统的背景的”" class="headerlink" title="“面向需求通常是不考虑系统的背景的”"></a>“面向需求通常是不考虑系统的背景的”</h4><p>从提供方来考虑的方案，通常是面向“同类系统的同类需求”的。这种需求上的相似性才决定了方案的价值。它并不考虑确定系统的背景，因为背景的不同正好削弱了方案的价值。然而，我们事实上是无法脱离背景来讨论系统问题的。</p><h4 id="“面向问题首先是客户视角的变化”"><a href="#“面向问题首先是客户视角的变化”" class="headerlink" title="“面向问题首先是客户视角的变化”"></a>“面向问题首先是客户视角的变化”</h4><p>“面向需求”本身是没什么错的，因为我们的软件开发活动最终总是要解决用户的实际需求。但需求的“持续可变”是所有问题浮在冰海上的表象，正是它们随海水的、风力的变化而变化着，才导致我们“面向需求”去求解时疲于奔命。这其中，一个重要的问题在于：客户是很难从系统角度上识别问题的，并且当他们站在“客户与供应商”的层面上思考时，他们也完全不必要对可能的系统问题作出解释。</p><p>只有当二者站到“共同解决问题”的角度上来看，才是共赢的，进而问题本身就变成了焦点：<strong>需求可以通过对问题的阶段性关注、梳理来明确；需求的变化可以通过架构的确定性来消化</strong>。</p><p>对于“供应商/开发方”来说，面向问题会是一个主动发起合作，进而争取普遍合作的开端。</p><h4 id="“面向问题与开发实作并无冲突”"><a href="#“面向问题与开发实作并无冲突”" class="headerlink" title="“面向问题与开发实作并无冲突”"></a>“面向问题与开发实作并无冲突”</h4><p>但是“面向问题”这一概念对于开发人员同样显得空乏。因为问题的关键求解在于架构，而不在于具体实作阶段的某一个技术行为。</p><p>开发人员可以在任意时候、任意位置，就地实现数据库或数据结构。但是，这必将给架构角色带来层次规划上的灾难。因为如果推进这一方法，则在“第二阶段”来考虑数据建模时，系统架构将无法进行调整以容纳、应用新的数据模型。</p><p>因此，架构在第一阶段既不能“放任”开发人员的数据规划行为，也没有足够的信息与时间来进行数据建模。但这一矛盾的实质并不在于“谁做数据建模”，而在于“何时定义其细节”。而使架构角色在这里陷入了两难困境的原因则在于，他对自身的职责仍然缺乏必要的了解。回顾此前我们在架构过程中提及的两项架构责任：</p><ul><li>其一，架构对实施的约束；</li><li>其二，架构的阶段抽象在实现域与交付域的映射。</li></ul><p>由此看来，架构应当在第一阶段中与开发人员约定（注意做这些约定，其本质上也是数据建模活动）：</p><ul><li>开发人员的数据规划行为必须限于当前应用中的数据层；</li><li>必须通过一个界面交付到应用层，避免直接访问；</li><li>若该数据规划涉及多个应用，则必须由架构角色来确认规划的有效性；</li><li>数据层的交付界面必须不涉及特定数据层实现方案的细节”</li></ul><p>架构的约束既体现为对问题的把握，也体现为面向问题的、阶段性的隔离。它对整个系统工程构成影响的方式既包括一系列架构图例，也包括上述的一些实施规则，最后——也最为重要的是，还包括架构师对问题的分解。</p><h4 id="“面向问题是架构活动的必须”"><a href="#“面向问题是架构活动的必须”" class="headerlink" title="“面向问题是架构活动的必须”"></a>“面向问题是架构活动的必须”</h4><p>软件架构活动的来处并不在于“变化的需求”，<strong>只有将架构所解决的本质对象定义为“问题”，架构本身才有长期与持续性的需求</strong>；架构本身的复杂性与规模才有出处；架构应对于“持续可变的需求”才能寻得方法。</p><p>总的来说，需求可能一样，但问题却未必相同；需求可能被满足，但问题未必会因满足需求而消失；需求可能是破碎的，但问题却恒久而弥新。因此，<strong>架构的思维对象必须直接指向问题</strong>。唯只如此，架构活动的本质，才在于面向问题的求解；而其结果，才会是一个长期的、有效的、可持续推进的架构，而非应对一时之所需的技法。</p><h3 id="架构第二原则：架构基于概念抽象，而非想象"><a href="#架构第二原则：架构基于概念抽象，而非想象" class="headerlink" title="架构第二原则：架构基于概念抽象，而非想象"></a>架构第二原则：架构基于概念抽象，而非想象</h3><h4 id="“1-形式化方法”"><a href="#“1-形式化方法”" class="headerlink" title="“1. 形式化方法”"></a>“1. 形式化方法”</h4><p>作为第一原则，“架构面向问题”是无助于讨论“架构是什么”这一设问的。架构作为一个确定的工作产物，它必须有对其形态的确切说明，否则我们无法以之作为后续实施的依据。</p><p>举例来说，若“架构师所想”是架构，那么架构的本意是无形的，它在被叙述的一刹那便已走了模样；若“架构师所言”是架构，那么架构最终必以录音为载体，并且后续的分析也将基于对录音的讨论。类似的，我们讨论架构的形态，是要讨论架构本身可否用作持续依赖（我的意思是实施）和持续讨论（我的意思是不同阶段的架构），并更具体地阐明“依赖与讨论”的可行方法。</p><p>不幸的是，总体来说，在这个问题上我们的可选答案并不多。就目前对思维表达方法的研究来看，我们只有<strong>意象化</strong>和<strong>形式化</strong>两条路可走。意象化包含联想与想象，例如说作者 A 在纸上画下一个圆，观者 B 可以自由地认为那是一张面饼，或者是昨晚所见的月亮。至于这一意象是否确实是 A 所绘的这个圆的本意，是不要紧的。如果非得说这一意象有传递的效果，那么我们可以强调 A 绘制的圆表达了“完整”，而 B 所见的面饼与月亮总的来说在形态上也是完整而无有或缺的。</p><p>从非形式化到形式化，一路走来，我们唯一可选的是“<strong>更加明确的形式化</strong>”。这是表达架构——这一思维活动的结果的最终方法。</p><h4 id="“2-形式化的基础是抽象”"><a href="#“2-形式化的基础是抽象”" class="headerlink" title="“2. 形式化的基础是抽象”"></a>“2. 形式化的基础是抽象”</h4><p>形式化方法本质上只是“在我们现在、在对思维的表达方式过于粗略的前提下的、不得已而为之的”一种方法。</p><p>其一，在表达之前的思维活动中，究竟形成了什么；其二，在表达之后的验证活动中，我们可选择何种方法。</p><p>确定的形式必然包括<strong>抽象</strong>、<strong>概念</strong>以及<strong>基于此的确定表达法</strong>。否则它必将无法作为我们表达确定思维的基础构件——与此相对应的，意象适合表达的是非确定的思维。<br>抽象是不具体的，但抽象的表达是确定的；具象是确实的，但基于具象的表达却是不确定的。如上二者互成矛盾，但是却构成我们思维与表达的全部极限。作为架构的目的——产生确定的系统——的所需，我们只能选择抽象。而所谓形式化，只是“思维的抽象表达”的一种方法。</p><h4 id="“3-形式化的表达必须以语法和语义为基础，而忽略语用”"><a href="#“3-形式化的表达必须以语法和语义为基础，而忽略语用”" class="headerlink" title="“3. 形式化的表达必须以语法和语义为基础，而忽略语用”"></a>“3. 形式化的表达必须以语法和语义为基础，而忽略语用”</h4><p>架构存在的基本价值在于交流，如果不需要交流，那么这个开发活动中就自然不需要一个“具形的、存在的架构”。</p><p>总的来说，交流有两个基本的要素，其一是交流的主客体，其二是交流的对象。</p><p>任何有语法与语义并以语法为交流形式，以语义为交流对象的，都可以称为（广义上的）语言。</p><p>我们尽可以有任意多种形式，也包括这一形式的要件（我是指概念、抽象与表达法），但如果要表达架构师的思维，那么它还必须以语义为交流的对象。这是“架构师应以形式化语言为交流工具”的一个推理过程，在“形式化”上，它是指语言工具的基础要件；在“语言”上，它是强调语言的语义特性。</p><p>忽略语用”仍然是考虑“架构的目的——产生确定的系统”的所需，而进行的一个选择。</p><p>架构师所表达的系统是不确定的，在交流客体的感受上会变成“架构师主观而随意地阐述着系统。</p><h3 id="架构第三原则：架构-范围-联接件。"><a href="#架构第三原则：架构-范围-联接件。" class="headerlink" title="架构第三原则：架构=范围+联接件。"></a>架构第三原则：架构=范围+联接件。</h3><h4 id="“1-基本前设”"><a href="#“1-基本前设”" class="headerlink" title="“1. 基本前设”"></a>“1. 基本前设”</h4><p>(本原则是对第二原则的补充，讨论架构作为工作产物时的内容。)</p><p>架构的目标究竟是什么？我们当然知道其目标是系统——无论是大的、复杂的体系，还是一个小的、有含义的组成，又或是我们要考虑其系统性的任何东西。然而这一概念下的系统，其内涵是丰富以至于无可穷尽的。架构作为一个事实工具或对于这一系统的事实影射，只能表达其中的部分而决非全集。因此，我们所谓“架构的目标是什么”，其答案必将指向系统，也必然是系统特定的一面两面或数个方面。</p><h4 id="“2-范围与联接件之于系统的意义”"><a href="#“2-范围与联接件之于系统的意义”" class="headerlink" title="“2. 范围与联接件之于系统的意义”"></a>“2. 范围与联接件之于系统的意义”</h4><p>决策层在系统的方向问题上赋予架构师的职责是“目标的映射”。这包括两方面的含义，其一，不一定是确实的目标，例如某个产品或产品的某个版本；其二，是对目标的约束，而非说明其实施的细节。范围与联接件是架构师的两个工具，与其说它们是对规模与复杂性的求解，不如说它们事实上就是架构师对“系统的方向问题”的两个求解。</p><p>所谓方向与目标有一些基本性质，包括：其一，<strong>系统的方向可能是确实的，也可能是阶段性变化的</strong>；其二，<strong>阶段目标清晰而明确，但方向却可能存有模糊性</strong>；其三，<strong>方向必是一个面的问题，而目标方才是点的问题</strong>。</p><p>我们在层次架构中通过“逐层清晰”来解构系统复杂性一样，这一手法通常用来确保系统长期的不变性——复杂性通常是由<strong>可变性</strong>引起的。</p><p>架构在应对系统方向下的规模问题时，采用的方法通常有两个：其一是<strong>对“系统组成”的明确约定</strong>，例如模块图或（细化的）层次架构图；其二是<strong>对系统构件的明确概念</strong>。后者——构建明确概念是架构抽象中最困难而又最重要的工作之一。</p><p>系统总在变大，在它的形态与内涵两个方面都必将存在失控的风险。这两个风险是骈生的。此外，风险与机会也是骈生的，所以架构不仅能够反映系统的“范围与联接件”，也可以反映系统的“转折点”。只是后者常常仅被视作风险而遭到严防死守罢了。</p><h3 id="架构第四原则：过程之于结果，并没有必然性。"><a href="#架构第四原则：过程之于结果，并没有必然性。" class="headerlink" title="架构第四原则：过程之于结果，并没有必然性。"></a>架构第四原则：过程之于结果，并没有必然性。</h3><h4 id="“1-基本前设”-1"><a href="#“1-基本前设”-1" class="headerlink" title="“1. 基本前设”"></a>“1. 基本前设”</h4><p>所谓工程，是一个实作问题，简而言之，工程讨论的就是如何把东西做出来。在这个问题上，架构工程与软件工程类似，也是可以追溯到“<strong>过程、方法、工具</strong>”三个要素的。其中，架构第二原则主要讨论的是方法论问题，间或讨论到与方法论适配的工具问题；架构第三原则可以视为对工程产物的补充。</p><p>形成论与组成论是两个过程观点，前者是过程论的动态模型，后者则是静态模型。将架构结果作为工程产物时，静态模型强调架构的构件之间的结构关系，以及通过这些结构关系来维护“架构目标的系统性”的方法；动态模型则强调架构是一个与时间相关的产生过程 13，在时间轴以及组织性上，架构团队以及系统的参与者都是变化的，（整体来看，）其结果在形态上也是变化的。在后者——形成论的视角下，架构结果是可以通过阶段进化来获得的，而至于这一产生过程是否是一次性的或迭代数次的，则是过程实施中的选择。</p><h4 id="“2-有关过程正确与结果正确的讨论”"><a href="#“2-有关过程正确与结果正确的讨论”" class="headerlink" title="“2. 有关过程正确与结果正确的讨论”"></a>“2. 有关过程正确与结果正确的讨论”</h4><p>“正确的步骤会产生正确的结果”是丰田模式的核心原则的重要组成部分。</p><p>生产过程中如果包含大量的修正过程，则其效率会变得相当低下。这是因为修正过程将使生产过程的周期变长且导致产品品质下降，这些都可以理解为是由过程的不确定性导致。因此，总的来说，尽量摒除生产过程中的修正是得到“正确的步骤”的必经之路。为了这一目标，传统的生产型企业都会有所谓的“产品研制”阶段，在这个阶段中允许大量的修正，并最终交付一个可投入生产的“正确的步骤”。“生产”作为一种工程手段，大抵上是从一个“正确的步骤”的交付开始的。</p><p>形成论下的架构产出是过程记录而非指导性规范，但这是出于“能力上无法做到规格化”，还是出于“架构的某些特殊性质决定了它无法被规格化”，是我仍存疑的；其二，软件系统产品通常是一次性产生的，因此它是否需要一个生产过程并将架构作为生产阶段来理解，是我存疑的；其三，即使上述两点均成立，即我们确需“基于架构的生产过程，且架构规格可作为指导性规范”，我对其可实施性（综合考虑实施成本与团队成本）也是存疑的。<br>但是形成论的“映射与约束”性质必将由组成论来实现。因此结合组成论与形成论，可以在一定程度上解决上面的问题。</p><p>我们尚未能找到过程正确性之于结果的必然关系，因此<strong>“正确形成+正确组成”并不等于正确的架构</strong>。</p><h3 id="架构第五原则：系统的本质，即是架构的本质。"><a href="#架构第五原则：系统的本质，即是架构的本质。" class="headerlink" title="架构第五原则：系统的本质，即是架构的本质。"></a>架构第五原则：系统的本质，即是架构的本质。</h3><h4 id="“1-普遍性架构原则的提出”"><a href="#“1-普遍性架构原则的提出”" class="headerlink" title="“1. 普遍性架构原则的提出”"></a>“1. 普遍性架构原则的提出”</h4><p>架构是面向问题的求解”也只是一个结果，而非完整的、准确的、概念上的架构的本义。</p><p>我们必须重新定义我们所讨论的架构、系统以及二者的关系，这是上述架构第一和第二原则作为普遍性架构原则的必要前提。</p><h4 id="“2-系统性”"><a href="#“2-系统性”" class="headerlink" title="“2. 系统性”"></a>“2. 系统性”</h4><p>总的来说，形成论与组成论是“（面向实作问题的）过程论”下的视角。我们不能因“过程是这样需要的”，而反过来指称“一个系统的本质为何”。本质是不应随应用的需求而变化的，否则其必然是一个“可用的观察”，而非本质本身。</p><p>我们之所以将某个领域集或其他类似的“组成/构成/集/……”称为系统，必是因为它们之间存在某种系统性，以维持它们的内部关系与外部表现。</p><p>这种系统性是系统存在的唯一依据、核心矛盾与主体价值。既如此，这种系统性也必是架构——系统所有的可能映像——的基本事实、本质问题与形成驱动。</p><p>唯有将系统的本质与架构的本质都设定为对“系统何以为系统”的拷问，才能抹去二者因概念抽象而导致的差异。唯只如此，它们才能在“问题与解”上真实地一致，才能在“过程与方法”上无视于系统与架构的先后问题。</p><h4 id="“3-本质”"><a href="#“3-本质”" class="headerlink" title="“3. 本质”"></a>“3. 本质”</h4><p>“在本质上相同的抽象系统，其系统解集的抽象也是本质上相同的。”</p><p>综观我们的知识构成，我们所见并能自由论及的一切系统，都是事实系统的抽象系统，我们只是在多个抽象系统中维持着本质上的相同。<br>系统的本质即是架构的本质。我们必将二者的本质指向同一，其复杂性，亦即结构的本质，方可同一；其方向性，亦即目标的本质，方可同一；其系统性，亦即问题的本质，方可同一。</p><h2 id="技艺、艺术与美"><a href="#技艺、艺术与美" class="headerlink" title="技艺、艺术与美"></a>技艺、艺术与美</h2><h3 id="架构可以“学而时习”的部分"><a href="#架构可以“学而时习”的部分" class="headerlink" title="架构可以“学而时习”的部分"></a>架构可以“学而时习”的部分</h3><p>就传授来说，授业者可以分解步骤、讲述原理并总结经验与诀窍；求学者可以亦步亦趋地跟随，先得其形实，再究其质底。就实作而言，实作者可以在技术的实践活动中有所变化，若这种变化是有了质的区别，我们就称之为“新技术”了。<strong>但即使新旧技术存在质的区别，其目的却没有变化：实现相同的目标，或解决一样的问题。</strong></p><p>架构的确首先是一种实作的技术。这是毋庸置疑的，因为的确是在工程实践过程中产生了架构这一角色并承载了属于它的需求。这也是架构过程的“形成论与组成论”两个观点的真正出处。对于一个既存的架构，实作者认为它是源自于一个形成的过程，所以得到前一种观点，即架构的出处在于这些阶段的组合；而当实作者认为架构表达的是系统映像的具体内容时，便会得到后一种观点，即架构的落足在于这些内容的组成。<br>无论是前者亦或后者，都是将架构作为一个死物，并试图通过模仿来复制一个新的架构。</p><h3 id="死过程与活灵魂"><a href="#死过程与活灵魂" class="headerlink" title="死过程与活灵魂"></a>死过程与活灵魂</h3><p>即使你做出来的同样是一个三层（或 N 层）架构，如果你是通过系统分析、思考、权衡而得到这一架构决策的，那么它仍具有独特而丰富的架构思想；但如果只是因为与当前系统的背景类似，而使得你选择了这种架构形式，那么这只是一个工程师的技术选型，而非架构师的架构过程。</p><p>架构思想是认识系统的方法与结果：从方法上来说，思想决定了如何认识系统；从结果上来说，思想表现为对系统的认识。</p><p>“窠臼是思想的表达，形式是架构的道具。”</p><h3 id="美"><a href="#美" class="headerlink" title="美"></a>美</h3><p>关于技术、技艺与艺术，有三种美。其重点各有不同。</p><ul><li>首先，技术的美在于可行。</li><li>其次，技艺的美在于超越。</li><li>第三，艺术的美在于如一。</li></ul><p>若架构师确有思想，但无法表达出来或他的表达与思想并不一致，那么是不美的；若架构师拿出了一个“看似完美”的作品，却没有任何有意义的思想，那么也是不美的。若架构是一门艺术，则架构艺术的美，必以追求思想、形式、技艺完美如一为最终标准。</p><h3 id="架构的美"><a href="#架构的美" class="headerlink" title="架构的美"></a>架构的美</h3><p>美的学问究其根底是讨论三类东西：美，美的对象，以及美的感受与意识。</p><p>从架构对于工程的意义、对于系统的意义以及对于一个实施团队的意义来说，无限制的、漫无目的地追求美是一种浪费。</p><p>架构的美的对象定位于“时间与空间”两个维度。在时间维度上，我希望一个架构的美在于能以其持续性来保障系统的实施；在空间维度上，我希望一个架构的美在于能以其结构性来保障系统的成本。无论是软件产品还是硬件产品，对于这样一个系统，若既是可实施的又是成本可控的，或称为规模与复杂性可控的，那么该系统是否能最终完成便只需由必要性来决定了。</p><p>当我们回到美的对象，亦即时间与空间下的架构，亦即探求其持续与结构上的美的问题时，我想尽我所能使用的词汇，尽我所能表达的认识，尽我所愿意接受的、对美的架构的最终审美标准来说</p><p>“架构的美在于不朽”</p><h3 id="舞者"><a href="#舞者" class="headerlink" title="舞者"></a>舞者</h3><p>通常，面对一个系统，一开始就讨论高并发、大流量、大数据以及大规模运算的架构师，是入门零段的。他还不懂得忽略与聚焦。</p><p>通常，面对一个系统的组成，大谈平衡与模型的架构师，是入门一段的。他还不懂得平衡只是技法，系统是没有平衡的，系统是在动态中不平衡地发展的；系统是一个时间轴上的东西，而非一个瞬间的衡态，例如模型。</p><p>通常，脱离了平衡的味趣，奔逐于系统的关键，寻求种种方案并努力实施的，是架构师的初段。这并没有不好，这些架构推进并演义了整个行业的瑰丽，如同那珠宝闪烁，成就了前台的舞者。</p><p>通常，诠释着舞蹈之绝美的有两种人，一种是会审美的看客，一种是会创造美的编舞。他们都将自我之见作用于美的一片一片，如同架构师通过时间与空间的拼接来完成系统的全体。美与不美都任由评说，而又各有评说的标准。无论是作为看客还是编舞，这样的架构师已得架构之纲法精要。</p><p>通常，把舞蹈表现得完美无缺的，是一个舞者。那个舞者就是那段舞，当他表演的时候，编舞认为这段舞蹈是为舞者而生，而自己只是那个接生者；看客认为自己是舞者；舞者却从不承认这是表演。这样的架构师，他的架构对象和自己已成一体，但我很难找到一个人来诠释这一角色，因为他必已完美地谢幕。</p><p>其作品也必为不朽。</p><h2 id="附"><a href="#附" class="headerlink" title="*附"></a>*附</h2><p>《大道至简》这本书通过“工程层状模型”（EHM），从“实现者”这一角色出发，并论及 “团队”和“经营”角色。但是——如同上面的问题一样，EHM 模型将这些角色析别出来的时候，也少了一半的观察。</p><p><img src="/images/20220912/p-31.png" alt="p-31"></p><p>在使用“在哪里？是谁？在做什么？”这一工具来仔细分析这两类角色时，我们会发现他们所在的领域也是有区别的：实现角色是在技术领域，团队角色则是在工程领域。技术领域关注的是实现的细节，即通过何种方法能将目标有效地实现出来，因而会追求这一实现过程的最优解；工程领域关注的是团队及其所应对目标的规模，在大多数的情况下，这一角色期望控制这一规模以使“目标、资源与质量”可按某种预期、整体地得到保障。有趣的是，从技术领域来说，一旦更细节的或者更宏大的实现成为可能，那么他们将毫不犹豫地将这种“可能”升级为“必须”，并为之充满激情；而这一切，往往又是以牺牲规模为代价的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编二——架构原则，技艺、艺术与美&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编二—
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</title>
    <link href="http://blog.michealwayne.cn/2022/10/04/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%BA%8C/"/>
    <id>http://blog.michealwayne.cn/2022/10/04/notes/【笔记】《我的架构思想：基本模型、理论与原则》编二/</id>
    <published>2022-10-04T02:01:23.000Z</published>
    <updated>2022-10-04T01:50:39.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果"><a href="#《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果"></a>《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</h1><h2 id="架构师的能力结构"><a href="#架构师的能力结构" class="headerlink" title="架构师的能力结构"></a>架构师的能力结构</h2><h3 id="组织视角下的架构师角色"><a href="#组织视角下的架构师角色" class="headerlink" title="组织视角下的架构师角色"></a>组织视角下的架构师角色</h3><p>架构作为一个实施对象，是有明确的实作和理论上的好坏的，并且它必将作用于一个以现实系统为对象或需求的架构目标。而架构师是以组织整体及其决策过程为背景的、实施活动中的角色之一，因而首先是以<strong>组织行为</strong>为核心的，其次才是将“架构”作为目标的优劣判别。</p><p>因此决策过程具有两个方向上的问题，其一是以<strong>架构目标</strong>为对象的，其二是以<strong>组织行为</strong>为对象的。因为架构目标的特点不同，所以这两个方向并非恒等。</p><p>如果架构可以由“一个人”来做，那么由架构意图驱动的架构决策过程将会相当完美。而这个“架构师个体”也必因上述的原因，只需要在架构与其相关领域中有丰富的经验与技术能力即可完成这一过程。事实上，这是软件产品开发中的常态：一名架构师决定整个的系统分析、架构与设计过程，并负责在这一软件的后续产品阶段中对这些原始决策加以修正</p><p>这时，架构师的个体能力往往决定了一个产品实施过程的推进。这一模式可以应用于大多数的软件产品开发过程中。</p><h3 id="架构师的能力模型"><a href="#架构师的能力模型" class="headerlink" title="架构师的能力模型"></a>架构师的能力模型</h3><p>作为一个“规模”的用词，系统是一个“领域集”；即使将这一领域聚焦到“数据+算法”这样的软件开发本质工作中，（在大型系统中）也被具体分成多个领域了。一旦在系统中出现跨领域和领域细分，也或者说这样的背景就是我们将“系统”作为一个规模设定的本质，那么架构也就通常是一个人无法完成的了。</p><p>因此，在这个系统的解决方案——某个具体的项目中，团队中需要一个架构团队来处理架构方面的具体实作：<strong>实施与推进</strong>。</p><p><img src="/images/20220912/p-8.png" alt="p-8.png"></p><ul><li><strong>领悟</strong>，主要包括架构思维的三个核心能力：“概念抽象能力、概念表达能力和基于概念的逻辑表达能力。”</li><li><strong>领域</strong>，是架构师在目标系统中的背景知识。架构师需要相当的背景知识，才“能够”对目标系统进行恰当的概念抽象，也才“能够”准确把握系统的内在动律与整体动向。</li><li><strong>领袖</strong>，是架构师在领域内和团队内的影响力。领袖能力与领导能力略有区别。后者（即领导能力）主要是在组织视角下对管理者（manager）这样的角色，在其职能、责权与实施能力上的说明；尤其重要的是，就组织的必要性来说，是希望限制领导角色的影响力范围的，跨责权范围的影响力是对领导职权的一个质问。而前者，这里讨论的领袖并非是一个组织角色，而是指架构角色所形成的、超出组织结构的影响力，其主要表达为方向、决策和对团队向心力的把握。</li></ul><p>这一模型由<strong>思维</strong>、<strong>知识</strong>、<strong>行动</strong>三个方向的能力构成。总的来说，个人能力的不同取向决定了他在组织中的职业倾向，而架构师所需的是在三者中相对平衡的一种整体能力。</p><p><img src="/images/20220912/p-9.png" alt="p-9.png"></p><p>当从领域专家这一方向上衡量时，在领域方面的背景知识（一定程度上）反映了他可以应对的架构的规模——之所以选择从领域方面进行考察，是因为“领域”是在架构师团队中进行分工的一般标准</p><p><img src="/images/20220912/p-10.png" alt="p-10.png"></p><p>三个方向上的能力在整体上是平衡的，如果架构师偏向于强化领悟能力而弱化其他，则由于在领域能力上的缺失，其架构思维趋向于理想化，偏于学术；又由于领袖能力的缺失，导致他在决策过程中丧失发言权，或有言无行，疏于实作。类似的，片面强调领域能力，则与工程师无异；片面强调领袖能力，则必将碌碌而难有所为。</p><p><img src="/images/20220912/p-11.png" alt="p-11.png"></p><p>当“架构”被作为计算机系统的一个领域时，该领域也必然具有自己特定的知识，也必然具有自身的系统性需求。因此，“架构整体”作为一个系统性的目标，仍然是存在自身在“目标、规模与实现”三方面的需求，仍然需要架构角色。</p><h3 id="架构决策"><a href="#架构决策" class="headerlink" title="架构决策"></a>架构决策</h3><p>“架构整体”的决策涉及团队管理中的几个问题：</p><ul><li>对架构师团队与技术团队的评估；</li><li>适时地中止讨论并形成架构决议；</li><li>对实施过程有效跟踪并适时发起调整过程。</li></ul><p>参考格拉斯问题解决模型，整个架构推进过程还涉及两个时间方面的决策：</p><ul><li>何时能确定架构解决了系统的核心问题并可以进入实施推进环节；</li><li>一旦实施中发生变更，确定该变更应当在何时予以满足。</li></ul><p><img src="/images/20220912/p-12.png" alt="p-12.png"></p><p>该模型应用于一个开发实施场景中的具体架构决策过程</p><p><img src="/images/20220912/p-13.png" alt="p-13.png"></p><p>这一复杂的决策过程是由多个架构师角色参与的，但其决策者必是其中“以架构整体为目标”的架构师。</p><h3 id="有价值的决策是对意图的响应"><a href="#有价值的决策是对意图的响应" class="headerlink" title="有价值的决策是对意图的响应"></a>有价值的决策是对意图的响应</h3><p>所讨论的系统的规模已经扩展到多个领域，因此需要由架构师团队来处理它的架构需求。进而地，多个领域之间的——系统本身的——问题作为一个独立领域仍然有自身的架构需求，因此我们提出了系统架构师或平台架构师等规模来应对之，并（根据其领袖能力、可能性地）赋予其一定的组织责权，例如“首席架构师”或“主架构师”。</p><p>这一架构角色面对的并非上述系统各个独立领域内部的问题，而是“架构整体”的问题。</p><p>架构有两个效果方面的考量，即它对<strong>时间需求</strong>与<strong>空间需求</strong>的响应与收益。</p><ul><li>其一，若架构不谈时间需求与空间需求，而只谈目标需求，那么“架构整体”就必将等效于“各种架构的全集”。然而，若这个全集的元素之间没有关系，也就无法构成整体，进而“全集”这一观念构成了对架构整体性的破坏。</li><li>其二，如前所论，架构是可以通过解决问题来实现需求的，而非单纯对需求的响应。若架构本身只谈上述全集的“目标需求”，那么也就无法触及其背后的“问题”；而时间需求与空间需求背后的问题是清晰的，即系统的规模与复杂性。</li><li>其三，架构本身的价值在于：在保持方向的同时控制成本。而架构在时间需求与空间需求上的考量，构成了“架构全集”到“架构整体”的价值提升。它使得架构可以通过在时间与空间上的分解——一般表达为架构阶段（以及对应的实施阶段）的迭代——来解决架构规模问题与复杂性问题，进而达到成本控制。</li></ul><p>团队模式下的决策与个体决策有很大的不同。团队决策考虑的对象有两点，</p><ul><li>其一是对架构整体的把握，</li><li>其二是对团队整体的把握。对前者的思考，仍然可以归于架构意图，是由领悟能力驱动的；而后者则可以视为对架构意图的效果的保障，是由领袖能力所驱动的。</li></ul><h2 id="系统架构与决策"><a href="#系统架构与决策" class="headerlink" title="系统架构与决策"></a>系统架构与决策</h2><h3 id="系统架构的提出"><a href="#系统架构的提出" class="headerlink" title="系统架构的提出"></a>系统架构的提出</h3><p>针对系统架构的架构意图，我们仍然可以提出如下设问：</p><ul><li>其一般过程是什么？</li><li>其可能的演化方向是什么？</li><li>该系统对于客户战略作何种响应？</li><li>什么是系统的本质问题？</li><li>能不能不做？</li></ul><h3 id="形成论：参考模型-M0-以及可参照的示例"><a href="#形成论：参考模型-M0-以及可参照的示例" class="headerlink" title="形成论：参考模型 M0 以及可参照的示例"></a>形成论：参考模型 M0 以及可参照的示例</h3><p>任何系统架构必存在其<strong>外部实现</strong>与<strong>内部实现</strong>的过程。所谓外部实现，即是指架构师团队用以形成与演化架构的过程，所谓内部实现，即是架构以及其部件的内部关系得以构建与维护的过程</p><p><img src="/images/20220912/p-14.png" alt="p-14.png"></p><p>这张图已经表达了一般过程中的限制条件与流转关系，但仍然需要强调两点：其一，在“实现架构”与“开发架构”中，分别只列举出了其中最重要的两个组成部分，这并非其全部；其二，在“实现架构”中只列出了运行架构与集成架构，其原因是它们对部署与开发的约束作用最为明显。</p><p>一个架构的有效性、正确性应当表达为：</p><ul><li>如何确保宏观规划层对需求映射层的约束，以及确保功能架构对开发架构的约束；</li><li>如何确保在将能力架构映射为实现架构时不丢失功能设计；</li><li>如何确保开发实现的结果能够被应用于预设的交付环境。</li></ul><h3 id="参考模型-M0：细解各部分的形成过程与关系"><a href="#参考模型-M0：细解各部分的形成过程与关系" class="headerlink" title="参考模型 M0：细解各部分的形成过程与关系"></a>参考模型 M0：细解各部分的形成过程与关系</h3><p><img src="/images/20220912/p-15.png" alt="p-15.png"></p><p>框架是一种动态的运行架构（dynamic view of process architecture）。运行架构被框架层和服务层分为了动态与静态两个部分，这取决于你以何种视角来观察这些部件。</p><p><img src="/images/20220912/p-16.png" alt="p-16.png"></p><h3 id="“通过什么来影响什么”作为一般过程是可行的，但不完备"><a href="#“通过什么来影响什么”作为一般过程是可行的，但不完备" class="headerlink" title="“通过什么来影响什么”作为一般过程是可行的，但不完备"></a>“通过什么来影响什么”作为一般过程是可行的，但不完备</h3><p><img src="/images/20220912/p-17.png" alt="p-17.png"></p><ul><li>功能架构：它是实现架构中的组成部分，把由能力架构映射而来的能力分割为基本独立的功能块，基本映射了用户的原始需求，并约束了开发架构中的功能模块。</li><li>运行架构（静态部分）：将这些功能包装并发布成服务，用以约束开发架构中的包的组织与接口的设计。</li><li>运行架构（动态部分）：选择或实现可运行框架来驱动服务与功能，基本约束了开发架构中可选的第三方应用服务器，以及应当自主开发的、系统中的关键联接件，如事务服务框架等。</li><li>集成架构：以产品来封装和交付可运行框架，基本约束了部署架构可用的部件，以及部件之间的组合、依赖等关系。</li></ul><p>系统架构的一般过程：</p><p><img src="/images/20220912/p-18.png" alt="p-18.png"></p><h3 id="平台与框架的极致是“做到看不见”"><a href="#平台与框架的极致是“做到看不见”" class="headerlink" title="平台与框架的极致是“做到看不见”"></a>平台与框架的极致是“做到看不见”</h3><p>一个架构总是对它的构成部件在边界与联接件两个方面的设定。所谓设定，即是明确边界的范围，或明确联接的方法。然而，架构的主体——系统本身，却是动态地基于现实系统而演进的。</p><p>就“系统架构”这个领域出现的本质来看，它就应当具有两点特性：</p><ul><li>它能反映系统长期演化中的不变性，以在演化过程中持续用于对系统的讨论；</li><li>它不能是系统阶段实现的负担。</li></ul><p>显然，系统架构的作用与其方向上构成了一对矛盾。但是在我们的实践中，这个矛盾是有解的，亦即所谓<strong>平台（platform）</strong>与<strong>框架</strong>（framework）。</p><p>这两个解，也是对系统架构中的“体系架构”的两个抽象。首先，架构的支撑性应当以数据为核心，也就是说，平台通常是围绕数据的位置、功用、生存周期或其分布特性来规划的，例如常提到的三层结构在本质上就有平台化的倾向，因为它明确了交互数据、应用数据与系统数据在三个层次上的位置，以及相互间的产生、转化过程。其次，架构的调度性应当以逻辑为核心，也就是说，框架应当追寻架构对象——系统——的一般过程，并将它实现为架构的核心调度逻辑。</p><p>若系统架构以平台为方向，则应当力求“<strong>大到看不见</strong>”；若系统架构以框架为方向，则应当力求“<strong>小到看不见</strong>”。所谓“看不见”，就是指该架构的存在不应当对系统的其他部件（例如对应于不同的领域的子系统）的实现构成影响。</p><p>无论是做平台，还是做框架，最终的目标都是让系统<strong>基于它或使用它，而又无视它</strong>。</p><h3 id="层次结构是架构的一种平台化表现方法，而非架构本身"><a href="#层次结构是架构的一种平台化表现方法，而非架构本身" class="headerlink" title="层次结构是架构的一种平台化表现方法，而非架构本身"></a>层次结构是架构的一种平台化表现方法，而非架构本身</h3><p>平台是用于<strong>整合资源</strong>的，这是由平台本身“面向数据”这一特性而决定的。平台的核心在于支撑，这意味着平台（或平台中的层次）对数据的持有是独占的——在同一平台中对数据的理解是一致的。如果不具有这种特性，那么应当增加一层数据抽象，并在该层次上再构建新的平台。</p><p>三层或更多层，并不是平台化。层次是平台化的一种表现方法，而非平台——作为架构意图的本身，也并不是平台在应对战略问题中的核心关注点。</p><h3 id="形成论的另一种求解：架构规划"><a href="#形成论的另一种求解：架构规划" class="headerlink" title="形成论的另一种求解：架构规划"></a>形成论的另一种求解：架构规划</h3><p>“系统”的本质是领域集。若以现实系统为各个领域的目标，那么系统只需实现目标需求即可，亦即本质问题将是“能或不能实现”的问题。但是这将会得到一个“死的”系统：从系统被完成的第一时间开始它就不再增删任何东西；也没有任何对外的接口，因为它不面向新的领域。这样的系统并非不存在，事实上它大量存在着，并且是“高可靠系统”的主要开发方式。这样的系统的一个主要特点是它在架构上的确定性，与之对应而又匹配的，则是其领域集中的运作模式也相对确定。但我们是在讨论复合领域集的问题。尤其其关键核心在于：由领域集构成的业务模式（犹如产业链等）是可能变化的，甚至是变化频繁的。</p><p>当我们将当前系统的目标与上述规划对应时，就很容易锁定我们“应有的”架构意图，并且能够通过阶段规划，来促使当前的架构意图契合业务方向对架构的要求。</p><p>“从架构的体系性上来考虑，即使在最初阶段的架构中，也不能缺少对后续架构阶段的设定。这至少包括两个方面：其一，后续架构阶段的启动条件；其二，后续架构过程“在当前架构中的”入手点。”</p><p>架构意图在各个阶段的不同变化，意味着我们可以用“有规划的变化”来讨论整体的架构意图。</p><h2 id="架构的表达与逻辑"><a href="#架构的表达与逻辑" class="headerlink" title="架构的表达与逻辑"></a>架构的表达与逻辑</h2><h3 id="从暗示、隐喻，到抽象概念的表达"><a href="#从暗示、隐喻，到抽象概念的表达" class="headerlink" title="从暗示、隐喻，到抽象概念的表达"></a>从暗示、隐喻，到抽象概念的表达</h3><p>架构过程中存在大量的背景知识和推定事实，并且信息表现得可能会模糊而含混。这是因为架构过程本身就是对目标系统中一些不太明晰的概念（边界、联接关系等）渐次清晰的过程，所以架构过程中的模糊信息是必然存在的，否则根本不必去架构它。</p><p>但是这并不妨碍我们要求对架构的表达必须清晰准确。因为实施过程必将依赖架构的结果，亦即是架构的最终表达与决策。架构表达是在架构过程的阶段性成果的基础上所进行的、尽可能准确而清晰的叙述。如果它不能尽量准确地反映架构过程的阶段性成果，那么它也就不能作为下一个阶段（无论是实施还是新的架构迭代）的有效依据。换言之，如果对架构结果的表达是模糊的，则该结果是无意义的。</p><h3 id="理解线与线框"><a href="#理解线与线框" class="headerlink" title="理解线与线框"></a>理解线与线框</h3><p>在架构图中出现了一条线，通常都意味着它将一个整体划分成了两个部分。习惯性地，我们用纵向的线来表明领域的划分，而用横向的线来表明层次的划分</p><p><img src="/images/20220912/p-19.png" alt="p-19.png"></p><h3 id="对系统或其构件的不变性的表达：平台、框架与库"><a href="#对系统或其构件的不变性的表达：平台、框架与库" class="headerlink" title="对系统或其构件的不变性的表达：平台、框架与库"></a>对系统或其构件的不变性的表达：平台、框架与库</h3><p>用一个方框来表示领域，并且把一个方框分成两个（或多个）以表明领域之间没有关系或仅有殊少关系，</p><p><img src="/images/20220912/p-20.png" alt="p-20.png"></p><p>如何降低或至少不增加系统整体的复杂性来说，一种可选的分类依据是：如何隔离变化。</p><p>系统的复杂性有很大一部分是由其可变性导致的 4。但既有其可变处，也必有其不变处。以上述三种结构的表达方式来看：</p><ul><li>如果一个系统的公共部分是不变的，那么它适合用层次结构来表示；</li><li>如果一个系统的总量是不变的，那么它适合用并列结构来表示；</li><li>如果一个系统的核心是不变的，那么它适合用嵌套结构来表示。</li></ul><p>以层次结构来论，如果我们能从系统中捕捉到那些不变的公共部分，我们就可以将它表达在底层，反之将“目前看起来可变”的部分表达在上层。如此，在一系列的架构活动结束之后，我们总是能保证系统的基底部分是无需变化的，亦即它是稳定的；相对于系统整体来说，它带来的复杂度应是衡为“1”的；它决定了系统整体的性状是不变的。</p><p>就“系统架构”的整体表达来看，层次结构适宜构建平台（platform）的过程，其基础领域倾向于不变；并列结构适宜构建库（library）的过程 7，其领域总量倾向于不变；嵌套结构适宜构建框架（framework）的过程，其核心领域（或核心过程）是倾向于不变的。</p><h3 id="系统总量不变，其本质是复杂性的不变"><a href="#系统总量不变，其本质是复杂性的不变" class="headerlink" title="系统总量不变，其本质是复杂性的不变"></a>系统总量不变，其本质是复杂性的不变</h3><p>多个方框放在一起的时候，它们（所表达的领域）之间是没有关系或仅有殊少关系的。其中，当使用并列结构时，它通常表明系统总量不变——系统的复杂性不因为拆分而增加。这事实上也约束了并列结构之间是不应有相互关系的。</p><p>当并列结构之间不存在关系并且它所表明的系统总量不变时，并列（的所有域）是可以被视为一个整体的。</p><p><img src="/images/20220912/p-21.png" alt="p-21.png"></p><p>嵌套结构所谓的“核心”，是指所有除核心之外的其他领域必然与该核心发生关系，亦即它必然可以表达为图 32 所示形式的结构。</p><p><img src="/images/20220912/p-22.png" alt="p-22.png"></p><p><img src="/images/20220912/p-23.png" alt="p-23.png"></p><p>就系统架构整体来说，我们必须关注三点：</p><ul><li>其一，应通过层次系统来隔离可变性，并尽量增大其中不变的部分；</li><li>其二，可变部分影响系统的形态，但不影响系统的性状（亦即是指系统的边界与联接件）；</li><li>其三，如何理解“不变部分的关系”决定了系统的性状，也决定了“不变部分的复杂度是 1”的单位大小。</li></ul><h3 id="化繁为简：控制架构的复杂性"><a href="#化繁为简：控制架构的复杂性" class="headerlink" title="化繁为简：控制架构的复杂性"></a>化繁为简：控制架构的复杂性</h3><p>若 A 需要 B 的数据资源，我们称为数据依赖；若 A 需要 B 的计算资源，我们称为逻辑依赖；若将 A 和 B 都视为逻辑（亦即是可计算的资源），并讨论二者之间的关系，那么我们就会看到（逻辑或数据的）时序依赖。</p><p><img src="/images/20220912/p-24.png" alt="p-24.png"></p><p><img src="/images/20220912/p-25.png" alt="p-25.png"></p><p>即 A 和 B 间存在相互的数据时序依赖关系。若 A 和 B 是各自依赖了不同的数据而导致这种关系，则可以将 A 中的数据抽离至 B，如：</p><p><img src="/images/20220912/p-26.png" alt="p-26.png"></p><p>如果 A 和 B 间存在相互的逻辑时序依赖关系，那么我们总是可以通过添加一层数据抽象，来将向上的逻辑时序依赖变成“数据的”时序依赖，如：</p><p><img src="/images/20220912/p-27.png" alt="p-27.png"></p><h3 id="系统确定性是界面原则的核心"><a href="#系统确定性是界面原则的核心" class="headerlink" title="系统确定性是界面原则的核心"></a>系统确定性是界面原则的核心</h3><p>通过讨论领域间的组成与关系，我们可以尽量将系统的可变性隔离在较晚实现的域中。因此，这意味着先期建设的系统总是不变的、稳定的、可重用的。这是组成论视角对系统架构的主要贡献。但从系统演进的趋势来说，任何系统的组成部分都必然面临我们持续开发行为将会带来的影响。</p><p>而界面（interface）——就提出这一概念的本意来说——就是通过对系统确定性加以规格化，从而来避免上述影响，如果一个界面（以及其规格细节）是确切而有效的，那么它应当完全满足如下条件：</p><ul><li>准确——合适的知识与表达，至少能让交流双方通过某种形式沟通；</li><li>有用——完全明白的意图，至少与系统架构的意图不违背；</li><li>可见——执行的效果显而易见，至少在领域或层次上的数据与逻辑流向明确；</li><li>可能——应当存在实现的手段，至少可以立即着手开始尝试。”</li></ul><p>在架构的表达上，由于纵向分开的并列部分之间是没有关系的，因此它们之间也就没有规格化的需求。而横向的层次之间，仅有向下依赖是确定的，因此界面必是由下层来规格化的。这应当包括（上层所需的）数据规格与（调用的）逻辑规格两个部分。</p><p>三类界面原则的示例：Erlang 的一些实践性原则：</p><p><img src="/images/20220912/p-28.png" alt="p-28.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编二——架构是
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《我的架构思想：基本模型、理论与原则》编一——你所关注的系统</title>
    <link href="http://blog.michealwayne.cn/2022/09/12/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%8E%9F%E5%88%99%E3%80%8B%E7%BC%96%E4%B8%80/"/>
    <id>http://blog.michealwayne.cn/2022/09/12/notes/【笔记】《我的架构思想：基本模型、理论与原则》编一/</id>
    <published>2022-09-12T06:19:10.000Z</published>
    <updated>2022-10-04T01:40:42.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《我的架构思想：基本模型、理论与原则》编一——你所关注的系统"><a href="#《我的架构思想：基本模型、理论与原则》编一——你所关注的系统" class="headerlink" title="《我的架构思想：基本模型、理论与原则》编一——你所关注的系统"></a>《我的架构思想：基本模型、理论与原则》编一——你所关注的系统</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="认知层次"><a href="#认知层次" class="headerlink" title="认知层次"></a>认知层次</h3><p><img src="/images/20220912/p-1.png" alt="p-1"></p><ul><li><p><code>L0</code>：机器学习的兴起，最直接的原因是大数据的出现。在大数据出现之前，大量的业务决策过程是所谓“拍脑袋”式的，也就是依靠经验和直觉。虽然数据很早就进入了商业管理的领域，但是时至今日，即使在全球领先的五百强企业当中，很多关键的决策，也只是把数据统计出来，变成图表，然后由“有经验”的管理人员根据数据来“拍脑袋”。</p></li><li><p><code>L1</code>：当前的机器学习工程师，未必需要深入理解机器学习的数学原理，只要根据一套完善的“套路”，配合类似 R 语言或者 Python 的 scikit-learn、TensorFlow 等工具，就可以开发出一个回归或者分类模型，帮助商业人士决策。</p></li></ul><p>而 L1 认知层次的局限性在于，一旦这个“套路”失效，只停留在这个认知层次的工程师，会束手无策，因为他们并不知道自己使用的方法和套路是怎么来的，自然也无法变通和调试。</p><ul><li><code>L2</code>：也就是通过理解“套路”和模型背后的原理，特别是数学原理，进入到方法论的层次。到了这个层次，你才能够在实践中知其然且知其所以然，恢恢乎游刃有余，才能称得上是“高手”</li></ul><p>L3：能站在上帝视角来审视自己的学科本身，考虑这门学问的根本问题和长远命运。<br>L2 的局限性，就在于他们对于自己的这一套做法，还缺乏“反躬自省”的审视。”其有效性的边界在哪里？对什么样的问题可能会失效？</p><blockquote><p>“台湾的高焕堂先生曾说架构的要旨是“以序容易”，我解释成“用规则来包容变化”，高老师说很合他的本意。这里的“易”，指的就是变化。既是变化，那当然是艰难而复杂的了。然而我们通常说一件事易做或另一件事不易做，这里的“易”却都是指简单的意思。所以“易”既是无穷的复杂，也是至极的简单，关键在于如何“容”它。”“知音变而得律，有容则易。”</p></blockquote><p>程序是可被组织的元素，这事实上是对程序的<strong>可结构化</strong>特性的一个阐释，貌似是说着相同的话。然而如果程序是可被组织的，那么“结构化”其实就只是组织的手法之一。这意味着后者——结构化——只是“程序是什么”的一个解，而绝非唯一解。这就是架构视角的独特处。当它找到一种新的抽象来定义事物时，旧的事物哪怕没有形式与内容上的变化，却在思维框架中有了新的位置、新的理解，以及新的矛盾与冲突。而所谓问题，就来自这些外在视角的变化和内在冲突的产生。<strong>架构的目标最终就是直指这些问题，而非解决一个切实的需求，例如写一个程序。</strong></p><p>架构本质上是一个<strong>映像</strong>。洞见映像背后的事实，就如同从镜子去观照现实，知道镜子是一层，知道镜子中的映像是第二层，知道镜子映像所现的实体是第三层。而至第四层时，还要看得到那实体周围的背景，这是实体之为实体所必须的依托，如绿叶之于红花。再深入到第五层，你得知道背景之外不可见的那些影影绰绰的事实，它们是环境中的残片和推想，它们不可确知而又影响着你在镜子中看见的那个主体。再至第六层……</p><p>如此层层渐近，才是真正的“镜之用在鉴”，才是“鉴”这一行为的本意。然而一旦你触及到“鉴作为行为的事实存在”，那么你就看到了镜子一侧的自我，进而看到自我之见，看到由自我、镜鉴和自我之见等等所构成的整个系统，这个系统被称为“观察”。当然，在这整个“被称之观察系统”的系统之外，还要有光。否则一切所谓事实都将湮灭，即便存在，亦无可证实，无可证伪。</p><h3 id="架构师的思维"><a href="#架构师的思维" class="headerlink" title="架构师的思维"></a>架构师的思维</h3><p>“着眼于<strong>高远</strong>”，便是架构师的基本修养，而几乎所有的架构思维，都从这修养中来。就架构来说，“高”就是指空间上的可拓展性，即系统的复杂性是否可以通过组成部件的增减来解决；“远”就是指时间上的可持续性，即系统的规模是否可以划分为多个时间阶段来实施。以软件架构为例，在讨论系统——这一架构目标的属性时，架构师可能关注的话题包括性能、可用性、可靠性等十余种，我们可以通过高、远两个维度的思考将它们大致地分类：</p><p><img src="/images/20220912/p-2.png" alt="p-2"></p><p>架构师在思维过程中使用的工具</p><p><img src="/images/20220912/p-3.png" alt="p-3"></p><blockquote><p>“系统，是对架构师所面对对象的基本抽象。架构师对系统的认识过程、方法与结果，决定了他如何理性地架构之。”</p></blockquote><p>认识系统不是架构系统。认识系统将致力于将系统中的核心概念抽象出来，将核心逻辑梳理出来，将核心问题（关系、依赖与冲突）揭示出来。但是架构系统的目的正好在于通过对概念与逻辑的映射来消弥这些核心问题，使核心问题对其外在（例如用户可见的产品）不构成明显的影响。</p><p><strong>架构是一个过程。</strong>既然是过程，必然有起始与终的。</p><h2 id="1-了解系统的过程"><a href="#1-了解系统的过程" class="headerlink" title="1.了解系统的过程"></a>1.了解系统的过程</h2><h3 id="感受一个系统的事实"><a href="#感受一个系统的事实" class="headerlink" title="感受一个系统的事实"></a>感受一个系统的事实</h3><p>如同新闻，以体察之，感同身受</p><h3 id="系统是一种认知，而非分析的结果"><a href="#系统是一种认知，而非分析的结果" class="headerlink" title="系统是一种认知，而非分析的结果"></a>系统是一种认知，而非分析的结果</h3><p>我们作为“计算机专业人士”的日子太久了，我们对太多的事物有了理性的认识，而缺乏感性的认识。正因为我们忘却了这种“感同身受”地了解事物的方式，所以我们对这些事物的认识流于浅表，流于那些有数字个数、形体大小、边界棱角或者演进逻辑的判断推理当中。我们忘了一个“系统”是可以去知道、了解、感知，进而感受的。</p><p>我们把对系统的观见与解说当成一种理论，这种理论称为“需求分析”。而我们在一定程度上忘记了，我们所谓之“系统”，并不仅仅是模块的组成，更是一种外界——之于这个系统——的认知。</p><h3 id="认知理论中的知识：知得与识得"><a href="#认知理论中的知识：知得与识得" class="headerlink" title="认知理论中的知识：知得与识得"></a>认知理论中的知识：知得与识得</h3><p>我们获取知识有两种手段，是所谓“知得”与“识得”。</p><p>当我们知道张三，却不知道它的形貌时，是知得，大多数图书馆知识是知得的；当我们亲触这个事物 3，却不知道它是什么时，是识得，大多数野外考察知识是识得的。</p><p><img src="/images/20220912/p-4.png" alt="p-4"></p><p>从动词角度上来说，认识是识得的具体方法之一。认，是指记认；识，是指辨识。</p><p>作为实践者，我们大多数时候是在讨论“某种记认的方法”，而未能追究：在认知理论上，这种记认的可靠性及其依赖的条件。而忽略这一点，就会产生一些似是而非的方法，例如失效的刻舟求剑。但是，失效并不是无法容忍的，例如 HASH 应用中存在的命中率问题。所以记认并不是准确无误的方法，实践中只是在寻求这种方法的背景限制并进一步控制误差而已。</p><p>辨识的一个基本含义在于分辨出差异。如果找不到差异，那么所有的事物也就混沌一物，无从辨识，也无从获得它的知识了。具体来说，辨识也可以分成两种方法：其一是识别，其二是分别。</p><p>识别依赖于我们对事实的直观了解，在一定程度上是与我们的感觉器官相关的，例如听见的、看见的或者闻见的等。然而识别是不可靠的。它首先取决于生理机能本身的可靠性。其次它还取决于既识的持续可靠性。“基于识别所构建的既有知识”为既识，称基于既识而识别为持续性。例如，某人此前听过猿啼（并确认正确），当他再听到某种啼声时，识别为“这是猿啼”。但后者并不一定是持续正确的。</p><p>分别则相对复杂一些，它建立于一个观察的角度、切面，或者依赖于某种参照。通常，“数”这一抽象，是我们能加以分别所依赖的核心概念。例如，核桃的个体与群体，以及火车的速度，都是我们对观察对象先进行数值化，再加以比较，最后得到的知识。</p><p>分别是可靠的吗？答案仍然是否定的，千人千面是一种理想状态，现实往往是一人千面。</p><p>分别的问题在于比较所需的角度与背景不同，以及不同人对于抽象概念的理解有异——如你所见的，基于“数的值”的分别往往准确一些，是因为人们对于“数”这一抽象有着大抵相同的理解。</p><h3 id="尝试一个“建立知识”的过程"><a href="#尝试一个“建立知识”的过程" class="headerlink" title="尝试一个“建立知识”的过程"></a>尝试一个“建立知识”的过程</h3><p>我们从一个系统中获得的知识因人、因方法而不同；既便是相同的方法，由于其实施者的不同以及方法（本质中存在的）误差，也会不同。这就是作为架构师，任何两个人都不可能得到相同的架构结果的根本原因。所有的最终架构都是在实施过程中的调和，以及某些决策者、决策机构的“决定”。</p><h3 id="建立知识以陈述现实系统”是不足以架构系统的"><a href="#建立知识以陈述现实系统”是不足以架构系统的" class="headerlink" title="建立知识以陈述现实系统”是不足以架构系统的"></a>建立知识以陈述现实系统”是不足以架构系统的</h3><p>归纳（概念）、梳理（关系）、推演（逻辑）这些架构活动所需要的，都是较高层次上的思维方法。</p><p>现实中，基于所面对的计算机系统，我们大多数的系统抽象与建模过程中都会用到“分别”这一认知方法。比如说，我们将已知需求规划为条目，然后分门别类，进而整理出子系统、模块、服务，以及规划出服务器、集群等的方案。对系统中的组成、要件、关系等加以分别，是上述这些活动的基点。</p><h2 id="2-知识的构建"><a href="#2-知识的构建" class="headerlink" title="2.知识的构建"></a>2.知识的构建</h2><h3 id="观察者的背景差异带来了更多不同的正确映像"><a href="#观察者的背景差异带来了更多不同的正确映像" class="headerlink" title="观察者的背景差异带来了更多不同的正确映像"></a>观察者的背景差异带来了更多不同的正确映像</h3><p>识别与分别对于了解事物的内在特性来说，都只是辅助手段。而这就是能够建立一个系统的物理模型（组成/结构模型），而难于建立它的逻辑模型的根本原因。</p><p>事实上，我们在架构活动中进行的归纳（概念）、梳理（关系）、推演（逻辑），这些活动的核心基础在于图中的“知得”而非“识得”。</p><p><img src="/images/20220912/p-5.png" alt="p-5"></p><p>其一，我们是否有能力得到一个物理模型；其二，我们得到上述物理模型的过程是否仅仅依赖“识得”。然而，这两个问题的答案都是否定的。首先，我们可能得到很多种物理模型，这些模型映射了现实系统的不同视角。真正的原因是：你难于一以贯之地采用特定视角去观察现实系统，并且你所了解的系统也会动态地以种种角度呈现给你。</p><p>现实中的系统总是自洽的——系统中的角色总是在制造冲突的同时消弭着冲突，这就是所谓的生态，亦或“它们”之所以表现为一个（活着的、动态的）系统的内在能量。</p><p>但计算机系统只能描述其中的一部分（事实上这也意味着计算机系统只能解决动态的现实系统中的部分问题），这一部分必须首先成为“我们”——作为观察者的认识，而后才会表达为软硬件系统中的“可计算的”映像。最终，我们事实是通过对“映像”的运算，来还原现实系统中的某些侧面，以达到我们的目的——替代之、推演之，并作为其他可计算系统的组成部分。</p><p>所以事实上我们可能得到多个物理模型，它们在表面上看起来都是现实系统的“正确映像”，但其内在是各自不同的。</p><h3 id="这种差异表现了不同的“架构意图"><a href="#这种差异表现了不同的“架构意图" class="headerlink" title="这种差异表现了不同的“架构意图"></a>这种差异表现了不同的“架构意图</h3><p>当我们试图去表达现实系统的“一个映像”时，我们总是存有特定的意图。这种“架构上的意图”决定了我们的观察视角，也决定了我们之后表达的结果。</p><h3 id="抽象概念与模型是展示架构意图的方式之一"><a href="#抽象概念与模型是展示架构意图的方式之一" class="headerlink" title="抽象概念与模型是展示架构意图的方式之一"></a>抽象概念与模型是展示架构意图的方式之一</h3><p>如果这是某一个特定类型的办公室成员使用的系统，那么它适宜实现为一个工作系统，用来重现某种特定工作的规则与流程；如果这是一个混合的、由不同成员及其工作需求交织而成的系统，那么这个系统（的本身）必然需要某种东西来使自身规则化。</p><p>也就是说，“管理”不是现实系统的意图，而是映射这一系统到计算环境时的一个需求。我们必须确定：如果这一需求来自于现实系统，那么它是原始需求；如果它来自于上述的这个软件系统本身，那么它首先是设计者的意图，其次才是对现实系统的反映。</p><p>这是一个典型的因果问题：究竟是现实产生了意图，还是先有了意图再去参考现实。我们强调这一细节的原因于：如果是前者，那么控制这一意图（以这里的例子来说，是指“管理”这一行为）的意义在于“控制原始需求”；如果是后者，那么控制它的意义在于“控制设计欲望”。</p><p>一旦我们确认这只是一个意图，并且这一意图的核心仅仅是“规则化”那些需求与需求的用户对象，我们就需要更深层次地设定“被规则化的”这个系统（本身）。它将会是：</p><ul><li>与现实系统看起来类似的</li><li>具有同等的组织容量的</li><li>基本符合现实系统的运作逻辑的<br>一个软件系统。</li></ul><p><img src="/images/20220912/p-6.png" alt="p-6"></p><p>现实系统中，并没有任何需求方来提出这些设定，例如经营角色会说“我们需要一个饼状图”，营销角色会说“我们每周至少发布一次营销活动”，但是他们都不会说“你的系统中需要这样有着管理层次关系的两个角色”。</p><h3 id="系统的识得，是在架构意图的逐步清晰中渐行渐显的"><a href="#系统的识得，是在架构意图的逐步清晰中渐行渐显的" class="headerlink" title="系统的识得，是在架构意图的逐步清晰中渐行渐显的"></a>系统的识得，是在架构意图的逐步清晰中渐行渐显的</h3><p>意图，是“识得”的核心，即“你想要什么”决定了系统如何构画，而不仅仅是对现实系统的复制。</p><p>意图是架构真正的灵魂。架构活动只是将这种意图表达在架构产出中，并阐述这一意图的合理性；如何得到或形成意图才是架构的精髓，其本质是通过抽象过程，对既有系统的再认识与再创造。简单地说，如果架构师没有意图，那么系统只是目标系统的某一时间上的静态映像 5；而架构师如果有意图，那么系统也就有了灵魂，就能跟随目标系统的实际需求的发展而演化，或至少为这种演化留备了可能。</p><p>这存在两个条件：其一，它首先必须是能够被规则化的，这是主要条件；其二，作为附加收益，规则化也可以为其他系统构件带来便利。对这两个条件的思考是架构过程中的一种权衡，即从“想要什么”到“能要什么”的一个过渡。这个过程中，“控制架构欲望”是一种关键素质。而这一素质的源起与核心，是架构师对自身职责的不断的、反复地省思，即“想要什么”应当能决定一个系统在时间与空间两个方面的特性，而不是（仅仅）出于客户需求或自我喜好。</p><p>组织机构表达的“人与人的授权”7 以及“被授权者是可以行使系统行为的角色”这两点是可以被规则化的。这很明显。但是它能带来哪些便利呢？表 2 是一个简要的考察。</p><p><img src="/images/20220912/p-7.png" alt="p-7"></p><p>在这些考量中最重要的是“概念完整性”，它决定了整个系统的核心逻辑，以及描述架构、功能与内部关系的一般方法。如果一个架构设定没有概念完整性方面的必要，通常它的价值收益就会偏小、偏局部，或者可备选。</p><p>最后需要补充的是：这样完备地考察通常是不必要的。这是因为，其一，很少有类似授权这样的架构意图，是能够影响到系统全局并在各考察点上都有相对平衡的重要性的；其二，架构意图通常是反向论证的，即“它不与哪些考察点冲突”；其三，核心架构意图通常是明显的、一贯的以及关键的，因此它的影响面也就巨大，这意味着多个这样的意图并存时将是轻重缓急的问题，而并不是是非取舍问题；其四，如上的轻重缓急是一时的选择，可能会随着所架构的系统——或者说项目——的推进而有变化，这既说明了多种意图的必然性，也说明了多种意图间冲突的根源，亦即是需求的内容与焦点会随时间与空间变化。</p><p>最关键的架构意图是架构师对上述第四个因素的推定，而并非依赖当前的、静止的需求。这种推定的合理性是建立在一个非常完整、缜密、基于抽象概念的逻辑推理基础上的，其背景多数已经超出了“软件系统”本身。</p><h3 id="知得，始于抽象概念的构建之后"><a href="#知得，始于抽象概念的构建之后" class="headerlink" title="知得，始于抽象概念的构建之后"></a>知得，始于抽象概念的构建之后</h3><p>“知得”是一个由抽象概念开始的思考过程。在我们的架构活动中，我强调这是一个由“架构意图”驱动的抽象活动。但这并非惟只的方向，并且可能是一个本末倒置的方向。这里需要强调两点，一是我们并没有完整地讨论“架构意图”的由来 9，二是“本末倒置”并非是一件坏事。</p><p>从经典的架构与设计的法则来看，是“需求决定架构及设计”，这种需求通常是以现实系统为核心的。这很合理，毕竟从上述的分析来看，现实系统才是系统的本体，系统只是现实系统的一个侧相，而“架构意图”只不过是由架构师对系统之所用的理解。我们一旦强调由所用来推动架构过程，而忽略了本体的真实与侧相的含义，那么往往就会被指为本末倒置。</p><p>我们可以找到这样两个不同的架构：它映射同一系统，由不同的架构师来实现。当我们对这样两个架构作分析时，一定可以找到一些相同的部分。这些内容大体来自于由需求驱动的架构方法，它们是架构师对需求的正确描述、复制与映射。如果这些描述、复制与映射中存在了差异，在这两个或更多的架构师之间是可以调和的，因为这仅仅是对一些真实可见、可以反复而又唯只陈述的需求的不同看法，它可以论证、分解、削弱或搁置，无论如何，它们不会成为两个架构中最核心与典型的差别。</p><p>我们也必然会找到一些不同的部分。（除了上述的差别之外，）不同的部分必然来自于架构意图的差别，是明显的主观认识，带有很强的目的性。</p><h3 id="“识别架构意图”的核心理论与方法"><a href="#“识别架构意图”的核心理论与方法" class="headerlink" title="“识别架构意图”的核心理论与方法"></a>“识别架构意图”的核心理论与方法</h3><p>架构意图需承架构的定义而来，它首先必是“经营角色对方向的设定”在系统上的体现。若架构意图不体现方向，则它将只是局部的、边角的一些架构决策或意图。架构师的核心价值，在于通过架构意图来将“方向设定”映射为“规模与细节”。其中，“规模”表现为架构的边界/范围，“细节”表现为架构部件的联接关系/联接件。</p><p>对于架构意图的识别，有三个入手的角度。这三个角度仍是“规模与细节”相关的，其一，是系统的脉络；其二，是系统的组织；其三，是系统组织间的关系。如果一个意图表现了架构师对系统上述三个方面的理解，则该意图应当视为架构意图。</p><p>架构意图中最重要的是系统的脉络，其整体动向是本质性的需求，其内在动律是上述需求的表现与表达方式 23。总体来说，任何一个架构意图的形成都是对三个“入手角度”整体的反复考量进而形成的一个最终认识，而决非其单一方面的阐述。</p><h2 id="3-最初的事实"><a href="#3-最初的事实" class="headerlink" title="3.最初的事实"></a>3.最初的事实</h2><h3 id="真相是相，而不是真"><a href="#真相是相，而不是真" class="headerlink" title="真相是相，而不是真"></a>真相是相，而不是真</h3><p>所谓“事实”的形成，与事实本身看起来没什么关系，而仅仅在于观察者的主观判断。这看起来相当地可笑：“科学”总是依赖客观事实，但我们对客观事实的认识本身就是发自主观的——从思维的角度上来讲，如果“毫无主观判断”，那么我们也就连任何概念都无法形成。</p><p>真正完整而科学的思维方法是将“概念、论证、应用”三者合而为一的：单独地提出概念确实是主观的，科学之谓科学，在于通过后面的两种行为使概念符合逻辑论证与现实实证。</p><p>质疑那些主观判断，是系统架构思维中的第一步。</p><h3 id="如何推翻那些最初设定的“事实”？"><a href="#如何推翻那些最初设定的“事实”？" class="headerlink" title="如何推翻那些最初设定的“事实”？"></a>如何推翻那些最初设定的“事实”？</h3><p>我们谈到过系统的脉络在架构意图中最为重要，它包括两个部分，即内在动律与整体动向。通常，前者是无可争辩的事实，后者则是主观判断或客户战略。</p><p>架构不是为客户设定战略，而是服从客户设定的战略。如果客户没有形成战略，那么架构也就只能依据内在动律来主观判断整体动向。如前所论，这种主观判断是依赖对系统的分析而非对战略的假定的，并且也主要用于描述系统的发展方向，而非系统的客户——企业或领域的发展方向。</p><p>所以在架构意图上中对整体动向的考虑主要是三点：依赖、复杂性与持续价值。这三方面的问题都可以从战略设定中去寻求最终答案；如果战略不清晰，则也可以从上述的一般过程中去得到一些（阶段性的、可维护系统自身的发展所需的）设定。</p><p>与其他工程活动一样，架构工作也是渐进的，并不是一开始就准确无误。因而架构思维中需要不断反思与回顾，而架构活动也将是持续与迭代的。</p><h3 id="仰首者瞻，凝神者瞩"><a href="#仰首者瞻，凝神者瞩" class="headerlink" title="仰首者瞻，凝神者瞩"></a>仰首者瞻，凝神者瞩</h3><p>战略与方向，是存在本质性的不同的。方向只表达动向，而战略其实是已经决策的动作，或对其行动步骤的规划 7。对于架构师来说，无法决定的其实是客户的战略决策，但对于客户的方向是可以有自己的判断的。</p><h3 id="找到问题也就等于找到了解"><a href="#找到问题也就等于找到了解" class="headerlink" title="找到问题也就等于找到了解"></a>找到问题也就等于找到了解</h3><p>在既不存在所谓事实（因而也难有可信的主观判断），又没有所谓战略时，我们是可以藉由前瞻方向来形成架构意图的。而另一方面，我们也可以尝试回溯问题。</p><p>我们的软件开发活动向来是从对需求的分析开始的，经过设计、开发等过程，最后交付和维护。这一过程是如此的自然，因而我们将它从历史的开发活动中“识别”出来之后，立即被看成是软件工程作为一个成熟概念的标志。</p><p>什么是问题？问题有两个形态：其一，若系统存在某种“一般过程”，则阻碍这个一般过程的，必然是核心问题；其二，若系统存在一个确定的观察者，则所谓问题，就是这个观察者的期望与现实之间的差异。换作精炼一点的描述：<br>“所谓问题，要么是系统与其要素之间的矛盾，要么是观察与其预期之间的矛盾。”</p><p>我们在系统中引入了一般过程与观察者，前者是“导致问题”的内因，后者则是其外因。系统的不变性，一般来说是由前者决定的，所谓平衡，即是在这个一般过程的要素之间的、时间与空间上的权衡；系统的变化往往是后者导致的，亦即观察者——例如经营角色或主管——对于系统的期望缺乏一贯性。</p><h3 id="反思那些事实与问题"><a href="#反思那些事实与问题" class="headerlink" title="反思那些事实与问题"></a>反思那些事实与问题</h3><p>在此前的讨论中，除了对基本的事实与真相的识别之外，大概涉及三种思维方法：设定、试探和归纳。而本质上来说，这三种思维的过程也是模型与概念抽取的过程。由此所得的，是一个可以用来作为基础并进一步讨论的现实系统的映像：软件系统的架构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot;&gt;&lt;a href=&quot;#《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot; class=&quot;headerlink&quot; title=&quot;《我的架构思想：基本模型、理论与原则》编一——你所关注的系统&quot;&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构" scheme="http://blog.michealwayne.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Browserslist 信息和使用整理</title>
    <link href="http://blog.michealwayne.cn/2022/08/20/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Browserslist%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.michealwayne.cn/2022/08/20/notes/【笔记】Browserslist和使用/</id>
    <published>2022-08-20T02:58:29.000Z</published>
    <updated>2023-02-25T07:18:29.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Browserslist-信息和使用整理"><a href="#Browserslist-信息和使用整理" class="headerlink" title="Browserslist 信息和使用整理"></a>Browserslist 信息和使用整理</h1><p>Browserslist 是由 Autoprefixer 团队维护的一个开源项目，用于自动处理 CSS 和 JavaScript 文件的浏览器兼容性前缀和 polyfill。官方描述：</p><blockquote><p>Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-preset-env.用在不同的前端开发工具之间，分享指定的目标 Browser。像是 Autoprefixer，Stylelint，和 babel-preset-env。</p></blockquote><p>主页：<a href="https://github.com/ai/browserslist" target="_blank" rel="noopener">https://github.com/ai/browserslist</a>、<a href="https://browsersl.ist/" target="_blank" rel="noopener">https://browsersl.ist/</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Browserslist 是一个根据目标浏览器（target browser）检查支持浏览器版本的 js 库。它是现代前端工程化不可或缺的工具，无论是处理 js 的 babel 还是处理 css 的 postcss，凡是与垫片相关的，他们背后都有 browserslist 的身影。比如：</p><ul><li><code>babel</code>，在 <code>@babel/preset-env</code> 中使用 <code>core-js</code> 作为垫片</li><li><code>postcss</code> 使用 <code>autoprefixer</code> 作为垫片</li></ul><p>在前端工程化实践中，当我们确认了浏览器版本号，那么它的垫片体积就会确认。关于垫片我们知道：</p><ul><li>由于低浏览器版本的存在，垫片是必不可少的；</li><li>垫片越少，打包体积越小；</li><li>随着时间的推移，浏览器版本越新，垫片越少。</li></ul><h2 id="Browserslist-原理"><a href="#Browserslist-原理" class="headerlink" title="Browserslist 原理"></a>Browserslist 原理</h2><p><code>browserslist</code> 根据正则解析查询语句，对浏览器版本数据库 <a href="https://github.com/browserslist/caniuse-lite" target="_blank" rel="noopener"><code>caniuse-lite</code></a> 进行查询，返回所得的浏览器版本列表。</p><p><img src="/images/browserslist/p-browserslist-ori.png" alt="p-browserslist-ori.png"></p><blockquote><p>caniuse-lite 这个库也由 browserslist 团队进行维护，它是基于 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a> 的数据库进行的数据整合。caniuse-lite 库是 CanIUse (这个网站用来查询浏览器兼容性)的数据库的小版本，只有一些必需数据，这些数据存放在 caniuse-lite/data 中</p></blockquote><p>因为 <code>browserslist</code> 并不维护数据库，因此它会经常提醒你去更新 <code>caniuse-lite</code> 这个库，由于 <code>lock</code> 文件的存在，因此需要使用以下命令手动更新数据库（我们需要定期更新）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist@latest --update-db</span><br></pre></td></tr></table></figure><p>该命令将会对 <code>caniuse-lite</code> 进行升级，并体现在 <code>lock</code> 文件中。此更新将为 Autoprefixer 或 Babel 等 polyfill 工具带来有关新浏览器的数据，并减少已经不必要的 polyfill。</p><p>需要定期更新主要有如下三个原因：</p><ul><li>在查询中使用最新的浏览器版本和统计信息：例如 <code>last 2 versions or &gt;1%</code> ，如果在 2 年前创建了项目但是没有更新依赖项，那么返回结果是 2 年前的浏览器</li><li>实际的浏览器数据将导致使用更少的 polyfill。它将减少 JS 和 CSS 文件的大小并提高网站性能。</li><li><code>caniuse-lite</code> 重复数据删除：在不同工具中同步版本。</li></ul><h4 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h4><p>如果您选择的前端工具包括对 browserslist 的支持，它将在以下位置查找指定浏览器版本的查询，从第一个到最后一个，browerslist 将使用如下配置文件限定的的浏览器和 node 版本范围：</p><ul><li>工具 options，例如 Autoprefixer 工具配置中的 browsers 属性。</li><li><code>BROWERSLIST</code> 环境变量。</li><li>当前目录或者上级目录的 <code>browserslist</code> 配置文件。</li><li>当前目录或者上级目录的 <code>.browserslistrc</code> 配置文件。</li><li>当前目录或者上级目录的 <code>package.json</code> 配置文件里面的 <code>browserslist</code> 配置项（推荐）。</li></ul><p>如果上述的配置文件缺失或者其他因素导致未能生成有效的配置，browserslist 将使用<code>default</code>配置<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>。</p><h2 id="Browserslist-使用者"><a href="#Browserslist-使用者" class="headerlink" title="Browserslist 使用者"></a>Browserslist 使用者</h2><p>目前主要前端工程工具都或多或少用到了 browserslist，如：</p><p><img src="/images/browserslist/p-users.jpg" alt="p-users.jpg"></p><ul><li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a>：Autoprefixer browserslist 从 package.json. 您无需执行任何其他操作——Autoprefixer 会自动查找并加载配置。</li><li><p><a href="https://github.com/babel/babel-preset-env" target="_blank" rel="noopener">babel-preset-env</a>是“JavaScript 的自动前缀”。如果它已经知道所有目标浏览器都支持它，它就不会编译 ES2015+ 语法。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel&quot;: &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;browsers&quot;: &quot;last 2 version&quot;,</span><br><span class="line">          &quot;node&quot;: 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;loose&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/amilajack/eslint-plugin-compat" target="_blank" rel="noopener">eslint-plugin-compat</a>：是 ESLint 的一个插件，当并非所有目标浏览器都支持您的 JavaScript 代码时，它会向您发出警告。它支持开箱即用的 Browserslist 配置；它获取目标浏览器版本列表并检查您的代码是否使用所有指定浏览器支持的 JavaScript API。</p></li><li><a href="https://github.com/ismay/stylelint-no-unsupported-browser-features" target="_blank" rel="noopener">stylelint-no-unsupported-browser-features</a> 的工作方式类似于 eslint-plugin-compat— 但适用于 CSS。Stylelint 是一个出色且最流行的 CSS linter。这个 Stylelint 插件确保所有目标浏览器都支持所有使用的 CSS 属性。它还支持开箱即用的 Browserslist 配置。</li><li><a href="https://github.com/jonathantneal/postcss-normalize" target="_blank" rel="noopener">postcss-normalize</a> 仅包含<a href="https://github.com/jonathantneal/normalize.css" target="_blank" rel="noopener">normalize.css</a>的必要部分 ，基于您支持的浏览器列表。</li></ul><h2 id="使用-常用配置"><a href="#使用-常用配置" class="headerlink" title="使用/常用配置"></a>使用/常用配置</h2><h3 id="根据用户份额"><a href="#根据用户份额" class="headerlink" title="根据用户份额:"></a>根据用户份额:</h3><ul><li><code>&gt; 5%</code>: 在全球用户份额大于 5% 的浏览器</li><li><code>&gt; 5% in CN</code>: 在中国用户份额大于 5% 的浏览器</li></ul><h3 id="根据最新浏览器版本"><a href="#根据最新浏览器版本" class="headerlink" title="根据最新浏览器版本"></a>根据最新浏览器版本</h3><ul><li><code>last 2 versions</code>: 所有浏览器的最新两个版本</li><li><code>last 2 Chrome versions</code>: Chrome 浏览器的最新两个版本</li></ul><h3 id="不再维护的浏览器"><a href="#不再维护的浏览器" class="headerlink" title="不再维护的浏览器"></a>不再维护的浏览器</h3><p><code>dead</code>: 官方不在维护已过两年，比如 IE10</p><h3 id="官方提供的查询"><a href="#官方提供的查询" class="headerlink" title="*官方提供的查询"></a>*官方提供的查询</h3><p>你可以用如下查询条件来限定浏览器和 node 的版本范围（大小写不敏感）：</p><ul><li><code>&gt; 5%</code>: 基于全球使用率统计而选择的浏览器版本范围。&gt;=,&lt;,&lt;=同样适用。</li><li><code>&gt; 5% in US</code> : 同上，只是使用地区变为美国。支持两个字母的国家码来指定地区。</li><li><code>&gt; 5% in alt-AS</code> : 同上，只是使用地区变为亚洲所有国家。这里列举了所有的地区码。</li><li><code>&gt; 5% in my stats</code> : 使用定制的浏览器统计数据。</li><li><code>cover 99.5%</code> : 使用率总和为 99.5%的浏览器版本，前提是浏览器提供了使用覆盖率。</li><li><code>cover 99.5% in US</code> : 同上，只是限制了地域，支持两个字母的国家码。</li><li><code>cover 99.5% in my stats</code> :使用定制的浏览器统计数据。</li><li><code>maintained node versions</code> :所有还被 node 基金会维护的 node 版本。</li><li><code>node 10 and node 10.4</code> : 最新的 node 10.x.x 或者 10.4.x 版本。</li><li><code>current node</code> :当前被 browserslist 使用的 node 版本。</li><li><code>extends browserslist-config-mycompany</code> :来自 browserslist-config-mycompany 包的查询设置</li><li><code>ie 6-8</code> : 选择一个浏览器的版本范围。</li><li><code>Firefox &gt; 20</code> : 版本高于 20 的所有火狐浏览器版本。&gt;=,&lt;,&lt;=同样适用。</li><li><code>ios 7</code> :ios 7 自带的浏览器。</li><li><code>Firefox ESR</code> :最新的火狐 ESR（长期支持版） 版本的浏览器。</li><li><code>unreleased versions or unreleased Chrome versions</code> : alpha 和 beta 版本。</li><li><code>last 2 major versions or last 2 ios major versions</code> :最近的两个发行版，包括所有的次版本号和补丁版本号变更的浏览器版本。</li><li><code>since 2015 or last 2 years</code> :自某个时间以来更新的版本（也可以写的更具体 since 2015-03 或者 since 2015-03-10）</li><li><code>dead</code> :通过 <code>last 2 versions</code> 筛选的浏览器版本中，全球使用率低于 0.5% 并且官方声明不在维护或者事实上已经两年没有再更新的版本。</li><li><code>last 2 versions</code>: 每个浏览器最近的两个版本。</li><li><code>last 2 Chrome versions</code>: chrome 浏览器最近的两个版本。</li><li><code>defaults</code>: <strong>默认配置<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code></strong>。</li><li><code>not ie &lt;= 8</code>: 浏览器范围的取反。</li></ul><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>直接在工程目录下运行 <code>npx browserslist</code> 来查看你配置的筛选条件筛选出的浏览器版本范围。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>browserslist 会处理浏览器的每个版本，所以应该避免配置这样的查询条件 <code>Firefox &gt; 0</code>.</p><p>多个查询条件组和在一起之后，其之间的的覆盖是以 <code>OR</code> 的方式，而是不是 <code>AND</code>,也就是说只要浏览器版本符合筛选条件里面的一种即可。</p><p>所有的查询条件均基于 <code>caniuse</code> 的支持列表。例如：<code>last 3 ios versions</code> 可能会返回 <code>8.4</code>, <code>9.2</code>, <code>9.3</code>(混合了主版本和次版本)，然而 <code>last 3 Chrome versions</code> 可能返回 <code>50</code>, <code>49</code>, <code>48</code>（只有主版本）。</p><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>可通过 and、or、not 关键字进行组合查询。</p><table><thead><tr><th>组合器类型</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>and</code></td><td>为交集，每个条件相交的结果</td><td><code>Chrome 58-65 and supports es6-module</code>：查找 Chrome 58 到 65 并且支持 es6-module 的版本。</td></tr><tr><td><code>or</code></td><td>为并集，每个条件合并的结果。也可以用逗号代替 or</td><td><code>Chrome &gt; 94 or Edge &gt; 94</code>或<code>Chrome &gt; 94,Edge &gt; 94</code>：查找 Chrome 与 Edge 大于 94 的版本。</td></tr><tr><td><code>not</code></td><td>为非，取反</td><td><code>&gt; .5% and not last 2 versions</code>或<code>&gt; .5% or not last 2 versions</code>或<code>&gt; .5%, not last 2 versions</code>：使用率大于 0.5% 的版本中排除不是最后两个版本。</td></tr></tbody></table><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="1-package-json"><a href="#1-package-json" class="headerlink" title="1.package.json"></a>1.package.json</h4><p>如果你想减少工程根目录下的配置文件的数量，可以在 package.json 中设置 browserslist 配置项，如下所示:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^6.5.4"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"browserslist"</span>: [<span class="string">"last 1 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><p>browserslist 配置文件应该被命名为 <code>.browserslistrc</code> 或者 <code>browserslist</code> 每条查询条件独占一行。 注释用 # 开头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Browsers that we support</span><br><span class="line"></span><br><span class="line">last 1 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10 # sorry</span><br></pre></td></tr></table></figure><p>browserslist 将检查 path 路径上每一级目录下面是否有配置文件. 所以，如果工具要处理的文件路径是这样的 <code>app/styles/main.css</code>, 那么你可以将配置文件放置在根目录, <code>app/</code> 或者 <code>app/styles</code>。</p><p>也可以在 <code>BROWSERSLIST_CONFIG</code> 环境变量中直接指定配置文件的路径 。</p><h4 id="3-Shareable-Configs"><a href="#3-Shareable-Configs" class="headerlink" title="3.Shareable Configs"></a>3.Shareable Configs</h4><p>可以使用如下写法，从另外一个输出 browserslist 配置的包导入配置数据:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">  <span class="string">"extends browserslist-config-mycompany"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>为了安全起见，额外的配置包只支持前缀 <code>browserslist-config-</code> 的包命名. npm 包作用域也同样支持 <code>@scope/browserslist-config</code>,例如： <code>@scope/browserslist-config</code> or <code>@scope/browserslist-config-mycompany</code>.</p><p>当写一个 shared config package 时，必须导出一个数组。如 <code>browserslist-config-mycompany/index.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [<span class="string">'last 1 version'</span>, <span class="string">'&gt; 1%'</span>, <span class="string">'ie 10'</span>];</span><br></pre></td></tr></table></figure><h4 id="4-环境的差异化配置"><a href="#4-环境的差异化配置" class="headerlink" title="4.环境的差异化配置"></a>4.环境的差异化配置</h4><p>你可以为不同的环境配置不同的浏览器查询条件。 browserslist 将依赖 <code>BROWSERSLIST_ENV</code> 或者 <code>NODE_ENV</code> 查询浏览器版本范围 . 如果两个环境变量都没有配置正确的查询条件，那么优先从 <code>production</code> 对应的配置项加载查询条件，如果再不行就应用默认配置。</p><p>如在<code>package.json</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": &#123;</span><br><span class="line">  "production": [</span><br><span class="line">    "&gt; 1%",</span><br><span class="line">    <span class="string">"ie 10"</span></span><br><span class="line">  ],</span><br><span class="line">  "development": [</span><br><span class="line">    "last 1 chrome version",</span><br><span class="line">    <span class="string">"last 1 firefox version"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或在<code>.browserslistrc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[production staging]</span><br><span class="line">&gt; 1%</span><br><span class="line">ie 10</span><br><span class="line"></span><br><span class="line">[development]</span><br><span class="line">last 1 chrome version</span><br><span class="line">last 1 firefox version</span><br></pre></td></tr></table></figure><h4 id="5-使用自定义数据"><a href="#5-使用自定义数据" class="headerlink" title="5.使用自定义数据"></a>5.使用自定义数据</h4><p>这需要 <a href="https://analytics.google.com/analytics/web/provision/#/provision" target="_blank" rel="noopener">Google Analytics</a>，然后可以通过数据生成<code>browserslist-stats.json</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist-ga</span><br></pre></td></tr></table></figure><p>你也可以通过其它方式得到统计，但是最终数据生成的内容格式应保持如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ie"</span>: &#123;</span><br><span class="line">    <span class="attr">"6"</span>: <span class="number">0.01</span>,</span><br><span class="line">    <span class="attr">"7"</span>: <span class="number">0.4</span>,</span><br><span class="line">    <span class="attr">"8"</span>: <span class="number">1.5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"chrome"</span>: &#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;,</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js-api"><a href="#js-api" class="headerlink" title="js api"></a>js api</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browserslist = <span class="built_in">require</span>(<span class="string">'browserslist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your CSS/JS build tool code</span></span><br><span class="line"><span class="keyword">const</span> process = <span class="function"><span class="keyword">function</span> (<span class="params">source, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> browsers = browserslist(opts.browsers, &#123;</span><br><span class="line">    stats: opts.stats,</span><br><span class="line">    path: opts.file,</span><br><span class="line">    env: opts.env,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Your code to add features for selected browsers</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查询可以是字符串 <code>&quot;&gt; 1%, IE 10&quot;</code> 或数组 <code>[&#39;&gt; 1%&#39;, &#39;IE 10&#39;]</code>。</p><p>如果缺少查询，browserslist 将查找配置文件。您可以提供一个路径选项（可以是一个文件）来查找相对于它的配置文件。</p><p>Options:</p><ul><li><code>path</code>: 文件或目录路径来查找配置文件。默认为<code>.</code></li><li><code>env</code>: 从配置中使用什么环境部分。默认为 <code>production</code></li><li><code>stats</code>: 自定义使用统计数据</li><li><code>config</code>: 如果要手动设置，则配置路径</li><li><code>ignoreUnknownVersions</code>: 不要直接查询（例如 <code>12</code>）。默认为 <code>false</code></li><li><code>dangerousExtend</code>: 禁用扩展查询的安全检查。默认为 <code>false</code></li></ul><p>对于非 js 环境和调试目的，可以使用 cli 工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist <span class="string">"&gt; 1%, IE 10"</span></span><br></pre></td></tr></table></figure><h3 id="覆盖率查询"><a href="#覆盖率查询" class="headerlink" title="覆盖率查询"></a>覆盖率查询</h3><p>可以通过 js API 获得所选浏览器的总用户覆盖率：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browserslist.coverage(browserslist(<span class="string">'&gt; 1%'</span>));</span><br><span class="line"><span class="comment">//=&gt; 81.4</span></span><br></pre></td></tr></table></figure><p>或者通过 cli：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist --coverage=US <span class="string">"&gt; 1% in US"</span></span><br></pre></td></tr></table></figure><h3 id="在线覆盖情况查询"><a href="#在线覆盖情况查询" class="headerlink" title="在线覆盖情况查询"></a>在线覆盖情况查询</h3><p>地址：<a href="https://browsersl.ist/" target="_blank" rel="noopener">https://browsersl.ist/</a>、<a href="https://browserslist.dev/" target="_blank" rel="noopener">https://browserslist.dev/</a></p><p>效果：</p><p><img src="/images/browserslist/p-browserslist-dev.jpg" alt="p-browserslist-dev.jpg"></p><p><img src="/images/browserslist/p-browserslist-ist.jpg" alt="p-browserslist-ist.jpg"></p><h2 id="衍生工具"><a href="#衍生工具" class="headerlink" title="衍生工具"></a>衍生工具</h2><p>browerslist 衍生的工具，具体可见<a href="https://github.com/browserslist/browserslist#tools" target="_blank" rel="noopener">browserslist tools</a></p><ul><li><a href="https://github.com/browserslist/browserslist-ga" target="_blank" rel="noopener">browserslist-ga</a>或<a href="https://github.com/browserslist/browserslist-ga-export" target="_blank" rel="noopener">browserslist-ga-export</a>： 该工具能生成访问你运营的网站的浏览器的版本分布数据，以便用于类似&gt; 0.5% in my stats 查询条件, 前提是你运营的网站部署有 Google Analytics。</li><li><a href="https://github.com/browserslist/browserslist-useragent-regexp" target="_blank" rel="noopener">browserslist-useragent</a> ： 检验 某浏览器的 user-agent 字符串是否匹配 browserslist 给出的浏览器范围。</li><li><a href="https://github.com/browserslist/browserslist-useragent-ruby" target="_blank" rel="noopener">browserslist-useragent-ruby</a> ： 功能同上，ruby 库。</li><li>caniuse-api： 返回支持指定特性的浏览器版本范围</li><li>npx browserslist ：在前端工程目录下运行上面命令，输出当前工程的目标浏览器列表。</li></ul><h2 id="Browserslist-2"><a href="#Browserslist-2" class="headerlink" title="Browserslist 2"></a>Browserslist 2</h2><h3 id="last-n-versions-为更好的网络而改变"><a href="#last-n-versions-为更好的网络而改变" class="headerlink" title="last n versions 为更好的网络而改变"></a><code>last n versions</code> 为更好的网络而改变</h3><p>从一开始，Autoprefixer 就 <code>last 2 versions</code> 选择了最后的 2 个浏览器版本，但不是从所有浏览器中挑选出来，只是最流行的那些。事实证明，这是一个错误。</p><p>现实世界中没有“主流”浏览器。例如，中国在线市场巨大，在中国有很多流行的本地浏览器。我们不能仅仅忽略本地浏览器——每个人都应该可以访问网络。</p><p>事实上，Autoprefixer 本身的创建是为了阻止浏览器的差异化（例如<code>-webkit-</code>对移动浏览器使用 <code>-only</code> 前缀）。</p><p>这就是为什么 Autoprefixer 7 和 Browserslist 2 <code>last 2 version</code> 会选择 所有浏览器的 2 个最新版本。</p><p>不用担心大小，<code>——gzip</code> 可以很好地压缩前缀，因此您很可能不会看到任何大小差异。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Browserslist 在托管过程中缓存它从 <code>package.json</code> 和 <code>browserslist</code> 文件中读取的配置，以及有关文件存在的知识。</p><p>要清除这些缓存，请使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserslist.clearCaches();</span><br></pre></td></tr></table></figure><p>要完全禁用缓存，请设置 <code>BROWSERSLIST_DISABLE_CACHE</code> 环境变量。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>不推荐用 <code>last 2 Chrome versions</code> 或 <code>not dead</code> 的查询条件来锁定特别具体的浏览器品牌和版本。市面上有各种各样的浏览器，同时浏览器的版本碎片化也很严重，如果你在开发一款通用的 webapp，那就应该考虑浏览器多样性导致的兼容问题。（<code>not dead</code>在国内外的差异见下图）</p><p><code>not dead</code> 国内覆盖率只有 73%</p><p><img src="/images/browserslist/p-browserslist-ist-notdead1.jpg" alt="p-browserslist-ist-notdead1.jpg"></p><p><code>not dead</code> 全球有 86.4%<br><img src="/images/browserslist/p-browserslist-ist-notdead2.jpg" alt="p-browserslist-ist-notdead2.jpg"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://github.com/ai/browserslist" target="_blank" rel="noopener">https://github.com/ai/browserslist</a></li><li><a href="https://evilmartians.com/chronicles/autoprefixer-7-browserslist-2-released" target="_blank" rel="noopener">https://evilmartians.com/chronicles/autoprefixer-7-browserslist-2-released</a></li><li><a href="https://css-tricks.com/browserlist-good-idea/" target="_blank" rel="noopener">https://css-tricks.com/browserlist-good-idea/</a></li><li><a href="http://browserl.ist/" target="_blank" rel="noopener">http://browserl.ist/</a></li><li><a href="https://browserslist.dev/" target="_blank" rel="noopener">https://browserslist.dev/</a></li><li><a href="https://github.com/browserslist/update-db#readme" target="_blank" rel="noopener">https://github.com/browserslist/update-db#readme</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Browserslist-信息和使用整理&quot;&gt;&lt;a href=&quot;#Browserslist-信息和使用整理&quot; class=&quot;headerlink&quot; title=&quot;Browserslist 信息和使用整理&quot;&gt;&lt;/a&gt;Browserslist 信息和使用整理&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浏览器" scheme="http://blog.michealwayne.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】越来越快的jsRuntime——Bun</title>
    <link href="http://blog.michealwayne.cn/2022/07/17/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%BF%AB%E7%9A%84jsRuntime%E2%80%94%E2%80%94Bun/"/>
    <id>http://blog.michealwayne.cn/2022/07/17/notes/【笔记】越来越快的jsRuntime——Bun/</id>
    <published>2022-07-17T08:17:10.000Z</published>
    <updated>2023-02-25T07:21:31.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="越来越快的-jsRuntime——Bun"><a href="#越来越快的-jsRuntime——Bun" class="headerlink" title="越来越快的 jsRuntime——Bun"></a>越来越快的 jsRuntime——Bun</h1><p>在 2020 年起，大家都在谈论 js 的未来发展，其中本人印象最为深刻的就是<a href="https://www.swyx.io/js-third-age/" target="_blank" rel="noopener">“js 三时代”</a>一论。大致表达意思是只每隔 10 年，js 就会发生一次变化，而我们正处于 js 第三个时代——整合工具层时期。在 js runtime 这块比较典型的就是<a href="https://github.com/denoland/deno" target="_blank" rel="noopener">Deno</a>，它试图将执行测试、格式化、linting 和捆绑等任务的常用工具合并到一个二进制文件中，使用 TypeScript，甚至包括一个标准库。<a href="https://github.com/rome" target="_blank" rel="noopener">Rome</a>采取了不同的策略，将所有这些层折叠在 Node.js 之上。</p><p>js 第三时代工具的特点：</p><ul><li>更快</li><li>ESM 优先</li><li>折叠层（一个工具做好很多事情，而不是很多工具做好一件事）</li><li>Typesafe-er（以强类型语言为核心构建，并以零配置支持用户代码中的 TS）</li><li>Secure-er（来自依赖攻击，或宽松的权限）</li><li>多语种</li><li>Neo-Isomorphic（JS 应该首先在构建时或服务器端运行，然后再到达客户端）</li></ul><p><img src="/images/bun/p-1.png" alt="p-1.png"></p><p>所有这些的结果是更好的开发人员体验（更快地构建，标准化行业工具）和用户体验（更小的 bundle 包、更快的功能交付）。它是 js 从站点脚本语言到完整应用平台的最终蜕变。</p><p>而本文介绍的也是第三阶段演进中近期快速发展的整合 Runtime ——<a href="https://github.com/oven-sh/bun" target="_blank" rel="noopener">Bun</a>。</p><blockquote><p>Bun——Incredibly fast JavaScript runtime, bundler, transpiler and package manager – all in one. 官网：<a href="https://bun.sh/" target="_blank" rel="noopener">https://bun.sh/</a>；Bun Github：<a href="https://github.com/oven-sh/bun" target="_blank" rel="noopener">https://github.com/oven-sh/bun</a></p></blockquote><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Bun 是采用 Zig 语言编写的高性能“全家桶” js runtime，官方称其为“all-in-one JavaScript runtime”，它原生（作者自己手撸）实现了数百个 Node.js 和 Web API，包括约 90% 的 node API 函数、fs、path、Buffer 等，并且 Bun 也可以直接运行 TypeScript 文件。</p><blockquote><p>作者 <a href="https://twitter.com/jarredsumner" target="_blank" rel="noopener">Jarred Sumner</a>，据说因为肝代码而天天都吃包子，所以取名叫 Bun。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>支持系统：macOS x64、Silicon、Linux x64、Windows Subsystem for Linux（WSL）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://bun.sh/install | bash</span><br></pre></td></tr></table></figure><p>（目前 2022.07.17 最新版本 v0.1.4 beta）</p><blockquote><p>注意 Windows 系统不能像装 Nodejs 一样直接程序安装，Windows 的安装使用可以参照<a href="https://juejin.cn/post/7119006461576871973" target="_blank" rel="noopener">https://juejin.cn/post/7119006461576871973</a></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装后可以写一个 demo（如官方 http server demo）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  fetch(request) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'Welcome to Bun!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun run http.js</span><br></pre></td></tr></table></figure><p>然后可以通过 <code>http://localhost:3000</code> 进行访问。</p><h4 id="TypeScript-使用"><a href="#TypeScript-使用" class="headerlink" title="TypeScript 使用"></a>TypeScript 使用</h4><p>在 Bun 中，天然支持运行运行 TypeScript，无需配置，无需额外安装；<br>如果你导入一个<code>.ts</code>或<code>.tsx</code>文件，Bun 会将它转换成 js。注意 Bun 还会编译<code>node_modules</code>中的<code>.ts</code>或<code>.tsx</code>文件；这是由 Bun 内置了 TypeScript 转译器，且速度很快。</p><p>如果你想在全局使用对应的 API，安装 <a href="https://github.com/oven-sh/bun/blob/main/types/bun/bun.d.ts" target="_blank" rel="noopener">bun-typs</a> 到你的项目即可：</p><p>1.安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun add -d bun-types</span><br></pre></td></tr></table></figure><p>2.在<code>tsconfig.json</code>中使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"types"</span>: [<span class="string">"bun-types"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Bun 目前处于初创和快速迭代器，使用建议看 github（<a href="https://github.com/oven-sh/bun#using-bunjs---a-new-javascript-runtime-environment" target="_blank" rel="noopener">https://github.com/oven-sh/bun#using-bunjs—a-new-javascript-runtime-environment</a>）</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>bun run</code>：执行 js/ts 脚本，可以执行 package.json 中的 “scripts” 脚本，而且官方说比 npm run 快 30 倍；</li><li><code>bun install</code>：安装模块。官方说 bun install 使用最快的系统调用来复制文件，官方说比 yarn 快 20 倍；<ul><li><code>bun remove</code>：删除一个模块；</li><li><code>bun add</code>：增加安装一个模块；</li><li><code>bun create</code>：创建一个模板项目，如<code>bun create react ./bun-react-demo</code>创建一个名为 bun-react-demo 的 react 项目</li></ul></li><li><code>bun wiptest</code>：进行测试，一个类似于 Jest 的测试运行器，用于内置到 bun 的 JavaScript 和 TypeScript 项目。</li><li><code>bun upgrade</code>：升级 bun。</li></ul><h3 id="配置文件bunfig-toml"><a href="#配置文件bunfig-toml" class="headerlink" title="配置文件bunfig.toml"></a>配置文件<code>bunfig.toml</code></h3><p><code>bunfig.toml</code> 是 bun 的配置文件。</p><p>通过配置文件我们可以在 <code>bunfig.toml</code> 加载配置，而不是每次都将参数传递给命令行。在解析命令行参数之前加载配置文件，这意味着命令行参数可以覆盖这个配置。</p><p>如官方案例（<a href="https://github.com/oven-sh/bun#bunfigtoml）：" target="_blank" rel="noopener">https://github.com/oven-sh/bun#bunfigtoml）：</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Set a default framework to use</span><br><span class="line"># By default, bun will look for an npm package like `bun-framework-$&#123;framework&#125;`, followed by `$&#123;framework&#125;`</span><br><span class="line">framework = "next"</span><br><span class="line">logLevel = "debug"</span><br><span class="line"></span><br><span class="line"># publicDir = "public"</span><br><span class="line"># external = ["jquery"]</span><br><span class="line"></span><br><span class="line">[macros]</span><br><span class="line"># Remap any import like this:</span><br><span class="line">#     import &#123;graphql&#125; from 'react-relay';</span><br><span class="line"># To:</span><br><span class="line">#     import &#123;graphql&#125; from 'macro:bun-macro-relay';</span><br><span class="line">react-relay = &#123; "graphql" = "bun-macro-relay" &#125;</span><br><span class="line"></span><br><span class="line">[bundle]</span><br><span class="line">saveTo = "node_modules.bun"</span><br><span class="line"># Don't need this if `framework` is set, but showing it here as an example anyway</span><br><span class="line">entryPoints = ["./app/index.ts"]</span><br><span class="line"></span><br><span class="line">[bundle.packages]</span><br><span class="line"># If you're bundling packages that do not actually live in a `node_modules` folder or do not have the full package name in the file path, you can pass this to bundle them anyway</span><br><span class="line">"@bigapp/design-system" = true</span><br><span class="line"></span><br><span class="line">[dev]</span><br><span class="line"># Change the default port from 3000 to 5000</span><br><span class="line"># Also inherited by Bun.serve</span><br><span class="line">port = 5000</span><br><span class="line"></span><br><span class="line">[define]</span><br><span class="line"># Replace any usage of "process.env.bagel" with the string `lox`.</span><br><span class="line"># The values are parsed as JSON, except single-quoted strings are supported and `'undefined'` becomes `undefined` in JS.</span><br><span class="line"># This will probably change in a future release to be just regular TOML instead. It is a holdover from the CLI argument parsing.</span><br><span class="line">"process.env.bagel" = "'lox'"</span><br><span class="line"></span><br><span class="line">[loaders]</span><br><span class="line"># When loading a .bagel file, run the JS parser</span><br><span class="line">".bagel" = "js"</span><br><span class="line"></span><br><span class="line">[debug]</span><br><span class="line"># When navigating to a blob: or src: link, open the file in your editor</span><br><span class="line"># If not, it tries $EDITOR or $VISUAL</span><br><span class="line"># If that still fails, it will try Visual Studio Code, then Sublime Text, then a few others</span><br><span class="line"># This is used by Bun.openInEditor()</span><br><span class="line">editor = "code"</span><br><span class="line"></span><br><span class="line"># List of editors:</span><br><span class="line"># - "subl", "sublime"</span><br><span class="line"># - "vscode", "code"</span><br><span class="line"># - "textmate", "mate"</span><br><span class="line"># - "idea"</span><br><span class="line"># - "webstorm"</span><br><span class="line"># - "nvim", "neovim"</span><br><span class="line"># - "vim","vi"</span><br><span class="line"># - "emacs"</span><br><span class="line"># - "atom"</span><br><span class="line"># If you pass it a file path, it will open with the file path instead</span><br><span class="line"># It will recognize non-GUI editors, but I don't think it will work yet</span><br></pre></td></tr></table></figure><p>属性解释：</p><ul><li><code>framework</code> ：指定默认使用的 framework 版本，bun 将根据 <code>bun-framework-${framework}</code> 格式找寻找 npm 包；</li><li><code>logLevel</code> ：指定 log 级别（可用值 error 、 warn 、 info 和 debug ）；</li><li><code>publicDir</code> ：指定 public 目录；</li><li><code>external</code> ：指定外部扩展，作用等同于 Webpack 的 externals；</li><li><code>macros</code> ：宏定义，用于替换 import 路径，比如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'react-relay'</span>; 将被转换为 <span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">"macro:bun-macro-relay/bun-macro-relay.tsx"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>dev.port</code> ：指定服务的监听端口（默认 3000 ）；</li><li><code>define</code> ：作用等同于 Webpack 的 DefinePlugin；</li><li><code>loaders</code> ：指定各类文件的解析器；</li></ul><h3 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h3><ul><li>Web API 支持：对  fetch、WebSocket、 ReadableStream  等  API  都提供了内置支持；</li><li>Node.js 模块：Bun  实现了  Node.js  的模块解析算法，，以便我们可以在 Bun 中使用 npm 包，同时支持  ESM  和  CommonJS，但  Bun  内部使用  ESM；</li><li>Bun.js  实现了大部分  Node-API (N-API)，大部分  Node.js  原生模块及全局变量（比如 Buffer 和 process）都可以正常工作；</li><li>自动加载环境变量  .env  文件，不需要再  require(“dotenv”).load()；</li><li>附带一个内置的快速  SQLite3 户端  bun:sqlite；</li><li>内置 JavaScript、TypeScript、JSX 等（见下表）各种转译器；</li></ul><table><thead><tr><th>Input</th><th>Loader</th><th>Output</th></tr></thead><tbody><tr><td><code>.js</code></td><td>JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.jsx</code></td><td>JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.ts</code></td><td>TypeScript + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.tsx</code></td><td>TypeScript + JSX + JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.mjs</code></td><td>JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.cjs</code></td><td>JavaScript</td><td><code>.js</code></td></tr><tr><td><code>.mts</code></td><td>TypeScript</td><td><code>.js</code></td></tr><tr><td><code>.cts</code></td><td>TypeScript</td><td><code>.js</code></td></tr><tr><td><code>.toml</code></td><td>TOML</td><td><code>.js</code></td></tr><tr><td><code>.css</code></td><td>CSS</td><td><code>.css</code></td></tr><tr><td><code>.env</code></td><td>Env</td><td><code>N/A</code></td></tr><tr><td><code>.*</code></td><td>file</td><td><code>string</code></td></tr></tbody></table><p>Bun 对 Node.js 生态实现了良好兼容：</p><ul><li>内置了 fetch、WebSocket、ReadableStream 等 Web API；</li><li>实现了 Node.js 核心模块（比如 fs、path、Buffer 等）及全局变量（比如 process）；</li><li>实现了 Node.js 的模块解析算法，以便我们可以在 Bun 中使用 npm 包；</li><li>支持 ESM 和 CommonJS（Bun 内部默认使用 ESM）。</li></ul><h2 id="有多快"><a href="#有多快" class="headerlink" title="有多快"></a>有多快</h2><p>Bun 的主要优势就是快，那么它快在哪里？</p><h3 id="官方对比数据"><a href="#官方对比数据" class="headerlink" title="官方对比数据"></a>官方对比数据</h3><p>首先是 React 的服务器端渲染速度（每秒的 HTTP 请求数）：</p><p><img src="/images/bun/p-compare-1.png" alt="p-compare-1.png"></p><p>加载一个大型数据表：每秒平均查询次数：</p><p><img src="/images/bun/p-compare-2.png" alt="p-compare-2.png"></p><p>FFI：每秒操作数：</p><p><img src="/images/bun/p-compare-3.png" alt="p-compare-3.png"></p><p>按作者推特上的测试：</p><p><img src="/images/bun/p-bun-fast.png" alt="p-bun-fast.png"></p><p>还有一篇文章中的多项测试（要翻墙）：<br><a href="https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9" target="_blank" rel="noopener">https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9</a></p><p>与 npm 对比：<br><img src="/images/bun/p-bun-npm.png" alt="p-bun-npm.png"></p><p>与 babel 对比：<br><img src="/images/bun/p-bun-babel.png" alt="p-bun-babel.png"></p><p>与 webpack 对比：<br><img src="/images/bun/p-bun-webpack.png" alt="p-bun-webpack.png"></p><p>与 vite、swc 对比：<br><img src="/images/bun/p-bun-vite.png" alt="p-bun-vite.png"></p><p>我们可以用 bun 的一些 demo 自行验证：<a href="https://github.com/oven-sh/bun/tree/main/examples" target="_blank" rel="noopener">https://github.com/oven-sh/bun/tree/main/examples</a></p><p>按官方的对比数据，Bun 可以说在性能方面是碾压 Node.js 和 Deno。</p><h3 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h3><h4 id="1-js-引擎差异"><a href="#1-js-引擎差异" class="headerlink" title="1.js 引擎差异"></a>1.js 引擎差异</h4><p>不同于 Node.js 和 Deno，Bun 并没有基于 V8 引擎，而是使用了轻量级的 <a href="https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore" target="_blank" rel="noopener">JavaScriptCore</a> 引擎，jsCore 一般用于移动端，它的执行速度往往要比 V8 等更传统引擎要快。</p><p>Bun 中一些 Web API 直接用了 Safari 的实现，如 Headers 和 URL，<a href="https://github.com/oven-sh/bun/blob/HEAD/src/bun.js/bindings/webcore/JSFetchHeaders.cpp" target="_blank" rel="noopener">https://github.com/oven-sh/bun/blob/HEAD/src/bun.js/bindings/webcore/JSFetchHeaders.cpp</a>。</p><h4 id="2-开发语言差异"><a href="#2-开发语言差异" class="headerlink" title="2.开发语言差异"></a>2.开发语言差异</h4><p>Bun.js 使用的是新兴的系统编程语言 <a href="https://ziglang.org/" target="_blank" rel="noopener">ZIG</a> 编写的，ZIG 一般用于嵌入式和系统级编程，使用 ZIG 主要通过手动内存管理对内存进行更细粒度的控制、无隐藏的控制流来提升程序的性能。</p><blockquote><p>Zig 是一门系统级编程语言，专为稳定性、可维护性和性能而设计，是追求替代 C 语言在系统编程上的最佳地位。</p></blockquote><p><img src="/images/bun/p-bun-language.png" alt="p-bun-language.png"></p><p>其中 C++的代码大部分是 web API 的实现（Safari）</p><h4 id="3-独立实现工具"><a href="#3-独立实现工具" class="headerlink" title="3.独立实现工具"></a>3.独立实现工具</h4><p>在前两点的前提下，作者重新实现了诸如 JSX/TypeScript 转编器、npm 客户端、SQLite 客户端、HTTP 客户端、WebSocket 客户端等类库。</p><h2 id="使用评估"><a href="#使用评估" class="headerlink" title="使用评估"></a>使用评估</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能。主要亮点、核心竞争力。至少短期 Node/Deno 是难以超越 Bun；</li><li>效率。集成各类工具，能大幅提高开发效率，这也是 js 第三阶段产物的典型特征。</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>是起步项目，目前存在内存泄露等问题，连作者也不建议在生产使用；</li><li>是个人项目，目前仍有 200+个 issue 待解决</li><li>部分 npm 包不兼容</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>版本较新，最新版本才 v0.1.4；</li><li>star 快速上升，目前 26.2k（至 2022.07.17）。油管上也有多了许多讲解视频；</li><li>社区维护：<a href="https://bun.sh/discord" target="_blank" rel="noopener">https://bun.sh/discord</a><br><img src="/images/bun/p-bun-discord.jpg" alt="p-bun-discord.jpg"></li><li>里程碑：<a href="https://github.com/oven-sh/bun/issues/159" target="_blank" rel="noopener">https://github.com/oven-sh/bun/issues/159</a></li></ul><p>综上，Bun 是一个有前景的项目，高效的性能能拓宽 js 的应用边界，但是目前项目仍处理起步阶段，整体并不成熟。因此我们目前不能在业务生产中直接使用 Bun，但我们可以尝试试用 Bun 并对 Bun 保持高度关注。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li>《The Third Age of JavaScript》<a href="https://www.swyx.io/js-third-age/" target="_blank" rel="noopener">https://www.swyx.io/js-third-age/</a></li><li>《Windows 下安装 Bun》<a href="https://juejin.cn/post/7119006461576871973" target="_blank" rel="noopener">https://juejin.cn/post/7119006461576871973</a></li><li>《Is Bun the Next Big Thing After Webpack?》<a href="https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9" target="_blank" rel="noopener">https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;越来越快的-jsRuntime——Bun&quot;&gt;&lt;a href=&quot;#越来越快的-jsRuntime——Bun&quot; class=&quot;headerlink&quot; title=&quot;越来越快的 jsRuntime——Bun&quot;&gt;&lt;/a&gt;越来越快的 jsRuntime——Bun&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Bun" scheme="http://blog.michealwayne.cn/tags/Bun/"/>
    
  </entry>
  
  <entry>
    <title>【整理】编码命名规范建议</title>
    <link href="http://blog.michealwayne.cn/2022/06/12/notes/%E3%80%90%E6%95%B4%E7%90%86%E3%80%91%E7%BC%96%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/"/>
    <id>http://blog.michealwayne.cn/2022/06/12/notes/【整理】编码命名规范建议/</id>
    <published>2022-06-12T12:41:10.000Z</published>
    <updated>2022-12-28T08:43:38.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码命名规范建议"><a href="#编码命名规范建议" class="headerlink" title="编码命名规范建议"></a>编码命名规范建议</h1><h2 id="编程中命名习惯的改进"><a href="#编程中命名习惯的改进" class="headerlink" title="编程中命名习惯的改进"></a>编程中命名习惯的改进</h2><blockquote><p>当我们看到一段代码时，最先注意到的，不是代码有几层循环，用了什么模式，而是变量与注释，因为它们是代码里最接近自然语言的东西。</p></blockquote><p>写代码前先决定名字。</p><h3 id="命名的指导方针"><a href="#命名的指导方针" class="headerlink" title="命名的指导方针"></a>命名的指导方针</h3><ul><li>名字中要尽量多包含信息。</li><li>名字不能有歧义。</li><li>名字说明的是效果和目的，而不是手段。</li><li>可以通过先写测试程序后写处理的方式检查一下自己取的名字是否合适。</li><li>名字要能念出来。</li><li>名字要能搜索出来。</li></ul><p>有一种叫做<strong>“名字可逆性”</strong>的命名思路，主张名字必须能还原其所指内容的说明文本。要想满足这一条件，就需要进行环回检测。先通过内容的说明文本来想名字，再通过名字倒推出说明文本。按照说明文本、名字、说明文本的顺序绕一圈回来后，如果说明文本一致，那这个名字就是好名字，如果不一致就需要我们注意了。</p><blockquote><p>*心理映射：读代码的人看到某元素名字后需要先在心里把它转换成自己知道的东西，这个过程就是心理映射，我们应该极力避免这种情况发生。</p></blockquote><h3 id="命名的基本原则"><a href="#命名的基本原则" class="headerlink" title="命名的基本原则"></a>命名的基本原则</h3><ul><li>全部采用易懂的英文来命名，可以辅以下划线和数字；</li><li>名称长度尽量不要超过<strong>16 个字符</strong>（有些常量名称可能长度会比较长）；</li><li>不要采用无意义的名字；</li><li>每个单词之间应该有合适的分割，可以采用大小写间隔，也可以采用下划线；</li><li>除了常量以外，都应该是大小写混合的形式，即使是 FTP，也要写成 Ftp；</li><li>遵循编程语言的标准，比如 Python 遵循 <a href="https://pep8.org/" target="_blank" rel="noopener">PEP8</a> 编码风格。</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><h5 id="1-snake-case"><a href="#1-snake-case" class="headerlink" title="1.snake-case"></a>1.snake-case</h5><p>蛇形命名法, 规定复合词或短语中的各个单词之间用<strong>下划线（<code>_</code>）分隔</strong>并且没有空格。复合词中的每一个单词的首字母通常都是小写的，并且复合词的第一个字母既可以是大写的又可以是小写的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: lisp_case、kebab_case、SCREAMING_SNAKE_CASE</span><br></pre></td></tr></table></figure><h5 id="2-camel-case"><a href="#2-camel-case" class="headerlink" title="2.camel-case"></a>2.camel-case</h5><p>驼峰命名法，其中又可分：</p><p><strong>lower-case</strong>：小驼峰命名法，第一个单词的首字母小写；第二个单词开始每个单词的的首字母大写。常用于方法名、参数名、成员变量、局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: firstName、lastName</span><br></pre></td></tr></table></figure><p><strong>upper-case / pascal-case</strong>：大驼峰命名法，每一个单词的首字母都大写。常用于接口或类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: FirstName、LastName、CamelCase</span><br></pre></td></tr></table></figure><h5 id="3-kebab-case"><a href="#3-kebab-case" class="headerlink" title="3.kebab-case"></a>3.kebab-case</h5><p>短横线命名法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: v-bind</span><br></pre></td></tr></table></figure><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><h4 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h4><ul><li><strong>尽量不要使用拼音，杜绝拼音和英文混用</strong>。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou 反例：validateCanShu</li><li>命名过程中<strong>尽量不要出现特殊的字符</strong>，常量除外；</li><li><strong>尽量不要和全局变量或者框架中已存在的类重名，也不能使用编程语言中的关键字命名</strong>；</li><li><strong>妙用介词</strong>，如 for(可以用同音的 4 代替), to(可用同音的 2 代替), from, with，of 等。如类名采用 User4RedisDO，方法名 getUserInfoFromRedis，convertJson2Map 等；</li><li><strong>避免误导</strong>。要注意使用小写字母 i 和大写字母 O 作为变量名，看起来像“壹”和“零”；</li><li><strong>使用可搜索的名称</strong>。单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来；</li><li><strong>言到意到，意到言到</strong>，别扮”可爱“，别用双关语。</li></ul><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。</p><p>为变量命名要结合代码情境和上下文，变量命名时，<strong>尽量简短且能清楚的表达变量的作用</strong>，命名体现具体的业务含义即可。</p><p>通用格式：</p><ul><li>变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法，lower-case），如 computedValues，index。</li><li>变量名<strong>不应以下划线或美元符号开头</strong>，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo（简单的 Java 对象，实际就是普通 JavaBeans）中的布尔变量，都不要加 is(数据库中的布尔字段全都要加 is_ 前缀)。</li><li>变量名描述性要强，但不宜过长，尽量<strong>不要超过 4 个</strong>单词。</li><li>在同一段代码内，不要出现多个相似的变量名。</li></ul><p>其他：</p><ul><li>变量越多，就越难全部跟踪它们的动向；</li><li>变量的作用域越大，就需要跟踪它的动向越久；</li><li>变量改变得越频繁，就越难以跟踪它的当前值。</li></ul><h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><p>通用格式：</p><ul><li>常量要采用全部大写的形式进行命名，如果有多个单词，用下划线进行分割；</li><li>常量的命名不要采用序号式命名；</li><li>常量应该通过其开头词进行分组。</li></ul><p>其他：</p><ul><li>常量一般都有自己的业务含义，<strong>不要害怕长度过长而进行省略或者缩写</strong>。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。</li><li>虽然很多常量名字本身已经很清楚感觉不需要注释，但是可以通过加注释得以改进，比如定义这个常量时的想法。</li></ul><h3 id="相似的命名"><a href="#相似的命名" class="headerlink" title="相似的命名"></a>相似的命名</h3><ul><li>*Form（获取页面输入）、持久化（想数据库存取数据）、View（想页面显示数据）的重复：难免会产生这三层需要采用同一个名称的情况，最佳方法就是将三者合一，通过 Annotation 来完成各自不同用途的格式定义，从而减少命名重复的困扰。</li><li>层 1、层 2……层 n 的无形层的重复：可以采用<code>～Form</code>、<code>～Wapper</code>、<code>～Layer</code>分别对不同的包装容器进行命名来规避这个问题。</li><li>类和内容的重复：一般来说，容器和内容之间都会有不同的名词，例如房子和家具、菜篮子和蔬菜、问卷和问题。</li><li>整体和部分：可以通过增加前缀来区分部分和整体，例如 matched、filtered、grouped、wrapper。</li><li>类型转换：可以通过连续调用来略过类型转换时的中间变量。</li></ul><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><h3 id="1-从阅读者角度，一些常见的编码问题"><a href="#1-从阅读者角度，一些常见的编码问题" class="headerlink" title="1.从阅读者角度，一些常见的编码问题"></a>1.从阅读者角度，一些常见的编码问题</h3><ul><li>一直滚动鼠标滚轮——方法过长；</li><li>总是全局搜索——方法过长；</li><li>反复地查看方法实现——命名无法反映其真实含义；</li><li>不停地查看调用方法实现——调用层数太多；</li><li>反复查看全局常量的值——常量定义方式无法反映其实质；</li><li>画流程图——嵌套太深。</li></ul><p>在阅读上的问题分为以下 5 类：</p><ul><li>命名类问题</li><li>注释类问题</li><li>结构类问题</li><li>架构类问题</li><li>风格类问题</li></ul><p>其中与命名相关的问题：</p><h4 id="命名类问题"><a href="#命名类问题" class="headerlink" title="命名类问题"></a>命名类问题</h4><p>代码能够用尽可能短的命名来表征尽可能多的含义。</p><ul><li>缺乏统一性：类/接口/方法/变量命名都应该遵守一定的规则；</li><li>没有考虑调用时的情形；</li><li>本地语言命名：除非专有名词，否则还是要用英语；</li><li>命名用词不当：所使用的英文有误、可能引起误解。如：<ul><li>research 不能表示重新检索，想要表示重新检索应该用 searchAgain；</li><li>limit 表示极限而不是限制，restriction 或者 constraint 才表示限制；</li><li>fasten 表示固定而不是加速，accelerate 才表示加速。</li></ul></li><li>超长的命名：超长的命名回花费较多时间阅读，也不容易记忆。例如 internationalization 这个词汇已经被缩略为 i18n，以方便书写和记忆。<ul><li>是否需要使用缩略词，取决于<strong>团队的新成员是否能理解这个名字的含义</strong>。</li></ul></li><li>命名含义模糊</li><li>命名和行为不一致：承诺多做得少；承诺少做得多；言行不一。</li><li>否定式命名：否定式命名往往会引起阅读成本。</li><li>无意义命名：temp、result、retVal 这些不表征具体的含义，包含的信息量少。</li><li>序号式命名：序号并不能表明其真实含义，例如 layer0、layer1.</li><li>工程名为类名前缀：把工程名作为类和接口的前缀是一种画蛇添足的行为，会降低阅读的速度。</li><li>超短命名：a、b、c 这种也无法获取有用信息，但注意循环体中约定俗成的 i、j、k 是无妨的。</li><li>匈牙利命名法：匈牙利命名法可以帮助读者了解数据的类型方面，但在例如面向对象的编程风格中代，编写的代码难以形成统一易懂的缩写。应当把类和函数做得足够小，消除对成员前缀的需要。</li></ul><h4 id="注释类问题"><a href="#注释类问题" class="headerlink" title="注释类问题"></a>注释类问题</h4><p>当代码通过其名称和符号无法很直观地表达其含义时，需要注释来帮助说明代码的作用。</p><ul><li>复制名称的注释：这种注释无法起到帮助作用。</li></ul><h4 id="风格类问题"><a href="#风格类问题" class="headerlink" title="风格类问题"></a>风格类问题</h4><ul><li>冗余的常量定义：<ul><li>有些可在原输入基础上补充而无需采用长常量列表的场景。不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。合适的做法比如缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</li><li>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。<br>2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</li></ul></li><li>变量意思不稳定：有歧义。</li><li>返回值意思不稳定</li><li>无用的方法或变量：特别是类中无用的 public 方法难以被发现。</li></ul><h3 id="问题产生的部分原因"><a href="#问题产生的部分原因" class="headerlink" title="问题产生的部分原因"></a>问题产生的部分原因</h3><h3 id="编程习惯不佳"><a href="#编程习惯不佳" class="headerlink" title="编程习惯不佳"></a>编程习惯不佳</h3><ul><li>命名习惯不好：<code>is</code> 等作用域开头等，变量名称和方法名称容易无法区分。</li><li>没有管理好代码的责任：UI 和数据和逻辑。</li><li>不考虑调用时的样子：调用时可能难以理解，要认真设计调用、比如接口。</li><li>不考虑命名的一致性：比如 <code>remove</code>/<code>delete</code>。</li><li>方法命名必须以动词开头：方法命名必须为动词，或者动词+名词的形式，因为方法必须是动作。但不绝对，比如 <code>List.size()</code>、<code>find.all()</code>，这样更易读。</li></ul><h3 id="英语能力不足"><a href="#英语能力不足" class="headerlink" title="英语能力不足"></a>英语能力不足</h3><ul><li><p>词性不对：对于集合性质的变量命名可以考虑采用其复数形式（有时也会降低阅读成本，这时可以换为在末尾加 <code>List</code>、<code>Map</code>），例如可以用 <code>books</code> 而不是 <code>bookList</code>。对于将动作变为变量的情况，应该将动作从动词改为动名词。例如可以用 <code>action</code> 而不是 <code>act</code>。对于只有开关两种状态的属性来说，可以采用形容词。而对于多种取值的属性来说，则应该采用对应的名词。</p></li><li><p>词汇不对：应该用更为准确的词汇，例如表示缩短，<code>makeShorter</code> 不如 <code>shorten</code> 更贴切；表示认证，<code>doLogin</code> 不如 <code>authenticate</code> 更准确。对于一些计算机专业术语也是有一定规定的，例如对于栈 <code>Stack</code>，它的行为应该是 <code>Push</code> 和 <code>Pop</code>，而不是 <code>Pull</code>。对于一些行业，也有其特定的术语，例如余额应该是 <code>Balance</code> 而不是 <code>LeftMoney</code>。如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称。</p><ul><li><p>比如有这么个函数为<code>getPage(url)</code>，我们虽然可以知道是获取一个页面，但是如果用<code>fetchPage</code>或者<code>downloadPage</code>进行更具体的动作区分命名会更好。</p></li><li><p>再比如有个函数为<code>getSize()</code>，更为形象化的话可以命名为<code>getHeight()</code>、<code>getNodeNum()</code>、<code>getArrLength()</code></p></li><li><p>再比如有个函数为<code>stopAnimation()</code>，我们不知道它将是终止动画还是中止动画，我们可以命名为<code>killAnimation()</code>、<code>pauseAnimation()</code>。</p></li><li><p>下面是一些例子，这些单词可以使命名更有表现力且适合语境</p></li></ul></li></ul><table><thead><tr><th>单词</th><th>更多选择</th></tr></thead><tbody><tr><td>send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td>find</td><td>search、extract、locate、recover</td></tr><tr><td>start</td><td>launch、create、begin、open</td></tr><tr><td>make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><ul><li><p>时态不对：采用动词原型命名的状态值往往会让读者猜测：到底是已经发生了这件事情，还是正在进行这件事情呢？例如 <code>register</code>、<code>attend</code>、<code>test</code>、<code>pass</code>、<code>failed</code>，而如果能够结合时态命名则状态的含义就更容易理解了，例如：<code>registered</code>、<code>atteneded</code>、<code>tested</code>、<code>evaluated</code>。</p></li><li><p>语法没有加善利用：由于受到一些限制和束缚，没有把介词和连词在方法的命名中，代码读起来就不够顺畅，如果把这些词汇放在代码中，代码就会变得更加易读了。例如判断 <code>cell</code> 是否在最后一排：<code>cell.isAtLastColumn()</code> / <code>gird.isAtLastColumn(cell)</code>。</p></li></ul><h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><h3 id="词性"><a href="#词性" class="headerlink" title="词性"></a>词性</h3><ul><li>名词：表示属性的常用词性。</li><li>动词：一般用来表示方法（处理），方法的名称中一般都应该包含一个动词，其构成形式上一个动词或者动词+名词形式的词组</li><li>动名词：动作可以作为属性出现，但是应该以动名词的形式表现。例如 <code>action</code>、<code>configuration</code>。动作行为也可以作为类或者接口出现，但是最好以动名词或者名词的形式出现，例如 <code>class Activity</code>，<code>class Service</code>。</li><li>形容词：形容词作为属性表示某种状态，例如 <code>visible</code>；用来表示某个状态的属性如果是形容词，一般是布尔型的，而其对应的判定方法则是 <code>is</code>，如 <code>isVisible</code>，其 <code>setter</code> 的形式是 <code>setVisible</code>。形容词也可以有多种取值范围，例如可见性除了显示、隐藏之外还增加了正在消失。对于这种情况，需要改用名词来使其多种取值范围得以体现，例如 <code>visibility</code>。</li><li>代词：代词可以用来指代其他事物，所以具有不必关心被指代事物的类型的特点。<code>this</code>（关键词，不能够使用）、<code>what</code>（当类中需要包含一个可能和自己重名的对象时）、<code>other</code>（当需要做对比时）、还有 <code>that</code>、<code>when</code>、<code>where</code>、<code>who</code>、<code>which</code>、<code>me</code>、<code>you</code>、<code>him</code>、<code>self</code>。</li><li>介词、连词等：介词、连词等让代码读起来更顺畅。<code>by</code>（表示根据后面的条件执行前面的动作，如 <code>getLicenseById</code>）、<code>for</code>（表示执行前面的动作是为了后面的目的，如 <code>waitForIdle</code>）、<code>at</code>（表示根据后面的条件执行前面的动作，如 <code>removeAt</code>）、<code>and</code>（表示两个条件都需要成立才能够执行前面的动作，如 <code>saveAndExit</code>）、<code>or</code>（表示两个条件只需要其中一个条件成立即可执行前面的动作，如 <code>isNullOrEmpty</code>）、另外还有 <code>with</code>、<code>after</code>、<code>before</code>、<code>through</code>、<code>as</code> 也都可以使用。另外介词、连词也可以作为方法的开头。</li></ul><h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><p>动词的时态有很多种，但编程中只要使用其中 3 种即可：</p><ul><li>一般现在时：表示状态类动作；</li><li>完成时：表示动作已经完成；</li><li>进行时：表示动作正在进行。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>宾语从句，如 <code>assertThat(num).isEqualTo(6)</code>，读起来更像一句话而不需要更多思考；</li><li>过去时：如 <code>viewDidLoad</code> 表示视图加载完成；</li><li>一般将来时：如 <code>sendDelayed(3)</code> -&gt; <code>updateUiAfter(3)</code></li></ul><h3 id="否定词"><a href="#否定词" class="headerlink" title="否定词"></a>否定词</h3><ul><li>Exception 与 Error 等的命名：异常或者错误本身就表示系统发生错误了，所以异常和错误都可以采用否定式命名以明确表示它原来的意思。如：<ul><li>InconvertibleException 表示不能转换；</li><li>FileNotExistException 表示文件不存在。</li></ul></li><li>错误常量：当处理发生错误时，有时需要使用错误值进行处理。错误号需要定义为常量，常量的命名可以采用否定式命名，如 <code>INVAILD_CODE</code></li><li>特殊类：如输入键盘。</li></ul><h3 id="成对词"><a href="#成对词" class="headerlink" title="成对词"></a>成对词</h3><p>固定方式出现的成对词能直接想到另一个方法的名称。常用成对词：</p><ul><li><code>get</code> 获取/<code>set</code> 设置</li><li><code>max</code> 最大/<code>min</code> 最小</li><li><code>start</code> 启动/<code>stop</code> 停止</li><li><code>begin</code> 开始/<code>end</code> 结束</li><li><code>backup</code> 备份/<code>restore</code> 恢复</li><li><code>bind</code> 绑定/ <code>separate</code> 分离</li><li><code>copy</code> 复制/ <code>paste</code> 粘贴</li><li><code>clean</code> 清理/ <code>clear</code> 清除</li><li><code>source</code> 来源/<code>destination</code> 目的地</li><li><code>from</code> 来/<code>to</code> 去</li><li><code>previous</code> 上一个/<code>current</code> 当前/<code>next</code> 下一个</li><li><code>create</code> 创建/<code>destroy</code> 移除</li><li><code>plus</code> 加/<code>minus</code> 减</li><li><code>positive</code> 积极的/<code>negative</code> 消极的</li><li><code>connect</code> 连接/ <code>disconnect</code> 断开（或 <code>close</code>）</li><li><code>download</code> 下载/ <code>upload</code> 上传</li><li><code>add</code> 增加/<code>remove</code> 删除</li><li><code>add</code> 数字加/<code>sub</code> 数字减</li><li><code>add</code> 加入/ <code>append</code> 添加</li><li><code>increase</code> 增加/ <code>decrease</code> 减少</li><li><code>enable</code> 启动/<code>disable</code> 废弃</li><li><code>encode</code> 编码/ <code>decode</code> 解码</li><li><code>encrypt</code> 加密/ <code>decrypt</code> 解密</li><li><code>compress</code> 压缩/ <code>decompress</code> 解压缩</li><li><code>parse</code> 解析/ <code>emit</code> 生成</li><li><code>pause</code> 暂停/<code>resume</code> 恢复</li><li><code>open</code> 打开/<code>close</code> 关闭</li><li><code>initialize</code> 初始/<code>finalize</code> 最后</li><li><code>request</code> 请求/<code>respond</code> 响应</li><li><code>success</code> 成功/<code>failed</code> 失败</li><li><code>top</code> 顶部/<code>bottom</code> 底部</li><li><code>include</code> 包含/<code>exclude</code> 排除</li><li><code>input</code> 输入/ <code>output</code> 输出</li><li><code>import</code> 导入/<code>export</code> 导出</li><li><code>width</code> 宽度/<code>height</code> 高度</li><li><code>read</code> 读取/<code>write</code> 写入</li><li><code>load</code> 载入/<code>save</code> 保存</li><li><code>split</code> 分割 /<code>merge</code> 合并</li><li><code>inject</code> 注入 /<code>extract</code> 提取</li><li><code>attach</code> 附着/ <code>detach</code> 脱离</li><li><code>view</code> 查看/ <code>browse</code> 浏览</li><li><code>edit</code> 编辑/ <code>modify</code> 修改</li><li><code>select</code> 选取/ <code>mark</code> 标记</li><li><code>undo</code> 撤销/ <code>redo</code> 重做</li><li><code>insert</code> 插入/ <code>delete</code> 移除</li><li><code>index</code> 索引/ <code>sort</code> 排序</li><li><code>play</code> 播放/ <code>pause</code> 暂停</li><li><code>launch</code> 启动/ <code>run</code> 运行</li><li><code>compile</code> 编译/ <code>execute</code> 执行</li><li><code>build</code> 构建/ <code>publish</code> 发布</li><li><code>pack</code> 打包/ <code>unpack</code> 解包</li><li><code>send</code> 发送/ <code>receive</code> 接收</li><li><code>refresh</code> 刷新/ <code>synchronize</code> 同步</li><li><code>update</code> 更新/ <code>revert</code> 复原</li><li><code>lock</code> 锁定/ <code>unlock</code> 解锁</li><li><code>check out</code> 签出/ <code>check in</code> 签入</li><li><code>push</code> 推/ <code>pull</code> 拉</li><li><code>expand</code> 展开/ <code>collapse</code> 折叠</li><li><code>begin</code> 起始/ <code>end</code> 结束</li><li><code>start</code> 开始/ <code>finish</code> 完成</li><li><code>enter</code> 进入/ <code>exit</code> 退出</li></ul><h3 id="近义词"><a href="#近义词" class="headerlink" title="近义词"></a>近义词</h3><p>近义词如果使用不对，会造成理解上的偏差，如：</p><ul><li><code>invalidate</code> 使无效 / <code>refresh</code> 刷新 / <code>update</code> 更新</li><li><code>draw</code> 绘制 / <code>render</code> 渲染 / <code>display</code> 展示/<code>show</code> 显示</li><li><code>perform</code> 执行 / <code>process</code> 处理 / <code>do</code> 做 / <code>run</code> 运行 / <code>execute</code> 实施 / <code>invoke</code> 调用</li><li><code>picture</code> 图片 / <code>image</code> 图像 / <code>bitmap</code> 位图 / <code>icon</code> 图标 / <code>thumbnail</code> 缩略图</li><li><code>size</code> 尺寸 / <code>length</code> 长度</li><li><code>refuse</code> 拒绝 / <code>decline</code> 拒绝、下降 / <code>reject</code> 拒绝、否决</li><li><code>revoke</code> 撤销 / <code>cancel</code> 取消</li><li><code>obsolete</code> 废弃 / <code>depreciate</code> 废旧</li><li><code>collect</code> 收集 / <code>aggregate</code> 聚集</li><li><code>abort</code> 放弃 / <code>quit</code> 离开</li><li><code>submit</code> 提交 / <code>commit</code> 交付</li><li><code>find</code> 查找 / <code>search</code> 搜索</li><li><code>observe</code> 观察 / <code>listen</code> 监听</li><li><code>debug</code> 调试 / <code>trace</code> 跟踪</li></ul><p>一个系统中最好不要出现各种同义词。</p><h3 id="前缀、扩展名"><a href="#前缀、扩展名" class="headerlink" title="前缀、扩展名"></a>前缀、扩展名</h3><ul><li><code>prev/curr/next</code> 表示顺序</li><li><code>on~</code>表示响应某个行为</li><li><code>is~</code>（表示“是”）/ <code>has~</code>（表示“有”）/<code>need~</code>（表示“需要”）/<code>can~</code>（表示“可以”）/<code>allow~</code>（表示“允许”）表示判定：注意这些词不应该用在域变量上，只能用在方法上。</li><li><code>do~</code>（表示执行某个操作）/<code>process~</code>/<code>run~</code>/<code>execute~</code>/<code>invoke~</code>/<code>perform~</code>都表示执行</li><li><code>~Wrapper</code>表示包装器：往往被包装的对象是成组的</li><li>设计模式名字作为结尾：<code>~State</code>表示状态模式、<code>~Proxy</code>表示代理模式</li><li><code>~Listener</code>表示事件接收器</li><li><code>get~</code>、<code>set~</code>表示获取和设置值：注意 boolean 类型的 getter 是用 <code>is~</code> 开头的</li><li><code>to~</code> 表示转换</li></ul><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>可以帮助缩短命名长度、但是滥用缩写会导致意思不明确。</p><ul><li><code>average</code> -&gt; <code>avg</code></li><li><code>administrator</code> -&gt; <code>admin</code></li><li><code>argument</code> -&gt; <code>arg</code></li><li><code>application</code> -&gt; <code>app</code></li><li><code>asynchronous</code> -&gt; <code>async</code>(注意关键字)</li><li><code>address</code> -&gt; <code>add</code></li><li><code>bitmap</code> -&gt; <code>bmp</code></li><li><code>button</code> -&gt; <code>btn</code></li><li><code>calculate</code> -&gt; <code>calc</code></li><li><code>column</code> -&gt; <code>col</code></li><li><code>connection</code> -&gt; <code>conn</code></li><li><code>configuration</code> -&gt; <code>conf</code></li><li><code>command</code> -&gt; <code>cmd</code></li><li><code>control</code> -&gt; <code>ctl</code></li><li><code>copy</code> -&gt; <code>cpy</code></li><li><code>decrease</code> -&gt; <code>dec</code></li><li><code>delete</code> -&gt; <code>del</code></li><li><code>default</code> -&gt; <code>def</code></li><li><code>dictionary</code> -&gt; <code>dict</code></li><li><code>document</code> -&gt; <code>doc</code></li><li><code>environment</code> -&gt; <code>env</code></li><li><code>event</code> -&gt; <code>evt</code></li><li><code>error</code> -&gt; <code>err</code></li><li><code>execute</code> -&gt; <code>exec</code></li><li><code>horizontal</code> -&gt; <code>horz</code></li><li><code>information</code> -&gt; <code>info</code></li><li><code>message</code> -&gt; <code>msg</code></li><li><code>memory</code> -&gt; <code>mem</code></li><li><code>manager</code> -&gt; <code>mgr</code></li><li><code>maximum</code> -&gt; <code>max</code></li><li><code>minimum</code> -&gt; <code>min</code></li><li><code>table</code> -&gt; <code>tbl</code></li><li><code>version</code> -&gt; <code>ver</code></li><li><code>object</code> -&gt; <code>obj</code></li><li><code>picture</code> -&gt; <code>pic</code></li><li><code>position</code> -&gt; <code>pos</code></li><li><code>reference</code> -&gt; <code>ref</code></li><li><code>subtract</code> -&gt; <code>sub</code></li><li><code>synchronization</code> -&gt; <code>sync</code></li><li><code>temporary</code> -&gt; <code>temp</code></li><li><code>variable</code> -&gt; <code>var</code>(注意关键字)</li><li><code>vertical</code> -&gt; <code>vert</code></li><li><code>initialize</code> -&gt; <code>init</code></li><li><code>temporary</code> -&gt; <code>temp</code>/<code>tmp</code></li><li><code>length</code> -&gt; <code>len</code></li><li><code>panel</code> -&gt; <code>pnl</code></li><li><code>frame</code> -&gt; <code>frm</code></li></ul><p>缩写如果全部都是大写字母，那么作为变量时也应该写为大小写混合。除了 <code>DO</code> / <code>BO</code> / <code>DTO</code> / <code>VO</code> / <code>AO</code> / <code>PO</code>，如 <code>UserDO</code>。</p><h3 id="正确用词"><a href="#正确用词" class="headerlink" title="正确用词"></a>正确用词</h3><ul><li>拼写正确</li><li>正确用词：如 <code>hasPermission</code> 比 <code>isAllowed</code> 更易读，如<ul><li>花费的时间不是 <code>usedTime</code>，而是 <code>elapsedTime</code></li><li>缩短不是 <code>makeShorter</code>，而是 <code>shorten</code></li><li>加快不是 <code>fasten</code>，而是 <code>accelerate</code></li><li>限制不是 <code>limit</code>，而是 <code>constraint</code> 或 <code>restriction</code></li><li>成熟不是 <code>aged</code> 而是 <code>sophisticated</code></li><li>上下不是 <code>upDown</code> 而是 <code>vertical</code></li><li>错误级别不是 <code>faultLevel</code> 而是 <code>severity</code></li></ul></li><li>准确的用词：<code>yyyyMMddhhmmss</code> -&gt; <code>timestamp</code></li><li>明确的用词：如 <code>fire</code> 可以表示点燃也可以表示开除</li><li>精确的用词：子啊列表当中会涉及各种顶点、节点、缝隙、元素之间的关系，需要有一套整体的命名规则，来为各个元素定义清楚其用词。</li></ul><h2 id="注释方面的改进"><a href="#注释方面的改进" class="headerlink" title="*注释方面的改进"></a>*注释方面的改进</h2><p>注释作为代码之外的说明性文字，应该<strong>尽量提供那些读者无法从代码里读出来的信息</strong>，描述代码为什么要这么做，而不是简单复述代码本身。若编程语言足够有表达力，就不需要注释。注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。</p><blockquote><p>注释总是一种失败，不准确的注释要比没注释坏得多。</p></blockquote><p>除了描述“为什么”的解释性注释外，还有一种注释：指引性注释，这种注释不直接复述代码，而是简明扼要地概括代码功能，起到“代码导读”的作用。</p><p>注释 jsdoc/javadoc 标签：</p><ul><li><code>@see</code>：表示参照代码，子类或实现类通过次连到声明类</li><li><code>@link</code>：表示连接，通过这个连接可以连到另外一个类的说明中去</li><li><code>@code</code>：表示应用一个值</li><li><code>@param</code>：表示参数</li><li><code>@return</code>：表示返回值</li><li><code>@throw</code>：表示方法抛出的异常</li><li><code>@author</code>：表示作者</li><li><code>@version</code>：表示版本</li><li><code>@since</code>：表示自哪个版本开始使用该方法</li><li><code>@example</code>：表示演示使用方式</li></ul><h3 id="TODO、FIXME-和-XXX"><a href="#TODO、FIXME-和-XXX" class="headerlink" title="TODO、FIXME 和 XXX"></a>TODO、FIXME 和 XXX</h3><ul><li><code>FIXME</code>：表示这段代码没有正确处理，需要修改</li><li><code>TODO</code>：表示这段代码尚未完成，需要实现</li><li><code>XXX</code>：表示这段代码目前可以完成工作，但是还需要改进。</li><li><code>HACK</code>：表示对一个问题不得不采用的比较粗糙的解决方案</li></ul><h3 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h3><ul><li>类的功能说明</li><li>类的主要方法介绍</li><li>类的方法常用调用方式</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>建议行尾不要加入注释，因为不利于行长的控制。</p><p>版权说明</p><ul><li>开放源代码：<a href="https://choosealicense.com/" target="_blank" rel="noopener">开源协议</a>通常有 MIT、BSD、Apache2.0、GPL3.0、LGPL</li><li>封闭源代码：<a href="https://www.copyright.gov/what-is-copyright/" target="_blank" rel="noopener">Copyright</a>（C）</li></ul><p>换行</p><ul><li>Annotation 之后要换行；</li><li>每行处理（分号）之后要换行；</li><li>每个花括号开头后面要换行；</li><li>每个花括号结尾后面要换行；</li><li>每行处理之后要换行；</li><li>不在同一行上声明超过两个变量；</li><li>每个变量、常量定义要换行。</li></ul><p>无效代码</p><ul><li>对于不再需要的代码，我们应该直接把它们删掉，而不是注释。</li></ul><p>空行</p><ul><li>适当地在代码中插入空行，把代码按不同的逻辑块分隔开，这样能有效提升代码的可读性。</li></ul><h2 id="测试代码的自表达改进"><a href="#测试代码的自表达改进" class="headerlink" title="测试代码的自表达改进"></a>测试代码的自表达改进</h2><p>自动测试的结构采用的都是三步结构：</p><ul><li><code>given</code>: 前提的数据</li><li><code>when</code>: 进行的操作</li><li><code>then</code>: 期望的结果</li><li><code>fixture</code>: 测试夹具前提的数据</li><li><code>behavior</code>: 行为进行的操作</li><li><code>expectation</code>: 期望值期望的结果</li></ul><h2 id="前端命名"><a href="#前端命名" class="headerlink" title="前端命名"></a>前端命名</h2><h3 id="html-文件的命名"><a href="#html-文件的命名" class="headerlink" title="html 文件的命名"></a>html 文件的命名</h3><p>格式：<strong>统一用小写的英文字母，</strong>单词间用连字符 “<code>-</code>” 连接，kebab-case (短横线分隔命名)</p><p>原则：</p><ul><li>可移植性。Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。</li><li>易读性。小写文件名通常比大写文件名更易读。</li><li>易用性：某些系统会生成一些预置的用户目录，采用首字母大写的目录名，用户的文件都采用小写文件名，就很方便与上面这些目录或文件相区分。</li><li>便捷性：文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用<code>-i</code> 参数了。</li></ul><p>常用命名：</p><ul><li>首页/主页面：<code>index.html</code></li><li>子页面：<ul><li>首页：<code>home.html</code></li><li>我的：<code>mine.html</code></li><li>关于我们：<code>about.html</code></li><li>信息反馈：<code>feedback.html</code></li><li>产品：<code>produot.html</code></li><li>购物：<code>shop.html</code></li><li>计数器: <code>count.html</code></li><li>购买：<code>buy.html</code></li></ul></li><li>一级页面：<ul><li>登录：<code>login.html</code></li><li>注册：<code>resign.html</code></li></ul></li></ul><h3 id="Image-图片的命名规则"><a href="#Image-图片的命名规则" class="headerlink" title="Image 图片的命名规则"></a>Image 图片的命名规则</h3><ul><li>*可以考虑带上前缀：<code>i-</code>表示 logo 类图标、<code>p-</code>表示普通图片</li><li><p>图片的后缀：<code>xxx.png</code>、<code>xxx.jpg</code>、<code>xxx.gif</code>、<code>xxx.bmp</code>、<code>xxx.webp</code></p></li><li><p>图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质。例如：产品 <code>product</code> 产品下的 -&gt; 电视 / 手机： <code>product_tv product_phone</code></p></li></ul><p>例如：广告、标志、菜单、按钮等等。</p><ul><li>放置在页面顶部的<strong>广告</strong>：<code>banner</code></li><li>企业商标/标志性的图：<code>logo</code></li><li>在页面上某个文字连续出现，性质相同的链接栏目图片： <code>menu</code></li><li>装饰用的照片： <code>pic</code></li><li>标题的图片：<code>title</code></li></ul><h3 id="文件夹命名-存放规则"><a href="#文件夹命名-存放规则" class="headerlink" title="文件夹命名/存放规则"></a>文件夹命名/存放规则</h3><ul><li><code>frontend</code>、<code>www</code> 或者 <code>web</code> 存放前端代码文件</li><li><code>bulid</code> 存放构建等脚本文件</li><li><code>css</code> 存放 xxx.css 文件</li><li><code>src</code> 存放源码文件</li><li><code>views</code> 或者 <code>pages</code> 存放 xxx.html 或者 xxx.vue</li><li><code>components</code> 存放组件文件</li><li><code>assets</code> 存放所有资源文件</li><li><code>images</code>/<code>imgs</code> 存放图片文件</li><li><code>library</code>/<code>lib</code> 存放第三方库文件</li><li><code>media</code> 存放媒体文件</li><li><code>backend</code>、<code>serve</code> 存放服务端代码文件</li><li><code>api</code> 存放[接口文件]</li><li><code>modules</code> 存放[数据库操作]文件</li></ul><h3 id="css-书写规范"><a href="#css-书写规范" class="headerlink" title="css 书写规范"></a>css 书写规范</h3><blockquote><p>可见 MooCSS 命名规则：<a href="http://blog.michealwayne.cn/Moo-CSS/docs/nameRule/">http://blog.michealwayne.cn/Moo-CSS/docs/nameRule/</a></p></blockquote><ul><li>禁止 class 和 id 重名;</li><li>书写顺序, 建议遵循 <code>布局定位属性--&gt;自身属性--&gt;文本属性--&gt;其他属性</code></li><li>布局定位属性 ：Margin\padding\float\clear\position （ 相 应 的 top,right,bottom,left）\display\visibility\overflow 等<ul><li>自身属性 ：Width\height\background\ border</li><li>文本属性 ：font\color\text-align\text-decoration\text-indent\ white-space\othertext\content 等</li><li>其他属性 ：list-style(列表样式)\vertical-align\cursor\z-index(层叠顺序)\zoom 等</li></ul></li></ul><h4 id="css-命名基本单词规范"><a href="#css-命名基本单词规范" class="headerlink" title="css 命名基本单词规范"></a>css 命名基本单词规范</h4><p>1.页面结构</p><ul><li>容器：<code>container</code>/<code>wrap</code></li><li>整体宽度：<code>wrapper</code></li><li>页头：<code>header</code></li><li>内容：<code>content</code></li><li>侧栏：<code>sidebar</code></li><li>栏目：<code>column</code></li><li>中间内容：<code>center</code></li></ul><p>2.导航</p><ul><li>导航：<code>nav</code></li><li>主导航：<code>mainNav</code>/ <code>main_nav</code></li><li>子导航：<code>subNav</code>/ <code>sub_nav</code></li><li>顶导航：<code>topNav</code>/ <code>top_nav</code></li><li>边导航：<code>sideBar</code>/ <code>side_bar</code></li><li>左导航：<code>leftSideBar</code>/ <code>left_side_bar</code></li><li>右导航：<code>righSideBar</code>/ <code>righ_side_bar</code></li><li>边导航图标：<code>sidebarIcon</code> <code>side_bar_icon</code></li><li>菜单：<code>menu</code></li><li>子菜单：<code>subMenu</code> <code>sub_menu</code></li><li>标题：<code>title</code></li></ul><p>3.功能</p><ul><li>标志：<code>logo</code></li><li>登陆：<code>login</code></li><li>登录条：<code>loginbar</code></li><li>注册：<code>regsiter</code></li><li>产品：<code>products</code></li><li>产品价格：<code>products_prices</code></li><li>产品评论：<code>products_review</code></li><li>编辑评论：<code>editor_review</code></li><li>最新评论：<code>news_release</code></li><li>广告/标语：<code>banner</code></li><li>摘要： <code>summary</code></li><li>生产商：<code>publisher</code></li><li>缩略图：<code>screenshot</code></li><li>常见问题：<code>faqs</code></li><li>关键词：<code>keyword</code></li><li>博客：<code>blog</code></li><li>论坛：<code>forum</code></li><li>搜索：<code>search</code></li><li>搜索输入框：<code>search_input</code></li><li>搜索输出：<code>search_output</code></li><li>搜索结果：<code>search_results</code></li><li>加入我们：<code>joinus</code></li><li>状态：<code>status</code></li><li>按钮：<code>btn</code></li><li>滚动：<code>scroll</code></li></ul><p>4.视图： <code>view</code></p><p>5.滚动</p><ul><li>视图：<code>scroll-view</code></li><li>标签页：<code>tab</code></li><li>文章列表：<code>list</code></li><li>提示信息：<code>msg</code> / <code>message</code></li><li>当前的: <code>current</code></li><li>小技巧：<code>tips</code></li><li>皮肤：<code>skin</code></li><li>充值：<code>pay</code></li><li>活动：<code>activities</code></li><li>推广：<code>promotion</code></li><li>公告：<code>announcement</code></li><li>排行：<code>ranking</code></li><li>公司简介：<code>company_profile</code></li><li>公司设备：<code>equipment</code></li><li>公司荣誉：<code>glories</code></li><li>企业文化：<code>culture</code></li><li>企业规模：<code>scale</code></li><li>营销网络：<code>sales_network</code></li><li>组织机构：<code>organization</code></li><li>技术力量：<code>technology</code></li><li>分支机构：<code>branches</code></li><li>经营理念：<code>operation_principle</code></li><li>经理致辞：<code>manager_oration</code></li><li>发展历程：<code>development_history</code></li><li>工程案例：<code>engineering_projects</code></li><li>分类浏览：<code>browse_by_category</code></li><li>应用领域：<code>application_fields</code></li><li>人力资源：<code>human_resource_hr</code></li><li>领导致辞： <code>leader_oration</code></li><li>客户留言：<code>customer_message</code></li><li>客户服务：<code>customer_service</code></li><li>您的要求：<code>your_requirements</code></li><li>销售信息：<code>sales_information</code></li><li>招商：<code>enterprise_establishing</code></li><li>教育培训：<code>education_training</code></li><li>合作加盟：<code>joinIn_cooperation</code></li><li>产品描述：<code>products_description</code></li><li>业务范围：<code>business_scope</code></li><li>产品销售：<code>sales_sales</code></li><li>联系我们：<code>contact_us</code></li><li>信息发布：<code>information</code></li><li>返回首页：<code>homepage</code></li><li>产品定购：<code>order</code></li><li>电子商务：<code>e_business</code></li><li>版权所有：<code>copy_right</code></li><li>友情连结：<code>hot_link</code></li><li>行业新闻：<code>trade_news</code></li><li>行业动态：<code>trends</code></li><li>邮编：<code>postal_code_zipcode</code></li><li>新闻动态：<code>news_trends</code></li><li>公司名称：<code>company_name</code></li><li>销售热线：<code>sales_hotline</code></li><li>联系人：<code>contact_person</code></li><li>建设中：<code>in_construction</code></li><li>证书：<code>certificate</code></li><li>地址：<code>address</code></li><li>电话：<code>tel</code></li><li>传真：<code>fax</code></li><li>产品名称：<code>product_name</code></li><li>产品说明：<code>description</code></li><li>价格：<code>price</code></li><li>品牌：<code>brand</code></li><li>规格：<code>specification</code></li><li>尺寸：<code>size</code></li><li>生产厂家：<code>manufacuturer</code></li><li>型号：<code>model</code></li><li>产品标号：<code>item_no</code></li><li>技术指标：<code>technique_data</code></li><li>产品描述：<code>description</code></li><li>产地：<code>production_place</code></li><li>用途：<code>application</code></li><li>论坛：<code>forum</code></li><li>在线订购：<code>on_line_order</code></li><li>招标：<code>bidInviting</code></li><li>综述：<code>general</code></li><li>业绩：<code>achievements</code></li><li>大事：<code>great_event</code></li><li>动态：<code>trends</code></li><li>服务：<code>service</code></li><li>投资：<code>investment</code></li><li>行业：<code>industry</code></li><li>规划：<code>programming</code></li><li>环境：<code>environment</code></li><li>发送：<code>delivery</code></li><li>提交：<code>submit</code></li><li>重写：<code>reset</code></li><li>社区：<code>community</code></li><li>业务：<code>business</code></li><li>在线调查：<code>online_inquiry</code></li><li>下载中心：<code>download</code></li><li>意见反馈：<code>feedback</code></li><li>常见问题：<code>faq</code></li><li>中心概况：<code>general_profile</code></li><li>游乐园：<code>amusement_park</code></li><li>专题报道：<code>special_report</code></li><li>图标: <code>icon</code></li><li>注释：<code>note</code></li><li>指南：<code>guild</code></li><li>服务：<code>service</code></li><li>热点：<code>hot</code></li><li>新闻：<code>news</code></li><li>下载：<code>download</code></li><li>投票：<code>vote</code></li><li>商标：<code>label</code>/<code>branding</code></li><li>当前位置：<code>breadcrumb</code>/<code>loc</code></li><li>购物车：<code>shop</code></li><li>标签：<code>tag</code></li><li>信誉：<code>siteinfo_credits</code></li><li>网站信息：<code>siteinfo</code></li><li>法律声明：<code>siteinfo_legal</code></li><li>合作伙伴：<code>partner</code></li><li>友情链接：<code>friendlink</code></li><li>版权：<code>copyright</code></li></ul><h2 id="class-命名规范"><a href="#class-命名规范" class="headerlink" title="class 命名规范"></a>class 命名规范</h2><p>分类式命名法（在前端组件优化下尤为重要）</p><ul><li>布局（grid）（<code>.g-</code>）:将页面分割为几大块，通常有头部，主体，主栏，侧栏，尾部等。</li><li>模块（module）（<code>.m-</code>）:通常是一个语义化可以重复使用的较大整体，比如导航，登录，注册等。</li><li>元件（unit）（<code>.u-</code>）:通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中，例如按钮，输入框。</li><li>功能（function）（<code>.f-</code>）:为了方便一些重用样式的使用，我们将这些使用频繁的样式剥离出来，按照需求使用，通常这些选择器具有固定样式表现，比如清除浮动等（不可滥用）。</li><li>状态（<code>.z-</code>）:为状态样式加入前缀，统一标识，方便识别，它只能组合使用或作为后代出现。</li><li>javascript（<code>.j-</code>）:j-被专用与 JS 获取节点，请勿使用 j-定义样式。</li><li>class 名称中只能出现小写字母和破折号”-“。破折号应当用于相关 class 的命名（类似于空间命名）例如: .btn 和.btn-xxx。</li><li>避免过度任意的简写。例如: <code>.btn</code>代表 button，但是<code>.s</code>不能代表任何意思。</li><li>class 名称应当尽可能短，并且意义明确。</li><li>使用有意义的名称，使用有组织或目的地明确的名称，不要使用表现形式的名称。</li><li>基于最近的父 class 或基本（base）class 作为新 class 的前缀。例如：父 class 为.btn 则子 class 为.btn-xxx。</li><li>使用 j-*class 来标识行为（与样式相对），并且不要将这些 class 包含到 css 文件中。</li></ul><h2 id="服务端-nodejs-java-命名规则"><a href="#服务端-nodejs-java-命名规则" class="headerlink" title="服务端 nodejs/java 命名规则"></a>服务端 nodejs/java 命名规则</h2><table><thead><tr><th>类型(名)</th><th>约束</th><th>例</th></tr></thead><tbody><tr><td>项目</td><td>全部小写 多个单词用中划线分隔‘-’</td><td><code>spring-cloud</code></td></tr><tr><td>包</td><td>全部小写</td><td><code>com.alibaba.fastjson</code></td></tr><tr><td>类</td><td>单词首字母大写</td><td><code>Feature</code>, <code>FieldDeserializer</code></td></tr><tr><td>变量</td><td>首字母小写 多个单词组成时， 除首个单词 其他单词首字母都要大写</td><td><code>password</code>, <code>userName</code></td></tr><tr><td>常量</td><td>全部大写，多个单词，用’_‘分隔</td><td><code>CACHEEXPIREDTIME</code></td></tr><tr><td>方法</td><td>同变量</td><td><code>read()</code>, <code>getById(Long id)</code></td></tr></tbody></table><h3 id="包的命名"><a href="#包的命名" class="headerlink" title="*包的命名"></a>*包的命名</h3><p>格式：<code>组织类型+组织名称+项目名称+功能名称</code> / <code>【前缀】 【发起者名】【项目名】【模块名】</code>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块，包名中不要有大写字母和下划线，最好也不要有数字。</p><p>包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p><table><thead><tr><th>前缀</th><th>例</th><th>含义</th></tr></thead><tbody><tr><td><code>indi</code> 或 <code>onem</code></td><td><code>indi.发起者名.项目名.模块名.……</code></td><td>个体项目 个人发起，但非自己独自完成 可公开或私有项目， copyright 主要属于发起者。</td></tr><tr><td><code>pers</code></td><td><code>pers.个人名.项目名.模块名.……</code></td><td>个人项目 指个人发起，独自完成， 可分享的项目 copyright 主要属于个人</td></tr><tr><td><code>priv</code></td><td><code>priv.个人名.项目名.模块名.……</code></td><td>私有项目，指个人发起，独自完成 非公开的私人使用的项目， copyright 属于个人。</td></tr><tr><td><code>team</code></td><td><code>team.团队名.项目名.模块名.……</code></td><td>团队项目，指由团队发起 并由该团队开发的项目 copyright 属于该团队所有</td></tr><tr><td>顶级域名</td><td><code>com.公司名.项目名.模块名.……</code></td><td>公司项目 copyright 由项目发起的公司所有</td></tr></tbody></table><h3 id="接口的名称"><a href="#接口的名称" class="headerlink" title="接口的名称"></a>接口的名称</h3><p>不要以<code>I</code>为开头。</p><p>如果以<code>~able</code>结尾表示具备某种能力，例如 <code>Cloneable</code> 和 <code>Runnable</code>。</p><h3 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h3><ul><li><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 <code>Cloneable</code>，<code>Callable</code> 等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以 <code>Test</code> 结尾，如 <code>HashMapTest</code>。</li><li>对于一些特殊特有名词缩写也可以使用全大写命名，比如 XMLHttpRequest，不过通常认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准，如阿里巴巴中<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>用 JSONObject 作为类命，而 google 则使用 JsonObjectRequest 命名，对于这种特殊的缩写，原则是组织统一就好。</li><li>不要以 <code>Base</code> 作为开头或者结尾，基类选用的词汇应该是具有通用意义的名称，例如 <code>Model</code>、<code>View</code>、<code>Control</code> 等。</li><li>子类的命名如果继承父类的名称则会好懂，例如 <code>SoftKeyboard extends AbstractKeyboard</code>。</li><li>抽象类前面可以增加 <code>Abstract</code> 开头，这是当有一个 Concrete 类存在，而无法直接使用名称为抽象类命名时使用的。例如 <code>AbstractInputMethodService</code>。</li><li>兄弟类之间要有明显的区别式赐予，如 <code>SoftKeyboard</code>、<code>HardKeyboard</code>。</li></ul><table><thead><tr><th>属性(类)</th><th>约束</th><th>例</th></tr></thead><tbody><tr><td>抽象</td><td><code>Abstract</code> 或 <code>Base</code> 开头</td><td><code>BaseUserService</code></td></tr><tr><td>枚举</td><td><code>Enum</code> 作为后缀</td><td><code>OSTypeEnum</code></td></tr><tr><td>工具</td><td><code>Utils</code> 作为后缀</td><td><code>StringUtils</code></td></tr><tr><td>异常</td><td><code>Exception</code> 结尾</td><td><code>RuntimeException</code></td></tr><tr><td>接口实现</td><td>接口名+ <code>Impl</code></td><td><code>UserServiceImpl</code></td></tr><tr><td>领域模型相</td><td><code>DO</code>/<code>DTO</code>/<code>VO</code>/<code>DAO</code></td><td>正例：<code>UserDAO</code> 反例：<code>UserDao</code></td></tr><tr><td>设计模式相关</td><td><code>Builder</code>，<code>Factory</code>等</td><td>当使用到设计模式时 要使用对应的设计模式作为后缀 如 <code>ThreadFactory</code></td></tr><tr><td>处理特定功能</td><td><code>Handler</code>，<code>Predicate</code> <code>Validator</code></td><td>表示处理器，校验器，断言 这些类工厂还有配套的方法名 如 <code>handle</code>，<code>predicate</code>，<code>validate</code></td></tr><tr><td>测试</td><td><code>Test</code> 后缀</td><td><code>UserServiceTest</code> 表示用来测试 <code>UserService</code> 类的</td></tr><tr><td>MVC 分层</td><td><code>Controller</code>，<code>Service ServiceImpl</code>，<code>DAO</code> 后缀</td><td><code>UserManageController</code> <code>UserManageDAO</code></td></tr></tbody></table><h3 id="注解的命名（装饰器）"><a href="#注解的命名（装饰器）" class="headerlink" title="注解的命名（装饰器）"></a>注解的命名（装饰器）</h3><p>一定要考虑被使用时的样子。</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，但并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p><p>-1. <strong>Nothing is strange.</strong> 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清楚，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。<br>-2. <strong>Less is more</strong>. 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。<br>-3. <strong>Advance with the time</strong>. 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</p><h4 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h4><p>注解大体上可以分为两种，一种是 jsdoc/javadoc 注解，另一种是简单注解。参与同一项目开发的同学，尽量设置成相同的注解模板。</p><h3 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h3><p>要考虑到声明和调用时的情形。</p><h3 id="方法的命名"><a href="#方法的命名" class="headerlink" title="方法的命名"></a>方法的命名</h3><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p><ul><li>动词+名词式命名的基本原则：要选择合适的动词，动词是方法的灵魂；其次要列明动作的对象，至于动作的修饰符（副词）或者对象的修饰语（定语），放到参数列表里就好了。</li><li>方法名称和返回值之间的关系：如果返回值有可能是个列表，那么方法所带有的名词最好就是复数形式；如果返回值是布尔型的，那么就要用 <code>is</code>/<code>can</code>/<code>need</code>/<code>has</code>/<code>contains</code> 等开头；如果返回值是确定类型的，那么该类型的名字有可能需要出现在方法名称里；如果返回值是个不确定类型的，那么 Object 或者父类名称是一个代替；如果是个 Getter，那么 get 对象的名称就是其名词部分。</li><li>考虑被调用时的样子</li><li>“执行”动词的使用：<code>doLogin</code> 意味着 <code>authenticate</code>，<code>doRegister</code> 意味着 <code>createUser</code>，<code>doEdit</code> 就是 Save`。</li><li>介词的使用：<code>by</code>、<code>with</code>、<code>and</code>、<code>after</code> 等</li><li>其他：命名不要有下划线，不要有临时字符。</li></ul><h4 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h4><p>注：<code>pre-</code> prefix 前缀，<code>suf-</code> suffix 后缀，<code>alo-</code> alone 单独使用</p><table><thead><tr><th>位置</th><th>单词</th><th>意义</th></tr></thead><tbody><tr><td>pre</td><td><code>is</code></td><td>对象是否符合期待的状态</td></tr><tr><td>pre</td><td><code>can</code></td><td>对象<strong>能否执行</strong>所期待的动作</td></tr><tr><td>pre</td><td><code>should</code></td><td>调用方执行某个命令或方法是好还是不好、应不应该， 或者说推荐还是不推荐</td></tr><tr><td>pre</td><td><code>has</code></td><td>对象<strong>是否持有</strong>所期待的数据和属性</td></tr><tr><td>pre</td><td><code>needs</code></td><td>调用方<strong>是否需要</strong>执行某个命令或方法</td></tr></tbody></table><h4 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td><code>ensure</code></td><td>检查是否为期待的状态不是则抛出异常或返回 error code</td><td><code>ensureCapacity</code></td></tr><tr><td><code>validate</code></td><td>检查是否为正确的状态不是则抛出异常或返回 error code</td><td><code>validateInputs</code></td></tr></tbody></table><h4 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>suf</td><td><code>IfNeeded</code></td><td>需要的时候执行不需要则什么都不做</td><td><code>drawIfNeeded</code></td></tr><tr><td>pre</td><td><code>might</code></td><td>同上</td><td><code>mightCreate</code></td></tr><tr><td>pre</td><td><code>try</code></td><td>尝试执行失败时抛出异常或是返回 errorcode</td><td><code>tryCreate</code></td></tr><tr><td>suf</td><td><code>OrDefault</code></td><td>尝试执行失败时返回默认值</td><td><code>getOrDefault</code></td></tr><tr><td>suf</td><td><code>OrElse</code></td><td>尝试执行失败时返回实际参数中指定的值</td><td><code>getOrElse</code></td></tr><tr><td>pre</td><td><code>force</code></td><td>强制尝试执行 error 抛出异常或是返回值</td><td><code>forceCreate</code>, <code>forceStop</code></td></tr></tbody></table><h4 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>pre</td><td><code>blocking</code></td><td>线程阻塞方法</td><td><code>blockingGetUser</code></td></tr><tr><td>suf</td><td><code>InBackground</code></td><td>执行在后台线程</td><td><code>doInBackground</code></td></tr><tr><td>suf</td><td><code>Async</code></td><td>异步方法</td><td><code>sendAsync</code></td></tr><tr><td>suf</td><td><code>Sync</code></td><td>同步方法</td><td><code>sendSync</code></td></tr><tr><td>pre / alo</td><td><code>schedule</code></td><td>Job 和 Tas k 放入队列</td><td><code>schedule</code>, <code>scheduleJob</code></td></tr><tr><td>pre / alo</td><td><code>post</code></td><td>同上</td><td><code>postJob</code></td></tr><tr><td>pre / alo</td><td><code>execute</code></td><td>执行异步 或同步方法</td><td><code>execute</code>, <code>executeTask</code></td></tr><tr><td>pre / alo</td><td><code>start</code></td><td>同上</td><td><code>start</code>, <code>startJob</code></td></tr><tr><td>pre / alo</td><td><code>cancel</code></td><td>停止异步方法</td><td><code>cance</code>, <code>cancelJob</code></td></tr><tr><td>pre / alo</td><td><code>stop</code></td><td>同上</td><td><code>stop</code>, <code>stopJob</code></td></tr></tbody></table><h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>pre</td><td><code>on</code></td><td>事件发生时执行</td><td><code>onCompleted</code></td></tr><tr><td>pre</td><td><code>before</code></td><td>事件发生前执行</td><td><code>beforeUpdate</code></td></tr><tr><td>pre</td><td><code>pre</code></td><td>同上</td><td><code>preUpdate</code></td></tr><tr><td>pre</td><td><code>will</code></td><td>同上</td><td><code>willUpdate</code></td></tr><tr><td>pre</td><td><code>after</code></td><td>事件发生后执行</td><td><code>afterUpdate</code></td></tr><tr><td>pre</td><td><code>post</code></td><td>同上</td><td><code>postUpdate</code></td></tr><tr><td>pre</td><td><code>did</code></td><td>同上</td><td><code>didUpdate</code></td></tr><tr><td>pre</td><td><code>should</code></td><td>确认事件是否可以执行</td><td><code>shouldUpdate</code></td></tr></tbody></table><h4 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td><code>initialize</code></td><td>初始化或延迟初始化使用</td><td><code>initialize</code></td></tr><tr><td><code>pause</code></td><td>暂停</td><td><code>onPause</code> , <code>pause</code></td></tr><tr><td><code>stop</code></td><td>停止</td><td><code>onStop</code>, <code>stop</code></td></tr><tr><td><code>abandon</code></td><td>销毁的替代</td><td><code>abandon</code></td></tr><tr><td><code>destroy</code></td><td>同上</td><td><code>destroy</code></td></tr><tr><td><code>dispose</code></td><td>同上</td><td><code>dispose</code></td></tr></tbody></table><h4 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td><code>contains</code></td><td>是包含指定对象相同的对象</td><td><code>contains</code></td></tr><tr><td><code>add</code></td><td>添加</td><td><code>addJob</code></td></tr><tr><td><code>append</code></td><td>添加</td><td><code>appendJob</code></td></tr><tr><td><code>insert</code></td><td>插入到下标 n</td><td><code>insertJob</code></td></tr><tr><td><code>put</code></td><td>添加与 key 对应的元素</td><td><code>putJob</code></td></tr><tr><td><code>remove</code></td><td>移除元素</td><td><code>removeJob</code></td></tr><tr><td><code>enqueue</code></td><td>添加到队列的最末位</td><td><code>enqueueJob</code></td></tr><tr><td><code>dequeue</code></td><td>从队列中头部取出并移除</td><td><code>dequeueJob</code></td></tr><tr><td><code>push</code></td><td>添加到栈头</td><td><code>pushJob</code></td></tr><tr><td><code>pop</code></td><td>从栈头取出并移除</td><td><code>popJob</code></td></tr><tr><td><code>peek</code></td><td>从栈头取出但不移除</td><td><code>peekJob</code></td></tr><tr><td><code>find</code></td><td>寻找符合条件的某物</td><td><code>findById</code></td></tr></tbody></table><h4 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h4><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td><code>create</code></td><td>新创建</td><td><code>createAccount</code></td></tr><tr><td><code>new</code></td><td>新创建</td><td><code>newAccount</code></td></tr><tr><td><code>from</code></td><td>从既有的某物新建或是从其他的数据新建</td><td><code>fromConfig</code></td></tr><tr><td><code>to</code></td><td>转换</td><td><code>toString</code></td></tr><tr><td><code>update</code></td><td>更新既有某物</td><td><code>updateAccount</code></td></tr><tr><td><code>load</code></td><td>读取</td><td><code>loadAccount</code></td></tr><tr><td><code>fetch</code></td><td>远程读取</td><td><code>fetchAccount</code></td></tr><tr><td><code>delete</code></td><td>删除</td><td><code>deleteAccount</code></td></tr><tr><td><code>remove</code></td><td>删除</td><td><code>removeAccount</code></td></tr><tr><td><code>save</code></td><td>保存</td><td><code>saveAccount</code></td></tr><tr><td><code>store</code></td><td>保存</td><td><code>storeAccount</code></td></tr><tr><td><code>commit</code></td><td>保存</td><td><code>commitChange</code></td></tr><tr><td><code>apply</code></td><td>保存或应用</td><td><code>applyChange</code></td></tr><tr><td><code>clear</code></td><td>清除或是恢复到初始状态</td><td><code>clearAll</code></td></tr><tr><td><code>reset</code></td><td>清除或是恢复到初始状态</td><td><code>resetAll</code></td></tr></tbody></table><p>函数的第一规则是要短小，第二条规则是还要更短小</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>一个命名插件：</p><ul><li>在线：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">https://unbug.github.io/codelf/</a>，不过不稳定，中文版用了有道翻译api有次数限制。</li></ul><p>Github：<a href="https://github.com/unbug/codelf" target="_blank" rel="noopener">https://github.com/unbug/codelf</a></p><p><img src="https://user-images.githubusercontent.com/799578/51435509-a2595d00-1cb3-11e9-8f4e-85ecbc3a2325.png" alt="codeif"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li>《Python 工匠》案例技巧与工程实践</li><li>《编写可读代码的艺术》</li><li>《会说话的代码》</li><li>《代码整洁之道》</li><li>《编程的原则》</li><li><a href="https://www.yuque.com/iv8gga/qgf69v/296ea151c0a1d5bd475f8b3c5ed1a0f4" target="_blank" rel="noopener">https://www.yuque.com/iv8gga/qgf69v/296ea151c0a1d5bd475f8b3c5ed1a0f4</a></li><li><a href="https://juejin.cn/post/6995342820512890893" target="_blank" rel="noopener">https://juejin.cn/post/6995342820512890893</a></li><li><a href="https://jimmysong.io/eng-practices/docs/review/reviewer/looking-for/#%E5%91%BD%E5%90%8D" target="_blank" rel="noopener">https://jimmysong.io/eng-practices/docs/review/reviewer/looking-for/#%E5%91%BD%E5%90%8D</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编码命名规范建议&quot;&gt;&lt;a href=&quot;#编码命名规范建议&quot; class=&quot;headerlink&quot; title=&quot;编码命名规范建议&quot;&gt;&lt;/a&gt;编码命名规范建议&lt;/h1&gt;&lt;h2 id=&quot;编程中命名习惯的改进&quot;&gt;&lt;a href=&quot;#编程中命名习惯的改进&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编码" scheme="http://blog.michealwayne.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《这样编码才规范 128个编码好习惯》</title>
    <link href="http://blog.michealwayne.cn/2022/05/08/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%BF%99%E6%A0%B7%E7%BC%96%E7%A0%81%E6%89%8D%E8%A7%84%E8%8C%83%20128%E4%B8%AA%E7%BC%96%E7%A0%81%E5%A5%BD%E4%B9%A0%E6%83%AF%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2022/05/08/notes/【笔记】《这样编码才规范 128个编码好习惯》/</id>
    <published>2022-05-08T12:41:10.000Z</published>
    <updated>2022-05-17T05:34:12.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《这样编码才规范-128个编码好习惯》"><a href="#《这样编码才规范-128个编码好习惯》" class="headerlink" title="《这样编码才规范 128个编码好习惯》"></a>《这样编码才规范 128个编码好习惯》</h1><p>此书从早好几年前开始阅读，一直断断续续至今才看完。整本书个人感觉总体一般（实际可用性不高），但帮助本人重新思考了一下当前代码规范或软件工程需要注意的点。<br>个人觉得前1～2章可读，从软件工程角度强调编码规范的注意事项，第3章开始是具体的格式、api规范，很多规范不适用于当前主流，也可以通过工具解决，比如格式化可以用prettier。</p><h2 id="1-基础知识概述"><a href="#1-基础知识概述" class="headerlink" title="1.基础知识概述"></a>1.基础知识概述</h2><h3 id="1-1-编码风格"><a href="#1-1-编码风格" class="headerlink" title="1.1 编码风格"></a>1.1 编码风格</h3><p>代码编写过程：</p><ul><li>1.认清问题</li><li>2.寻求解决问题的算法</li><li>3.用流程图或伪代码描述算法</li><li>4.用编程语言编写原始代码，此步骤也称为编码（coding）。编写代码的过程中需要处理以下几个部分，<ul><li>逻辑的表述方式</li><li>算法的表述方式</li><li>声明语句（statement）的布局方式</li><li>表达式（expression）的表述方式</li></ul></li><li>5.编译源代码并生成目标代码</li><li>6.进行单元测试并修正错误</li></ul><blockquote><p>编码和编程的含义几乎相同，但编程是指开发应用程序的逻辑层面的工作，编码可以理解为根据程序的逻辑、用特定的编程语言编写代码的工作。</p></blockquote><p>其中编码过程中，程序员之间有约定速成的处理方法，统称为编码风格或编码方式。简言之，编写原始代码的过程=编码风格。</p><h3 id="1-2-编码风格教育缺失"><a href="#1-2-编码风格教育缺失" class="headerlink" title="1.2 编码风格教育缺失"></a>1.2 编码风格教育缺失</h3><p>代码错误</p><ul><li>逻辑错误：存在逻辑方面的漏洞，特殊情况下会导致程序运行异常</li><li>运算错误：特别是实数型运算时出现的误差不断积累，形成蝴蝶效应，造成运算上的严重误差</li><li>调用错误：库提供的函数可能存在函数编写者也没有意识到的问题，导致调用此类函数的程序无法运行</li><li>漏洞错误：函数调用、类的继承、组件之间的漏洞导致参数和返回的数据类型或数据值无法匹配</li><li>环境错误：如果子啊不同于编写程序时假定的运行环境下运行，会出现意外的效果</li><li>输入错误：输入程序员没有预料到的特殊值，导致运算结果出错</li><li>运行错误：没有按照程序指定的顺序运行。如果是控制发电站等大规模工程的程序，则会导致严重问题</li></ul><p>出现这些问题的原因多种多样，但最重要的是，开发人员没有经过充分训练，而且开发过程中没有遵循良好的编码习惯。</p><h3 id="1-3-打磨编码风格的时机"><a href="#1-3-打磨编码风格的时机" class="headerlink" title="1.3 打磨编码风格的时机"></a>1.3 打磨编码风格的时机</h3><p>趁早。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大学生 &gt; 码农 &gt; 初级程序员 &gt; 高级程序员 &gt; 首席程序员 &gt; 系统架构师 &gt; 系统分析师 &gt; 项目经理</span><br></pre></td></tr></table></figure><p><img src="/images/code128/p-01.jpg" alt="p-01.jpg"></p><h3 id="1-4-必须学习编码风格的原因"><a href="#1-4-必须学习编码风格的原因" class="headerlink" title="1.4 必须学习编码风格的原因"></a>1.4 必须学习编码风格的原因</h3><ul><li>1.为了缩短开发时间</li><li>2.为了便于维护</li><li>3.为了编写零漏洞的完美程序</li></ul><blockquote><p>所有软件研发项目中，开发成本占总成本的比例仅为20%，而维护成本占比高67%。        ——《人月神话》</p></blockquote><p><img src="/images/code128/p-02.jpg" alt="p-02.jpg"></p><p>维护工作主要由<strong>完善现有程序、修改错误等组成</strong>，即使开发新功能，通常也可以通过对现有程序进行变形而实现。因此只要现有程序是在严格遵守编码风格规则的基础上编写的，就可以大幅降低维护成本，进而提升开发公司的收益。</p><p><img src="/images/code128/p-03.jpg" alt="p-03.jpg"></p><h3 id="1-5-编码风格比数学或英语更重要"><a href="#1-5-编码风格比数学或英语更重要" class="headerlink" title="1.5 编码风格比数学或英语更重要"></a>1.5 编码风格比数学或英语更重要</h3><p>程序进行对话。</p><p><img src="/images/code128/p-04.jpg" alt="p-04.jpg"></p><h3 id="1-6-所有编程语言都需要编码风格"><a href="#1-6-所有编程语言都需要编码风格" class="headerlink" title="1.6 所有编程语言都需要编码风格"></a>1.6 所有编程语言都需要编码风格</h3><p>编程语言出现的时间不同，使用范围也各不相同，但适用于各自的编码风格规范却大同小异，因为所有编程语言都是将字符书写成语句的形态。<br>编码风格不受编程领域影响，编码风格适用于所有编程语言和业务领域。</p><h3 id="1-7-选择用C语言阐述编程风格的原因"><a href="#1-7-选择用C语言阐述编程风格的原因" class="headerlink" title="1.7 选择用C语言阐述编程风格的原因"></a>1.7 选择用C语言阐述编程风格的原因</h3><p>它得到了大范围的应用、可用于研究的源代码易于查找、它是各种语言的原型，可以最大程度保证程序员的自由。</p><p><img src="/images/code128/p-05.jpg" alt="p-05.jpg"></p><ul><li>C语言中可能出现的问题：</li></ul><ul><li>1.除数为0会出现问题；</li><li>2.使用空指针会出现问题；</li><li>3.可再次访问已释放的动态分配内存；</li><li>4.字符串末尾必须添加空字符；</li><li>5.向超出数组范围的数组元素赋值会出现问题；</li><li>6.数据类型不同的变量间可以进行运算；</li><li>7.数据类型不同的指针访问内存会产生意想不到的结果；</li><li>8.终止条件不明确导致无法检查递归函数；</li><li>9.无法检查地址及其运算；</li><li>10.使用指针变量前必须初始化。</li></ul><p>C语言极有可能引发问题，所以更适合阐述编码风格。</p><h3 id="1-8-编码风格有益于编译执行方式和混合执行方式"><a href="#1-8-编码风格有益于编译执行方式和混合执行方式" class="headerlink" title="1.8 编码风格有益于编译执行方式和混合执行方式"></a>1.8 编码风格有益于编译执行方式和混合执行方式</h3><p>解释执行，如web;</p><p>混合执行方式是指，编译后生成的不是机器语言而是中间语言，其他部分与编译执行方式无异。</p><h3 id="1-9-基于组件的软件开发方式与编码风格"><a href="#1-9-基于组件的软件开发方式与编码风格" class="headerlink" title="1.9 基于组件的软件开发方式与编码风格"></a>1.9 基于组件的软件开发方式与编码风格</h3><p>基于组件的开发方式CBD（Component Based Development），这种方式采用面向对象的技术编写代码单元，每个代码单元就是组件，再将这些组件组装起来形成软件。</p><p>基于组件的开发方式能够提高效率，微软提出了包含组件设计原则（Principles of Component Design）在内的微软解决方案框架MSF（Microsoft Solutions Framework）</p><p><img src="/images/code128/p-06.jpg" alt="p-06.jpg"></p><p>CBD的核心概念是将程序单元视为组件。</p><h3 id="1-10-码农的力量不容小觑"><a href="#1-10-码农的力量不容小觑" class="headerlink" title="1.10 码农的力量不容小觑"></a>1.10 码农的力量不容小觑</h3><p>码农负责编写整个系统中最基础的部分——代码，虽然与软件开发业务中的架构师工作相比，码农的工作或许看起来微不足道，但它实际占据着决定软件质量的核心地位。因此码农的作用不容忽视，码农编写的代码决定着整个系统的质量。</p><p>软件开发的核心应该是“代码！代码！代码”，只有代码质量达到了一定标准，软件质量才能令人满意。而保证代码质量的不是别人，正是程序员和码农。</p><h3 id="1-11-将编码惯例文档化以统一应用"><a href="#1-11-将编码惯例文档化以统一应用" class="headerlink" title="1.11 将编码惯例文档化以统一应用"></a>1.11 将编码惯例文档化以统一应用</h3><p>写代码和写文章之间有着千丝万缕的联系。写文章的人常常需要参考其他书目，比如讲些语法规则或者经典词句，这些类似于编程中的编码惯例。编程过程虽然没有全球统一的规则，但无论是编程语言创始人或大师们提出的管理，还是业内约定俗成的管理，都可以视为统一规则。</p><p>程序员也应该经常参考编程惯例，参考全球普遍认可的编码惯例。编程惯例就像一种惯用语句，如果不能与对方的语言和习惯形成共鸣，就很难理解其语言或代码，双方沟通会受到影响。</p><p>各公司应该收集各种编码惯例，从中选择与自身情况匹配的内容，并要求内部开发人员统一采纳。</p><hr><h2 id="2-程序设计相关-编码准则"><a href="#2-程序设计相关-编码准则" class="headerlink" title="2.程序设计相关 编码准则"></a>2.程序设计相关 编码准则</h2><h3 id="2-1-遵循最新标准"><a href="#2-1-遵循最新标准" class="headerlink" title="2.1 遵循最新标准"></a>2.1 遵循最新标准</h3><p>行业标准日趋多样和精确。</p><h3 id="2-2-合理限制开发人员的规模"><a href="#2-2-合理限制开发人员的规模" class="headerlink" title="2.2 合理限制开发人员的规模"></a>2.2 合理限制开发人员的规模</h3><blockquote><p>并不是投入的开发人员越多，生产效率就越高。    ——《人月神话》</p></blockquote><p>每个项目都应该适当限制开发人员数量，项目投入再多人力，也并不一定能显著提高生产效率。问题就在于<strong>沟通渠道</strong>（<code>n * (n - 1) / 2</code>）。</p><p>沟通的实现程度称为“沟通强度”，也有人称为“团队精神”。公司规模越小，沟通渠道越少，沟通强度反而越高。</p><p>大公司参与开发的人员较多，一般采用正式的方式进行沟通，强调采用规范化的文书、规范化的方式和渠道，从而减慢了沟通的速度。因此虽然沟通渠道变多了但沟通强度反而变弱、导致整体沟通效率降低。</p><p>从“管理的极限”看，7人左右比较合适。</p><h3 id="2-3-维护旧程序比开发新程序更常见"><a href="#2-3-维护旧程序比开发新程序更常见" class="headerlink" title="2.3 维护旧程序比开发新程序更常见"></a>2.3 维护旧程序比开发新程序更常见</h3><p>与编写程序的耗时相比，维护程序的耗时呈现逐渐增多的趋势，且这种趋势正在日渐加快。从这一层面看，程序员的工作既包含创新性业务，又包含功能型业务。其中，修改现有程序并对其进行维护的功能性工作较多。</p><p>制定编码风格需要坚持以“标注便于理解的注释，编写清晰简明的代码”为原则，明确规定各方面的详细规则。程序员则要遵循给定的编码规则，不断努力编写像小说或随笔一样具有较高可读性的代码，这也将有助于讲话后续对程序的修复、更新等维护工作。</p><h3 id="2-4-不要认为修改程序很容易"><a href="#2-4-不要认为修改程序很容易" class="headerlink" title="2.4 不要认为修改程序很容易"></a>2.4 不要认为修改程序很容易</h3><p>实际上，重新编写程序确实比修改原有程序更快。</p><p>要限制需求变更。</p><h3 id="2-5-慎重采用新技术"><a href="#2-5-慎重采用新技术" class="headerlink" title="2.5 慎重采用新技术"></a>2.5 慎重采用新技术</h3><p>类似用惯了斧子伐木的人突然改用电锯，可能出现故障、误伤、效率下降等问题。当前，经过一段时间的磨合，掌握正确的电锯使用方法后，用电锯伐木的效率会明显高于用斧子的情况。</p><p>我们应当对不熟悉的事物保持敬畏之心。采用新技术时，不要忘记为学习新技术预留时间，如果项目工期紧需要在掌握新技术之前🔚，则应该果断放弃新技术直接采用熟悉的技术。</p><p>新方法得到广泛认可并能稳定应用之前，采用相对不浪费时间的技术才是比较正确的做法。编码风格宣扬的既不是激进主义也不是保守主义，而是改良主义。它主张在正常我们熟悉的语言的同时，对其稍加改进。长沙应用各种新的程序开发方法、编程语言、CASE（计算机辅助软件工程）工具前，应该优先考虑制定规范的编码风格，之后再投入使用并严格遵循。</p><h3 id="2-6-不要采用RAF策略"><a href="#2-6-不要采用RAF策略" class="headerlink" title="2.6 不要采用RAF策略"></a>2.6 不要采用RAF策略</h3><p><img src="/images/code128/p-07.jpg" alt="p-07.jpg"></p><p>RAF策略：Run and Fix，“先查看运行结果再修改程序”的工作方式。</p><p>欲速则不达。但仍然有很多程序员盲目相信压缩工期的魔力，认为快速完成任务才是第一要务。</p><p>程序是基于看不见的抽象逻辑编写的，而仅凭逻辑很难预测结果。</p><p>即使是小规模程序单元，RAF策略也会严重影响生产效率。</p><p>正确的做法：</p><ul><li>1.增加在程序构思阶段投入的时间；</li><li>2.采用流程图和伪代码，充分梳理程序逻辑；</li><li>3.在纸上投入的时间要多于在电脑上投入的时间；</li><li>4.事先预测程序可能出现的问题，并寻找解决方法；</li><li>5.深思熟虑后再编写代码。</li></ul><hr><h2 id="3-间隔相关编码准则"><a href="#3-间隔相关编码准则" class="headerlink" title="3.间隔相关编码准则"></a>3.间隔相关编码准则</h2><h3 id="3-1-一行只写一条语句"><a href="#3-1-一行只写一条语句" class="headerlink" title="3.1 一行只写一条语句"></a>3.1 一行只写一条语句</h3><p>可读性。（Js-prettier可以处理）</p><p>其中的“行”是在编辑器上显示的行，而不是一条执行语句。</p><p>（Js-prettier可以处理）</p><h3 id="3-2-区分声明语句和执行语句"><a href="#3-2-区分声明语句和执行语句" class="headerlink" title="3.2 区分声明语句和执行语句"></a>3.2 区分声明语句和执行语句</h3><p>可读性。</p><p>用空行区分声明语句和执行语句。不过注意插入太多空行同样会影响可读性。</p><h3 id="3-3-区分段落"><a href="#3-3-区分段落" class="headerlink" title="3.3 区分段落"></a>3.3 区分段落</h3><p>可读性。</p><p>执行语句之间也需要互相明确区分，当然，声明语句之间最好也能够明确区分。</p><p>编写程序时，无论是声明语句还是执行语句，都应该注意将相似的部分集中在一起，并在其前后插入空行，以便区分于其他语句。根据各语句负责的功能，将其划分为不同段落，这样有助于提高程序可读性，同时添加各段落主要功能的注释语句，更会起到锦上添花的作用。</p><h3 id="3-4-区分各种控制语句"><a href="#3-4-区分各种控制语句" class="headerlink" title="3.4 区分各种控制语句"></a>3.4 区分各种控制语句</h3><p>可读性。</p><p>表达统一思想的段落内部也应该插入空行，以划分更细的层次。最常见的情况是针对控制语句，如果某人没能正确理解程序中的控制语句，那么他极有可能误解整个程序的功能。</p><p>即使在段落内部，也应该在控制语句前后插入空行，以便快速识别。</p><p><img src="/images/code128/p-08.jpg" alt="p-08.jpg"></p><p>switch 语句适用的段落划分准则：</p><ul><li>1.switch语句开始部分单独占据一行；</li><li>2.以空行区分各case语句；</li><li>3.像case语句一样，用空行隔开default语句，以示区分。</li></ul><p>插入空行的方法有助于明确区分if、else、while、switch语句个字的控制范围。</p><h3 id="3-5-区分各函数"><a href="#3-5-区分各函数" class="headerlink" title="3.5 区分各函数"></a>3.5 区分各函数</h3><p>可读性。</p><p>函数之间无空行的缺点：</p><ul><li>难以掌握函数的起始位置和结束位置；</li><li>难以了解程序由几个函数组成；</li><li>难以定位某个特定函数。</li></ul><p>需要在各函数之间插入足够多的空行（可以考虑多行，保证间距够大）。</p><h3 id="3-6-运算符前后留出空格"><a href="#3-6-运算符前后留出空格" class="headerlink" title="3.6 运算符前后留出空格"></a>3.6 运算符前后留出空格</h3><p>可读性。（Js-prettier可以处理）</p><p>在运算符前后各插入一个空格，使前后部分更加明确；分号后插入更多空格，可以使条件表达式、判断表达式、增减表达式更易区分。</p><p>不同情况下，适当插入一个或多个空格，可以使一条语句中连续使用的多个表达式层次更清晰。</p><h3 id="3-7-不要在一元运算符与操作数之间插入空格"><a href="#3-7-不要在一元运算符与操作数之间插入空格" class="headerlink" title="3.7 不要在一元运算符与操作数之间插入空格"></a>3.7 不要在一元运算符与操作数之间插入空格</h3><p>可读性。（Js-prettier可以处理）</p><p><code>++</code>、<code>--</code>这种只需要一个操作数的运算符称为一元运算符。</p><h3 id="3-8-分号前不要插入空格"><a href="#3-8-分号前不要插入空格" class="headerlink" title="3.8 分号前不要插入空格"></a>3.8 分号前不要插入空格</h3><p>可读性。</p><h3 id="3-9-不要滥用Tab键"><a href="#3-9-不要滥用Tab键" class="headerlink" title="3.9 不要滥用Tab键"></a>3.9 不要滥用Tab键</h3><p>可读性。（Js-prettier可以处理）</p><h3 id="3-10-逗号后必须插入一个空格"><a href="#3-10-逗号后必须插入一个空格" class="headerlink" title="3.10 逗号后必须插入一个空格"></a>3.10 逗号后必须插入一个空格</h3><p>可读性。（Js-prettier可以处理）</p><p>以更好地区分各参数。</p><h3 id="3-11-逗号后不要插入太多空格"><a href="#3-11-逗号后不要插入太多空格" class="headerlink" title="3.11 逗号后不要插入太多空格"></a>3.11 逗号后不要插入太多空格</h3><p>可读性。（Js-prettier可以处理）</p><p>一般1～2，基本1个够用。</p><h3 id="3-12-变量初始化时的列对齐"><a href="#3-12-变量初始化时的列对齐" class="headerlink" title="3.12 变量初始化时的列对齐"></a>3.12 变量初始化时的列对齐</h3><p>可读性。（Js-prettier可以处理）</p><p>根据变量的用途，利用空行进行区分；还可以使用tab键，对齐各变量初始值所在列，但它可能会损害可读性，如：</p><p><img src="/images/code128/p-09.jpg" alt="p-09.jpg"></p><p>应该在合适的范围内，即不能插入过多空格的前提下，对齐初始化值所在列。</p><p><img src="/images/code128/p-10.jpg" alt="p-10.jpg"></p><p>通过空格的多少控制不同含义的变量初始值在不同位置对齐。</p><h3 id="3-13-一行只声明一个变量"><a href="#3-13-一行只声明一个变量" class="headerlink" title="3.13 一行只声明一个变量"></a>3.13 一行只声明一个变量</h3><p>可读性。</p><hr><h2 id="4-编写缩进相关编码准则"><a href="#4-编写缩进相关编码准则" class="headerlink" title="4.编写缩进相关编码准则"></a>4.编写缩进相关编码准则</h2><h3 id="4-1-大括号的位置"><a href="#4-1-大括号的位置" class="headerlink" title="4.1 大括号的位置"></a>4.1 大括号的位置</h3><p>可读性。（Js-prettier可以处理）</p><p>第一种风格是，大括号始终与语句位于同一行。</p><p>第二种风格是，大括号和语句分占不同行。</p><p>第三种风格是，左边大括号与语句在同一行，右边大括号另起一行。<br></p><h3 id="4-2-统一大括号的位置"><a href="#4-2-统一大括号的位置" class="headerlink" title="4.2 统一大括号的位置"></a>4.2 统一大括号的位置</h3><p>可读性。（Js-prettier可以处理）</p><p>如果大括号不缩进，则很容易掌握函数结束的位置。</p><h3 id="4-3-内部代码块需要缩进"><a href="#4-3-内部代码块需要缩进" class="headerlink" title="4.3 内部代码块需要缩进"></a>4.3 内部代码块需要缩进</h3><p>可读性。（Js-prettier可以处理）</p><h3 id="4-4-输出部分需要缩进"><a href="#4-4-输出部分需要缩进" class="headerlink" title="4.4 输出部分需要缩进"></a>4.4 输出部分需要缩进</h3><p>可读性。（Js-prettier可以处理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xx)</span><br><span class="line">  <span class="built_in">console</span>.log(xxx);</span><br></pre></td></tr></table></figure><p>程序员选择不缩进的理由：</p><ul><li>全部精力集中于项目本身，对缩进并不关注；</li><li>改写代码并将原始代码文件移植到其他系统平台的过程中，缩进不知不觉地消失了；</li></ul><p>需要检查缩进的时间点：</p><ul><li>程序完结之前；</li><li>与他人进行程序交接之前；</li><li>文件改写完成之后。</li></ul><h3 id="4-5-不要毫无意义地缩进"><a href="#4-5-不要毫无意义地缩进" class="headerlink" title="4.5 不要毫无意义地缩进"></a>4.5 不要毫无意义地缩进</h3><p>可读性。（Js-prettier可以处理）</p><p>不要用毫无意义的缩进，如果只想表示强调，那么顽强可以用添加注释等方式代替缩进。</p><h3 id="4-6-保持缩进程度的一致性"><a href="#4-6-保持缩进程度的一致性" class="headerlink" title="4.6 保持缩进程度的一致性"></a>4.6 保持缩进程度的一致性</h3><p>可读性。（Js-prettier可以处理）</p><p>缩进程度与嵌套程度并不相关，嵌套较深需要注释进行说明和区分。</p><h3 id="4-7-选择合适的缩进程度"><a href="#4-7-选择合适的缩进程度" class="headerlink" title="4.7 选择合适的缩进程度"></a>4.7 选择合适的缩进程度</h3><p>可读性。（Js-prettier可以处理）</p><p>4/2都可以，但不能过浅或过深。</p><h3 id="4-8-不要缩写凸出形式的代码"><a href="#4-8-不要缩写凸出形式的代码" class="headerlink" title="4.8 不要缩写凸出形式的代码"></a>4.8 不要缩写凸出形式的代码</h3><p>可读性。（Js-prettier可以处理）</p><p>凸出形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  <span class="comment">// 此行突出</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>凸出书写的代码和在稿纸边缘以外写字是一样的。</p><hr><h2 id="5-注释相关编码准则"><a href="#5-注释相关编码准则" class="headerlink" title="5.注释相关编码准则"></a>5.注释相关编码准则</h2><h3 id="5-1-多种注释形态"><a href="#5-1-多种注释形态" class="headerlink" title="5.1 多种注释形态"></a>5.1 多种注释形态</h3><p>可读性。</p><p>程序专用编辑器不能实现黑体、加粗等样式效果，因此程序员设计了多种注释形态，以实现各类装饰效果</p><h4 id="5-1-1-不包含强调内容的单行注释"><a href="#5-1-1-不包含强调内容的单行注释" class="headerlink" title="5.1.1 不包含强调内容的单行注释"></a>5.1.1 不包含强调内容的单行注释</h4><p>最常见，没有需要特别强调的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单行注释常用于注释程序主体代码 */</span></span><br></pre></td></tr></table></figure><h4 id="5-1-2-包含强调内容的单行注释"><a href="#5-1-2-包含强调内容的单行注释" class="headerlink" title="5.1.2 包含强调内容的单行注释"></a>5.1.2 包含强调内容的单行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--&gt; 注意：需要处理错误信息 &lt;--*/</span></span><br></pre></td></tr></table></figure><p>或：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&gt;&gt;&gt;&gt;&gt;&gt;&gt; 精密计算例程 &lt;&lt;&lt;&lt;&lt;&lt;&lt;*/</span></span><br></pre></td></tr></table></figure></p><p>如何装饰单行注释取决于程序员的个人喜好，无论使用何种特殊字符，只要它能够吸引眼球，并能明确标识注释的起止点即可。</p><h4 id="5-1-3-不包含强调内容的多行注释"><a href="#5-1-3-不包含强调内容的多行注释" class="headerlink" title="5.1.3 不包含强调内容的多行注释"></a>5.1.3 不包含强调内容的多行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编写包含多行语句的注释</span></span><br><span class="line"><span class="comment">* 没有需要特别强调的内容，但需要用较长的句子进行更准确的说明时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以插入特殊字符区分注释内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编写包含多行语句的注释</span></span><br><span class="line"><span class="comment">* ----------------------------</span></span><br><span class="line"><span class="comment">* input1: 。。。</span></span><br><span class="line"><span class="comment">* input2: 。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-包含强调内容的多行注释"><a href="#5-1-4-包含强调内容的多行注释" class="headerlink" title="5.1.4 包含强调内容的多行注释"></a>5.1.4 包含强调内容的多行注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* !!!!!!!!!!! 警告（Warning） !!!!!!!!!! */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="comment">/* 需要特别注意这段程序，，，，，，，，，       */</span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br></pre></td></tr></table></figure><p>注释最重要的用途是引起程序员的注意，不要纠结于外观。</p><h4 id="5-2-区分单行注释和注释框"><a href="#5-2-区分单行注释和注释框" class="headerlink" title="5.2 区分单行注释和注释框"></a>5.2 区分单行注释和注释框</h4><p>可读性。</p><p>注释形式可大致分为：</p><ul><li>单行注释</li><li>非单行注释（多行注释）</li></ul><p>需要说明程序或函数时，应该采用多行注释。多行注释又称“注释框”或“块注释”。<br>注释框包含程序名、目标、编写者、修改者、编写日期和修改日期等众多信息，方便人们理解程序。除此之外程序员还可以增加任意信息。注释框相当于程序的参考文献，对于大规模项目尤为重要。</p><p>程序主体语句中不要使用注释框。任何人都能理解的内容，或代码中明确出现的内容都没有必要添加注释，更没有必要进行详细说明。如果实在想添加，那么单行注释足矣，而且此单行注释主要标注程序代码本身没有体现的信息。</p><h3 id="5-3-添加“变量字典编写专用注释”"><a href="#5-3-添加“变量字典编写专用注释”" class="headerlink" title="5.3 添加“变量字典编写专用注释”"></a>5.3 添加“变量字典编写专用注释”</h3><p>可读性。</p><p>但声明变量未必能让人理解变量具体信息，如单位。这时候可以在变量旁添加详细注释，这种方法称为“变量字典编写专用注释”，简称“字典注释”（diction comment）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> area;    <span class="comment">// 面积：计算正在施工中的建筑物的地基面积。 </span></span><br><span class="line"><span class="keyword">let</span> wide;    <span class="comment">// 宽度：以米为单位，计算地基横向长度。</span></span><br><span class="line"><span class="keyword">let</span> height;  <span class="comment">// 高度：以米为单位，计算地基纵向长度。</span></span><br></pre></td></tr></table></figure><p>字典注释不仅能够在程序内部描述各变量作用，还可以将各模块中变量声明的部分复制并保存到同一个文件，该文件即可视为能够说明所有变量的字典。这种字典在检查程序时非常重要，还可以避免变量命名冲突。</p><h3 id="5-4-向程序插入伪代码"><a href="#5-4-向程序插入伪代码" class="headerlink" title="5.4 向程序插入伪代码"></a>5.4 向程序插入伪代码</h3><p>可读性。</p><p>注释的存在是为了使程序便于理解，即为了使包含程序编写者在内的所有人都能轻松理解程序的“目标和逻辑”。程序的“目标和逻辑”中，“逻辑”可以用伪代码补充。在程序起始部分用注释形式标注伪代码后，程序的整体脉络旧一目了然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 计算两个数字变量num1、num2的最大值</span></span><br><span class="line"><span class="comment"> [该程序伪代码]  </span></span><br><span class="line"><span class="comment"> 如果 num1 大于 num2</span></span><br><span class="line"><span class="comment">   则num1是最大值</span></span><br><span class="line"><span class="comment">   返回num1</span></span><br><span class="line"><span class="comment"> 否则</span></span><br><span class="line"><span class="comment">   返回num2</span></span><br><span class="line"><span class="comment"> [伪代码结束]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>伪代码对于快速把握程序非常有效。</p><h3 id="5-5-通过注释标注程序目标"><a href="#5-5-通过注释标注程序目标" class="headerlink" title="5.5 通过注释标注程序目标"></a>5.5 通过注释标注程序目标</h3><p>可读性。</p><p>添加伪代码可以使程序逻辑一目了然。但有时候伪代码也并不短。这时候可以将程序的“目标”以注释的形式标注于程序最开始的部分：</p><p>/**</p><h2 id="编写目标：计算两个数字变量num1、num2的最大值"><a href="#编写目标：计算两个数字变量num1、num2的最大值" class="headerlink" title=" 编写目标：计算两个数字变量num1、num2的最大值"></a> 编写目标：计算两个数字变量num1、num2的最大值</h2><p> [该程序伪代码]<br> 如果 num1 大于 num2<br>   则num1是最大值<br>   返回num1<br> 否则<br>   返回num2<br> [伪代码结束]<br> */</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">伪代码的主要作用是体现程序的“逻辑”，而不能完全展现“目标”。如果程序本身没有明确标注目标，那么人们阅读该程序时就不得不根据伪代码进行推测。</span><br><span class="line"></span><br><span class="line">标注程序目标时，应该遵守“六何原则”：</span><br><span class="line"></span><br><span class="line">``` js</span><br><span class="line">/* 何时（when）  编写日期：2022年5月16日 */</span><br><span class="line">/* 何地（where） 场   所：XX事业部XX组 */</span><br><span class="line">/* 何人（who）   编写 者：XXX */</span><br><span class="line">/* 何事（what）  代码性质：c语言代码，约200行 */</span><br><span class="line">/* 为何（why）   编写理由：最大值最小值求值 */</span><br><span class="line">/* 如何（how）   编写环境：控制台 */</span><br></pre></td></tr></table></figure><p>我们应该在程序起始部分用注释形式添加伪代码和程序目标。</p><h3 id="5-6-程序起始部分必须添加头注释"><a href="#5-6-程序起始部分必须添加头注释" class="headerlink" title="5.6 程序起始部分必须添加头注释"></a>5.6 程序起始部分必须添加头注释</h3><p>可读性。</p><p>注释可以分为“主体注释”和“头注释”两类，主体注释位于程序代码之间，用于说明对应部分的作用；头注释位于程序起始部分，用于指出程序的题目、作者、目标等。<br>头注释相当于名片，我们通过头注释可以首先对程序有整体的认知，再基于主体注释对其进行更细致的了解。</p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件名：demo.ts</span></span><br><span class="line"><span class="comment">* 出处：blog.michealwayne.cn</span></span><br><span class="line"><span class="comment">* 编写者：MichealWayne</span></span><br><span class="line"><span class="comment">* 目标：读取用户登录记录，xxx。。。</span></span><br><span class="line"><span class="comment">* 提供方式：构建后的js</span></span><br><span class="line"><span class="comment">* 限制条件：1.nodejs 12.22以上</span></span><br><span class="line"><span class="comment">* 异常处理：1.出现各种错误时，应在xxx稳定上记录错误日志</span></span><br><span class="line"><span class="comment">* 历史记录：1.2022年5月16日，初始化，增加登录功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><ul><li>文件名：记录程序或模块保存到内存时的源文件名。目标文件名或可执行文件名与源文件名不同时，需要同时记录。如果存在其他需要链接的目标代码，可以用<code>+</code>符号连接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名：源代码：demo.ts</span></span><br><span class="line"><span class="comment"> * 目标代码：demo.js</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>编写者</p></li><li><p>目标：记录为什么要编写这个程序，该程序负责处理什么任务，在整个系统中担任什么角色等。</p></li><li><p>使用方式：方式、执行频率等。</p></li><li><p>所需文件：记录需要处理的文件名、属性等，同时需要标注该文件释放可读、可写、可修改、可删除。</p></li><li><p>限制条件：操作系统、CPU速度、程序大小、所需的硬盘容量等。</p></li><li><p>异常处理：一定程度上预测并管理致命的异常。</p></li><li><p>历史记录：修改时间、修改内容的核心、修改者。</p></li></ul><h3 id="5-7-在等于运算符旁添加注释"><a href="#5-7-在等于运算符旁添加注释" class="headerlink" title="5.7 在等于运算符旁添加注释"></a>5.7 在等于运算符旁添加注释</h3><p>可读性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++) &#123;  <span class="comment">// i从1开始计数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，在条件语句中使用等于运算符或赋值运算符时，应尽可能在旁边添加注释。</p><h3 id="5-8-在大括号闭合处添加注释"><a href="#5-8-在大括号闭合处添加注释" class="headerlink" title="5.8 在大括号闭合处添加注释"></a>5.8 在大括号闭合处添加注释</h3><p>可读性。</p><p>通常，应该在大括号闭合处的旁边添加注释，说明该大括号表示哪部分结束。按照惯例，应该用<code>end if</code>、<code>end main</code>、<code>end while</code>、<code>end class MyClass</code>这种以end开头的注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end if</span></span><br><span class="line">&#125; <span class="comment">// end demo</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-9-在函数内部添加详细介绍函数的注释"><a href="#5-9-在函数内部添加详细介绍函数的注释" class="headerlink" title="5.9 在函数内部添加详细介绍函数的注释"></a>5.9 在函数内部添加详细介绍函数的注释</h3><p>可读性。</p><p>如果函数正上方或正下方添加了关于其作用和含义的详细注释，那么就不必逐条查看代码，也能提高效率。</p><p>应当记录：</p><ul><li>函数的目标；</li><li>各参数允许的数据类型及含义；</li><li>返回值应用于何处</li></ul><h3 id="5-10-注释标记原则"><a href="#5-10-注释标记原则" class="headerlink" title="5.10 注释标记原则"></a>5.10 注释标记原则</h3><ul><li>代码本身足以说明问题时，不必添加注释；</li><li>代码本身不足以说明问题时，尽可能添加详细注释。</li></ul><hr><h2 id="6-标识符名称定义相关编码准则1"><a href="#6-标识符名称定义相关编码准则1" class="headerlink" title="6.标识符名称定义相关编码准则1"></a>6.标识符名称定义相关编码准则1</h2><h3 id="6-1-系统化定义变量名"><a href="#6-1-系统化定义变量名" class="headerlink" title="6.1 系统化定义变量名"></a>6.1 系统化定义变量名</h3><p>可读性。</p><p>应该统一变量命名规则，系统化整理变量名可以避免混淆。</p><p>### 6.2 用匈牙利表示法命名变量</p><p>可读性。（不是特别推荐）</p><p>变量名以能表示——包含数据类型在内的——变量特性或功能的字符串为前缀。如下为整数型变量添加字符<code>i</code>作为前缀：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iNumber</span><br><span class="line">iCounter</span><br></pre></td></tr></table></figure></p><p>指针类型变量应添加前缀<code>p</code>或<code>ptr</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pMyPointer</span><br><span class="line">ptrFilePointer</span><br></pre></td></tr></table></figure></p><p><img src="/images/code128/p-11.jpg" alt="p-11.jpg"></p><p>采用匈牙利表示法可以使变量的数据类型一目了然。但是使用匈牙利表示法需要记住每种数据类型并添加到变量名前缀，这非常繁琐。</p><h3 id="6-3-用变量名前缀表示变量数据类型"><a href="#6-3-用变量名前缀表示变量数据类型" class="headerlink" title="6.3 用变量名前缀表示变量数据类型"></a>6.3 用变量名前缀表示变量数据类型</h3><p>可读性。（不是特别推荐）</p><p><img src="/images/code128/p-12.jpg" alt="p-12.jpg"></p><h3 id="6-4-用变量名前缀表示变量存储类型"><a href="#6-4-用变量名前缀表示变量存储类型" class="headerlink" title="6.4 用变量名前缀表示变量存储类型"></a>6.4 用变量名前缀表示变量存储类型</h3><p>可读性。（不是特别推荐）</p><p><img src="/images/code128/p-13.jpg" alt="p-13.jpg"></p><p>存储类型指的是，考虑变量在内存中的生存期的长短、在程序代码中影响范围的大小，对变量进行分类。</p><p>还有用下划线区分变量的存储类型和数据类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g_uc_mynum;</span><br></pre></td></tr></table></figure></p><h3 id="6-5-用函数名前缀表示函数功能"><a href="#6-5-用函数名前缀表示函数功能" class="headerlink" title="6.5 用函数名前缀表示函数功能"></a>6.5 用函数名前缀表示函数功能</h3><p>可读性。</p><ul><li><code>avr</code>：计算平均值，如<code>avrOfTot</code></li><li><code>cnt</code>：计算数据个数，如<code>cntAllthing</code></li><li><code>check</code>：检查某数值，如<code>checkData</code></li><li><code>get</code>：表示用于获取某数值</li><li><code>set</code>：表示用于设置某数值</li><li><code>is</code>：用于提出“是什么”的疑问</li><li><code>key</code>：从数据中只获取关键字的值，如<code>keyPaymentTable</code></li><li><code>max</code>：表示获取最大</li><li><code>mid</code>：表示获取中间值</li><li><code>min</code>：表示获取最小值</li><li><code>put</code>：表示用于存储</li></ul><p><code>动词 + 宾语</code>的形式。</p><h3 id="6-6-编写个人专属前缀"><a href="#6-6-编写个人专属前缀" class="headerlink" title="6.6 编写个人专属前缀"></a>6.6 编写个人专属前缀</h3><p>可读性。</p><p>如<code>BreakSystem</code>类创建了一个实例：<code>bsNewBreak</code>。</p><p>需要注意的是，进行团队开发时，编写新的前缀需要告知团队中的所有人，或者在声明语句前添加相应注释。</p><hr><h2 id="标识符名称定义相关编码准则2"><a href="#标识符名称定义相关编码准则2" class="headerlink" title="标识符名称定义相关编码准则2"></a>标识符名称定义相关编码准则2</h2><h3 id="7-1-用有意义的名称命名"><a href="#7-1-用有意义的名称命名" class="headerlink" title="7.1 用有意义的名称命名"></a>7.1 用有意义的名称命名</h3><p>可读性。</p><p>标识符的名称一定要有意义。</p><h3 id="7-2-不要使用相似的变量名"><a href="#7-2-不要使用相似的变量名" class="headerlink" title="7.2 不要使用相似的变量名"></a>7.2 不要使用相似的变量名</h3><p>可读性。</p><p>比如通过变量名后加s以区分不同变量，如number和numbers，使用这种相似的变量名命名变量后，编程过程中容易混淆，应该用明显不同的单词命名，如number和digit。<br>不得不采用相似的变量名时，可以向原名称添加前缀或后缀。如day_yy、day_mm、day_dd。前缀有时比后缀更有效，比如iTotal和dTotal。</p><h3 id="7-3-在不影响含义的前提下尽可能简短命名"><a href="#7-3-在不影响含义的前提下尽可能简短命名" class="headerlink" title="7.3 在不影响含义的前提下尽可能简短命名"></a>7.3 在不影响含义的前提下尽可能简短命名</h3><p>可读性。</p><p>“短小精悍”。可以使用惯用缩写：</p><p><img src="/images/code128/p-14.jpg" alt="p-14.jpg"></p><p>其他的还有：</p><ul><li>Break -&gt; brk</li><li>Control -&gt; ctl</li><li>System -&gt; sys</li></ul><h3 id="7-4-用下划线和大小写区分较长变量名"><a href="#7-4-用下划线和大小写区分较长变量名" class="headerlink" title="7.4 用下划线和大小写区分较长变量名"></a>7.4 用下划线和大小写区分较长变量名</h3><p>可读性。</p><p>甚至可以下划线和大小写都用。</p><h3 id="7-5-变量名不要以下划线开始"><a href="#7-5-变量名不要以下划线开始" class="headerlink" title="7.5 变量名不要以下划线开始"></a>7.5 变量名不要以下划线开始</h3><p>可读性。</p><p>用下划线主要是为了避免冲突，但如果都推荐用下划线，反而就造成了命名冲突。</p><h3 id="7-6-不要过度使用下划线"><a href="#7-6-不要过度使用下划线" class="headerlink" title="7.6 不要过度使用下划线"></a>7.6 不要过度使用下划线</h3><p>可读性。</p><p>只用一个下划线，不要用多个。</p><h3 id="7-7-合理使用大小写命名标识符"><a href="#7-7-合理使用大小写命名标识符" class="headerlink" title="7.7 合理使用大小写命名标识符"></a>7.7 合理使用大小写命名标识符</h3><p>可读性。</p><ul><li>变量和对象名以小写字母开始；</li><li>函数、类、结构体、共用体等名称以大写字母开始（js函数一般不用）；</li><li>符号常量或宏函数的所有字母均大写。</li></ul><h3 id="7-8-不要滥用大小写区分1"><a href="#7-8-不要滥用大小写区分1" class="headerlink" title="7.8 不要滥用大小写区分1"></a>7.8 不要滥用大小写区分1</h3><p>可读性。</p><p>滥用1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num;</span><br><span class="line">let Num;</span><br><span class="line">let NUM;</span><br></pre></td></tr></table></figure></p><h3 id="7-9-不要滥用大小写区分2"><a href="#7-9-不要滥用大小写区分2" class="headerlink" title="7.9 不要滥用大小写区分2"></a>7.9 不要滥用大小写区分2</h3><p>可读性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iMyNumber = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> iMynumber = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="7-10-不能用相同名称同时命名类和变量"><a href="#7-10-不能用相同名称同时命名类和变量" class="headerlink" title="7.10 不能用相同名称同时命名类和变量"></a>7.10 不能用相同名称同时命名类和变量</h3><p>可读性。</p><h3 id="7-11-用大写字母表示变量名中需要强调的部分"><a href="#7-11-用大写字母表示变量名中需要强调的部分" class="headerlink" title="7.11 用大写字母表示变量名中需要强调的部分"></a>7.11 用大写字母表示变量名中需要强调的部分</h3><p>可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localButIMPORTANT</span><br></pre></td></tr></table></figure><hr><h2 id="8-运算符相关编码准则"><a href="#8-运算符相关编码准则" class="headerlink" title="8.运算符相关编码准则"></a>8.运算符相关编码准则</h2><h3 id="8-1-恰当应用条件运算符有助于提高可读性"><a href="#8-1-恰当应用条件运算符有助于提高可读性" class="headerlink" title="8.1 恰当应用条件运算符有助于提高可读性"></a>8.1 恰当应用条件运算符有助于提高可读性</h3><p>可读性。</p><p>如果if判断较多，有些情况下可以使用运算符缩减代码长度。</p><h3 id="8-2-不要凭借运算符优先级排列算式"><a href="#8-2-不要凭借运算符优先级排列算式" class="headerlink" title="8.2 不要凭借运算符优先级排列算式"></a>8.2 不要凭借运算符优先级排列算式</h3><p>可读性。</p><p>需要添加括号，让人能够轻松理解。</p><h3 id="8-3-指针运算符应该紧接变量名"><a href="#8-3-指针运算符应该紧接变量名" class="headerlink" title="8.3 指针运算符应该紧接变量名"></a>8.3 指针运算符应该紧接变量名</h3><p>可读性。（js倒不涉及）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> b, c;</span><br></pre></td></tr></table></figure><h3 id="8-4-慎选移位运算，多用算术运算"><a href="#8-4-慎选移位运算，多用算术运算" class="headerlink" title="8.4 慎选移位运算，多用算术运算"></a>8.4 慎选移位运算，多用算术运算</h3><p>可读性。</p><p>程序难以理解，也容易存在边界问题。</p><h3 id="8-5-不要追求极端效率"><a href="#8-5-不要追求极端效率" class="headerlink" title="8.5 不要追求极端效率"></a>8.5 不要追求极端效率</h3><p>要考虑可读性。</p><hr><h2 id="9-编写清晰代码所需编码准则"><a href="#9-编写清晰代码所需编码准则" class="headerlink" title="9.编写清晰代码所需编码准则"></a>9.编写清晰代码所需编码准则</h2><h3 id="9-1-不要投机取巧，应致力于编写清晰易懂的程序"><a href="#9-1-不要投机取巧，应致力于编写清晰易懂的程序" class="headerlink" title="9.1 不要投机取巧，应致力于编写清晰易懂的程序"></a>9.1 不要投机取巧，应致力于编写清晰易懂的程序</h3><p>考虑可读性，也不要过分注释。</p><h3 id="9-2-切忌混淆while语句中关系运算符和赋值运算符的优先级"><a href="#9-2-切忌混淆while语句中关系运算符和赋值运算符的优先级" class="headerlink" title="9.2 切忌混淆while语句中关系运算符和赋值运算符的优先级"></a>9.2 切忌混淆while语句中关系运算符和赋值运算符的优先级</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (c = (getChar() !== <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可观，也容易失误。</p><h3 id="9-3-不要进行隐式“非零测试”"><a href="#9-3-不要进行隐式“非零测试”" class="headerlink" title="9.3 不要进行隐式“非零测试”"></a>9.3 不要进行隐式“非零测试”</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getNum()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好明确写出条件表达式。</p><h3 id="9-4-不要在条件表达式中使用赋值语句"><a href="#9-4-不要在条件表达式中使用赋值语句" class="headerlink" title="9.4 不要在条件表达式中使用赋值语句"></a>9.4 不要在条件表达式中使用赋值语句</h3><p>while/if/for/switch不要使用赋值语句。</p><h3 id="9-5-避免产生副作用"><a href="#9-5-避免产生副作用" class="headerlink" title="9.5 避免产生副作用"></a>9.5 避免产生副作用</h3><p>比如++的取值等。几乎所有运算、控制、调用都可能引起副作用，遵循KISS原则编写程序。</p><h3 id="9-6-函数原型中也要标注参数的数据类型"><a href="#9-6-函数原型中也要标注参数的数据类型" class="headerlink" title="9.6 函数原型中也要标注参数的数据类型"></a>9.6 函数原型中也要标注参数的数据类型</h3><p>为了避免模糊性、强化明确性，必须在函数原型中也标记参数。</p><h3 id="9-7-形式参数也需要命名"><a href="#9-7-形式参数也需要命名" class="headerlink" title="9.7 形式参数也需要命名"></a>9.7 形式参数也需要命名</h3><p>Val、num可能还不够语义化。</p><h3 id="9-8-必须标注返回值的数据类型"><a href="#9-8-必须标注返回值的数据类型" class="headerlink" title="9.8 必须标注返回值的数据类型"></a>9.8 必须标注返回值的数据类型</h3><p>（ts可以遵守这条规则）</p><h3 id="9-9-留意结果值"><a href="#9-9-留意结果值" class="headerlink" title="9.9 留意结果值"></a>9.9 留意结果值</h3><p>各种运算、调用、控制返回值的最终结果的值。</p><h3 id="9-10-在for语句等条件表达式中谨慎运算"><a href="#9-10-在for语句等条件表达式中谨慎运算" class="headerlink" title="9.10 在for语句等条件表达式中谨慎运算"></a>9.10 在for语句等条件表达式中谨慎运算</h3><p>可以将运算执行、方法提前。</p><h3 id="9-11-大量使用冗余括号"><a href="#9-11-大量使用冗余括号" class="headerlink" title="9.11 大量使用冗余括号"></a>9.11 大量使用冗余括号</h3><p>可用可不用的括号有时能帮助理解，有助于区分关系运算符和逻辑运算符。</p><h3 id="9-12-如果else语句使用大括号，那么if语句也应该使用"><a href="#9-12-如果else语句使用大括号，那么if语句也应该使用" class="headerlink" title="9.12 如果else语句使用大括号，那么if语句也应该使用"></a>9.12 如果else语句使用大括号，那么if语句也应该使用</h3><h3 id="9-13-函数末尾务必编写return语句"><a href="#9-13-函数末尾务必编写return语句" class="headerlink" title="9.13 函数末尾务必编写return语句"></a>9.13 函数末尾务必编写return语句</h3><hr><h2 id="10-编写可移植代码所需编码准则"><a href="#10-编写可移植代码所需编码准则" class="headerlink" title="10.编写可移植代码所需编码准则"></a>10.编写可移植代码所需编码准则</h2><h3 id="10-1-文件名不超过14个字符"><a href="#10-1-文件名不超过14个字符" class="headerlink" title="10.1 文件名不超过14个字符"></a>10.1 文件名不超过14个字符</h3><p>不同操作系统对文件名长度有不同限制，保证程序能够顺利移植到对文件名长度有所限制的系统。</p><h3 id="10-2-不要在文件名中使用特殊字符"><a href="#10-2-不要在文件名中使用特殊字符" class="headerlink" title="10.2 不要在文件名中使用特殊字符"></a>10.2 不要在文件名中使用特殊字符</h3><h3 id="10-3-利用条件编译提高可移植性"><a href="#10-3-利用条件编译提高可移植性" class="headerlink" title="10.3 利用条件编译提高可移植性"></a>10.3 利用条件编译提高可移植性</h3><p>Js不涉及</p><h3 id="10-4-了解编译器的限制"><a href="#10-4-了解编译器的限制" class="headerlink" title="10.4 了解编译器的限制"></a>10.4 了解编译器的限制</h3><p>如调用栈限制。</p><h3 id="10-5-需考虑数据类型大小可能变化"><a href="#10-5-需考虑数据类型大小可能变化" class="headerlink" title="10.5 需考虑数据类型大小可能变化"></a>10.5 需考虑数据类型大小可能变化</h3><h3 id="10-6-不要指定绝对路径"><a href="#10-6-不要指定绝对路径" class="headerlink" title="10.6 不要指定绝对路径"></a>10.6 不要指定绝对路径</h3><h3 id="10-7-可移植性和高效性二选一"><a href="#10-7-可移植性和高效性二选一" class="headerlink" title="10.7 可移植性和高效性二选一"></a>10.7 可移植性和高效性二选一</h3><p><img src="/images/code128/p-15.jpg" alt="p-15.jpg"></p><p>提高效率的技术方法很大程序上都依赖系统，越是针对专门设备进行特殊化处理的程序，效率越高，也就是一定会牺牲可移植性。</p><h3 id="10-8-用数组代替指针以提高可移植性"><a href="#10-8-用数组代替指针以提高可移植性" class="headerlink" title="10.8 用数组代替指针以提高可移植性"></a>10.8 用数组代替指针以提高可移植性</h3><h3 id="10-9-选择可移植性更好的编程语言"><a href="#10-9-选择可移植性更好的编程语言" class="headerlink" title="10.9 选择可移植性更好的编程语言"></a>10.9 选择可移植性更好的编程语言</h3><p>可移植性和可读性通常成正比。</p><h3 id="10-10-不要插入低级语言编写的代码"><a href="#10-10-不要插入低级语言编写的代码" class="headerlink" title="10.10 不要插入低级语言编写的代码"></a>10.10 不要插入低级语言编写的代码</h3><p>汇编、机器语言。那么可移植性方面可能会出现问题。如果不得不用低级语言实现特定功能，则应该用相应语言编写库，事先编译，然后再以函数形式调用。</p><hr><h2 id="11-编写精确代码所需编码准则"><a href="#11-编写精确代码所需编码准则" class="headerlink" title="11.编写精确代码所需编码准则"></a>11.编写精确代码所需编码准则</h2><p>可拓展性。</p><h3 id="11-1计算机并不如想象得那么精确"><a href="#11-1计算机并不如想象得那么精确" class="headerlink" title="11.1计算机并不如想象得那么精确"></a>11.1计算机并不如想象得那么精确</h3><p>数字电路机器无法准确表示小数。</p><h3 id="11-2-需要进行准确计算时避开浮点数运算"><a href="#11-2-需要进行准确计算时避开浮点数运算" class="headerlink" title="11.2 需要进行准确计算时避开浮点数运算"></a>11.2 需要进行准确计算时避开浮点数运算</h3><p>浮点数的特性决定其无法进行精确运算，它一直存在误差，比如1/3。</p><h3 id="11-3-double型比float型更适合精确计算"><a href="#11-3-double型比float型更适合精确计算" class="headerlink" title="11.3 double型比float型更适合精确计算"></a>11.3 double型比float型更适合精确计算</h3><p>Doublue型运算速度比float要快（相差无几）。</p><blockquote><p>要处理精度高的数值，可以用科学计算专用语言FORTRAN，或者用数组实现精度更高的实数运算。</p></blockquote><h3 id="11-4-确认整数型大小"><a href="#11-4-确认整数型大小" class="headerlink" title="11.4 确认整数型大小"></a>11.4 确认整数型大小</h3><p>大部分UNIX系列操作系统定义整数型大小为4字节（32位），PC常用操作系统定义整数型大小为2字节（16位），有的是4字节（32字节），事先最好确认整数型数据大小。</p><p>整数型大小也会影响程序的可移植性。</p><h3 id="11-5-必须明确计算单位"><a href="#11-5-必须明确计算单位" class="headerlink" title="11.5 必须明确计算单位"></a>11.5 必须明确计算单位</h3><p>最好在头注释和正文注释中全部记录计算单位，而且在变量声明部分和实际计算部分也再次标记计算单位。可以降低实际计算语句中误解单位的可能性，程序也会相应变得更加精确。</p><h3 id="11-6-特别留意除法运算"><a href="#11-6-特别留意除法运算" class="headerlink" title="11.6 特别留意除法运算"></a>11.6 特别留意除法运算</h3><p>要想正真理解除法运算，就要对编译器处理计算表达式的顺序烂熟于心。不同编译器对表达式的处理方法略有不同。</p><p><img src="/images/code128/p-16.jpg" alt="p-16.jpg"></p><p><img src="/images/code128/p-17.jpg" alt="p-17.jpg"></p><h3 id="11-7-尽量避免数据类型转换"><a href="#11-7-尽量避免数据类型转换" class="headerlink" title="11.7 尽量避免数据类型转换"></a>11.7 尽量避免数据类型转换</h3><p>数据类型的转换始终会存在风险。将高类型（长字节）转换为低类型（短字节）时，会损失一定的数据精度。如将double型转换为float型。还要特别注意是否存在隐式数据类型转换。</p><p>一种做法是保证相关变量都声明为相同数据类型，还有一种方法是在变量名前添加可表示数据类型的前缀。</p><h3 id="11-8-精通编程语言的语法"><a href="#11-8-精通编程语言的语法" class="headerlink" title="11.8 精通编程语言的语法"></a>11.8 精通编程语言的语法</h3><p>略显繁琐的语法往往能够决定整个程序。要想编写精确程序必须精通采用的编程语言的语法。</p><h3 id="11-9-留意可能出现的非线形计算结果"><a href="#11-9-留意可能出现的非线形计算结果" class="headerlink" title="11.9 留意可能出现的非线形计算结果"></a>11.9 留意可能出现的非线形计算结果</h3><p>计算机反复运算的结果可能远远偏离我们的预期。特别是涉及浮点数的话，这种现象尤为突出。</p><p>务必多次校验运算结果。</p><hr><h2 id="12-提升性能所需编码准则"><a href="#12-提升性能所需编码准则" class="headerlink" title="12.提升性能所需编码准则"></a>12.提升性能所需编码准则</h2><p>可拓展性、稳定性。</p><h3 id="12-1-重视性能，限制输出"><a href="#12-1-重视性能，限制输出" class="headerlink" title="12.1 重视性能，限制输出"></a>12.1 重视性能，限制输出</h3><p>最好支持用户可以自由设置程序运行时是否输出提示信息，也就是用户可以选择输出或不输出这些信息。</p><p>比如C语言中，负责格式化输出的<code>printf()</code>函数的运算成本要远高于其他运算。</p><h3 id="12-2-用简单形式改写运算表达式"><a href="#12-2-用简单形式改写运算表达式" class="headerlink" title="12.2 用简单形式改写运算表达式"></a>12.2 用简单形式改写运算表达式</h3><p>从C编译器处理运算层面来看，乘法运算成本高于加减法，除法运算成本又高于乘法，浮点数之间的运算成本高于整数型运算，成本最低的运算是位运算或者逻辑运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位运算、逻辑运算 &lt; 加减法运算 &lt; 乘法运算 &lt; 除法运算 &lt; 处理浮点数</span><br></pre></td></tr></table></figure><p>尽可能选择成本较低的运算。</p><h3 id="12-3-需要高效处理大文件时应使用二进制文件"><a href="#12-3-需要高效处理大文件时应使用二进制文件" class="headerlink" title="12.3 需要高效处理大文件时应使用二进制文件"></a>12.3 需要高效处理大文件时应使用二进制文件</h3><p>用C语言处理文件时，一般使用ASCII格式的文件，优点在于在任何地方都可以查看该文件，因为任何计算机都提供可以查看ASCII格式文件的命令或程序。<br>但是ASCII文件的读写速度要低于二进制文件，而且所占空间更大。</p><p>因此如果程序性能至关重要或需要节约存储空间，最好选用二进制文件而非ASCII文件。</p><h3 id="12-4-了解并使用压缩-未压缩结构体优缺点"><a href="#12-4-了解并使用压缩-未压缩结构体优缺点" class="headerlink" title="12.4 了解并使用压缩/未压缩结构体优缺点"></a>12.4 了解并使用压缩/未压缩结构体优缺点</h3><p>压缩结构体：使用位域减少所占空间大小的结构体。<br>为了节约内存空间，信号处理领域多采用压缩结构体，但压缩结构体会减慢程序运行速度，因为位域运算需要消耗大量时间。相反，未压缩结构体虽然占据较多内存，但与压缩结构体相比，处理速度更快，而且不使用位域会使程序更容易理解、更加明确。</p><p>如果没有限制栈大小或栈足够大，或者并不需要很多信号处理变量，那么最好采用未压缩结构体；如果栈大小受限或需要很多信号处理变量，则最好使用压缩结构体。</p><h3 id="12-5-根据运行环境选择编程语言"><a href="#12-5-根据运行环境选择编程语言" class="headerlink" title="12.5 根据运行环境选择编程语言"></a>12.5 根据运行环境选择编程语言</h3><p>比如C/C++写的程序可以在操作系统中直接运行，速度比Java或C#编写的程序更快，但C/C++在网络环境下相对有些力不从心。</p><p>选择何种编程语言对程序的影响程度远大于缩进等细枝末节的影响。</p><h3 id="12-6-根据情况选择手段"><a href="#12-6-根据情况选择手段" class="headerlink" title="12.6 根据情况选择手段"></a>12.6 根据情况选择手段</h3><p>能够选择与业务情况、系统情况相吻合的恰当方法处理问题的程序员更为可贵。</p><p>能够从语言提供的各种工具中挑选最合适的，并知道如何充分利用该工具才最重要。</p><h3 id="12-7-选择更优秀的数据结构"><a href="#12-7-选择更优秀的数据结构" class="headerlink" title="12.7 选择更优秀的数据结构"></a>12.7 选择更优秀的数据结构</h3><p>内存廉价且足够大的情况下，没有必要节约内存。有时需要处理的数据太多，超出数组可以承受的范围时应该选择数组以外的其他数据结构，比如链表。<br>应该根据情况选择合适的数据结构，程序员还可以用结构体、共用体和枚举定义并使用用户独有的数据结构，即用户自定义数据结构。</p><p>选用不同的数据结构决定了排序方式和排序性能。</p><hr><h2 id="13-编写易于理解的代码所需编码准则"><a href="#13-编写易于理解的代码所需编码准则" class="headerlink" title="13.编写易于理解的代码所需编码准则"></a>13.编写易于理解的代码所需编码准则</h2><p>可维护性。</p><h3 id="13-1-不要使用goto语句"><a href="#13-1-不要使用goto语句" class="headerlink" title="13.1 不要使用goto语句"></a>13.1 不要使用goto语句</h3><p>Goto语句更易上手和使用，但从程序易于理解和维护的角度来看，应该使用能够将逻辑块紧密联系的结构化程序设计方式，goto常常打乱程序逻辑。</p><h3 id="13-2-不要替换C语言组成要素"><a href="#13-2-不要替换C语言组成要素" class="headerlink" title="13.2 不要替换C语言组成要素"></a>13.2 不要替换C语言组成要素</h3><p>汉字编程或自定义代码形态。</p><h3 id="13-3-缩短过长数据类型名称"><a href="#13-3-缩短过长数据类型名称" class="headerlink" title="13.3 缩短过长数据类型名称"></a>13.3 缩短过长数据类型名称</h3><p>缩短过长的数据类型名，用更容易理解的名字重命名（与变量特性相吻合）。</p><h3 id="13-4-使用if语句而非三元运算符"><a href="#13-4-使用if语句而非三元运算符" class="headerlink" title="13.4 使用if语句而非三元运算符"></a>13.4 使用if语句而非三元运算符</h3><p>三元运算符有时更简洁，但容易导致代码难以理解。</p><h3 id="13-5-数组维数应限制在三维之内"><a href="#13-5-数组维数应限制在三维之内" class="headerlink" title="13.5 数组维数应限制在三维之内"></a>13.5 数组维数应限制在三维之内</h3><p>会导致难以理解和想象。</p><h3 id="13-6-考虑驱动函数main函数的作用"><a href="#13-6-考虑驱动函数main函数的作用" class="headerlink" title="13.6 考虑驱动函数main函数的作用"></a>13.6 考虑驱动函数main函数的作用</h3><p>Main函数是驱动函数，main函数调用的函数称为被动函数，main函数类似书的封面，应该记录各种程序信息以便日后其他人可以快速查找和更容易理解。</p><h3 id="13-7-将常量替换为符号常量或const形态常量"><a href="#13-7-将常量替换为符号常量或const形态常量" class="headerlink" title="13.7 将常量替换为符号常量或const形态常量"></a>13.7 将常量替换为符号常量或const形态常量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">const</span> sleepTime = <span class="number">18</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="keyword">const</span> INITIAL_AIRCON_DEGREE = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> AIRCON_DEGREE_STEP = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SLEEP_TIME = INITIAL_AIRCON_DEGREE + AIRCON_DEGREE_STEP;</span><br></pre></td></tr></table></figure><h3 id="13-8-考虑变量声明部分的顺序"><a href="#13-8-考虑变量声明部分的顺序" class="headerlink" title="13.8 考虑变量声明部分的顺序"></a>13.8 考虑变量声明部分的顺序</h3><p>顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户自定义数据类型</span><br><span class="line">多个程序共用的外部变量</span><br><span class="line">程序单元内部多个函数共用的全局变量</span><br><span class="line">只有对应函数才会用到的局部变量</span><br></pre></td></tr></table></figure></p><h3 id="13-9-尽可能不使用全局变量"><a href="#13-9-尽可能不使用全局变量" class="headerlink" title="13.9 尽可能不使用全局变量"></a>13.9 尽可能不使用全局变量</h3><p>扰乱程序逻辑、增大理解难度。</p><h3 id="13-10-遵循KISS原则"><a href="#13-10-遵循KISS原则" class="headerlink" title="13.10 遵循KISS原则"></a>13.10 遵循KISS原则</h3><p>Keep it simple and short。</p><ul><li>易于修复代码漏洞（debugging）</li><li>易于重构代码（refractoring）</li><li>易于维护代码（maintenance）</li><li>易于修复代码（rebuilding）</li><li>易于复用代码（reusing）</li></ul><hr><h2 id="14-用户接口处理相关编码准则"><a href="#14-用户接口处理相关编码准则" class="headerlink" title="14.用户接口处理相关编码准则"></a>14.用户接口处理相关编码准则</h2><p>可拓展性。</p><h3 id="14-1-确保保存输入值的变量足够大"><a href="#14-1-确保保存输入值的变量足够大" class="headerlink" title="14.1 确保保存输入值的变量足够大"></a>14.1 确保保存输入值的变量足够大</h3><p>与double相比应选择long double，与int型相比应用long int型声明变量。</p><h3 id="14-2-转换说明符和参数个数应保持一致"><a href="#14-2-转换说明符和参数个数应保持一致" class="headerlink" title="14.2 转换说明符和参数个数应保持一致"></a>14.2 转换说明符和参数个数应保持一致</h3><p>printf()的使用</p><h3 id="14-3-使用fgets-和sscanf-函数而非scanf-函数"><a href="#14-3-使用fgets-和sscanf-函数而非scanf-函数" class="headerlink" title="14.3 使用fgets()和sscanf()函数而非scanf()函数"></a>14.3 使用fgets()和sscanf()函数而非scanf()函数</h3><p>scanf()对文件末尾出现的EOF的处理并不稳定，有时会遗漏EOF。</p><blockquote><p>windows环境下，EOF对应的键盘输入值为<code>^Z(Ctrl+Z)</code>，UNIX中对应的是<code>^D(Ctrl+D)</code>。</p></blockquote><h3 id="14-4-使用fflush-函数清空标准输入-输出设备缓冲"><a href="#14-4-使用fflush-函数清空标准输入-输出设备缓冲" class="headerlink" title="14.4 使用fflush()函数清空标准输入/输出设备缓冲"></a>14.4 使用fflush()函数清空标准输入/输出设备缓冲</h3><p>可以将缓冲内容强制传递到输入/输出设备。</p><hr><h2 id="15-编写零漏洞代码所需编码准则"><a href="#15-编写零漏洞代码所需编码准则" class="headerlink" title="15.编写零漏洞代码所需编码准则"></a>15.编写零漏洞代码所需编码准则</h2><h3 id="15-1-数组下标应从0开始"><a href="#15-1-数组下标应从0开始" class="headerlink" title="15.1 数组下标应从0开始"></a>15.1 数组下标应从0开始</h3><p>从1开始对数组进行计数引起的错误又称大小差一（off-by-one）错误。</p><h3 id="15-2-置换字符串时必须使用括号"><a href="#15-2-置换字符串时必须使用括号" class="headerlink" title="15.2 置换字符串时必须使用括号"></a>15.2 置换字符串时必须使用括号</h3><h3 id="15-3-文件必须有开就有关"><a href="#15-3-文件必须有开就有关" class="headerlink" title="15.3 文件必须有开就有关"></a>15.3 文件必须有开就有关</h3><h3 id="15-4-不要无视编译器的警告错误"><a href="#15-4-不要无视编译器的警告错误" class="headerlink" title="15.4 不要无视编译器的警告错误"></a>15.4 不要无视编译器的警告错误</h3><ul><li>致命错误（fatal error）</li><li>警告错误（warning error）：也不能忽视</li></ul><h3 id="15-5-掌握并在编码时防止运行时错误"><a href="#15-5-掌握并在编码时防止运行时错误" class="headerlink" title="15.5 掌握并在编码时防止运行时错误"></a>15.5 掌握并在编码时防止运行时错误</h3><p>运行时错误不同于编译错误和逻辑错误，运行时错误与运行时环境紧密相关。</p><p>典型的运行时错误——栈溢出是由于操作系统限制栈的大小而产生的。最好在函数内部添加限制调用次数的龃龉。</p><p>还有一个典型的运行时错误就是除以0，特别是在循环中的“不小心”除以0。这需要细致检查程序所有可能的运行情况。</p><h3 id="15-6-用静态变量声明大数组"><a href="#15-6-用静态变量声明大数组" class="headerlink" title="15.6 用静态变量声明大数组"></a>15.6 用静态变量声明大数组</h3><p><img src="/images/code128/p-18.jpg" alt="p-18.jpg"></p><p>除特别用extern、static、register声明的变量外，其他变量均为自动变量。自动变量存储于以栈形态管理数据的内存。如果一个程序用到的所有自动变量的综合超出栈的大小，就会触发栈溢出进而导致程序异常终止。</p><p>输入声明为静态变量，那么数组的存放位置就是堆，而不是栈，也就不会出现栈溢出。</p><h3 id="15-7-预留足够大的存储空间"><a href="#15-7-预留足够大的存储空间" class="headerlink" title="15.7 预留足够大的存储空间"></a>15.7 预留足够大的存储空间</h3><p>可以预留2～3倍甚至更多字符串存储空间。</p><h3 id="15-8-注意信息交换引发的涌现效果"><a href="#15-8-注意信息交换引发的涌现效果" class="headerlink" title="15.8 注意信息交换引发的涌现效果"></a>15.8 注意信息交换引发的涌现效果</h3><p>程序单元之间进行信息交换的过程中，可能出现信息丢失，也可能新增荣誉信息。</p><p>涌现性指的是能够引起意想不到的效果的性质，是复杂系统相关研究领域非常常见的词汇。<br>目前没有可行的对策但存在一种沿用至今的解决方式，即系统层面的综合测试方法。以严格的综合测试为基础，可以在一定程度上发现并预防涌现性现象，这要求在测试过程中投入域软件开发过程同样多的资源。</p><hr><h2 id="16-提升生产效率所需编码准则"><a href="#16-提升生产效率所需编码准则" class="headerlink" title="16.提升生产效率所需编码准则"></a>16.提升生产效率所需编码准则</h2><p>可拓展性。</p><h3 id="16-1-在对立关系中事先确定侧重于哪一方"><a href="#16-1-在对立关系中事先确定侧重于哪一方" class="headerlink" title="16.1 在对立关系中事先确定侧重于哪一方"></a>16.1 在对立关系中事先确定侧重于哪一方</h3><p>对立关系指的是，选择两个策略性目标之一，则无法追求另一个目标的实现。比如使用位运算符有助于提高处理速度但同时会损坏系统安全。</p><p>这种对立关系中，侧重于哪一方面、牺牲哪一方面的选择在一定程度上与价值观有关。标准的做法是，应当事先规定在对立关系中选择侧重哪一方面。应该逐一列举处于对立关系的各个对象，从中选择更希望侧重的一个方面，并在项目流程中始终坚持自己的选择。</p><h3 id="16-2-慎重采用最新工具"><a href="#16-2-慎重采用最新工具" class="headerlink" title="16.2 慎重采用最新工具"></a>16.2 慎重采用最新工具</h3><p>始终以挑剔的眼光看待工具，寻找更好的扩展应用、更好的开发工具。但需要注意，应用新工具时需要慎重，不要仓促地应用新的工具或方法论，因为它们有可能起到反作用。锋利的斧子固然有用，但首先要具备能够挥动斧子的力量。</p><h3 id="16-3-记住所有标准库"><a href="#16-3-记住所有标准库" class="headerlink" title="16.3 记住所有标准库"></a>16.3 记住所有标准库</h3><p>要想使用某种编程语言，就应该牢记该编程语言提供的标准函数。</p><h3 id="16-4-最大程度划分模块"><a href="#16-4-最大程度划分模块" class="headerlink" title="16.4 最大程度划分模块"></a>16.4 最大程度划分模块</h3><p>积木。</p><p>设计系统或程序时，应该最大限度实现模块化，更小、更细的模块才更为重要。</p><h3 id="16-5-明确区分术语"><a href="#16-5-明确区分术语" class="headerlink" title="16.5 明确区分术语"></a>16.5 明确区分术语</h3><p>沟通顺畅才能有更高的生产效率，开发多人参与的项目前，应该先统一术语。</p><h3 id="16-6-明确区分结构体、枚举体、共用体"><a href="#16-6-明确区分结构体、枚举体、共用体" class="headerlink" title="16.6 明确区分结构体、枚举体、共用体"></a>16.6 明确区分结构体、枚举体、共用体</h3><p><img src="/images/code128/p-19.jpg" alt="p-19.jpg"></p><h3 id="16-7-明确区分概念"><a href="#16-7-明确区分概念" class="headerlink" title="16.7 明确区分概念"></a>16.7 明确区分概念</h3><p>比如对象和类。</p><h3 id="16-8-明确区分对象、类、实例"><a href="#16-8-明确区分对象、类、实例" class="headerlink" title="16.8 明确区分对象、类、实例"></a>16.8 明确区分对象、类、实例</h3><p><img src="/images/code128/p-20.jpg" alt="p-20.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《这样编码才规范-128个编码好习惯》&quot;&gt;&lt;a href=&quot;#《这样编码才规范-128个编码好习惯》&quot; class=&quot;headerlink&quot; title=&quot;《这样编码才规范 128个编码好习惯》&quot;&gt;&lt;/a&gt;《这样编码才规范 128个编码好习惯》&lt;/h1&gt;&lt;p&gt;此书
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编码" scheme="http://blog.michealwayne.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Vue3和React18源码片段1——shared</title>
    <link href="http://blog.michealwayne.cn/2022/04/16/react/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Vue3%E5%92%8CReact18%E6%BA%90%E7%A0%81%E7%89%87%E6%AE%B51%E2%80%94%E2%80%94shared/"/>
    <id>http://blog.michealwayne.cn/2022/04/16/react/【笔记】Vue3和React18源码片段1——shared/</id>
    <published>2022-04-16T15:39:18.000Z</published>
    <updated>2022-04-19T07:36:54.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-和-React18-源码片段1——shared"><a href="#Vue3-和-React18-源码片段1——shared" class="headerlink" title="Vue3 和 React18 源码片段1——shared"></a>Vue3 和 React18 源码片段1——shared</h1><p>最近在整合框架时，又一次涉及到了 Vue/React 相关源码，也包括<code>tarjs</code>、<code>raxjs</code>、<code>uni-app</code>等跨端 DSL，优秀的框架通常都会注重性能和代码执行细节，因此借此文/系列开始进行整理。</p><h2 id="代码来源"><a href="#代码来源" class="headerlink" title="代码来源"></a>代码来源</h2><ul><li>Vue3.2：<a href="https://github.com/vuejs/core/tree/3.2" target="_blank" rel="noopener">https://github.com/vuejs/core/tree/3.2</a></li><li>React18.0：<a href="https://github.com/facebook/react/releases/tag/v18.0.0" target="_blank" rel="noopener">https://github.com/facebook/react/releases/tag/v18.0.0</a></li></ul><h2 id="一、工具函数部分shared"><a href="#一、工具函数部分shared" class="headerlink" title="一、工具函数部分shared"></a>一、工具函数部分<code>shared</code></h2><h3 id="Vue：packages-shared"><a href="#Vue：packages-shared" class="headerlink" title="Vue：packages/shared"></a>Vue：<code>packages/shared</code></h3><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稳妥的类型判断方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> objectToString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toTypeString = (value: unknown): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">  objectToString.call(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array类型判断，很直接用了Array.isArray，也可以用`toTypeString`判断。*移动端兼容没问题，PC IE9起步，不过可以用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray</span><br><span class="line"></span><br><span class="line"><span class="comment">// toTypeString判断。*Map和Set都是安卓5起、IE11起步，可以用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isMap = (val: unknown): val is Map&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Map]'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isSet = (val: unknown): val is Set&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Set]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用了instanceof，根据原型判断。注意Date实例toTypeString的结果是`[object Object]`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isDate = (val: unknown): val is <span class="built_in">Date</span> =&gt; val <span class="keyword">instanceof</span> <span class="built_in">Date</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isFunction = (val: unknown): val is <span class="built_in">Function</span> =&gt;</span><br><span class="line">  <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isString = (val: unknown): val is <span class="built_in">string</span> =&gt; <span class="keyword">typeof</span> val === <span class="string">'string'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isSymbol = (val: unknown): val is symbol =&gt; <span class="keyword">typeof</span> val === <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的Object比较宽泛，除了Object、Array外，其他Set、Map等引用类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isObject = (val: unknown): val is Record&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  val !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// duck type，根据关键方法进行判断，所以包含这些属性方法也能过</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isPromise = &lt;T = <span class="built_in">any</span>&gt;(val: unknown): val is <span class="built_in">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格的对象比较</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isPlainObject = (val: unknown): val is object =&gt;</span><br><span class="line">  toTypeString(val) === <span class="string">'[object Object]'</span></span><br></pre></td></tr></table></figure><h4 id="数据信息判断"><a href="#数据信息判断" class="headerlink" title="数据信息判断"></a>数据信息判断</h4><p>正整数字符串的判断：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正整数字符串的判断，主要排除NaN、Infinity、负数等边界</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isIntegerKey = <span class="function">(<span class="params">key: unknown</span>) =&gt;</span></span><br><span class="line">  isString(key) &amp;&amp;</span><br><span class="line">  key !== <span class="string">'NaN'</span> &amp;&amp;</span><br><span class="line">  key[<span class="number">0</span>] !== <span class="string">'-'</span> &amp;&amp;</span><br><span class="line">  <span class="string">''</span> + <span class="built_in">parseInt</span>(key, <span class="number">10</span>) === key</span><br></pre></td></tr></table></figure></p><p>判断属性：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断属性key是否为对象数据val本身属性</span></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasOwn = (</span><br><span class="line">  val: object,</span><br><span class="line">  key: <span class="built_in">string</span> | symbol</span><br><span class="line">): key is keyof <span class="keyword">typeof</span> val =&gt; hasOwnProperty.call(val, key)</span><br></pre></td></tr></table></figure></p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>对象拓展/合并属性：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于拓展/合并属性。*Object.assign兼容移动端还好、PC IE11起步，可用Polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> extend = <span class="built_in">Object</span>.assign</span><br></pre></td></tr></table></figure></p><p>删除数组元素：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> remove = &lt;T&gt;<span class="function">(<span class="params">arr: T[], el: T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> i = arr.indexOf(el)</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    arr.splice(i, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字符串转数字：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理了NaN的边界</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toNumber = (val: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="built_in">parseFloat</span>(val)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? val : n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新旧值比较：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oldValue === oldValue主要考虑了NaN</span></span><br><span class="line"><span class="comment">// compare whether a value has changed, accounting for NaN.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasChanged = (value: <span class="built_in">any</span>, oldValue: <span class="built_in">any</span>): <span class="function"><span class="params">boolean</span> =&gt;</span></span><br><span class="line">  value !== oldValue &amp;&amp; (value === value || oldValue === oldValue)</span><br></pre></td></tr></table></figure></p><p>处理HTML转义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @from escapeHtml.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> escapeRE = <span class="regexp">/["'&amp;&lt;&gt;]/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params"><span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">''</span> + <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">const</span> match = escapeRE.exec(str)<span class="comment">// 匹配值将进行转义替换</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> escaped</span><br><span class="line">  <span class="keyword">let</span> index</span><br><span class="line">  <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (index = match.index; index &lt; str.length; index++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (str.charCodeAt(index)) &#123;<span class="comment">// 根据 Unicode 编码进行判断</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">34</span>: <span class="comment">// "</span></span><br><span class="line">        escaped = <span class="string">'&amp;quot;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">38</span>: <span class="comment">// &amp;</span></span><br><span class="line">        escaped = <span class="string">'&amp;amp;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">39</span>: <span class="comment">// '</span></span><br><span class="line">        escaped = <span class="string">'&amp;#39;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">60</span>: <span class="comment">// &lt;</span></span><br><span class="line">        escaped = <span class="string">'&amp;lt;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">62</span>: <span class="comment">// &gt;</span></span><br><span class="line">        escaped = <span class="string">'&amp;gt;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex !== index) &#123;</span><br><span class="line">      html += str.substring(lastIndex, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastIndex = index + <span class="number">1</span></span><br><span class="line">    html += escaped</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lastIndex !== index ? html + str.substring(lastIndex, index) : html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://www.w3.org/TR/html52/syntax.html#comments</span></span><br><span class="line"><span class="keyword">const</span> commentStripRE = <span class="regexp">/^-?&gt;|&lt;!--|--&gt;|--!&gt;|&lt;!-$/g</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHtmlComment</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src.replace(commentStripRE, <span class="string">''</span>)<span class="comment">// 删除html注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据比较：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @from looseEqual.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isArray, isDate, isObject &#125; <span class="keyword">from</span> <span class="string">'./'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looseCompareArrays</span>(<span class="params">a: <span class="built_in">any</span>[], b: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length !== b.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> equal = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; equal &amp;&amp; i &lt; a.length; i++) &#123;</span><br><span class="line">    equal = looseEqual(a[i], b[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> equal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较严格的比较</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> aValidType = isDate(a)</span><br><span class="line">  <span class="keyword">let</span> bValidType = isDate(b)</span><br><span class="line">  <span class="comment">// Date数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="keyword">return</span> aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  aValidType = isArray(a)</span><br><span class="line">  bValidType = isArray(b)</span><br><span class="line">  <span class="comment">// Array数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="keyword">return</span> aValidType &amp;&amp; bValidType ? looseCompareArrays(a, b) : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  aValidType = isObject(a)</span><br><span class="line">  bValidType = isObject(b)</span><br><span class="line">  <span class="comment">// Object数据类型比较</span></span><br><span class="line">  <span class="keyword">if</span> (aValidType || bValidType) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if: this if will probably never be called */</span></span><br><span class="line">    <span class="keyword">if</span> (!aValidType || !bValidType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> aKeysCount = <span class="built_in">Object</span>.keys(a).length</span><br><span class="line">    <span class="keyword">const</span> bKeysCount = <span class="built_in">Object</span>.keys(b).length</span><br><span class="line">    <span class="keyword">if</span> (aKeysCount !== bKeysCount) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">      <span class="keyword">const</span> aHasKey = a.hasOwnProperty(key)</span><br><span class="line">      <span class="keyword">const</span> bHasKey = b.hasOwnProperty(key)</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (aHasKey &amp;&amp; !bHasKey) ||</span><br><span class="line">        (!aHasKey &amp;&amp; bHasKey) ||</span><br><span class="line">        !looseEqual(a[key], b[key])</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// NaN</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIndexOf</span>(<span class="params">arr: <span class="built_in">any</span>[], val: <span class="built_in">any</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> looseEqual(item, val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="React：packages-shared"><a href="#React：packages-shared" class="headerlink" title="React：packages/shared"></a>React：<code>packages/shared</code></h3><p>React 的 shared 模块更为松散。</p><h4 id="类型判断-1"><a href="#类型判断-1" class="headerlink" title="类型判断"></a>类型判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>isArray.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flow声明</span></span><br><span class="line">declare function isArray(a: mixed): boolean %checks(Array.isArray(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实也是用了Array.isArray</span></span><br><span class="line"><span class="keyword">const</span> isArrayImpl = <span class="built_in">Array</span>.isArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证类型</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line no-redeclare</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">a: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isArrayImpl(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> isArray;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>ReactSymbols.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MAYBE_ITERATOR_SYMBOL = <span class="built_in">Symbol</span>.iterator;</span><br><span class="line"><span class="keyword">const</span> FAUX_ITERATOR_SYMBOL = <span class="string">'@@iterator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为迭代器函数，也是根据关键属性函数进行判断</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getIteratorFn</span>(<span class="params">maybeIterable: ?any</span>): ?(<span class="params"></span>) =&gt; ?<span class="title">Iterator</span>&lt;*&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maybeIterable === <span class="literal">null</span> || <span class="keyword">typeof</span> maybeIterable !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> maybeIterator =</span><br><span class="line">    (MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span><br><span class="line">    maybeIterable[FAUX_ITERATOR_SYMBOL];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> maybeIterator === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> maybeIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据信息判断-1"><a href="#数据信息判断-1" class="headerlink" title="数据信息判断"></a>数据信息判断</h4><p>属性判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>hasOwnProperty.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hasOwnProperty;</span><br></pre></td></tr></table></figure></p><h4 id="环境信息判断"><a href="#环境信息判断" class="headerlink" title="环境信息判断"></a>环境信息判断</h4><p>是否为DOM环境：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>ExecutionEnvironment.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> canUseDOM: boolean = !!(</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.document !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.document.createElement !== <span class="string">'undefined'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a>数据处理</h4><p>对象拓展/合并：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>assign.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟Vue中extend函数一样</span></span><br><span class="line"><span class="keyword">const</span> assign = <span class="built_in">Object</span>.assign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> assign;</span><br></pre></td></tr></table></figure></p><p>数据比较：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>objectIs.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算是Object.is的polyfill</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x: any, y: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">// 后面的比较主要区分+0和-0</span></span><br><span class="line">    (x === y &amp;&amp; (x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y)) || (x !== x &amp;&amp; y !== y) <span class="comment">// eslint-disable-line no-self-compare</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.is iOS9/安卓5起支持，IE不兼容</span></span><br><span class="line"><span class="keyword">const</span> objectIs: <span class="function">(<span class="params">x: any, y: any</span>) =&gt;</span> boolean =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">Object</span>.is === <span class="string">'function'</span> ? <span class="built_in">Object</span>.is : is;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> objectIs;</span><br></pre></td></tr></table></figure></p><p>浅比较：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from </span>shallowEqual.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> is <span class="keyword">from</span> <span class="string">'./objectIs'</span>;</span><br><span class="line"><span class="keyword">import</span> hasOwnProperty <span class="keyword">from</span> <span class="string">'./hasOwnProperty'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs equality by iterating through keys on an object and returning false</span></span><br><span class="line"><span class="comment"> * when any key has values which are not strictly equal between the arguments.</span></span><br><span class="line"><span class="comment"> * Returns true when the values of all keys are strictly equal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据键数量先排除一波</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for A's keys different from B.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentKey = keysA[i];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call(objB, currentKey) ||</span><br><span class="line">      !is(objA[currentKey], objB[currentKey])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> shallowEqual;</span><br></pre></td></tr></table></figure></p><hr><p>二、标识处理</p><h3 id="Vue：Patch-flag"><a href="#Vue：Patch-flag" class="headerlink" title="Vue：Patch flag"></a>Vue：<code>Patch flag</code></h3><p>Vue3的静态标记是diff性能优化的一个手段、主要是在与上次 virtual DOM 比较时，只对比带有Patch Flag的节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from patchFlags.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务内容不是本文关注的，</span></span><br><span class="line"><span class="comment">// 这里使用了掩码来避免比较冲突，对大部分前端同学来说其实比较陌生，</span></span><br><span class="line"><span class="comment">// 可见之前记录的位运算笔记：http://blog.michealwayne.cn/2019/10/29/notes/js%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/</span></span><br><span class="line"><span class="comment">// ShapeFlags.ts也用了相同的方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> PatchFlags &#123;</span><br><span class="line"></span><br><span class="line">  TEXT = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">// 32</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React：Symbol-Flag"><a href="#React：Symbol-Flag" class="headerlink" title="React：Symbol Flag"></a>React：<code>Symbol Flag</code></h3><p>React16起，源码中的大多判断处理就依赖与Symbol常量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from ReactSymbols.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol内存占用小，也有不重复、“私有”的特点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_ELEMENT_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PORTAL_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.portal'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_FRAGMENT_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.fragment'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_STRICT_MODE_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.strict_mode'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PROFILER_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.profiler'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_PROVIDER_TYPE = <span class="built_in">Symbol</span>.for(<span class="string">'react.provider'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @from ReactTypes.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type ReactProvider&lt;T&gt; = &#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span> | number,<span class="comment">// 用Symbol可以避免一些如注入类的安全风险</span></span><br><span class="line">  type: ReactProviderType&lt;T&gt;,</span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    children?: ReactNodeList,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>从 <code>shared</code> 包中就不难发现，<code>shared</code>承担高频工具函数、标识和通用处理，也是整个框架中至关重要的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue3-和-React18-源码片段1——shared&quot;&gt;&lt;a href=&quot;#Vue3-和-React18-源码片段1——shared&quot; class=&quot;headerlink&quot; title=&quot;Vue3 和 React18 源码片段1——shared&quot;&gt;&lt;/a&gt;Vu
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://blog.michealwayne.cn/tags/React/"/>
    
      <category term="Vue" scheme="http://blog.michealwayne.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【应用】web内存分析手段及自动化方案</title>
    <link href="http://blog.michealwayne.cn/2022/03/06/notes/web%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.michealwayne.cn/2022/03/06/notes/web内存分析及工具/</id>
    <published>2022-03-06T12:20:06.000Z</published>
    <updated>2022-12-27T12:57:00.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web内存分析及工具"><a href="#web内存分析及工具" class="headerlink" title="web内存分析及工具"></a>web内存分析及工具</h1><p>js 自带 GC（垃圾回收）机制，因此绝大多数 web 开发人员不会在日常开发中考虑内存情况（包括我自己），在多数业务场景中，这可能没有问题，但在一些核心web应用场景下（比如某个页面投放在一级tab下这种 WebView 基本不会销毁的场景，或者像 PhoneGap / Electron 这种以 WebView 渲染为主的应用），会造成一些白屏崩溃这种意想不到的bug，影响用户体验。</p><blockquote><p>*文中大多三方链接需要翻墙访问</p></blockquote><h2 id="内存泄漏的影响"><a href="#内存泄漏的影响" class="headerlink" title="内存泄漏的影响"></a>内存泄漏的影响</h2><p>对于用户来说，一般内存泄漏场景根本感知不到，但是一旦内存泄漏比较严重，用户的直观感觉就是页面/电脑开始操作卡顿、直到某一时刻彻底卡死或者页面/应用崩溃闪退，这种情况下会让用户对你的产品丧失信任感。</p><ul><li>PC 浏览器：浏览器卡顿、甚至崩溃</li><li>iOS：早期 UIWebView 由于与 app 共享内存空间， 会容易导致app/浏览器卡顿、白屏、甚至崩溃，甚至 input 传个大图/文件如果处理不当就直接崩；之后 WKWebView 虽然优化了 WebView 内存及管理，但仍存在很多bug，加上 iPhone 本身内存空间较小，综合起来还是容易出现卡顿、白屏、甚至崩溃问题；</li><li>安卓：相比 iPhone，安卓设备通常内存空间较大，且 WebView 的内存分配更足，这为 WebView 的稳定性提供了一些帮助，但是安卓由于生态混乱，加上引擎等对 js 支持的问题，会导致很多奇葩问题，更容易出现内存泄漏。容易出现卡顿、白屏、甚至崩溃问题；</li></ul><p>相比于 PC 端，移动端硬件条件往往较为落后，并且 WebView 环境和内存限制也更为严格。并且移动端由于存在系统限制，不像PC端能方便进行浏览器更新/切换，因此更难以通过环境改善进行WebView管理优化，因此移动端的内存问题会更为严重，需要得到足够的重视。</p><blockquote><p>通常 PC 端通过代码或引导浏览器更新/切换来减少内存问题，PC 应用也可以更新内核来优化环境，总体成本较小。移动端主流的优化手段就是优化内核/内存管理，有能力/有切实需求的往往会自研内核以减少内存问题，像很多安卓应用会基于 QQX5 进行改造，这些成本也往往较大并且还有宿主环境的限制要求。关于内存优化及管理本文就不做具体说明了。</p></blockquote><h3 id="SPA-页面需要更加关注"><a href="#SPA-页面需要更加关注" class="headerlink" title="SPA 页面需要更加关注"></a>SPA 页面需要更加关注</h3><p>在 SPA 页面中，内存并不会在每次导航切换时自动清除，相比于 MPA 更容易引发内存泄漏。因此SPA中事件监听、DOM操作、网络请求、定时器等都需要更加关注。</p><hr><p>真机内存检测</p><h2 id="最通用的检测手段——Chrome-DevTool"><a href="#最通用的检测手段——Chrome-DevTool" class="headerlink" title="最通用的检测手段——Chrome DevTool"></a>最通用的检测手段——Chrome DevTool</h2><h3 id="1-“任务管理器”——查看整体情况"><a href="#1-“任务管理器”——查看整体情况" class="headerlink" title="1.“任务管理器”——查看整体情况"></a>1.<code>“任务管理器”</code>——查看整体情况</h3><p>入口为 Chrome 右上角<code>设置 - 更多工具 - 任务管理器</code>（<code>Setting - More Tools - Task Manager</code>）。</p><p><img src="/images/webMemory/p-chrome-1.png" alt="p-chrome-1"></p><p>并且我们可以通过右键菜单选择需要展示的字段：</p><p><img src="/images/webMemory/p-chrome-2.png" alt="p-chrome-2"></p><p>其中字段说明：</p><ul><li>任务：<code>Task</code></li><li>个人资料：<code>Profile</code></li><li>内存占用空间：<code>Memory Footprint</code></li><li>CPU</li><li>网络：<code>Network</code></li><li>进程ID：<code>Process ID</code></li><li>图片缓存：<code>Image Cache</code></li><li>脚本缓存：<code>Script Cache</code></li><li>CSS缓存：<code>CSS Cache</code></li><li>GPU缓存：<code>GPU Memory</code></li><li>SQLite使用的内存：<code>SQLite Memory</code></li><li>NaCI调试端口：<code>NaCI Debug Port</code></li><li>JavaScript 使用的内存：<code>JavaScript Memory</code></li><li>闲置状态唤醒：<code>Idle Wake Ups</code></li><li>文件描述符：<code>File Descriptors</code></li><li>进程优先级：<code>Process Priority</code></li><li>正在使用相应拓展程序的活动数：<code>Keepalive Count</code></li></ul><h3 id="2-Performance——js-Heap-查看时间轴上的内存变化情况"><a href="#2-Performance——js-Heap-查看时间轴上的内存变化情况" class="headerlink" title="2.Performance——js Heap 查看时间轴上的内存变化情况"></a>2.<code>Performance</code>——<code>js Heap</code> 查看时间轴上的内存变化情况</h3><p>Performance 大家会用的相对多些，只要我们勾选了 <code>Memory</code> 便可以增加内存的变化统计。</p><p><img src="/images/webMemory/p-chrome-3.png" alt="p-chrome-3"></p><h4 id="Recorder，结合用户事件进行记录"><a href="#Recorder，结合用户事件进行记录" class="headerlink" title="*Recorder，结合用户事件进行记录"></a>*Recorder，结合用户事件进行记录</h4><p>Chrome 97开始支持（大约是在2021.10），可以作为 Performance 的 plus 版，增加了用户操作等相关的事件记录，以更好得定位具体操作场景：</p><p><img src="/images/webMemory/p-chrome-7.png" alt="p-chrome-7"></p><p><img src="/images/webMemory/p-chrome-8.png" alt="p-chrome-8"></p><blockquote><p>官网使用介绍：<a href="https://developer.chrome.com/docs/devtools/recorder/" target="_blank" rel="noopener">《Chrome Developers——Record, replay and measure user flows》</a></p></blockquote><h3 id="3-Memory-——查看某段-一时刻内存具体快照信息"><a href="#3-Memory-——查看某段-一时刻内存具体快照信息" class="headerlink" title="3.Memory ——查看某段/一时刻内存具体快照信息"></a>3.<code>Memory</code> ——查看某段/一时刻内存具体快照信息</h3><p>真要定位内存问题，这是必不可少的工具，它的使用也比较简单。</p><p><img src="/images/webMemory/p-chrome-4.png" alt="p-chrome-4"></p><p>选择模式：</p><ul><li><code>Heap snapshot</code>：堆快照，用以打印堆快照，堆快照文件显示页面的 js 对象和相关 DOM 节点之间的内存分配；</li><li><code>Allocation instrumentation on timeline</code>: 在时间轴上记录内存信息，随着时间变化记录内存信息；</li><li><code>Allocation sampling</code>： 内存信息采样，使用采样的方法记录内存分配。此配置文件类型具有最小的性能开销，可用于长时间运行的操作。它提供了由 js 执行堆栈细分的良好近似值分配。</li></ul><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>选择模式进行快照后，可通过右上选择模块进行筛选：</p><ul><li>快照查看方式：默认<code>Summary</code><ul><li><code>Summary</code>： 可以显示按构造函数名称分组的对象。使用此视图可以根据按构造函数名称分组的类型深入了解对象（及其内存使用），适用于跟踪 DOM 泄漏。</li><li><code>Comparison</code>： 可以显示两个快照之间的不同。使用此视图可以比较两个（或多个）内存快照在某个操作前后的差异。检查已释放内存的变化和参考计数，可以确认是否存在内存泄漏及其原因。</li><li><code>Containment</code>： 此视图提供了一种对象结构视图来分析内存使用，由顶级对象作为入口。</li><li><code>Statistic</code>：内存使用饼状的统计图。</li></ul></li><li>对象归类的筛选：对<code>Constructor</code>的筛选</li><li>对象选择：默认<code>All objects</code></li></ul><h4 id="展示字段"><a href="#展示字段" class="headerlink" title="展示字段"></a>展示字段</h4><p>表中展示字段的说明：</p><ul><li><code>Contructor</code>：表示使用此构造函数创建的所有对象</li><li><code>Distance</code>：显示使用节点最短简单路径时距根节点的距离</li><li><code>Shallow Size</code>： 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大）</li><li><code>Retained Size</code>： 显示同一组对象中最大的保留大小。某个对象删除后（其依赖项不再可到达）可以释放的内存大小称为保留大小。</li><li><code>New</code>：（Comparison 特有）新增项</li><li><code>Deleted</code>：（Comparison 特有）删除项</li><li><code>Delta</code>：（Comparison 特有）增量</li><li><code>Alloc. Size</code>：（Comparison 特有）内存分配大小</li><li><code>Freed Size</code>：（Comparison 特有）释放大小</li><li><code>Size Delta</code>：（Comparison 特有）内存增量</li></ul><blockquote><p>官网术语解释：<a href="https://developer.chrome.com/docs/devtools/memory-problems/memory-101/" target="_blank" rel="noopener">《Chrome Developers——Memory terminology》</a></p></blockquote><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p><code>ctrl/command + F</code> 唤醒搜索，根据关键字进行筛选</p><p><img src="/images/webMemory/p-chrome-5.png" alt="p-chrome-5"></p><h3 id="4-Performance-monitor——简易查看"><a href="#4-Performance-monitor——简易查看" class="headerlink" title="4.Performance monitor——简易查看"></a>4.<code>Performance monitor</code>——简易查看</h3><p><img src="/images/webMemory/p-chrome-6.png" alt="p-chrome-6"></p><p>Performance monitor 是实时的，但是没办法看到细节信息。</p><p>Chrome排查内存的手段和场景还有很多，如</p><ul><li>检查ArrayBuffer<a href="https://developer.chrome.com/docs/devtools/memory-inspector/" target="_blank" rel="noopener">《Chrome Developers——Inspect JavaScript ArrayBuffer with the Memory inspector》</a></li></ul><hr><h2 id="移动端——Chrome-Safari"><a href="#移动端——Chrome-Safari" class="headerlink" title="移动端——Chrome/Safari"></a>移动端——Chrome/Safari</h2><p>相比于PC，移动端真机调试一直是比较麻烦的，特别是内存分析难以像样式调试这种可以借助一些 socket 连接手段（<a href="https://caniuse.com/mdn-api_performance_memory" target="_blank" rel="noopener">Performance Memory</a>兼容拉跨），所以要查看移动端页面的真实内存使用情况需要设备/环境帮助。</p><h3 id="iOS——Safari"><a href="#iOS——Safari" class="headerlink" title="iOS——Safari"></a>iOS——Safari</h3><p>有线，需要有一台 iPhone 、Mac 和数据线。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.确认手机设置（<code>设置</code> -&gt; <code>Safari</code> -&gt; <code>高级</code> -&gt; <code>Web检查器</code>为打开状态）；</li><li>2.USB连接真机；</li><li>3.确认设备信任；</li><li>4.手机和电脑都打开Safari；</li><li>5.Safari菜单中<code>开发</code>-<code>XXX 的 iPhone</code>，点击开始调试。</li></ul><p>注意如果要看时间线的内存变化，菜单选择为<code>时间线</code>、左侧编程选中<code>内存</code>模块，如：</p><p><img src="/images/webMemory/p-safari-1.png" alt="p-safari-1.jpg"></p><blockquote><p>特别提醒，要查看内存情况的话最好只选择<code>内存</code>一个指标模块，有多个指标选择的话容易 Safari 崩溃闪退。</p></blockquote><blockquote><p>*iOS 也能通过 ios-webkit-debug-proxy 然后使用 Chrome 进行调试，本身机制也是通过创建代理服务器与 Chrome 进行连接，可参考这篇文章：<a href="https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7" target="_blank" rel="noopener">《How to debug remote iOS device using Chrome DevTools》</a></p></blockquote><h3 id="安卓-鸿蒙——Chrome-Android-Studio"><a href="#安卓-鸿蒙——Chrome-Android-Studio" class="headerlink" title="安卓/鸿蒙——Chrome/Android Studio"></a>安卓/鸿蒙——Chrome/Android Studio</h3><p>与iOS调试比较类似，有线，需要有一台 安卓手机 、Windows/Mac电脑 和数据线。</p><blockquote><p>Chrome官方说明：<a href="https://developer.chrome.com/docs/devtools/remote-debugging/" target="_blank" rel="noopener">《Chrome Developers——Remote debug Android devices》</a></p></blockquote><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.确认手机设置（<code>开发者模式</code>打开 -&gt; <code>USB调试</code>打开状态）；</li><li>2.USB连接真机；</li><li>3.确认设备信任；</li><li>4.手机和电脑都打开 Chrome；</li><li>5.PC Chrome访问<code>chrome://inspect</code>：确认连接状态<br>  <img src="/images/webMemory/p-dchrome-1.png" alt="p-dchrome-1.jpg"></li><li>6.选择对应页面的’inspect’进行访问<br>  <img src="/images/webMemory/p-dchrome-2.png" alt="p-dchrome-2.jpg"></li></ul><p>Android Studio 的调试模式与 Chrome 类似，也依赖 Chrome，操作可以参考<a href="https://raygun.com/blog/debug-android-chrome/" target="_blank" rel="noopener">《How to debug Android Chrome from Windows, Linux, or Mac——Install Android Debug Bridge (ADB)》</a></p><blockquote><p>特别提醒：如果通过<code>&#39;inspect&#39;</code>进行访问时，发现调试控制台始终空白或者404，大概率为控制台涉及的js文件加载失败，大部分js文件需要翻墙访问，这时候需要翻一下。</p></blockquote><h4 id="有没有不用插线的远程方法"><a href="#有没有不用插线的远程方法" class="headerlink" title="有没有不用插线的远程方法"></a>有没有不用插线的远程方法</h4><p>有，但是需要设备在一个网段。在开发电脑上建立个 Web 服务器并托管一个站点，然后从 Android 设备访问内容。具体可以查看文档说明：<a href="https://developer.chrome.com/docs/devtools/remote-debugging/local-server/" target="_blank" rel="noopener">《Chrome Developers——Access local servers》</a></p><h3 id="app内页面"><a href="#app内页面" class="headerlink" title="app内页面"></a>app内页面</h3><p>一般通用的方案就是装 debug app，然后可以通过 IDE debug 或者再借助 Safari/Chrome。这种方式的主要问题就是有 debug 包及环境的要求；<br>要么就是用客户端开发的模拟器进行排查。这种方式的主要问题就是因为是模拟环境，与真实环境有一定区别；<br>要么就是客户端提供控制台，将内存信息放到控制台中展示，如滴滴的<a href="https://github.com/didi/DoraemonKit" target="_blank" rel="noopener">DoraemonKit</a>，但要注意，iOS 现在 App 基本会用 WKWebView，这种情况下客户端是拿不到页面（WebView）的内存信息的（因为系统共享 WebView 虚拟内存），因此像 DoraemonKit 的内存模块也是无法观察页面内存情况，这时候的方案就是获取整个设备的内存信息，通过观察设备内存变化来进行判断，缺点就是难以保证其他应用及系统的影响；</p><p>iOS 开发获取内存的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前app消耗的内存，注意捕获不了WebView的内存消耗</span><br><span class="line">+ (NSUInteger)useMemoryForApp &#123;</span><br><span class="line">  task_vm_info_data_t vmInfo;</span><br><span class="line">  mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">  kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">  if (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">    int64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;</span><br><span class="line">return memoryUsageInByte / 1024 / 1024;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取整个设备的内存情况</span><br><span class="line">+ (NSUInteger)totalMemoryForDevice &#123;</span><br><span class="line">  return [NSProcessInfo processInfo].physicalMemory / 1024 / 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="js-VM"><a href="#js-VM" class="headerlink" title="*js VM"></a>*js VM</h4><p>最后还有一种方式就是利用Chrome和服务器搭建一套js VM 调试生态，如下小程序开发者工具也是这种模式，有兴趣可以看下Chrome DevTools Protocol： <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">https://chromedevtools.github.io/devtools-protocol/</a></p><h3 id="小程序——开发者工具"><a href="#小程序——开发者工具" class="headerlink" title="小程序——开发者工具"></a>小程序——开发者工具</h3><p>像微信/支付宝的小程序开发者工具，通常都较好得利用了Chrome 67起支持的<a href="https://developer.chrome.com/blog/new-in-devtools-67/#vm" target="_blank" rel="noopener">js VM内存工具</a>，因此可以非常方便得远程进行真机内存分析。</p><p><img src="/images/webMemory/p-weapp-1.png" alt="p-weapp-1.jpg"></p><hr><p>另外，借助 Puppeteer，我们可以做到内存检测的自动化</p><h2 id="快速手段——FuiteJs"><a href="#快速手段——FuiteJs" class="headerlink" title="快速手段——FuiteJs"></a>快速手段——FuiteJs</h2><p>github地址：<a href="https://github.com/nolanlawson/fuite" target="_blank" rel="noopener">https://github.com/nolanlawson/fuite</a></p><p>Fuite是一个 js 写的 cli 工具，它基于 <a href="https://pptr.dev/" target="_blank" rel="noopener">Puppeteer</a> 分析页面是否存在内存泄漏，对SPA友好</p><blockquote><p>注意：Fuite需要 nodejs v14.14.0及以上的环境，（目前 nodejs 稳定版在16+）</p></blockquote><h3 id="原理机制"><a href="#原理机制" class="headerlink" title="原理机制"></a>原理机制</h3><p>Fuite 比较简单，主要通过监控路由跳转来判断是否存在内存泄漏：</p><ul><li>1.使用 Puppeteer 打开对于参数的页面；</li><li>2.找到页面中所有路由页面并打开；</li><li>3.模拟后退（路由返回）；</li><li>4.重复（默认为7次）以确认是否存在内存泄漏。整个库的主要逻辑处理就是这块。判断依据：<ul><li>Objects：对象（Chrome heap snapshots）</li><li>Event listeners：事件监听</li><li>DOM节点</li><li>Arrays, Maps, Sets、普通Object</li></ul></li></ul><p>如果 Fuite 发现存在泄漏情况，它将在控制台或者 output文件中展示信息。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h4><p>安装及测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx fuite https://blog.michealwayne.cn</span><br></pre></td></tr></table></figure><p>使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuite [options] &lt;url&gt;</span><br></pre></td></tr></table></figure></p><p>参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url                        URL to load in the browser and analyze</span><br></pre></td></tr></table></figure></p><p>其中Options:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-o, --output &lt;file&gt;        Write JSON output to a file</span><br><span class="line">-i, --iterations &lt;number&gt;  Number of iterations (default: 7)</span><br><span class="line">-s, --scenario &lt;scenario&gt;  Scenario file to run</span><br><span class="line">-S, --setup &lt;setup&gt;        Setup function to run</span><br><span class="line">-H, --heapsnapshot         Save heapsnapshot files</span><br><span class="line">-d, --debug                Run in debug mode</span><br><span class="line">-p, --progress             Show progress spinner (use --no-progress to disable)</span><br><span class="line">-b, --browser-arg &lt;arg&gt;    Arg(s) to pass when launching the browser</span><br><span class="line">-V, --version              output the version number</span><br><span class="line">-h, --help                 display help for command</span><br></pre></td></tr></table></figure></p><h4 id="引用式"><a href="#引用式" class="headerlink" title="引用式"></a>引用式</h4><pre><code class="js"><span class="keyword">import</span> { findLeaks } <span class="keyword">from</span> <span class="string">'fuite'</span>;<span class="keyword">const</span> myScenario = {  <span class="keyword">async</span> setup(page) { <span class="comment">/* ... */</span> },            <span class="comment">// 默认无</span>  <span class="keyword">async</span> createTests(page) { <span class="comment">/* ... */</span> },    <span class="comment">// 默认拿href</span>  <span class="keyword">async</span> iteration(page, data) { <span class="comment">/* ... */</span> }    <span class="comment">// 默认为页面后退的往返</span>};<span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> result <span class="keyword">of</span> findLeaks(<span class="string">'https://blog.michealwayne.cn'</span>, {  scenario: myScenario,        <span class="comment">// scenario参数可选，默认为defaultScenario</span>})) {  <span class="built_in">console</span>.log(result);}</code></pre><blockquote><p>有意思的是，Fuite 的作者用 Fuite 对10个前端主流框架的主页进行了测试，发现都存在泄漏问题（作者在统计中隐藏了具体名称，有兴趣可以试一下）：</p></blockquote><p><img src="/images/webMemory/p-author-page-1.png" alt="p-author-page-1.jpg"></p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>我们可以扩展延伸 Fuite 的功能和使用场景，以更好地服务业务内存检测：</p><ul><li>1.服务化：我们可以将 Fuite 放在服务器，通过配置化进行定时检查，以及对应的异常报警等，将内存检测服务化、平台化；</li><li>2.集群处理：使用 Fuite 通常耗时会比较久，如果有多个地址需要检测的话建议起多进程集群进行分开检测；</li><li>3.改造：Fuite 逻辑是获取页面中所有路由进行检测，我们可以调整筛选控制，并且对 MPA 的处理进行业务优化，以提升检测效率和覆盖率。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>并非所有内存泄漏都是需要解决的问题，如 v8 的 JIT 也会导致内存增长，但作为 web 开发者，我们有义务通过工具方法找出业务中所有内存泄漏的场景。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://developer.chrome.com/docs/devtools/open/" target="_blank" rel="noopener">https://developer.chrome.com/docs/devtools/open/</a></li><li><a href="https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/" target="_blank" rel="noopener">https://nolanlawson.com/2021/12/17/introducing-fuite-a-tool-for-finding-memory-leaks-in-web-apps/</a></li><li><a href="https://developer.chrome.com/docs/devtools/memory-problems/" target="_blank" rel="noopener">https://developer.chrome.com/docs/devtools/memory-problems/</a></li><li><a href="https://github.com/nolanlawson/fuite" target="_blank" rel="noopener">https://github.com/nolanlawson/fuite</a></li><li><a href="https://developer.chrome.com/blog/new-in-devtools-67/" target="_blank" rel="noopener">https://developer.chrome.com/blog/new-in-devtools-67/</a></li><li><a href="https://gilfink.medium.com/help-my-memory-is-leaking-bf5dcaf83fc6" target="_blank" rel="noopener">https://gilfink.medium.com/help-my-memory-is-leaking-bf5dcaf83fc6</a></li><li><a href="https://chromedevtools.github.io/" target="_blank" rel="noopener">https://chromedevtools.github.io/</a></li><li><a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">https://chromedevtools.github.io/devtools-protocol/</a></li><li><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="noopener">https://github.com/google/ios-webkit-debug-proxy</a></li><li><a href="https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7" target="_blank" rel="noopener">https://medium.com/@nikoloza/how-to-debug-remote-ios-device-using-chrome-devtools-f44d697003a7</a></li><li><a href="https://raygun.com/blog/debug-android-chrome/" target="_blank" rel="noopener">https://raygun.com/blog/debug-android-chrome/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web内存分析及工具&quot;&gt;&lt;a href=&quot;#web内存分析及工具&quot; class=&quot;headerlink&quot; title=&quot;web内存分析及工具&quot;&gt;&lt;/a&gt;web内存分析及工具&lt;/h1&gt;&lt;p&gt;js 自带 GC（垃圾回收）机制，因此绝大多数 web 开发人员不会在日常开
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.michealwayne.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://blog.michealwayne.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="调试" scheme="http://blog.michealwayne.cn/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】包管理工具pnpm整理</title>
    <link href="http://blog.michealwayne.cn/2022/02/19/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pnpm%E6%95%B4%E7%90%86/"/>
    <id>http://blog.michealwayne.cn/2022/02/19/notes/【笔记】包管理工具pnpm整理/</id>
    <published>2022-02-19T03:21:10.000Z</published>
    <updated>2022-03-09T09:10:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包管理工具-pnpm-整理"><a href="#包管理工具-pnpm-整理" class="headerlink" title="包管理工具 pnpm 整理"></a>包管理工具 pnpm 整理</h1><p>官网：<a href="https://pnpm.io/" target="_blank" rel="noopener">https://pnpm.io/</a>，github：<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">https://github.com/pnpm/pnpm</a></p><blockquote><p>其实 pnpm 官网从使用、特性、原理社区等建设得都很细致，真正打算使用的话建议通读下官网。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote><p>Fast, disk space efficient package manager</p></blockquote><p>pnpm 也是一款包管理工具，这点与 npm/yarn/cnpm/tnpm 一样，目前主流版本为<code>6.x</code>，<code>7.0</code>也已开始。</p><p><img src="/images/pnpm/p-download.png" alt="p-download.png"></p><p>其实 pnpm 是一个挺早的项目，在 21 年才在国内火了起来。</p><p>截止目前（2022.02.19）来看，该<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">项目</a>已上升至 15k 的 star，并且像 vue3 等一些著名项目也开始使用了 pnpm：</p><p><img src="/images/pnpm/p-vue.jpg" alt="p-vue.jpg"></p><p>从<a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">源码</a>来看，pnpm 是一个高浓度 TypeScript 项目（目前代码中 99%+都是 ts），所以源码方面可以放心食用。</p><ul><li>从依赖来看，可以重点留意<a href="https://www.npmjs.com/package/verdaccio" target="_blank" rel="noopener">verdaccio</a>和<a href="https://www.npmjs.com/package/c8" target="_blank" rel="noopener">c8</a>，这是 npm 注册及管理的工具；并且源码中多包使用了<a href="https://www.npmjs.com/package/syncpack" target="_blank" rel="noopener">syncpack</a></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>直接拿官网的宣称：pnpm 是一款快速、节省磁盘空间的包管理器。</p><ul><li>快速：pnpm 比替代方案（yarn/npm 等）快 2 倍</li><li>高效：node_modules 中的文件是从一个单一的可内容寻址的存储中链接过来的</li><li>支持 monorepos：pnpm 内置支持了单仓多包</li><li>严格：pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li></ul><p>pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，核心优势就是<strong>快</strong>以及<strong>磁盘利用得好</strong>。其他优势也可以在作者 blog 中查看：<a href="https://www.kochan.io/" target="_blank" rel="noopener">https://www.kochan.io/</a></p><p>以下是一些比较数据，也可以在官网上看到：</p><p><img src="/images/pnpm/p-compare-1.png" alt="p-compare-1"></p><p><img src="/images/pnpm/p-compare-2.png" alt="p-compare-2"></p><h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>根据核心优势，就需要大致了解下 node_modules 的安装和依赖模式：</p><ul><li><p>Nested installation（嵌套安装）: 在 <code>npm@3</code> 之前，<code>node_modules</code> 结构是干净、可预测的，因为 <code>node_modules</code> 中的每个依赖项都有自己的 <code>node_modules</code> 文件夹，在 <code>package.json</code> 中指定了所有依赖项。结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">  - package A</span><br><span class="line">      - packageX 1.0</span><br><span class="line">      - packageY 1.0</span><br><span class="line">  - package B</span><br><span class="line">      - packageX 2.0</span><br><span class="line">      - packageY 2.0</span><br><span class="line">  - package C</span><br><span class="line">      - packageX 1.0</span><br><span class="line">      - packageY 2.0</span><br><span class="line">  - package D</span><br><span class="line">      - packageX 2.0</span><br><span class="line">      - packageY 1.0</span><br></pre></td></tr></table></figure></li><li><p>Flat installation（扁平安装）：<code>npm@3 / yarn</code>，扁平化结构，多个版本的包只能有一个被提升上来（hoist 机制），优势就是避免了一些重复，其余版本的包会嵌套安装到各自的依赖当中（类似 npm2 的结构），至于哪个版本的包被提升，依赖于包的安装顺序。结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    - package X =&gt; 1.0 版本</span><br><span class="line">    - package Y =&gt; 1.0 版本</span><br><span class="line"></span><br><span class="line">    - package A</span><br><span class="line">    - package B</span><br><span class="line">        - packageX 2.0</span><br><span class="line">        - packageY 2.0</span><br><span class="line">    - package C</span><br><span class="line">        - packageY 2.0</span><br><span class="line">    - package D</span><br><span class="line">        - packageX 2.0</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure></li></ul><p>pnpm 既然改了依赖方式，那么就可以看当前模式的主要问题：</p><ul><li>重复安装，如上所示的 packageX 2.0 和 packageY 2.0 被重复安装多次，从而造成 npm 和 yarn 的性能一些性能损失。这种场景在 monorepo 多包场景下尤其明显，另外扁平化的算法实现也相当复杂，改动成本很高。</li><li>Phantom dependencies，幽灵依赖或幻影依赖，即某个包没有在 <code>package.json</code> 被依赖，但是用户却能够引用到这个包。</li></ul><p>pnpm 的改变：</p><ul><li><p>Net 网状 + Flat 平铺 的 <code>node_modules</code> 结构</p><ul><li>虚拟存储目录：<code>.pnpm</code>， 以平铺的形式储存着所有的包，正常的包都可以在这种命名模式的文件夹中被找到（peerDep 例外）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.pnpm/&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span><br><span class="line"></span><br><span class="line">// 组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称)</span><br></pre></td></tr></table></figure><p>该目录通过<code>&lt;package-name&gt;@&lt;version&gt;</code>来实现相同模块不同版本之间隔离和复用，由于它只会根据项目中的依赖生成，并不存在提升，所以不存在幽灵依赖。</p></li></ul><p>结构就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    - .pnpm</span><br><span class="line">        - package A</span><br><span class="line">            - node_modules</span><br><span class="line">                - A -&gt; &lt;store&gt;/A</span><br><span class="line">                    - index.js</span><br><span class="line">                    - package.json</span><br><span class="line">    - package B</span><br><span class="line">        - node_modules</span><br><span class="line">                - B -&gt; &lt;store&gt;/B</span><br><span class="line">                    - index.js</span><br><span class="line">                    - package.json</span><br></pre></td></tr></table></figure><p>如官网描述：<br><img src="/images/pnpm/p-pnpm-nodemodules.png" alt="p-pnpm-nodemodules.png"></p><p>那么它如何跟文件资源进行关联的呢？答案是 Store + Links，可以看官网介绍<a href="https://pnpm.io/symlinked-node-modules-structure" target="_blank" rel="noopener">《Symlinked <code>node_modules</code> structure》</a>或掘金上这篇易于理解的文章<a href="https://juejin.cn/post/7053340250210795557#heading-6" target="_blank" rel="noopener">《pnpm 的破解之道：网状 + 平铺的 node_modules 结构》</a></p><p>根目录下的 <code>node_modules</code> 下面不再是眼花缭乱的依赖，而是跟 <code>package.json</code> 声明的依赖基本保持一致。即使 pnpm 内部会有一些包会设置依赖提升，会被提升到根目录 <code>node_modules</code> 当中，但整体上，根目录的 <code>node_modules</code> 比以前还是清晰和规范了许多。</p><p>pnpm 这种依赖管理的方式也巧妙地规避了非法访问依赖的问题，pnpm 不允许安装 <code>package.json</code> 中没有包含的包，也就是说只要一个包未在 <code>package.json</code> 中声明依赖，那么在项目中是无法访问的。</p><blockquote><p>在此背景情况下，据说 yarn 也计划开始存储模式的优化。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在 <code>node_modules</code> 的依赖模式改变下，因为软链的关系必然也会导致一些问题：</p><ul><li>1.子依赖提升到同级的目录结构的兼容性问题，类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配；</li><li>2.软链在不同操作系统的实现不太一样，且在非 SSD 的硬盘上，还是会有一定的磁盘 io 损耗的。</li><li>3.多包某种情况下，依赖出现两次：可见官网说明<a href="https://pnpm.io/how-peers-are-resolved" target="_blank" rel="noopener">https://pnpm.io/how-peers-are-resolved</a></li></ul><p>其余大部分问题可在<a href="https://pnpm.io/zh/faq" target="_blank" rel="noopener">官网 faq</a>中找到，也可以看 github 上一些 <a href="https://github.com/pnpm/pnpm/issues" target="_blank" rel="noopener">issue</a> 反馈，包括现在的问题：</p><p><img src="/images/pnpm/p-bugs.jpg" alt="p-bugs.jpg"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>极为简单</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pnpm</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>与 yarn 类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pnpm add xxx  <span class="comment"># 安装xxx到dependencies</span></span><br><span class="line"></span><br><span class="line">pnpm add -D xxx  <span class="comment"># 安装xxx到devDependencies</span></span><br><span class="line"></span><br><span class="line">pnpm install <span class="comment"># 安装项目所有依赖</span></span><br><span class="line"></span><br><span class="line">pnpm install -S xxx 安装xxx并添加到dependencies</span><br><span class="line"></span><br><span class="line">pnpm remove xxx <span class="comment"># 删除dependencies中的xxx</span></span><br><span class="line"></span><br><span class="line">pnpm remove -D xxx <span class="comment"># 删除devDependencies中的xxx</span></span><br></pre></td></tr></table></figure><h4 id="pnpm-workspace-yaml"><a href="#pnpm-workspace-yaml" class="headerlink" title="pnpm-workspace.yaml"></a><code>pnpm-workspace.yaml</code></h4><p>此文件定义了工作空间的根目录，并能够使您从工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pnpm-workspace.yaml</span><br><span class="line">packages:</span><br><span class="line">  # 所有在 packages/ 和 components/ 子目录下的 package</span><br><span class="line">  - &apos;packages/**&apos;</span><br><span class="line">  - &apos;components/**&apos;</span><br><span class="line">  # 不包括在 test 文件夹下的 package</span><br><span class="line">  - &apos;!**/test/**&apos;</span><br></pre></td></tr></table></figure><p>其他如钩子、别名等不太常用的功能查询官网<a href="https://pnpm.io/zh/motivation" target="_blank" rel="noopener">https://pnpm.io/zh/motivation</a>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>新的工具必然带来性能/空间上的提升，但在业务使用中我们需要注意它的隐患，避免乐观主义陷阱。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://pnpm.io/" target="_blank" rel="noopener">https://pnpm.io/</a></li><li><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">https://github.com/pnpm/pnpm</a></li><li><a href="https://pnpm.io/zh/blog" target="_blank" rel="noopener">https://pnpm.io/zh/blog</a></li><li><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">https://www.kochan.io/nodejs/why-should-we-use-pnpm.html</a></li><li><a href="https://juejin.cn/post/7053340250210795557#heading-6" target="_blank" rel="noopener">https://juejin.cn/post/7053340250210795557#heading-6</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;包管理工具-pnpm-整理&quot;&gt;&lt;a href=&quot;#包管理工具-pnpm-整理&quot; class=&quot;headerlink&quot; title=&quot;包管理工具 pnpm 整理&quot;&gt;&lt;/a&gt;包管理工具 pnpm 整理&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;https://pnpm.i
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nodejs" scheme="http://blog.michealwayne.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>js 中 parseInt 和 parseFloat 的执行机制</title>
    <link href="http://blog.michealwayne.cn/2022/01/03/notes/%E7%BB%86%E8%B0%88js%E4%B8%AD%E7%9A%84parseInt%E5%92%8CparseFloat/"/>
    <id>http://blog.michealwayne.cn/2022/01/03/notes/细谈js中的parseInt和parseFloat/</id>
    <published>2022-01-03T11:38:23.000Z</published>
    <updated>2022-01-11T05:13:52.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-中-parseInt-和-parseFloat-的执行机制"><a href="#js-中-parseInt-和-parseFloat-的执行机制" class="headerlink" title="js 中 parseInt 和 parseFloat 的执行机制"></a>js 中 parseInt 和 parseFloat 的执行机制</h1><p><code>parseInt()</code>和<code>parseFloat()</code>这两个常用 API 其实还是有很多“坑”的，最近发现有同学不小心踩到了，再加上挺久没看 js 了，便以此文统一梳理一下。（本文比较适合常与数字打交道的 jser 或对这两 API 运作感兴趣的同学）</p><h2 id="执行检验"><a href="#执行检验" class="headerlink" title="执行检验"></a>执行检验</h2><blockquote><p>在 19 年描述 js 数值时（<a href="https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md#q3%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%95%B0%E5%AD%97%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">Q3.说出以下转换数字数值转换的结果</a>），有提到 <code>parseInt</code>和<code>parseFloat</code>的运行机制，其实这两 API 还是有蛮多坑的，虽然平时不太会踩到。</p></blockquote><p>首先猜测以下执行自我检验一番：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parseInt */</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123abc'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc123'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e6'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'    1    '</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x11'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'a'</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1e6</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1n</span>);</span><br><span class="line"><span class="built_in">parseInt</span>();</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个“超纲”题</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.00000001</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">-99999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">99999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">123.456</span>, <span class="number">9999999999999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">9999999999999999</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'11111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'11111111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1e21</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123aef'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xf'</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'111'</span>, <span class="number">2</span> ** <span class="number">32</span> + <span class="number">2.1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="keyword">const</span> objTest1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">parseInt</span>(objTest1);</span><br><span class="line">objTest1.toString = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>;</span><br><span class="line"><span class="built_in">parseInt</span>(objTest1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parseFloat */</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.456.789'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123abc.456.789'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'    123abc    '</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1e6'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'+Infinity'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">123.456</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1e6</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">0.00000001</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0x1a'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1n</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>();</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个“超纲”题</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">9999999999999999</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11111111111111111111'</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="built_in">parseFloat</span>);</span><br><span class="line"><span class="keyword">const</span> objTest2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">parseFloat</span>(objTest2);</span><br><span class="line">objTest2.toString = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>;</span><br><span class="line"><span class="built_in">parseFloat</span>(objTest2);</span><br></pre></td></tr></table></figure><h2 id="ECMAScript-规范"><a href="#ECMAScript-规范" class="headerlink" title="ECMAScript 规范"></a>ECMAScript 规范</h2><p>无论啥内核、浏览器或是 NodeJs，都会遵循 ECMA 的主要规范，因此要思考上列的执行结果，可以重点了解 ECMA 规范的执行描述。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a><code>parseInt()</code></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure><p>其中参数：</p><ul><li><code>string</code>：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。标准输入：<br><img src="/images/js/parseInt/p-parseInt-input-string.jpg" alt="p-parseInt-input-string.jpg"></li><li><code>radix</code>：<strong>可选</strong>，介于<code>2</code>~<code>36</code>之间的整数。告知<code>parseInt()</code>函数<code>string</code>（比如 11）是<code>radix</code>（比如 2）进制的表示，如果<code>radix</code>不存在，<code>parseInt</code>将固定返回<code>string</code>以十进制显示的数。</li></ul><p>另外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span> === <span class="built_in">Number</span>.parseInt; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="ECMAScript（6-0）-规范说明"><a href="#ECMAScript（6-0）-规范说明" class="headerlink" title="ECMAScript（6.0） 规范说明"></a>ECMAScript（6.0） 规范说明</h4><p>官网描述：<br><img src="/images/js/parseInt/p-parseInt-1.jpg" alt="p-parseInt-1.jpg"></p><p>简单翻译一下执行步骤：</p><ul><li>1.定义变量<code>inputString</code>，它是入参<code>string</code>执行 <code>ToString(string)</code> 的字符串结果。（<code>ToString</code>是一个内部 abstract operations、不对外，具体执行见<a href="https://262.ecma-international.org/6.0/#sec-tostring" target="_blank" rel="noopener">文档</a>或文末附录）；</li><li>2.执行出现异常则返回（<a href="https://262.ecma-international.org/6.0/#sec-returnifabrupt" target="_blank" rel="noopener"><code>ReturnIfAbrupt</code></a>，关于<code>ReturnIfAbrupt</code>的执行其实还蛮复杂的，涉及 ECMA 规范的规格术语，本文不做描述）；</li><li>3.定义变量<code>S</code>，它是<code>inputString</code>创建的一个子字符串，它由第一个不是空白字符的代码单元和该代码单元之后的所有代码单元组成，即去除前置空格，也就是说<code>parseInt(&#39;123&#39;)</code>和<code>parseInt(&#39; 123&#39;)</code>效果相同。如果找不到这样的单元，则<code>S</code>为空字符串（<code>&quot;&quot;</code>）；</li><li>4.定义变量<code>sign</code>为<code>1</code>；</li><li>5.如果变量<code>S</code>不为空并且<code>S</code>的第一个单元是<code>0x002D</code> （<code>HYPHEN-MINUS</code>，即减号），变量<code>sign</code>改为<code>-1</code>；</li><li>6.如果变量<code>S</code>不为空并且<code>S</code>的第一个单元是<code>0x002B</code> （<code>PLUS SIGN</code>，即加号） 或<code>0x002D</code> （HYPHEN-MINUS，即减号），去除<code>S</code>的第一个单元，即去除<code>&#39;+&#39;</code>/<code>-</code>符号；</li><li>7.定义变量<code>R</code>为<code>ToInt32(radix)</code>，即对进制声明进行<a href="https://262.ecma-international.org/6.0/#sec-toint32" target="_blank" rel="noopener">ToInt32</a>数字转换，也就是说<code>parseInt(&#39;123&#39;, 8)</code> 和 <code>parseInt(&#39;123&#39;, &#39;8&#39;)</code>效果相同；</li><li>8.执行出现异常则返回（<code>ReturnIfAbrupt</code>）；</li><li>9.定义变量<code>stripPrefix</code> 为 <code>true</code>；</li><li>10.如果变量<code>R</code>不等于<code>0</code>，则：<ul><li>如果变量<code>R</code>小于 2 或大于 36，直接返回<code>NaN</code>；</li><li>如果变量<code>R</code>不等于 16，变量<code>stripPrefix</code> 改为 <code>false</code>；</li></ul></li><li>11.如果变量<code>R</code>等于<code>0</code>，则变量<code>R</code>改为<code>10</code>；</li><li>12.如果变量<code>stripPrefix</code>值为<code>true</code>，则：<ul><li>如果变量<code>S</code>字符串长度不小于 2 并且前两个字符单元是<code>0x</code>或<code>0X</code>，则删除这两字符，且设置变量<code>R</code>为<code>16</code>；</li></ul></li><li>13.设置变量<code>Z</code>，如果变量<code>S</code>包含一个不是变量<code>R</code>数字的字符单元，则<code>Z</code>为<code>S</code>的子字符串，且由第一个这样的字符单元之前的所有代码单元组成，即<code>parseInt(&#39;789&#39;, 8)</code>和<code>parseInt(&#39;7&#39;, 8)</code>效果相同；否则，<code>Z</code> 为 <code>S</code>；</li><li>14.如果变量<code>Z</code>为空，直接返回<code>NaN</code>；</li><li>15.设置变量<code>mathInt</code>为由<code>Z</code>以基数<code>R</code>进行表示的数学进制整数值，其中使用字母<code>A-Z</code>和<code>a-z</code>表示值为 10 ～ 35 的数字（如果<code>R</code>为 10，且<code>Z</code>包含 20 个以上的有效数字，则根据实现的选择，第 20 位之后的每个有效数字都可以替换为 0）<br>，如果 <code>R</code> 不是 2、4、8、10、16 或 32，则 <code>mathInt</code> 可能是对数学整数值的依赖实现的近似值，该值由 <code>Z</code> 以基数<code>R</code> 表示法表示。</li><li>16.如果<code>mathInt</code>等于 0，则：<ul><li>如果<code>sign</code>等于-1，则返回<code>-0</code>；</li><li>否则返回<code>+0</code>；</li></ul></li><li>17.设置变量<code>number</code>为<code>mathInt</code>的 Number 值；</li><li>18.返回<code>sign * number</code></li></ul><p>看起来有点复杂，画了个流程图：<br><img src="/images/js/parseInt/p-rule_parseInt.png" alt="p-rule_parseInt.png"></p><blockquote><p><code>parseInt()</code> 只能将字符串的前导部分解释为整数值；它忽略任何不能被解释为整数符号的一部分的代码单元，并且没有给出任何此类代码单元被忽略的迹象。</p></blockquote><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a><code>parseFloat()</code></h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(string)</span><br></pre></td></tr></table></figure><p>其中参数：</p><ul><li><code>string</code>：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。标准输入：<br><img src="/images/js/parseInt/p-parseFloat-input-string.jpg" alt="p-parseFloat-input-string.jpg"></li></ul><p>另外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span> === <span class="built_in">Number</span>.parseFloat; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="ECMAScript（6-0）-规范"><a href="#ECMAScript（6-0）-规范" class="headerlink" title="ECMAScript（6.0） 规范"></a>ECMAScript（6.0） 规范</h4><p>官网描述：</p><p><img src="/images/js/parseInt/p-parseFloat-1.jpg" alt="p-parseFloat-1.jpg"></p><p>执行步骤：</p><ul><li>1.定义变量<code>inputString</code>，它是入参<code>string</code>执行 <code>ToString(string)</code> 的字符串结果。；</li><li>2.执行出现异常则返回（<code>ReturnIfAbrupt</code>）；</li><li>3.定义变量<code>trimmedString</code>，它是<code>inputString</code>创建的一个子字符串，它由第一个不是空白字符的代码单元和该代码单元之后的所有代码单元组成，即去除前置空格，也就是说<code>parseFloat(&#39;123.456&#39;)</code>和<code>parseFloat(&#39; 123.456&#39;)</code>效果相同。如果找不到这样的单元，边<code>trimmedString</code>为空字符串（<code>&quot;&quot;</code>）；</li><li>4.如果<code>trimmedString</code>或<code>trimmedString</code>的任何前缀都不满足<a href="https://262.ecma-international.org/6.0/#sec-tonumber-applied-to-the-string-type" target="_blank" rel="noopener"><code>StrDecimalLiteral</code></a>的语法，则返回<code>NaN</code>；<br><code>StrDecimalLiteral</code> 语法：<br><img src="/images/js/parseInt/p-strDecimalLiteral.jpg" alt="p-strDecimalLiteral.jpg"><br>文档不是很清晰，画了张铁路图：<br><img src="/images/js/parseInt/p-strDecimalLiteral_rd.jpg" alt="p-strDecimalLiteral_rd.jpg"></li><li>5.定义变量<code>numberString</code>，它是<code>trimmedString</code> 的最长前缀（可能是<code>trimmedString</code>） 本身，<code>numberString</code>满足<code>StrDecimalLiteral</code> 的语法。</li><li>6.定义变量<code>mathFloat</code>，它是 <code>numberString</code> 的 <code>MV</code>（mathematical value）：从文字中导出<code>MV</code>，其次对这个值进行四舍五入（也有 20 位的阈值处理），这一步处理与<code>parseInt()</code>有很大的不同。至于具体 MV 基本就是大学里学的内容，可见<a href="https://262.ecma-international.org/6.0/#sec-runtime-semantics-mv-s" target="_blank" rel="noopener">文档</a>；</li><li>7.如果<code>mathFloat</code> 等于 0，则：<ul><li>如果<code>trimmedString</code>的第一个字符等于<code>&quot;-&quot;</code>，则返回<code>-0</code>；</li><li>否则返回<code>+0</code>；</li></ul></li><li>8.返回<code>mathFloat</code>的 Number 值；</li></ul><p>也画了个流程图：<br><img src="/images/js/parseInt/p-rule_parseFloat.png" alt="p-rule_parseFloat.png"></p><blockquote><p><code>parseFloat()</code> 只能将字符串的前导部分解释为整数值；它忽略任何不能被解释为整数符号的一部分的代码单元，并且没有给出任何此类代码单元被忽略的迹象。</p></blockquote><h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><p>声明文件（<code>lib.es5.d.ts</code>）很简单：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a string to an integer.</span></span><br><span class="line"><span class="comment"> * @param string A string to convert into a number.</span></span><br><span class="line"><span class="comment"> * @param radix A value between 2 and 36 that specifies the base of the number in `string`.</span></span><br><span class="line"><span class="comment"> * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.</span></span><br><span class="line"><span class="comment"> * All other strings are considered decimal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parseInt</span>(<span class="params"><span class="built_in">string</span>: <span class="built_in">string</span>, radix?: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a string to a floating-point number.</span></span><br><span class="line"><span class="comment"> * @param string A string that contains a floating-point number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">parseFloat</span>(<span class="params"><span class="built_in">string</span>: <span class="built_in">string</span></span>): <span class="title">number</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>再次注意<code>NaN</code>也是<code>&quot;number&quot;</code>哦</p></blockquote><hr><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>以典型的<a href="https://webkit.org/" target="_blank" rel="noopener">WebKit</a>（依赖 v8）为例，可以看下<code>parseInt()</code>和<code>parseFloat</code>的具体代码实现和单测内容（版本：<code>tags/9.9.56</code>）</p><h4 id="parseInt-源码"><a href="#parseInt-源码" class="headerlink" title="parseInt 源码"></a><code>parseInt</code> 源码</h4><p>(主要文件：<code>/Source/JavaScriptCore/runtime/ParseInt.h</code>)</p><p>主要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口，方法定义</span></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseInt</span><span class="params">(StringView s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.is8Bit())</span><br><span class="line">        <span class="keyword">return</span> parseInt(s, s.characters8(), radix);</span><br><span class="line">    <span class="keyword">return</span> parseInt(s, s.characters16(), radix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5.1 15.1.2.2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;</span><br><span class="line">ALWAYS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseInt</span><span class="params">(StringView s, <span class="keyword">const</span> CharType* data, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. Let inputString be ToString(string).</span></span><br><span class="line">    <span class="comment">// 2. Let S be a newly created substring of inputString consisting of the first character that is not a</span></span><br><span class="line">    <span class="comment">//    StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white</span></span><br><span class="line">    <span class="comment">//    space.) If inputString does not contain any such characters, let S be the empty string.</span></span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))</span><br><span class="line">        ++p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Let sign be 1.</span></span><br><span class="line">    <span class="comment">// 4. If S is not empty and the first character of S is a minus sign -, let sign be -1.</span></span><br><span class="line">    <span class="comment">// 5. If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first character from S.</span></span><br><span class="line">    <span class="keyword">double</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[p] == <span class="string">'+'</span>)</span><br><span class="line">            ++p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[p] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. Let R = ToInt32(radix).</span></span><br><span class="line">    <span class="comment">// 7. Let stripPrefix be true.</span></span><br><span class="line">    <span class="comment">// 8. If R != 0,then</span></span><br><span class="line">    <span class="comment">//   b. If R != 16, let stripPrefix be false.</span></span><br><span class="line">    <span class="comment">// 9. Else, R == 0</span></span><br><span class="line">    <span class="comment">//   a. LetR = 10.</span></span><br><span class="line">    <span class="comment">// 10. If stripPrefix is true, then</span></span><br><span class="line">    <span class="comment">//   a. If the length of S is at least 2 and the first two characters of S are either ―0x or ―0X,</span></span><br><span class="line">    <span class="comment">//      then remove the first two characters from S and let R = 16.</span></span><br><span class="line">    <span class="comment">// 11. If S contains any character that is not a radix-R digit, then let Z be the substring of S</span></span><br><span class="line">    <span class="comment">//     consisting of all characters before the first such character; otherwise, let Z be S.</span></span><br><span class="line">    <span class="keyword">if</span> ((radix == <span class="number">0</span> || radix == <span class="number">16</span>) &amp;&amp; length - p &gt;= <span class="number">2</span> &amp;&amp; data[p] == <span class="string">'0'</span> &amp;&amp; (data[p + <span class="number">1</span>] == <span class="string">'x'</span> || data[p + <span class="number">1</span>] == <span class="string">'X'</span>)) &#123;</span><br><span class="line">        radix = <span class="number">16</span>;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (radix == <span class="number">0</span>)</span><br><span class="line">        radix = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.a If R &lt; 2 or R &gt; 36, then return NaN.</span></span><br><span class="line">    <span class="keyword">if</span> (radix &lt; <span class="number">2</span> || radix &gt; <span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters</span></span><br><span class="line">    <span class="comment">//     A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant</span></span><br><span class="line">    <span class="comment">//     digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation;</span></span><br><span class="line">    <span class="comment">//     and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the</span></span><br><span class="line">    <span class="comment">//     mathematical integer value that is represented by Z in radix-R notation.)</span></span><br><span class="line">    <span class="comment">// 14. Let number be the Number value for mathInt.</span></span><br><span class="line">    <span class="keyword">int</span> firstDigitPosition = p;</span><br><span class="line">    <span class="keyword">bool</span> sawDigit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; length) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = parseDigit(data[p], radix);</span><br><span class="line">        <span class="keyword">if</span> (digit == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sawDigit = <span class="literal">true</span>;</span><br><span class="line">        number *= radix;</span><br><span class="line">        number += digit;</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12. If Z is empty, return NaN.</span></span><br><span class="line">    <span class="keyword">if</span> (!sawDigit)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternate code path for certain large numbers.</span></span><br><span class="line">    <span class="keyword">if</span> (number &gt;= mantissaOverflowLowerBound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (radix == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> parsedLength;</span><br><span class="line">            number = parseDouble(s.substring(firstDigitPosition, p - firstDigitPosition), parsedLength);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (radix == <span class="number">2</span> || radix == <span class="number">4</span> || radix == <span class="number">8</span> || radix == <span class="number">16</span> || radix == <span class="number">32</span>)</span><br><span class="line">            number = parseIntOverflow(s.substring(firstDigitPosition, p - firstDigitPosition), radix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 15. Return sign x number.</span></span><br><span class="line">    <span class="keyword">return</span> sign * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中没有“骚”操作，从执行到备注都完全贴合规范。</p><h4 id="parseInt-unit-test"><a href="#parseInt-unit-test" class="headerlink" title="parseInt unit test"></a>parseInt unit test</h4><p>（文件：<code>chromium / v8 / v8 / 9.9.56 / . / test / webkit / parseInt-expected.txt</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PASS parseInt(&apos;123&apos;) is 123</span><br><span class="line">PASS parseInt(&apos;123x4&apos;) is 123</span><br><span class="line">PASS parseInt(&apos;-123&apos;) is -123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123x4&apos;) is 0x123</span><br><span class="line">PASS parseInt(&apos;-0x123x4&apos;) is -0x123</span><br><span class="line">PASS parseInt(&apos;-&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;0x&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;-0x&apos;) is Number.NaN</span><br><span class="line">PASS parseInt(&apos;123&apos;, undefined) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, null) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 0) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 10) is 123</span><br><span class="line">PASS parseInt(&apos;123&apos;, 16) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, undefined) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, null) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 0) is 0x123</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 10) is 0</span><br><span class="line">PASS parseInt(&apos;0x123&apos;, 16) is 0x123</span><br><span class="line">PASS parseInt(Math.pow(10, 20)) is 100000000000000000000</span><br><span class="line">PASS parseInt(Math.pow(10, 21)) is 1</span><br><span class="line">PASS parseInt(Math.pow(10, -6)) is 0</span><br><span class="line">PASS parseInt(Math.pow(10, -7)) is 1</span><br><span class="line">PASS parseInt(-Math.pow(10, 20)) is -100000000000000000000</span><br><span class="line">PASS parseInt(-Math.pow(10, 21)) is -1</span><br><span class="line">PASS parseInt(-Math.pow(10, -6)) is -0</span><br><span class="line">PASS parseInt(-Math.pow(10, -7)) is -1</span><br><span class="line">PASS parseInt(&apos;0&apos;) is 0</span><br><span class="line">PASS parseInt(&apos;-0&apos;) is -0</span><br><span class="line">PASS parseInt(0) is 0</span><br><span class="line">PASS parseInt(-0) is 0</span><br><span class="line">PASS parseInt(2147483647) is 2147483647</span><br><span class="line">PASS parseInt(2147483648) is 2147483648</span><br><span class="line">PASS parseInt(&apos;2147483647&apos;) is 2147483647</span><br><span class="line">PASS parseInt(&apos;2147483648&apos;) is 2147483648</span><br><span class="line">PASS state = null; try &#123; parseInt(&apos;123&apos;, throwingRadix); &#125; catch (e) &#123;&#125; state; is &quot;throwingRadix&quot;</span><br><span class="line">PASS state = null; try &#123; parseInt(throwingString, throwingRadix); &#125; catch (e) &#123;&#125; state; is &quot;throwingString&quot;</span><br></pre></td></tr></table></figure><h4 id="parseFloat-源码"><a href="#parseFloat-源码" class="headerlink" title="parseFloat 源码"></a><code>parseFloat</code> 源码</h4><p>(主要文件：<code>/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseFloat</span><span class="params">(StringView s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> size = s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        UChar c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (isASCIIDigit(c))</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.is8Bit()) &#123;</span><br><span class="line">        <span class="keyword">const</span> LChar* data = s.characters8();</span><br><span class="line">        <span class="keyword">const</span> LChar* end = data + size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip leading white space.</span></span><br><span class="line">        <span class="keyword">for</span> (; data &lt; end; ++data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isStrWhiteSpace(*data))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty string.</span></span><br><span class="line">        <span class="keyword">if</span> (data == end)</span><br><span class="line">            <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsStrDecimalLiteral(data, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> UChar* data = s.characters16();</span><br><span class="line">    <span class="keyword">const</span> UChar* end = data + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip leading white space.</span></span><br><span class="line">    <span class="keyword">for</span> (; data &lt; end; ++data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStrWhiteSpace(*data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Empty string.</span></span><br><span class="line">    <span class="keyword">if</span> (data == end)</span><br><span class="line">        <span class="keyword">return</span> PNaN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsStrDecimalLiteral(data, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// See ecma-262 6th 11.8.3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">jsStrDecimalLiteral</span><span class="params">(<span class="keyword">const</span> CharType*&amp; data, <span class="keyword">const</span> CharType* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RELEASE_ASSERT(data &lt; end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> parsedLength;</span><br><span class="line">    <span class="keyword">double</span> number = parseDouble(data, end - data, parsedLength);</span><br><span class="line">    <span class="keyword">if</span> (parsedLength) &#123;</span><br><span class="line">        data += parsedLength;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for [+-]?Infinity</span></span><br><span class="line">    <span class="keyword">switch</span> (*data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data + <span class="number">1</span>, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">if</span> (isInfinity(data + <span class="number">1</span>, end)) &#123;</span><br><span class="line">            data += SizeOfInfinity + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not a number.</span></span><br><span class="line">    <span class="keyword">return</span> PNaN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，<code>parseInt</code>的注释要更为完善。</p><h4 id="parseFloat-test"><a href="#parseFloat-test" class="headerlink" title="parseFloat test"></a>parseFloat test</h4><p>（文件：<code>chromium / v8 / v8 / 9.9.56 / . / test / webkit / parseFloat-expected.txt</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PASS parseFloat() is NaN</span><br><span class="line">PASS parseFloat(&apos;&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos; &apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos; 0&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;0 &apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;x0&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;0x&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos; 1&apos;) is 1</span><br><span class="line">PASS parseFloat(&apos;1 &apos;) is 1</span><br><span class="line">PASS parseFloat(&apos;x1&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;1x&apos;) is 1</span><br><span class="line">PASS parseFloat(&apos; 2.3&apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;2.3 &apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;x2.3&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;2.3x&apos;) is 2.3</span><br><span class="line">PASS parseFloat(&apos;0x2&apos;) is 0</span><br><span class="line">PASS parseFloat(&apos;1&apos; + nonASCIINonSpaceCharacter) is 1</span><br><span class="line">PASS parseFloat(nonASCIINonSpaceCharacter + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(&apos;1&apos; + illegalUTF16Sequence) is 1</span><br><span class="line">PASS parseFloat(illegalUTF16Sequence + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(tab + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(nbsp + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ff + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(vt + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(cr + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(lf + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ls + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ps + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(oghamSpaceMark + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(mongolianVowelSeparator + &apos;1&apos;) is NaN</span><br><span class="line">PASS parseFloat(enQuad + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(emQuad + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(enSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(emSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(threePerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(fourPerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(sixPerEmSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(figureSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(punctuationSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(thinSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(hairSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(narrowNoBreakSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(mediumMathematicalSpace + &apos;1&apos;) is 1</span><br><span class="line">PASS parseFloat(ideographicSpace + &apos;1&apos;) is 1</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从 ECMA 规范和典型内核的代码实现中我们可以发现，<code>parseFloat</code>和<code>parseInt</code>存在很多边界处理，这也是造成踩坑的主要原因。</p><p>至此可以再回过头想想最初的那些执行问题，绝大部分都能得到解释。至于“超纲”题，有兴趣可以去看下 ECMA 规范中的数字及类型转换部分。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="tostring"><a href="#tostring" class="headerlink" title="tostring"></a>tostring</h4><p><img src="/images/js/parseInt/p-table12-tostring.jpg" alt="p-table12-tostring.jpg"></p><h4 id="MV（mathematical-value）"><a href="#MV（mathematical-value）" class="headerlink" title="MV（mathematical value）"></a>MV（mathematical value）</h4><p><img src="/images/js/parseInt/p-mv.png" alt="p-mv.png"></p><h4 id="parseFloat-input-string-格式"><a href="#parseFloat-input-string-格式" class="headerlink" title="parseFloat input string 格式"></a>parseFloat input string 格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Diagram(</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">  Optional(</span><br><span class="line">    Choice(0,</span><br><span class="line">      &apos;+&apos;,</span><br><span class="line">      &apos;-&apos;,</span><br><span class="line">    ), &apos;skip&apos;</span><br><span class="line">  ),</span><br><span class="line">  Choice(1,</span><br><span class="line">    &apos;Infinity&apos;,</span><br><span class="line">    Sequence(</span><br><span class="line">      Choice(0,</span><br><span class="line">        Sequence(</span><br><span class="line">          ZeroOrMore(&apos;0-9&apos;),</span><br><span class="line">          Optional(&apos;.&apos;, &apos;skip&apos;),</span><br><span class="line">          OneOrMore(&apos;0-9&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      Optional(</span><br><span class="line">        Sequence(</span><br><span class="line">          Choice(0,</span><br><span class="line">            &apos;e&apos;,</span><br><span class="line">            &apos;E&apos;,</span><br><span class="line">          ),</span><br><span class="line">          Optional(</span><br><span class="line">            Choice(0,</span><br><span class="line">              &apos;+&apos;,</span><br><span class="line">              &apos;-&apos;,</span><br><span class="line">            ), &apos;skip&apos;</span><br><span class="line">          ),</span><br><span class="line">          OneOrMore(&apos;0-9&apos;),</span><br><span class="line">        )</span><br><span class="line">      , &apos;skip&apos;)</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="parseInt-input-string-格式"><a href="#parseInt-input-string-格式" class="headerlink" title="parseInt input string 格式"></a>parseInt input string 格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Diagram(</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">  Optional(</span><br><span class="line">    Choice(0,</span><br><span class="line">      &apos;+&apos;,</span><br><span class="line">      &apos;-&apos;,</span><br><span class="line">    ), &apos;skip&apos;</span><br><span class="line">  ),</span><br><span class="line">  ZeroOrMore(&apos;0-R&apos;),// R 为进制最大值</span><br><span class="line">  ZeroOrMore(&apos;Space&apos;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://262.ecma-international.org/6.0/" target="_blank" rel="noopener">https://262.ecma-international.org/6.0/</a></li><li><a href="https://262.ecma-international.org/6.0/#sec-tostring-applied-to-the-number-type" target="_blank" rel="noopener">https://262.ecma-international.org/6.0/#sec-tostring-applied-to-the-number-type</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat</a></li><li><a href="https://webkit.org/" target="_blank" rel="noopener">https://webkit.org/</a></li><li><a href="https://github.com/WebKit/WebKit" target="_blank" rel="noopener">https://github.com/WebKit/WebKit</a></li><li><a href="https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md#q3%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%95%B0%E5%AD%97%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">https://github.com/MichealWayne/study-js-from-questions/blob/master/1.1%20MemoryHeap.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js-中-parseInt-和-parseFloat-的执行机制&quot;&gt;&lt;a href=&quot;#js-中-parseInt-和-parseFloat-的执行机制&quot; class=&quot;headerlink&quot; title=&quot;js 中 parseInt 和 parseFloat 的
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="js" scheme="http://blog.michealwayne.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【综合】web性能及优化</title>
    <link href="http://blog.michealwayne.cn/2021/12/12/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91web%E6%80%A7%E8%83%BD%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.michealwayne.cn/2021/12/12/【综合】web性能及优化/</id>
    <published>2021-12-12T10:36:06.000Z</published>
    <updated>2023-02-25T06:22:29.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-性能及优化"><a href="#web-性能及优化" class="headerlink" title="web 性能及优化"></a>web 性能及优化</h1><h4 id="更新信息"><a href="#更新信息" class="headerlink" title="*更新信息"></a>*更新信息</h4><ul><li>2023.02.25：更新部分站点</li><li>2022.01.23：更新端侧应用的性能优化手段；整理常用优化手段；</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户在访问 web 网页时，大部分都希望网页能够在一秒完成。事实上，加载时间每多 1 秒，就会流失 7%的用户。如果时间超过 8s 就会感到不耐烦，如果加载需要太长时间，用户就会放弃访问。这也就是著名的 <strong>“8s 原则”</strong>。</p><p>虽然当今设备及网络环境都大幅提升，但“带宽低”、“速度慢”、“内存小”的平均情况仍然是明显性能瓶颈，特别是移动端。</p><p>因此，性能优化是一个非常庞大的工程，需要制定指标、确定标准、采用优化手段、进行性能测试、确定性能指标上报、确定性能监控和预警等。本文将重点讲述指标制定和优化手段，希望能为你的网页性能优化提供一些帮助。</p><h2 id="一、如何评估网页性能"><a href="#一、如何评估网页性能" class="headerlink" title="一、如何评估网页性能"></a>一、如何评估网页性能</h2><h3 id="性能度量指标"><a href="#性能度量指标" class="headerlink" title="性能度量指标"></a>性能度量指标</h3><p>我们都明白性能的重要性，但当我们谈起性能时，我们具体指的是什么？其实<strong>性能是相对的</strong>，比如：</p><ul><li>由于网速或设备的差异，某个网站可能对一个用户来说速度很快，但可能对另一个用户来说速度很慢。</li><li>两个网站完成加载所需的时间或许相同，但其中一个却显得加载速度更快（如果该网站逐步加载内容，而不是等到最后才一起显示）。</li><li>一个网站可能看起来加载速度很快，但随后对用户交互的响应速度却很慢（或根本无响应）。</li></ul><p>因此，在谈论性能时，重要的是做到精确，并且根据能够进行定量测量的<strong>客观标准</strong>来论及性能。这些标准就是指标，常用的性能指标如下：</p><ul><li><a href="https://web.dev/fcp/" target="_blank" rel="noopener"><strong>FCP</strong></a>：First Contentful Paint，首次内容绘制，测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。</li><li><strong>FMP</strong>：First Meaningful Paint，首次有效绘制，当主要内容呈现在页面上；</li><li><strong>HRT</strong>：Hero Rendering Times，英雄渲染时间，度量用户体验的新指标，当用户最关心的内容渲染完成；</li><li><a href="https://web.dev/tti/" target="_blank" rel="noopener"><strong>TTI</strong></a>：Time to Interactive，可交互时间，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击 UI 并与其交互；<br>输入响应（Input responsiveness，界面响应用户输入所需的时间）</li><li><strong>PSI</strong>：Perceptual Speed Index，感知速度指数，测量页面在加载过程中视觉上的变化速度，分数越低越好；</li><li><a href="https://web.dev/lcp/" target="_blank" rel="noopener"><strong>LCP</strong></a>：Largest Contentful Paint 最大内容绘制，测量页面从开始加载到最大文本块或图像元素在屏幕上完成渲染的时间。</li><li><a href="https://web.dev/fid/" target="_blank" rel="noopener"><strong>FID</strong></a>：First Input Delay，首次输入延迟，测量从用户第一次与您的网站交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器实际能够对交互做出响应所经过的时间。</li><li><a href="https://web.dev/tbt/" target="_blank" rel="noopener"><strong>TBT</strong></a>：Total blocking time 总阻塞时间，测量 FCP 与 TTI 之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。</li><li><a href="https://web.dev/cls/" target="_blank" rel="noopener"><strong>CLS</strong></a>：Cumulative Layout Shift，累积布局偏移，测量页面在开始加载和其生命周期状态变为隐藏期间发生的所有意外布局偏移的累积分数。</li></ul><blockquote><p>注：FMP 与 HRT 非常相似，但它们不一样的地方在于 FMP 不区分内容是否有用，不区分渲染出的内容是否是用户关心的。</p></blockquote><p>但仅仅因为某个指标基于客观标准并且能够进行定量测量，也并不一定意味着那些测量值就是有用的。我们需要自定义指标，由业务需求和用户体验来决定。</p><p>有时候，可能会有某个特定网站比较独树一帜，需要额外的指标来捕获完整的性能全貌。例如，LCP 指标用于测量页面的主要内容何时完成加载，但在某些情况下，最大元素并不是页面主要内容的一部分，因此 LCP 就不再是相关指标。</p><p>为了解决这种情况，<a href="https://www.w3.org/webperf/" target="_blank" rel="noopener">Web 性能工作组</a>还推出了一系列较低级别的标准化 API，可用于实现您自己的自定义指标。如：</p><ul><li><a href="https://w3c.github.io/user-timing/" target="_blank" rel="noopener">用户计时 API https://w3c.github.io/user-timing/</a></li><li><a href="https://w3c.github.io/longtasks/" target="_blank" rel="noopener">长任务 API https://w3c.github.io/longtasks/</a></li><li><a href="https://wicg.github.io/element-timing/" target="_blank" rel="noopener">元素计时 API https://wicg.github.io/element-timing/</a></li><li><a href="https://w3c.github.io/navigation-timing/" target="_blank" rel="noopener">导航计时 API https://w3c.github.io/navigation-timing/</a></li><li><a href="https://w3c.github.io/resource-timing/" target="_blank" rel="noopener">资源计时 API https://w3c.github.io/resource-timing/</a></li><li><a href="https://w3c.github.io/server-timing/" target="_blank" rel="noopener">服务器计时 https://w3c.github.io/server-timing/</a></li></ul><h3 id="RAIL-体验模型"><a href="#RAIL-体验模型" class="headerlink" title="RAIL 体验模型"></a>RAIL 体验模型</h3><p><a href="https://web.dev/rail/" target="_blank" rel="noopener">RAIL</a> 是 response （响应）、 animation（动画）、idle（浏览器空置状态）和 load（加载）。</p><p>从这四个模块角度来思考你的产品。如果在每个模块上，你都可以达到性能优化的目标值，那么最终用户感受到的将会是极致的体验。</p><p>RAIL 模型中，通常建议性能阈值：</p><ul><li><code>Response</code>：点击/轻触后 100 ms 内得到响应；</li><li><code>Animation</code>：每一帧的渲染在 16 ms 内完成；拖拽后的页面渲染也要在 16 ms 内完成；</li><li><code>Idle</code>：合理地使用浏览器空闲时间；任务要在 50 ms 内完成；</li><li><code>Page Load</code>：加载的过程要满足“响应”目标；最重要的内容要在 1000 ms 内完成加载。</li></ul><p><img src="/images/webOptimize/p-2-rail-model.png" alt="p-2-rail-model.png"></p><p>在次性能目标/阈值基础上，结合 APM 统计，便能对线上用户的 RAIL 性能情况得到统计和评估。</p><h3 id="开发者性能检测工具"><a href="#开发者性能检测工具" class="headerlink" title="开发者性能检测工具"></a>开发者性能检测工具</h3><p>很多工具能够帮助我们获取或分析上文中的一些通用性指标。</p><h4 id="Chrome-DevTools"><a href="#Chrome-DevTools" class="headerlink" title="Chrome DevTools"></a>Chrome DevTools</h4><p>Chrome 浏览器开发者工具中的 <code>Lighthouse</code> 和 <code>Performance</code> 能有效帮助我们进行性能分析：</p><ul><li><code>Lighthouse</code>：生成性能分析报告。并且给予相关优化建议；</li><li><code>Performace</code>：分析运行时数据报告，包含阻塞、重排等细节信息；</li></ul><p><img src="/images/webOptimize/p-1_chrome-devtools.jpg" alt="p-1_chrome-devtools.jpg"></p><p>根据这两个有效工具能够帮我们分析当前页面/运行的性能情况，以便有效做出优化。具体工具使用可以直接参考官网文档<a href="https://developer.chrome.com/docs/devtools/evaluate-performance/" target="_blank" rel="noopener">《Chrome-Analyze runtime performance》</a>、<a href="https://developers.google.com/web/updates/2018/05/lighthouse" target="_blank" rel="noopener">《Using Lighthouse To Improve Page Load Performance》</a></p><h4 id="lighthouse-本地使用"><a href="#lighthouse-本地使用" class="headerlink" title="*lighthouse 本地使用"></a>*lighthouse 本地使用</h4><p><code>Nodejs 12.x</code> 版本起，可以直接安装 <code>lighthouse</code> 在本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g lighthouse</span><br></pre></td></tr></table></figure><p>简单分析，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lighthouse URL地址 参数</span></span><br><span class="line">lighthouse https://blog.michealwayne.cn</span><br></pre></td></tr></table></figure><p>以此为基础，我们可以尝试将分析工作自动化及平台化。比如 <a href="https://web.dev/measure/" target="_blank" rel="noopener">https://web.dev/measure/</a> 中的 <a href="https://pagespeed.web.dev/" target="_blank" rel="noopener">PageSpeed</a>测试。</p><p><img src="/images/webOptimize/p-3_pagespeed.jpg" alt="p-3_pagespeed.jpg"></p><h4 id="React-Profiler-分析-React-性能"><a href="#React-Profiler-分析-React-性能" class="headerlink" title="*React Profiler 分析 React 性能"></a>*React Profiler 分析 React 性能</h4><p>React Profiler 是 React 官方提供的性能审查工具。<code>React 16.5</code> 添加了对新 DevTools 分析器插件的支持。该插件使用 React 的实验性 Profiler API 来收集有关渲染的每个组件的时间信息，以便识别 React 应用程序中的性能瓶颈。使用官网说明<a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html</a></p><p><img src="/images/webOptimize/p-5_react-profiler.jpg" alt="p-5_react-profiler.jpg"></p><h4 id="通过-webpack-bundle-analyzer-和-vue-cli-report-分析模块"><a href="#通过-webpack-bundle-analyzer-和-vue-cli-report-分析模块" class="headerlink" title="*通过 webpack-bundle-analyzer 和 vue-cli report 分析模块"></a>*通过 webpack-bundle-analyzer 和 vue-cli report 分析模块</h4><p>通过<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>，我们可以分析各个模块的大小，进行对性能影响最大的模块进行优化。<a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener">vue-cli report</a> 也集成了这功能。</p><p><img src="/images/webOptimize/p-6_webpack-report.jpg" alt="p-6_webpack-report.jpg"></p><h4 id="真实的性能分析工具：WebPageTest"><a href="#真实的性能分析工具：WebPageTest" class="headerlink" title="真实的性能分析工具：WebPageTest"></a>真实的性能分析工具：WebPageTest</h4><p>WebPageTest（地址<a href="https://www.webpagetest.org/" target="_blank" rel="noopener">https://www.webpagetest.org/</a>），通过浏览器访问，基于输入的 WebSite URL，以及选择的国家城市、浏览器类型、网络带宽等信息，启动对应的远程服务器上的浏览器进行性能分析测试。相似的还有 YSlow、PageSpeed。</p><blockquote><p>目前发现 WebPageTest 网站无法正常访问，不知其是否会修复。</p></blockquote><h3 id="其他性能测试方案"><a href="#其他性能测试方案" class="headerlink" title="其他性能测试方案"></a>其他性能测试方案</h3><h4 id="使用性能-SDK"><a href="#使用性能-SDK" class="headerlink" title="使用性能 SDK"></a>使用性能 SDK</h4><p>如 <a href="https://skywalking.apache.org/docs/" target="_blank" rel="noopener">APM-SkyWalking client</a>。优点是方案与到时候线上用户一致，缺点是在测试环节样本少，需要暴露到线上。</p><h4 id="借助工具录视频"><a href="#借助工具录视频" class="headerlink" title="借助工具录视频"></a>借助工具录视频</h4><p>通过自动化工具进行视频录制，优点是可以和 QA 设施相结合，还能同时测试内存和 CPU 等信息。缺点是对于真实用户的监控力度不足。</p><h4 id="借助端侧打点"><a href="#借助端侧打点" class="headerlink" title="借助端侧打点"></a>借助端侧打点</h4><p>与端侧能力相结合，通过像素检测等手段进行打点上报。优点是能兼顾线上用户及 QA 设施结合。缺点是只能作用在端内业务，无法检测端外业务。</p><hr><h2 id="二、性能优化原则"><a href="#二、性能优化原则" class="headerlink" title="二、性能优化原则"></a>二、性能优化原则</h2><ul><li><strong>数据驱动</strong>。依据数据而不是凭空猜测，性能指标需要满足可度量的条件，当我们怀疑性能有问题时，应该通过日志数据、测试和来分析。</li><li><strong>忌过早优化和过度优化</strong>。过早优化很容易拍脑袋，优化过程也要考虑性价比。</li><li><strong>深入理解业务</strong>。选择合适的衡量指标。性能优化服务于业务，业务服务于最终用户，关注以用户为中心的真实体验。</li><li><strong>持久战</strong>。性能优化也有渐进明细的规划和实施特征。</li><li><strong>正推&amp;反推</strong>。结合正推和反推制定目标，正推：<code>线索</code> -&gt; <code>本质/痛点</code> -&gt; <code>解决方案</code> -&gt; <code>目标</code>；反推：<code>目标</code> -&gt; <code>解决方案</code> -&gt; <code>本质/痛点</code> -&gt; <code>线索</code>，综合制定目标。如 <code>30%的性能提升</code>，<code>带来 10%的流量增加</code>。</li></ul><h3 id="业界性能标准"><a href="#业界性能标准" class="headerlink" title="*业界性能标准"></a>*业界性能标准</h3><p>百度、美团等主要指标以 FCP、FMP 和卡顿率为主；阿里云 <a href="https://www.aliyun.com/product/arms/" target="_blank" rel="noopener">ARMS</a> 性能监控方案，定义性能指数 Apdex，使用白屏时间作为计算指标。</p><p>业界较为通用的标准：</p><table><thead><tr><th>业务类别</th><th>快</th><th>较快</th><th>慢</th><th>很慢</th><th>指标示例</th></tr></thead><tbody><tr><td>时间敏感</td><td><code>&lt;1s</code></td><td><code>1~1.5s</code></td><td><code>1.5~2.5s</code></td><td><code>&gt;2.5s</code></td><td>首屏/白屏</td></tr><tr><td>时间不敏感</td><td><code>&lt;2s</code></td><td><code>2~4s</code></td><td><code>4~8s</code></td><td><code>&gt;2.5s</code></td><td>onload</td></tr></tbody></table><p>像 2C 的页面，“秒开”应作为性能目标，如：</p><table><thead><tr><th>类型</th><th>FCP</th><th>秒开率</th><th>1.5 秒开率</th><th>2 秒开率</th></tr></thead><tbody><tr><td>全离线</td><td>700ms</td><td>90%</td><td>98%</td><td>99%</td></tr><tr><td>部分离线/SSG/SSR</td><td>1000ms</td><td>80%</td><td>95%</td><td>98%</td></tr><tr><td>端内</td><td>1200ms</td><td>70%</td><td>90%</td><td>95%</td></tr><tr><td>端外</td><td>1500ms</td><td>50%</td><td>60%</td><td>80%</td></tr></tbody></table><hr><h2 id="三、通用性能优化手段"><a href="#三、通用性能优化手段" class="headerlink" title="三、通用性能优化手段"></a>三、通用性能优化手段</h2><p>性能优化手段可以大致分为以下几个阶段：</p><p><img src="/images/webOptimize/p-main.png" alt="p-main.png"></p><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>好的前端模式及架构设计能带来性能优化事半功倍的效果，目前主流的做法就是通过借助<strong>客户端侧</strong>或者<strong>服务端</strong>能力。</p><h4 id="借助端侧能力"><a href="#借助端侧能力" class="headerlink" title="借助端侧能力"></a>借助端侧能力</h4><p>客户端原生性能更为优异，所以端侧业务可以借助客户端能力进行有效性能优化。常用的方式如下：</p><ul><li><strong>离线化</strong>：通过将在线请求的资源本地化，减少资源请求时间，提升页面加载性能。<ul><li><strong>通用资源离线</strong>。页面及业务代码在线，通用资源走端侧离线，适用运营活动等流动页面。</li><li><strong>页面整体离线</strong>。页面相关静态资源基本全部离线，适用于强性能、稳定性要求的页面。</li></ul></li><li><strong>混合/原生</strong>：借助端侧能力降低渲染成本。<ul><li><strong>原生组件</strong>。弹窗、toast、Video 等控件原生调用。</li><li><strong>原生渲染</strong>。通过 DSL 控制原生呈现、RN、小程序等。</li></ul></li><li><strong>js 引擎优化</strong>：通过性能更优、对 ES 新特性支持更好的引擎降低 js 解释及执行时间。<ul><li><strong>多线程</strong>。类似 web worker 的能力，但端侧的双线程定制通常面向业务更为灵活。</li><li><strong>抛弃系统引擎</strong>。使用如 Quickjs，并结合字节码等优化技术。</li></ul></li></ul><h4 id="借助服务端能力"><a href="#借助服务端能力" class="headerlink" title="借助服务端能力"></a>借助服务端能力</h4><p>意义在于弥补主要内容在前端渲染的成本，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。比较推荐的通用做法是：使用服务端渲染静态 HTML 来获得更快的首次有效绘制，一旦 js 加载完毕再将页面接管下来。</p><ul><li><strong>SSG</strong>。通常需要业务定制，不过也有像 JAMStack 等相对通用型框架；也包括 PHP、Java 等实现；</li><li><strong>SSR</strong>。Nextjs、Nustjs 等，也包括 PHP、Java 等实现。</li><li><strong>微前端</strong>。如 qiankun 等基于 single-spa 的系列、fronts 等基于 module-federation 的系列。</li><li><strong>边缘能力及 CDN</strong>。通过大面积范围的 cdn 节点减少服务端远距离传输的性能问题，有效提升加载性能。常用的有 cdn 存放静态资源。</li><li>*<strong>bigPipe</strong>。一种动态网页加载技术。将网页分解成称为 pagelets 的小块，然后分块传输到浏览器端，进行渲染。</li></ul><blockquote><p>借助服务端能力一定要注意“三高”的控制及监控。</p></blockquote><h4 id="前端框架选择"><a href="#前端框架选择" class="headerlink" title="前端框架选择"></a>前端框架选择</h4><p>从性能角度考虑：</p><ul><li>纯 web：性能最佳，开发成本相对较大，适合极高性能要求的单数据流业务场景，如首页。模板渲染可使用<a href="http://mustache.github.io/" target="_blank" rel="noopener">Mustache</a>等模版引擎。</li><li>Vue：开发成本最小。可考虑使用<a href="https://github.com/vuejs/petite-vue" target="_blank" rel="noopener">petite-vue</a>等 lite 库减负。</li><li>React：开发成本小。可考虑使用<a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a>等 lite 库减负。</li><li>其他：像<a href="https://github.com/sveltejs/svelte" target="_blank" rel="noopener">Svelte</a>其实也比较轻，但目前沉淀少、生态相对较弱，开发成本仍较大。</li></ul><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><h4 id="静态资源准备工作"><a href="#静态资源准备工作" class="headerlink" title="静态资源准备工作"></a>静态资源准备工作</h4><ul><li>图片格式选择：<ul><li>丰富色彩使用 <code>jpg</code>、透明色使用 <code>png</code>、单调色彩使用 <code>2/4/8/16/32/64/128/256</code> 位 <code>png</code>（每个通道 8 位为每个通道提供 256 个值，RGB 三个通道一共可以为每个像素提供 16777216 种颜色。）；</li><li>根据环境使用 <code>WebP</code>；</li><li>减少 <code>gif</code> 的使用，使用 CSS3/SVG/canvas 动画、lottie 等新形式，一些场景下视频也比 <code>gif</code> 效率高。</li></ul></li><li>响应式图片。<code>srcset</code>，<code>sizes</code>和<code>&lt;picture&gt;</code>元素使用响应式图片。也可以通过<code>&lt;picture&gt;</code>元素使用 <code>WebP</code> 格式的图像。</li><li>CSS3/SVG 代替图片，SVG 也可以通过<a href="https://github.com/svg/svgo" target="_blank" rel="noopener">svgo</a>等工具进行压缩优化。</li><li>使用字体图标代替图片图标<br><img src="/images/webOptimize/p-4_img-optimize.png" alt="p-4_img-optimize.png"></li></ul><h4 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h4><ul><li><p>HTML 注意事项：</p><ul><li>正确的标签写法。当 HTML 标签不满足 web 语义化时，浏览器需要更多时间去解析 DOM 标签的含义，进行语法纠错。</li><li>减少 iframes 使用，或者延迟 iframes 加载，保证不会影响父文档加载。</li><li>删除无效内容，减少 DOM 节点。</li><li>删除元素默认属性。</li><li>避免节点深层级嵌套，避免生成 dom 树时占用太对内存。</li><li>减少 table 布局，table 开销非常大。</li><li>css、js 尽量外链，js 考虑异步引入。</li></ul></li><li><p>CSS 注意事项：</p><ul><li>降低 CSS 选择器复杂性。避免使用通用选择器<code>*</code>；选择器层级不宜过多；提高关键选择器（最右）的匹配强度，比如不适用元素选择器；谨慎使用一些<code>expensive</code>的属性，如<code>nth-child</code>。</li><li>避免浮动布局，使用 <code>flexbox</code>。</li><li>善用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" target="_blank" rel="noopener"><code>will-change</code></a> 属性：<code>will-change</code> 属性告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。</li><li>善用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display" target="_blank" rel="noopener"><code>font-display</code></a> 属性优化字体：<code>font-display</code> 属性定义了浏览器如何加载和显示字体文件，允许文本在字体加载或加载失败时显示回退字体。可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能。</li><li>善用 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Performance/CSS#contain_%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener"><code>contain</code></a> 属性：<code>contain</code> 属性允许开发者指示元素及其内容尽可能独立于文档树的其余部分。 这允许浏览器针对 DOM 的有限区域而不是整个页面重新计算布局/样式。</li></ul></li><li><p>JS 注意事项：</p><ul><li>使用原生方法。有些 lodash/polyfill 方法已经过时了</li><li>异步化。任务冲突时（主线程和合成线程调度不合理）使用<code>requestAnimatinFrame(..)</code>/<code>setTimeout(..)</code>分割队列；Web Worker 等。</li><li>减少重绘重排。<ul><li>对高频触发的事件进行节流或防抖。</li><li>减少 DOM 操作，批量操作 DOM：请尽可能减少访问 DOM 的次数（缓存 DOM 属性和元素、把 DOM 集合的长度缓存到变量中并在迭代中使用）；如果操作需要进行多次重排与重绘，建议先让元素脱离文档流；善于使用事件委托。</li></ul></li><li>考虑使用事件委托。</li><li>循环/运算优化。<ul><li><code>switch</code> 和 <code>if...else</code> 的使用。</li><li>善用位运算。</li></ul></li><li>流程控制优化。一些流程控制相关的一些做法可以略微提升性能（这些细节在大型开源项目中大量运用）：避免使用 <code>for...in</code>（它能枚举到原型，所以很慢）；在 js 中倒序循环会略微提升性能；减少迭代的次数；基于循环的迭代比基于函数的迭代快；用 Map 表代替大量的 <code>if-else</code> 和 <code>switch</code>等。</li><li>数据读取优化。如字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢；变量从局部作用域到全局作用域的搜索过程越长速度越慢；对象嵌套的越深，读取速度就越慢；对象在原型链中存在的位置越深，找到它的速度就越慢；</li><li>配合 V8 等引擎的优化。如 JIT、Hidden Class、函数的解析方式有 lazy parsing 懒解析和 eager parsing 饥饿解析。</li></ul></li><li><p>vue 注意事项：</p><ul><li>根据场景使用 no-reactive data</li><li>不要将所有数据都放到 data 中</li><li>尝试 JSX/TSX 写法</li><li>善用 Functional component</li><li>子组件拆分</li><li>使用局部变量</li><li>根据业务场景使用 v-show</li><li>keep-alive 缓存组件</li><li>列表使用 key，且不建议使用索引</li><li>使用事件代理</li><li>虚拟列表</li><li>组件按需加载</li><li>去除无用的路由、状态管理引用</li><li>…</li></ul></li><li><p>React 注意事项：</p><ul><li>善用 Functional Component，留意其中函数定义及 render 场景</li><li>善用 React.memo、PureComponent/shouldComponentUpdate</li><li>善用 useMemo、useCallback</li><li>useEffect 设置合理的依赖项</li><li>批量更新，unstable_batchedUpdates</li><li>发布订阅者跳过中间组件 Render、跳过回调函数改变触发的 Render</li><li>状态下放，缩小状态影响范围</li><li>避免在 didMount、didUpdate 中更新组件 state</li><li>子组件拆分</li><li>使用局部变量</li><li>css 控制节前展示隐藏</li><li>列表使用 key，且不建议使用索引</li><li>使用事件代理</li><li>虚拟列表</li><li>组件按需加载</li><li>去除无用的路由、状态管理引用</li><li>…</li></ul></li></ul><h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><ul><li><p>构建处理优化</p><ul><li>提取三方库代码。如使用<code>html-webpack-externals-plugin</code>。</li><li>Webpack 按需引入。</li><li>使用动态引入。</li><li>Tree Shaking、Scope hoisting、Code-splitting。Webpack 与 Rollup 都支持 Scope Hoisting。code-splitting 能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。</li></ul></li><li><p>压缩文件。webpack 插件（webpack4 默认<code>optimization.minimize</code>配置）：</p><ul><li>js：UglifyPlugin</li><li>css：MiniCssExtractPlugin、clean-css</li><li>html：HtmlWebpackPlugin、html-minifier</li><li>图片：tinypng、image-webpack-loader</li></ul></li><li><p>预渲染。根据业务场景，类似 SSG 方案将主要内容渲染至 html，如使用<a href="https://www.npmjs.com/package/prerender-spa-plugin" target="_blank" rel="noopener"><code>prerender-spa-plugin</code></a>插件。</p></li><li><p>根据资源优先级和阻塞情况，优先加载关键资源。</p><ul><li>将 CSS 文件放在 HTML 头部，js 文件放在 HTML 底部。</li><li>按需异步加载 js：acync、defer、动态脚本。</li><li>懒加载。延迟加载所有体积较大的组件、字体、JS、视频或 Iframe。可以通过 Intersection Observer 延迟加载图片、视频、广告脚本、或任何其他资源。可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。</li><li>优先加载关键的 CSS。可以将首屏渲染必须用到的 CSS 提取出来内嵌到<code>&lt;head&gt;</code>中，然后再将剩余部分的 CSS 用异步的方式加载。可以借助工具<a href="https://github.com/addyosmani/critical" target="_blank" rel="noopener">critical</a></li><li>利用<a href="https://w3c.github.io/resource-hints/" target="_blank" rel="noopener">资源提示 Resource hints</a>，<code>dns-prefetch</code>、<code>preconnect</code>、<code>prefetch</code>与<code>prerender</code>、这些可以帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。</li><li>利用<a href="https://www.w3.org/TR/preload/" target="_blank" rel="noopener">预加载 Preload</a>，Preload 提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过声明性标记预加载 CSS 资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"https://undefined.cn/moo-css-base.min.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或，通过JavaScript预加载 CSS 资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> res = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">  res.rel = <span class="string">'preload'</span>;</span></span><br><span class="line"><span class="javascript">  res.as = <span class="string">'style'</span>;</span></span><br><span class="line"><span class="javascript">  res.href = <span class="string">'https://undefined.cn/moo-css-base.min.css'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.head.appendChild(res);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>PRPL 描述了一种用于使网页加载并变得更快的交互模式：Push (or preload)：推送或预加载最重要的资源；Render：尽快渲染初始路径；Pre-cache：预缓存剩余资源；Lazy load：延迟加载其他路由和非关键资源。</p></blockquote><p><img src="/images/webOptimize/p-load_flow.png" alt="p-load_flow.png"></p><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS 缓存优化；</li><li>预解析 DNS，减少 DNS 查找。关于 DNS 的预解析可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch" target="_blank" rel="noopener">《MDN-dns-prefetch》</a>；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"https://blog.michealwayne.cn"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>页面中资源的域名的合理分配，涉及域名不要太多（通常不要超过 6 个）；</li></ul><h4 id="HTTP-s-请求"><a href="#HTTP-s-请求" class="headerlink" title="HTTP(s) 请求"></a>HTTP(s) 请求</h4><ul><li><p>减少请求</p><ul><li>资源合并。根据复用情况使用<code>s.thsi.cn</code>的<code>cb</code>拼接；</li></ul></li><li><p>使用 HTTP2。相比 HTTP1.1，HTTP2 解析速度更快，也提供了部首压缩功能。更为重要的，多路复用实现并行能力。当前<code>*.thsi.cn</code>具备了 HTTP2 能力，因此静态资源应尽可能得部署在 thsi。</p></li><li><p>善用缓存，不重复加载相同的静态资源。正确设置 <code>expires</code>，<code>cache-control</code> 和其他 HTTP 缓存头。</p><ul><li>强缓存。如长期不变的资源设置<code>Cache-Control:max-age=31536000</code></li><li>协商缓存。资源可能随时发生变动。</li></ul></li><li><p>静态资源使用 CDN。借助边缘能力，静态资源尽可能放<code>*.thsi.cn</code></p></li><li><p>服务端启动 gzip。</p></li><li><p>避免重定向。服务端的 302、<code>&lt;meta&gt;</code>标签实现的重定向以及前端<code>location.replace(..)</code>的重定向都会引发新的 DNS 查询。</p></li><li><p>懒加载。考虑请求优先级，非首屏图片/资源考虑延迟加载。</p></li><li><p>离线化。见下文</p></li></ul><h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><ul><li><p>减少渲染成本</p><ul><li>控制首次渲染节点及样式，不易过多。</li><li>简单图形以 CSS 呈现。</li><li>避免首次渲染时的重绘重排。</li></ul></li><li><p>预渲染。见下文</p></li><li><p>骨架屏。可以自己手动写骨架，也可以通过一些基于 puppeteer 的骨架生成方案。</p></li></ul><h3 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h3><ul><li><p>减少重绘重排</p><ul><li>对高频触发的事件进行节流或防抖</li><li>减少 DOM 操作，批量操作 DOM</li></ul></li><li><p>动画</p><ul><li>在 GPU 上呈现动画，适时开启硬件加速。属性包括 3D transforms (<code>transform: translateZ()</code>, <code>rotate3d()</code>等)，<code>animating transform</code> 和 <code>opacity</code>, <code>position: fixed</code>，<code>will-change</code>，和 <code>filter</code>。如 <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code> 和 <code>&lt;iframe&gt;</code>，也位于各自的图层上。 将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成，从而改善性能，尤其是在移动设备上。虽然一些像 <a href="https://greensock.com/gsap/" target="_blank" rel="noopener">GSAP</a>、 <a href="http://velocityjs.org/" target="_blank" rel="noopener">VelocityJs</a> 等一些 js 动画库声称性能上可以做得比 CSS 好，但目前绝大多数业务场景用不到这些库；反观 CSS3，简单的<code>transform</code>便能减少 reflow。</li><li>较复杂动画中，用 lottie/视频 代替 gif。</li><li><code>requestAnimationFrame</code> 实现视觉变化。</li></ul></li><li><p>交互</p><ul><li>快速响应的用户界面。PSI 是提升用户体验的重要指标，可以多使用一些骨架或 Loading 过渡。比如一些游戏类场景，可以先通过 loading 进度条保证主要资源提前加载或处理完成，带来运行时的体验提升。</li><li>避免阻塞性执行，保证输入响应（Input responsiveness），如输入框的节流处理等。</li></ul></li></ul><p><img src="/images/webOptimize/p-7_ux-optimize.png" alt="p-7_ux-optimize.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>Canvas 性能优化</p><ul><li>离屏</li><li>图像缓存</li></ul></li><li><p>web worker</p><ul><li>应用场景：编码/解码大字符串；复杂数学运算（包括图像，视屏处理）；大数组排序；</li></ul></li><li>PWA：Service Worker &amp; Offline data<ul><li>应用场景：端外复杂 web 应用，可见<a href="https://web.dev/learn/pwa/" target="_blank" rel="noopener">https://web.dev/learn/pwa/</a>。注意 PWA 的缓存控制以及它不解决首次启动问题。</li></ul></li></ul><hr><h2 id="4-端侧应用的性能优化手段-hybrid"><a href="#4-端侧应用的性能优化手段-hybrid" class="headerlink" title="4.端侧应用的性能优化手段(hybrid)"></a>4.端侧应用的性能优化手段(hybrid)</h2><p>上文也提到过，借助端侧能力，hybrid 的性能优化效果远大于普通的处理优化，目前在主流应用中广泛应用。</p><h3 id="端侧-Web-运行环境优化"><a href="#端侧-Web-运行环境优化" class="headerlink" title="端侧 Web 运行环境优化"></a>端侧 Web 运行环境优化</h3><ul><li><strong>内核升级</strong>。iOS 升级 WKWebView、Android 升级 X5。</li><li><strong>协议及 WebView 启动优化</strong>。如全局化 WebView。</li></ul><h3 id="离线化"><a href="#离线化" class="headerlink" title="离线化"></a>离线化</h3><p>离线化可以最大程度地摆脱网络环境对 web 的影响。基本运作是将项目的静态资源打成离线包，客户端在启动应用等时机进行加载及解压操作。在访问资源时，客户端根据 URL 标识进行拦截，如果能在本地找到对应资源文件，则直接以本地信息响应，否则加载远程页面。</p><ul><li>优点：避免资源请求，首开性能极佳（全离线 FCP 通常能保证在 800ms 内）；</li><li>缺点：维护成本较高，需要平台及构建工具支持；</li><li>适用场景：迭代频率相对稳定、高加载性能要求的业务场景。</li></ul><h4 id="离线包方案"><a href="#离线包方案" class="headerlink" title="离线包方案"></a>离线包方案</h4><p>需要与客户端配合，方案可以借鉴阿里 mPaaS——<a href="https://help.aliyun.com/document_detail/49762.html" target="_blank" rel="noopener">H5 容器和离线包</a></p><h3 id="webview-预热"><a href="#webview-预热" class="headerlink" title="webview 预热"></a>webview 预热</h3><p>在应用启动等特定触发时机下，在后台无感知启动 webview 并预热页面，此 webview 全局化、池化，在访问 URL 时即直接调起预热 webview。</p><ul><li>优点：访问是统一 webview ，加载体验最佳（外界最佳实践下通常能达到 <code>200ms</code>的均值 FCP）；</li><li>缺点：有性能开销（空间换时间）；仅能使用于业务最重要业务场景；</li><li>适用场景：如资讯、双十一活动等高频业务。</li></ul><blockquote><p>性能要求极强的场景甚至可以考虑 NSR</p></blockquote><h3 id="WebView-资源预加载"><a href="#WebView-资源预加载" class="headerlink" title="WebView 资源预加载"></a>WebView 资源预加载</h3><p>在应用启动时，在后台无感知启动 WebView，此 WebView 通过配置项预先加载应用内常用 js/css/image/font 资源，以在访问页面时资源请求命中本地缓存。</p><ul><li>优点：不影响业务开发，成本小；</li><li>缺点：通用资源的定义和配置需要评估、避免请求浪费；</li><li>适用场景：应用存在高频公共资源，但这些资源无法使用离线方案。</li></ul><h4 id="通用预加载方案接入"><a href="#通用预加载方案接入" class="headerlink" title="通用预加载方案接入"></a>通用预加载方案接入</h4><p>可借助通用预热方案，启动预热 WebView，此 WebView 根据配置进行资源预加载。</p><p>当然，无论是离线还是预热，我们仍然需要考虑资源优化，比如通过分包、图片远程等方式，减少不必要的资源加载。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在当今信息爆炸的时代，人们对网页性能的要求越来越高，对于许多网站来说，性能是影响用户满意度和转化率的重要因素。本文主要介绍了 web 性能优化的指标和手段，从响应时间、页面加载速度、资源优化等多个方面进行了分析。但是，性能优化是一个不断迭代的过程，需要根据实际情况进行分析和优化。只有持续不断地进行性能测试和优化，才能保证网站始终处于最佳状态，为用户提供流畅、高效、愉悦的体验。因此，我们应该时刻关注性能指标，不断探索新的优化手段，为用户带来更好的体验。</p><hr><h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><ul><li>《Google-Developer Loading Performace》<a href="https://developers.google.com/web/fundamentals/performance/get-started?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/get-started?hl=zh-cn</a></li><li>《Google-Developer Rendering Performace》<a href="https://developers.google.com/web/fundamentals/performance/rendering?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering?hl=zh-cn</a></li><li>《以用户为中心的性能指标》<a href="https://web.dev/user-centric-performance-metrics/" target="_blank" rel="noopener">https://web.dev/user-centric-performance-metrics/</a></li><li>《WebDev RAIL 模型》<a href="https://web.dev/rail/" target="_blank" rel="noopener">https://web.dev/rail/</a></li><li>《MDN-Web 性能》<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Performance</a></li><li><p>《MDN-Performance》<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p></li><li><p>《嗨，送你一张 Web 性能优化地图》<a href="https://github.com/berwin/Blog/issues/23" target="_blank" rel="noopener">https://github.com/berwin/Blog/issues/23</a></p></li><li>《Web Vitals》<a href="https://web.dev/learn-web-vitals/" target="_blank" rel="noopener">https://web.dev/learn-web-vitals/</a></li><li>《合集-Web 性能优化》<a href="https://asmcn.icopy.site/awesome/awesome-wpo/" target="_blank" rel="noopener">https://asmcn.icopy.site/awesome/awesome-wpo/</a>，（有广告）</li><li>《大型网站性能优化实战——从前端、网络、CDN 到后端、大促的全链路性能优化详解》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web-性能及优化&quot;&gt;&lt;a href=&quot;#web-性能及优化&quot; class=&quot;headerlink&quot; title=&quot;web 性能及优化&quot;&gt;&lt;/a&gt;web 性能及优化&lt;/h1&gt;&lt;h4 id=&quot;更新信息&quot;&gt;&lt;a href=&quot;#更新信息&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能" scheme="http://blog.michealwayne.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《软件开发的201个原则》（201 Principles of software development）读书笔记</title>
    <link href="http://blog.michealwayne.cn/2021/11/28/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84201%E4%B8%AA%E5%8E%9F%E5%88%99%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2021/11/28/notes/【笔记】《软件开发的201个原则》/</id>
    <published>2021-11-28T09:20:09.000Z</published>
    <updated>2021-11-29T05:11:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《软件开发的201个原则》（201-Principles-of-software-development）"><a href="#《软件开发的201个原则》（201-Principles-of-software-development）" class="headerlink" title="《软件开发的201个原则》（201 Principles of software development）"></a>《软件开发的201个原则》（201 Principles of software development）</h1><blockquote><p>作者：Alan M. Davis，Offtoa 公司联合创始人兼首席执行官（2012年开始）；曾任Omni-Vista 公司的联合创始人、董事长兼首席执行官，Requisite 公司的董事会创始成员，BTG 公司副总裁。</p></blockquote><p>从项目管理十大领域及其他涉及领域进行分类记录：</p><p><img src="/images/20211128/p-guide.png" alt="p-guide"></p><h3 id="书中划分维度-章节"><a href="#书中划分维度-章节" class="headerlink" title="* 书中划分维度/章节"></a>* 书中划分维度/章节</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p><img src="/images/20211128/p-1.jpg" alt="p-1.jpg"></p><h4 id="（第二章）一般原则"><a href="#（第二章）一般原则" class="headerlink" title="（第二章）一般原则"></a>（第二章）一般原则</h4><p>对应原则1～37。</p><h4 id="（第三章）需求工程原则"><a href="#（第三章）需求工程原则" class="headerlink" title="（第三章）需求工程原则"></a>（第三章）需求工程原则</h4><p>对应原则38～60。</p><p>需求工程包括以下活动：</p><ul><li>1.提出或研究需要解决的问题；</li><li>2.具体说明一个能解决该问题的系统外部（黑盒）行为。</li></ul><p>需求工程的最终产出是需求规格说明书（Requirement Specification）。</p><h4 id="（第四章）设计原则"><a href="#（第四章）设计原则" class="headerlink" title="（第四章）设计原则"></a>（第四章）设计原则</h4><p>对应原则61～86。</p><p>设计包括以下活动：</p><ul><li>1.定义满足需求的软件架构（architecture）；</li><li>2.具体说明架构中的各个软件组件的算法。</li></ul><p>架构包括：软件中所有模块的定义，它们之间如何提供接口，它们之间如何组装，组件的拷贝如何实例化和销毁。</p><p>设计的最终产出是设计规格说明书（Design Specification）。</p><h4 id="（第五章）编码原则"><a href="#（第五章）编码原则" class="headerlink" title="（第五章）编码原则"></a>（第五章）编码原则</h4><p>对应原则87～106。</p><p>编码是包含以下行为的集合：</p><ul><li>1.将设计阶段确定的算法转换为用计算机语言编写的程序；</li><li>2.将程序（通常是自动化的）转换为可被计算机直接执行的语言。</li></ul><p>编码的主要输出结果就是程序清单。</p><h4 id="（第六章）测试原则"><a href="#（第六章）测试原则" class="headerlink" title="（第六章）测试原则"></a>（第六章）测试原则</h4><p>对应原则107～126。</p><p>测试是包含以下行为的集合：</p><ul><li>1.对独立的软件组件执行测试（即单元测试，Unit Testing），以确保其行为与组件设计规格说明中的定义足够接近；</li><li>2.对执行过单元测试的组件集合执行测试（即集成测试，Integration Testing），以确保这些组件一起工作时的行为足够接近设计规格说明中的定义；</li><li>3.对集成测试过的所有组件进行测试（即软件系统级测试，Software Systems-level Testing），以确保它们可以作为一个系统来运行，且行为足够接近软件需求规格说明中的定义；</li><li>4.制订软件系统级测试的测试计划；</li><li>5.制订软件集成测试的测试计划；</li><li>6.制订单元测试的测试计划；</li><li>7.建立测试装置（test hamess）和测试环境（test environment）。</li></ul><h4 id="（第七章）管理原则"><a href="#（第七章）管理原则" class="headerlink" title="（第七章）管理原则"></a>（第七章）管理原则</h4><p>对应原则127～172。</p><p>管理是围绕软件开发的所有工程活动，是进行计划（plan）、控制（control）、监视（monitor）和报告（report）的一组活动。</p><h4 id="（第八章）产品保证原则"><a href="#（第八章）产品保证原则" class="headerlink" title="（第八章）产品保证原则"></a>（第八章）产品保证原则</h4><p>对应原则173～184。</p><p>产品保证是通过使用分权制衡（checks and balances）来确保软件质量的一系列活动。产品保证通常包括如下几项：</p><ul><li>1.软件配置管理（Software configuration management）：是管理软件变更的过程；</li><li>2.软件质量保证（Software quality assurance）：是检查所有做法和产品是否符合既定流程和标准的过程；</li><li>3.软件验证和确认（Software verification and validation）：这个过程用于验证（verify）每个中间产品是否正确地建立在以前的中间产品的基础上，以及确认（validate）每个中间产品是否适当地满足客户的要求；</li><li>4.测试（Testing）。</li></ul><h4 id="（第九章）演变原则"><a href="#（第九章）演变原则" class="headerlink" title="（第九章）演变原则"></a>（第九章）演变原则</h4><p>对应原则185～201。</p><p>演变是与修改软件产品相关的一系列工作。用于：</p><ul><li>1.满足新功能；</li><li>2.更有效地运行；</li><li>3.正常运行（当检测到原始产品中的错误时）。</li></ul><hr><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>豆瓣：英文原版<a href="https://book.douban.com/subject/4775995/" target="_blank" rel="noopener">https://book.douban.com/subject/4775995/</a>，中文版<a href="https://book.douban.com/subject/35628886/" target="_blank" rel="noopener">https://book.douban.com/subject/35628886/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《软件开发的201个原则》（201-Principles-of-software-development）&quot;&gt;&lt;a href=&quot;#《软件开发的201个原则》（201-Principles-of-software-development）&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://blog.michealwayne.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《人件》（Peopleware，第三版）读书笔记（下）人件》（第三版）</title>
    <link href="http://blog.michealwayne.cn/2021/11/07/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BA%BA%E4%BB%B6%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2021/11/07/notes/【笔记】《人件》（第三版）（下）/</id>
    <published>2021-11-07T12:15:56.000Z</published>
    <updated>2021-11-16T07:46:47.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《人件》（Peopleware，第三版）读书笔记（下）"><a href="#《人件》（Peopleware，第三版）读书笔记（下）" class="headerlink" title="《人件》（Peopleware，第三版）读书笔记（下）"></a>《人件》（Peopleware，第三版）读书笔记（下）</h1><blockquote><p>也许，软件系统的主要问题不在于技术，而在于社会性因素。</p></blockquote><h2 id="高效团队养成"><a href="#高效团队养成" class="headerlink" title="高效团队养成"></a>高效团队养成</h2><p>好的工作体验总是伴随着一定的挑战性。在我们那些珍贵的工作记忆中，浮现在眼前的都是团队的互动。当一组人融合为一个整体时，工作的全部特征就改变了。工作中的挑战固然重要，但重要的不是它本身，而是它指引着我们共同努力的方向。挑战是我们成为整体的载体。在那些能够让大家尽情发挥到自己极限的工作团队里，团队互动就是全部工作。</p><h3 id="整体大于部分之和"><a href="#整体大于部分之和" class="headerlink" title="整体大于部分之和"></a>整体大于部分之和</h3><p>对拥有共同任务的一群人都称其为团队。然而，很多这样的小组并不像团队。他们没有对成功进行共同定义，或者没有一种可识别的团队精神。某些东西缺失了，那是一种被我们称为“凝聚力”的现象。</p><h4 id="有凝聚力团队的概念"><a href="#有凝聚力团队的概念" class="headerlink" title="有凝聚力团队的概念"></a>有凝聚力团队的概念</h4><blockquote><p>一个有凝聚力的团队是一组紧密交织在一起的人，他们的整体大于个体之和。</p></blockquote><p>一旦团队产生了凝聚力，成功的几率将大大增加。这样的团队不需要传统意义上的管理，更不需要激励，他们斗志昂扬。</p><p>产生这种现象的原因并不复杂：团队都是围绕共同目标成立的。在凝聚为团队之前，团队中的每个人可能都有自己不同的目标。但作为凝聚过程的一部分，他们聚拢所有，汇成一个共同目标。公司级目标至关重要，因为它对团队而言意义非凡。目标自身对团队成员来说可能有一定的随机性，但大家可以竭力去追求目标的实现。</p><h4 id="歇斯底里式的乐观管理"><a href="#歇斯底里式的乐观管理" class="headerlink" title="歇斯底里式的乐观管理"></a>歇斯底里式的乐观管理</h4><p>相信员工都会自动认同组织的目标，只能说明管理上的盲目乐观。要让个体把自身融入组织目标中的机制实在太复杂了。例如某一位数据库专家，他更倾向于把自己描述为一位父亲、或本地学校委会的一员。在这些角色中，他随时都在通过深入思考做出价值判断。让人诧异的是，他是否会在谈及工作时停止进行价值判断呢？他不会，他会在工作中持续地评判和他个人能力及信任度有关的各种言论。组织里的人时刻都在批判组织目标，而且，他们认为大多数目标都过于随意。</p><p>这里的困境在于，倘若你是一名老板，你可能真心诚意地接受了企业的经营目标，要是你的员工不够热情你就会感到失望。但回头想想，你自己对企业目标的强认可也许也不仅仅是职业素养的表现吧？难道不是你的老板或者企业高层通过一点点聪明的设计，让企业的目标和你个人目标一致带来的吗。利用组织阶梯，保证管理者有强烈个人动机去接受企业目标，这种设计很巧妙。然而到了最底层，在真正开展工作的地方，这种设计就失效了。在那里，我们仅仅希望用所谓的“职业素质”来保证大家都向同一个方向前进，这完全就是撞大运。</p><p>所有员工拥有共同信念，别再心存这样的幻想啦。</p><h4 id="纳瓦隆大炮"><a href="#纳瓦隆大炮" class="headerlink" title="纳瓦隆大炮"></a>纳瓦隆大炮</h4><p>企业的目标或多或少总是会让大家感到过于专制——企业对人们来说本来就是专制的——但带有强制性的目标并不意味着没人接受。如果真是这样，那么就不会有体育竞赛了，体育竞赛的目标总是强制的。</p><p>团队外围的人可能对团队的成败感兴趣，但他们的兴趣相对团队成员来说就微乎其微了。在凝聚力强的团队中工作的人们常常会过度投入，以至于疯狂到想要使用纳瓦隆大炮。</p><p>尽管有凝聚力的团队拥有这样的动力及热情，管理者却不愿意经历必需的痛苦去孵化它。部分原因在于不理解为什么团队需要凝聚力。对达成目标有强烈驱动力的管理者会发现团队并不会帮助达成目标，反而是团队里的人在达成目标。为达成目标，分解的每个任务基本都是由团队中的个体来完成的，大部分工作也是由个体单独完成的。</p><blockquote><p>团队存在的目标不是达成目标，而是让目标一致。</p></blockquote><h4 id="有凝聚力团队的标志"><a href="#有凝聚力团队的标志" class="headerlink" title="有凝聚力团队的标志"></a>有凝聚力团队的标志</h4><p>最重要的一项是在项目和任务执行过程中的低人员流失率。团队成员都愿意留下来完成项目。可悲的是，管理者通常会忽视团队成功的标志。即使情况已经很糟糕，他们仍然不愿意关注人员的流失；让流失率较低时，他们根本不会去想。</p><p>有凝聚力的团队通常都有一个很强的自我认知。队友之间都用一些朗朗上口的称呼而且会分享诸多玩笑。团队可能拥有明显的地盘，大家聚在一块儿共进午餐。</p><p>在好的团队中，有一种精英的感觉。队员们都觉得自己是独特事物的一部分，他们感觉比机器强多了。他们自有一种傲慢，从而使得那些不在团队的人们感到不舒服。</p><p>有凝聚力的团队对生产出来的产品有强烈的归属感。参与者都希望一个产品或某个组成部分能够留下大家的名字。每个人都希望别人看到自己的成果。</p><p>有凝聚力的团队的最后一个标志是队员们对工作乐在其中。有凝聚力的团队显得健康而拥有活力，交流轻松自如，自信而充满热情。</p><h4 id="团队和团伙"><a href="#团队和团伙" class="headerlink" title="团队和团伙"></a>团队和团伙</h4><p>团队和团伙的区别就像微风和阵风，他们意义相同，都是凉的流动空气。若你感到让人心旷神怡，你会说这是微风；如果让人烦闷不安，你会说这是阵风。同理，当一个密切协作的工作小组凝聚在一起并让大家感到愉快时，大家会说这是一个团队；但如果让大家感觉是一种威胁，人们会使其为团伙。</p><p>对团伙的恐惧是管理缺乏安全感的表现。越感觉不安全，越害怕团伙这个想法。个中自有因由：管理者往往不是真正意义上的团队成员，所以被排除在团队外的感觉超过了跟团队紧密相连的感觉。团队内部的信任程度也要高于把团队联系在公司内的信任度。然后就会滋生一种糟糕的想法，认为紧密连接的团队可能会脱离集体而把所有的动力和热情用于竞争。就是这些原因造成了缺乏安全感的管理者们惧怕团伙的情形。他会感觉跟一群统一的可替代的塑料人一起工作会更好。</p><p>一个拥有凝聚力的工作组可能自傲、自足、让人头疼还有点排外，但对比拼凑起来的可替换部件，它却能帮助管理者实现真正的目标。</p><h3 id="黑衣团伙"><a href="#黑衣团伙" class="headerlink" title="黑衣团伙"></a>黑衣团伙</h3><h4 id="传奇团队的人员组成"><a href="#传奇团队的人员组成" class="headerlink" title="传奇团队的人员组成"></a>传奇团队的人员组成</h4><p>在软件交付前，要找到最后的缺陷很难，但一些测试人员能够做得更好。于是这一家公司集合了一些才华卓越的测试人员，分配给他们任务，要求关键软件交付给客户之前做最后的测试。于是具有传奇色彩的黑衣团队（Black Team）诞生了。黑衣团队最让人吃惊的不是他们在一开始有多好，而是在接下来的一年时间里的改进。一些神奇的事情发生了：团队形成了自己的个性。在测试的对抗哲学影响下，这一个性在团队成员中形成，它让大家积极主动地去发现缺陷。他们并不完全是为开发人员提供支持，恰恰相反，他们乐于提交一个程序去接受一系列测试，更像是一种考验。提交你的程序去接受黑衣团队测试，就像去经受冷血魔王的考验一样。</p><h4 id="可怜的地球生物，谁能拯救你们呢？"><a href="#可怜的地球生物，谁能拯救你们呢？" class="headerlink" title="可怜的地球生物，谁能拯救你们呢？"></a>可怜的地球生物，谁能拯救你们呢？</h4><p>团队开始树立起毁灭者的形象。他们毁灭的不仅仅是你的代码，而是你的一整天。他们使用各种惨无人道的手段来造成程序失败，比如缓冲区过载、空文件比较或者输入无理的长字符串。看着自己的程序被如此邪恶的方式给践踏，你越感到难过，但他们越开心。</p><p>为了加强邪恶形象的效果，团队开始身着黑衣（黑衣团队得名的由来）。逐渐程序员们开始抱怨黑衣团队这种病态的折磨。</p><p>不用说，公司自然乐见于此，团队找到的每一个缺陷都不是客户发现的，团队获得了巨大的成功。作为一个测试组织，它成功了，但更重要的，团队作为一个社会单元成功了。团队内部的化学反应本身成了目标。</p><p>随着时间推移，团队成员逐渐转移到其他事情上。由于团队担负了如此重要的任务，每离开一位就有新人加入，这样一直到全部原班人马都离开了团队。但黑衣团队仍然存在，团队失去了原来的所有人，但团队的动力和个性依然存在。</p><h3 id="团队自毁"><a href="#团队自毁" class="headerlink" title="团队自毁"></a>团队自毁</h3><p>当你试图解决问题时感觉被卡住了，Edward deBono《水平思考》（Lateral Thinking）建议，与其一根筋地寻找实现目标的方法，不如尝试寻找实现目标对立面的方法。这种方法能够让你理清阻碍你创造性思维的杂乱因素。</p><p>团队自毁“技巧”清单：</p><ul><li>防御式管理</li><li>官僚主义</li><li>物理分隔</li><li>时间碎片</li><li>牺牲产品质量</li><li>伪造截止日期</li><li>团伙控制</li></ul><h4 id="防御式管理"><a href="#防御式管理" class="headerlink" title="防御式管理"></a>防御式管理</h4><p>作为一名管理者，对于大多数风险采取防御动作再正常不过了。如果你要使用一件极容易失败的工具，你会准备一个备用品；如果你的客户总是犹豫矫情，你会多花时间来细化产品规格定义；如果你的合作商总是忘记承诺，每次会议你会发布纪要。然而在一个领域里，防御一定会带来反效果：当你的人能力不足时，你不可能运用防御措施来保护自己。倘若你的员工能力达不到工作的要求，你就会失败。当然如果确实不足以胜任工作，就应该去找新人。但是一旦你已经决定使用这一组人，那么最佳战术就是信任他们。因为想保证成功而采取的任何防御性措施都指挥让事情变得糟糕，即使短期能够给你一些宽慰，长期看一定没有帮助，相反会成为团队凝聚的毒药。</p><p>如果你是管理者，你当然会感觉你的判断比你手下的人要好很多。你拥有更多的经验，而且高于施加给他们的卓越标准；这也是你成了管理者的原因。在项目的任何时间点，如果你不去做判断，你的团队就更容易犯错误，但那又怎样呢？让他们去犯错吧。这并不代表你就不能（偶尔）去改变一个决定或者帮助项目调整方向。但如果大家认为不允许他们自己犯下任何错误时，你就传递了一个对团队不信任的信号。没有什么比这个信号更能够阻止团队形成了。</p><p>大多数管理者都认为自己善于判断他的下属何时值得信任，何时需要质疑。但就我们的经验来看，大多数管理者在错误地使用不信任。他们都基于这样一条基本的假设，如果大家能够正确地运作，就可以自主地运作。这等于没有任何的自主权利，真正有意义的自主是走一条不同于管理者决定的道路。从更宽泛的意义上来看，这也是正确的：（在你的管理者或者政府眼里）做正确的事情跟自主无关；有权做错误的事情才称得上是自由。</p><p>最显而易见的防御式管理方法是程序化的方法论和管理者的技术干涉。长远来看，这两种方法都会导致失败，而且是导致团队自毁的有效手段。不被信任的人不会有动力愿意在一起组成一个协作的团队。</p><h4 id="官僚主义"><a href="#官僚主义" class="headerlink" title="官僚主义"></a>官僚主义</h4><p>Caper Jones在20世纪70年代和80年代都做过关于个类型系统开发成本的调查。一种类型叫“文案工作”，Jones认为那是不需要动脑子的整理文档的工作，因为决定文档内容的工作都被归纳在其他活动中了，如分析、设计、测试计划等。换个角度看，他所谓的“文案工作”类型就是纯粹的官僚。这种类型的工作是系统开发的第二大类，大约超过30%的花销都花在这上面。</p><p>令人失望的是，现在的一个趋势让越来越多的开发人员进入官僚体系里。可能这就是防御性管理流行的一个信号。虽然这种趋势是全球性的，但各个地区却不相同。</p><p>无须思考的文案工作就是一种浪费，我们应该向他们宣战，因为这些事情让人没法干活。这是官僚主义在伤害团队的形成。团队需要相信他们为之组成的目标。目标可能是随机的，但一定需要有，而且至少有证据表明管理层也是认可的。仅仅告诉大家目标很重要，然后让大家花1/3的时间做文案工作是不够的。文案写手不可能进入SWAT团队模式，也不可能视自己为追求成功的奋斗者。</p><h4 id="物理分隔"><a href="#物理分隔" class="headerlink" title="物理分隔"></a>物理分隔</h4><p>原本可以紧密协作的团队被安排在不同的区域、楼层，甚至是不同的大楼。团队工作的交互可能没什么大影响，但团队日常的交流就没有了。团队里的人可能跟不是一个团队的邻居更亲密些，因为他们经常见面。由于没有团队的空间，没有团队的即时互动，也就没有形成团队文化的可能。</p><p>在物理上分隔需要紧密交流的人本来就不合理，邻桌的员工彼此成了噪声和打扰的来源。但当他们都在一个团队中时，他们倾向性地会同时进入安静模式，这样对流的打扰就少很多了。让团队成员在一起也给了大家日常互动的机会，而这是团队形成所必需的。</p><h4 id="时间碎片"><a href="#时间碎片" class="headerlink" title="时间碎片"></a>时间碎片</h4><p>每个人的指责都成了碎片，因为他们的技能和知识造成他们时不可或缺的，没法把事情再分出去。这没有任何道理，碎片化对团队形成是有害的，而且也伤害效率。人们只能有效跟踪有限的人际互动。让一个人同时在4个项目里时，他就需要承受4倍的人际互动，就等于把所有时间都花在角色切换上了。</p><p>没有人可以同时是多个有凝聚力团队的一员。紧密协作的有凝聚力团队是排他的，碎片化的团队不可能形成凝聚力。糟糕的事情是我们容忍了太多没有必要的碎片化。我们其实可以做到不战而胜，简单来说就是定下目标，让大家在一段时间只做一项工作，从而减少碎片化，让团队真正有机会形成。</p><h4 id="牺牲产品质量"><a href="#牺牲产品质量" class="headerlink" title="牺牲产品质量"></a>牺牲产品质量</h4><p>没人会真正说自己的产品具有质量缺陷，他们会说这是成本压缩的产品，其实往往就是同一回事。通常，缩短产品生产时间的方法到最后就会造成质量下降。产品的最终用户一般愿意接受这样的置换，但这是对开发人员良心的拷问，他们的自我价值及实现被破坏了，现实要求他们只能生产出质量低于他们力所能及的产品。</p><p>团队建立起来的自我认知在决定牺牲质量时就荡然无存了。大家知道，只有停止做这样的事情才能得到解脱。项目结束后，大家都想尽量彼此分开，然后去做其他有意义的事情。</p><h4 id="伪造截止日期"><a href="#伪造截止日期" class="headerlink" title="伪造截止日期"></a>伪造截止日期</h4><p>当一个管理者摆出“我们必须在。。。之前完成”的姿态时，大家可能连眼皮都不会太一下。他们经历过太多次了，知道这是什么样的游戏。</p><p>你的员工很容易知道你是否在欺骗。在一个典型的伪造截止日期的谈话中，管理者宣布工作必需在某某日期前完成。要按照这个时间，工作根本没有成功的希望，因而对员工来说信号很明确：老板是一个帕金森式的机器人，从来不尊重和关心他们。老板相信如果不加束缚，大家是不会有产出的。在这样的项目中，就别想有什么凝聚力的团队了。</p><h4 id="团伙控制"><a href="#团伙控制" class="headerlink" title="团伙控制"></a>团伙控制</h4><p>团队活动的愉悦以及团队互动产生的动力是我们建立互信的基础。商业组织怎么能够对这些事情无动于衷或者对自己的团队漠不关心呢？部分原因出自不安全感，另一部分原因是高层管理对团队显然的无知。团队现象发生在金字塔的最底端。对于我们常说的“管理团队”，这根本不存在——在管理层从来没有有凝聚力的团队。即使管理者加入到真正的团队，也只是因为他们的双重职责：一面是管理，一面是小组的一员。他们被自己管理的员工认为是一个兼职队员。公司组织越往高层，有凝聚力的团队这个概念就越被人遗忘。</p><p>#### </p><h3 id="再谈团队自毁"><a href="#再谈团队自毁" class="headerlink" title="再谈团队自毁"></a>再谈团队自毁</h3><h4 id="可恶的标语和纪念碑"><a href="#可恶的标语和纪念碑" class="headerlink" title="可恶的标语和纪念碑"></a>可恶的标语和纪念碑</h4><p>大部分形式的团队自毁，其危害来自于贬低工作或贬低做工作的人。工作的重要性和把工作做好的价值可以催化团队。团队给自己的任务是要达到匠艺的水平。所有成员都知道工作质量对于组织的重要性，而团队会通过遵守更高的标准脱颖而出。没有这一突显的因素，小组还是小组，不会成为真正的团队。</p><p>在这个复杂的机制里，想象一下我们买了条标语，提醒大家“质量第一”。他们称为励志小附件的东西，就是形式大于实质的表现。他们好像在宣扬质量、领导力、创造力、团队协作、忠诚守信和其他组织美德的重要性。但其实通过这样简单的形式却发出了完全不同的信号：管理者相信这些美德可以通过搞些招贴就能提高，并不需要努力工作或者什么管理才能。所有人很快就能发现，这些招贴就是不用努力工作、无须才能的保证。</p><p>励志小附件假到让大家起鸡皮疙瘩，它们给健康的组织带来危害。</p><h4 id="加班：一种意外的副作用"><a href="#加班：一种意外的副作用" class="headerlink" title="加班：一种意外的副作用"></a>加班：一种意外的副作用</h4><p>副作用很明显：犯错、累倒、离职率上升和付薪的无用时间。当然，还有对一个良性运转的工作团队的自毁反应。</p><p>在任何四五个人的团队里，一定会有几个人不能承受在其他人看来很灵活的加班时间。过去的加班仅仅是几次晚班或者偶尔一天的周末，大家都能够咬咬牙。但如果加班延长到几个月，即便是最为精诚团结的团队成员也要受到影响时，就一定会对团队的凝聚力造成破坏。不能够分担痛苦的人会一点点被其他人疏远。</p><p>毫无疑问，延长加班时间就是一项减产的实践。额外几个小时的产出总会被之后的副作用抵消，即使不考虑它对团队的破坏也是一样。只是当你考虑到团队成员不同的加班能力会破坏团队凝聚力的时候，这一点就更具说服力。</p><blockquote><p>“我们并非是要通过加班来完成工作，而是希望能够在工作根本无法按时完成时通过加班来避免指责。”</p></blockquote><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>你一定听说过，公司的存在就是为了能够跟其他公司竞争，所以延伸一下，公司内部的一点点竞争也是保持公司竞争力的健康手段。另一些管理者则认为，如果团队成员感觉到自己被强迫与队友竞争，那是有问题的。从极端角度来看，竞争当然会阻碍团队凝聚。要是团队被告知：明年，他们之中只有最棒的一个才能留下来，毫无疑问，他们不可能在工作中友好相处并走向成功。</p><h4 id="考虑一个类比"><a href="#考虑一个类比" class="headerlink" title="考虑一个类比"></a>考虑一个类比</h4><p>兄弟姐妹之间的竞争并不完全可行。例如我们知道，兄弟姐妹倘若是在激烈竞争的环境中成长，在长大之后通常都会变得疏远。那些竞争较少的孩子们一旦成人，更有可能建立起温馨的亲属情谊。目前，对于父母是否激励或制止兄弟姐妹之间的竞争，已达成了共识。竞争之所以产生，或许出于父母对子女的感情关心不够，他们没有足够的时间，没有给予足够的尊重、关心和爱护。</p><h4 id="这有关系吗？辅导的重要性"><a href="#这有关系吗？辅导的重要性" class="headerlink" title="这有关系吗？辅导的重要性"></a>这有关系吗？辅导的重要性</h4><p>在需要一起工作的人群中强调竞争带来的长期影响是什么？首先，牺牲的是对健康团队而言必需的简单有效的个体辅导。</p><p>今时今日，一个典型的知识型团队需要各种不同的技能，老板掌握的只是其中一些，老板只能辅导团队的部分人员，其他人怎么办？我们慢慢认同应该由团队成员自己提供大部分的辅导。</p><p>观察一个紧密协作的团队工作，你会发现直截了当的个体辅导时常发生。团队成员坐在一起结对传递知识。每当此时，总是一人教一人学。他们的角色随着时间推移不断交换，或许A辅导了B关于TCP/IP的知识，B又会辅导A怎样实现队列。一旦这种方式得到了良好运转，参与者几乎是不自觉的，甚至不会有谁感觉到是在辅导；对大家来说，这就是工作。</p><p>无论提及与否，辅导都是成功团队互动的关键因素。它提供了参与者协作和自我提升的机会。同时，辅导会让人感觉愉快。</p><p>若大家感觉不够安全，辅导行为就不可能发生。在一个竞争环境中，除非你疯了，否则才不会让人看到你正在接受辅导呢。</p><h4 id="再谈团队自毁-1"><a href="#再谈团队自毁-1" class="headerlink" title="再谈团队自毁"></a>再谈团队自毁</h4><p>内部竞争会直接造成辅导工作异常艰难，甚至根本就不可能。由于辅导是健康团队工作的核心，管理者做的任何增强团队内部竞争的事情都是在进行团队自毁。下面是一些能够引起团队自毁副作用的管理行为：</p><ul><li>年度薪酬评审</li><li>目标管理法MBO</li><li>表彰个别员工的突出成就</li><li>跟绩效相关的证书、奖励和奖金</li><li>任何形式的绩效考核</li></ul><p>W.Edwards Deming在他1982年出版的《走出危机》一书中，总结了协作被普遍遵守的“十四点”。隐藏于其中的第12B条基本可以看做是深思熟虑的结果：</p><blockquote><p>在管理及工程过程中消除障碍人们追求匠艺的障碍，就意味着（和其他事情一起）废除掉年度或量化评级与目标管理的方式。</p></blockquote><p>戴明的观点在于MBO等系列方法都是管理者站不住脚的借口。使用简单的外部激励来促进绩效，会使得管理者们不去处理应该思考的复杂事物，如能力投资、个人直接动机、团队形成、人员留用及可持续的分析以及对工作流程的再设计。</p><p>针对团队成员的任何不同的奖励机制都可能增加内部竞争。管理者需要采取措施降低或抵消这样的影响。</p><h4 id="混合的隐喻"><a href="#混合的隐喻" class="headerlink" title="混合的隐喻"></a>混合的隐喻</h4><p>我们都见过体育团队不受某个队员失败的影响而获得成功；我们也见过尽管个别球员拥有精彩的表现，团队还是输得很惨。所以个体的成败与整个团队的成败看起来风马牛不相及。这种状况并不完美，只能让最初对于竞争的倾向更加恶化。</p><p>对比之下，像唱诗班、合唱团这样的组织就建立起了几乎完美的个体与团体成败绑在一起的关系。</p><h3 id="一顿意面晚餐"><a href="#一顿意面晚餐" class="headerlink" title="一顿意面晚餐"></a>一顿意面晚餐</h3><h4 id="团队效应开始起作用"><a href="#团队效应开始起作用" class="headerlink" title="团队效应开始起作用"></a>团队效应开始起作用</h4><p>成功会孕育成功，高产的和谐会带来更高产的和谐。一位与生俱来的管理者会下意识地感觉到什么是一项好的团队活动。这种感觉一直会持续到项目中的决策管理上。整个体验上围绕着小巧、简单、协作的成功来组织的。不仔细观察，你可能无法察觉管理者的存在；事情就自然而然发生了。</p><p>好的管理者会经常给团队提供机会，让大家来一起享受成功。这些机会可能是一些小的策划、演示或模拟练习，总之是任何能够让团队快速习惯共同成功的事情。最棒的成功就是看不到任何明显的管理，团队是平等而友好个体的聚合，在一起努力工作。最棒的老板就是这样能够不断地管理，切让团队成员感觉不到是在被管理。</p><p>表明看来如此容易，以至于大家都不相信他们是在做管理。</p><h3 id="敞开和服"><a href="#敞开和服" class="headerlink" title="敞开和服"></a>敞开和服</h3><p>有时候，人员组成了一个小组，小组的人却不想凝聚成一个团队；他们就是独狼，喜欢一个人。</p><p>在《人和项目管理》一书中，Rob Thomsett 分析了阻碍团队形成的病因。然而这些病因基本上无药可治，唯一可行的疗法就是将那些阻碍团队凝聚的个人提出团队。从学术上来讲，这可能是合理的，但现实操作起来，你会发现这其实再愚蠢不过了。因为那个你想踢出去的人在其他方面可能是一把好手。很多事情都需要在没有凝聚力的团队中开展。</p><h4 id="感觉好，请“病”假"><a href="#感觉好，请“病”假" class="headerlink" title="感觉好，请“病”假"></a>感觉好，请“病”假</h4><p>并不是生理上的病态，而是指在这种地方工作，需要扭曲一些精神上的生存法则，而这些法则本身是保护我们心理健康的。这些法则中最重要的就是关于自我认知。要是一项工作伤害了你的自我认知，本身就是“病态”。</p><p>只有在工作中感觉良好，才会增强自我认知。从事这样的工作，是对自身在相关领域竞争力的认可，并且能够给予员工足够的自主权，让他们能够同时履行对应职责。一经授权，这些优秀员工的管理者会小心翼翼地呵护这种自主权。他们知道，虽然员工的失败会让老板感到难堪，但这只不过是游戏中的一个小插曲罢了。他们对于偶然的倒退心有准备，也愿意接受其中一个人的失败带来的直接后果。一旦事情发生，他们也会心存怀疑，要是自己亲自操刀而不是管理别人来执行，这种失败或许永远不会发生。但这又有什么大不了的呢？你已经做到了唯才是举，人尽其才，那就要做到用人不疑。</p><p>敞开和服（Open Kimono）的态度恰好是防御式管理的反面。用人不疑，你将他放在这个岗位上，就要信任他，不需要做任何防御。你领导下的所有人都是值得信任的。一个不被你信任，工作没有自主权的人，对你来说简直一无是处。</p><p>老板将自己的声誉托付给下属，会让大家感到那么一点小小的兴奋和刺激。这会使每个人竭尽全力。大家不仅仅是在完成工作，更是在证明对他们的信任是值得的。正是这种敞开和服的管理方式让大家最有可能形成团队。</p><h4 id="走出去"><a href="#走出去" class="headerlink" title="走出去"></a>走出去</h4><p>老板防着自己人的最常见办法就是进行物理监控。</p><p>如果你的下属很有能力，要提升成功几率，可能没什么比偶尔让你自己远离他们更加有效了。任何一种容易隔离出来的任务都是一个好机会。这些任务不需要真正的管理存在。</p><p>因为这样的计划有些大胆，你的管理层和同事一定会心存疑问。但答案很简单，从他们交付的产品就能知道。如果他们交付了一个精心设计得到的完整结果，就证明他们努力工作了；倘若没有，就说明他们人浮于事。</p><p>离开办公室在诸多方面皆有裨益。首先排除了对你最有价值资源的各种干扰和打断。在短时间内，找个借口让你的团队走出去吧。除了可以让他们效率更高之外，这种完全自主的时间则有机会让他们形成一个士气高昂的团队。</p><h4 id="存在规则，但我们要打破规则"><a href="#存在规则，但我们要打破规则" class="headerlink" title="存在规则，但我们要打破规则"></a>存在规则，但我们要打破规则</h4><p>工程类职业有一种众所周知的开发模式，这种模式在其他地方是没有的，那就是<strong>臭鼬工程项目</strong>。指的是项目可以在上层管理不知情的情况下悄悄开展。当底层的员工深信产品的正确性，因而不愿意接受管理层取消项目的决定时，这种项目就会诞生。这样的项目可大有学问。有趣的是，臭鼬工程的另一方面就是犯上作乱。管理层说不，项目却照常进行。</p><h4 id="带嘴唇的鸡"><a href="#带嘴唇的鸡" class="headerlink" title="带嘴唇的鸡"></a>带嘴唇的鸡</h4><p>20世纪70年代中期，组织系统顾问Larry Constantine 为特定的几家公司提供健康公司社会生态圈方面的帮助。在他给公司提供的建议中，有一点就是让最底层员工能够在团队选择过程中具有发言权。员工们自发组成参选团队来“竞标”项目。评判标准为成员的胜任程度，成员之间的互补程度，以及把各个成员放在一起对其他项目的影响程度。公司由此挑选最适合的团队。</p><p>这样的设计给了员工两个维度上不同寻常的自由：他们能够选择自己工作的项目和自己的团队。令人惊讶的发现是第一个维度并不起什么作用。管理层一开始担心只有最耀眼的项目会有人竞标，事实却并非如此，即使最烦琐的项目也有人竞标。能够有机会与自己渴望共事的人一起工作看起来更加重要。</p><h4 id="这里谁说了算"><a href="#这里谁说了算" class="headerlink" title="这里谁说了算"></a>这里谁说了算</h4><p>最好的老板都会冒些风险，他们勇于在他们的员工身上冒险。并不是说好的管理者就不管理，而是他们不会给出固定的方向或者独断专行。他们必须时刻做出决定和判断。这里给出的建议是他们应该充分利用那种与生俱来的权威。在匠艺级的大师与学徒之间横亘着这种与生俱来的权威——大师知道如何开展工作，学徒不会。服从这样的权利不会贬低任何一个人，不会消除激励，也不会让同事之间变得不融洽。这种服从的反面则是出于不安全感而要求的服从，它表明“隶属于我麾下的员工必须执行我的决定”。</p><p>在最好的组织里，这种与生俱来的权威在各个方面发挥着效力。大家知道一个管理者的长处，可能是制定大方向、进行谈判或者招聘，而且大家对他做这些事情心悦诚服。每个员工皆有一技之长，而且在相应的领域具有权威性，从而被大家所信任。在敞开和服的氛围下，团队有最大的融合可能。</p><h3 id="团队形成的化学反应"><a href="#团队形成的化学反应" class="headerlink" title="团队形成的化学反应"></a>团队形成的化学反应</h3><p>一些组织被公认为在培育良好的融合团队方面保持了持续的好运。当然，这不是什么好运而是化学反应。在这些组织中，融合团队的养成提供了肥沃土壤。这样的环境没有防御保守的气息，没有个人罔顾集体努力，只想着获得成功。大家的工作是一个整合的产品，每个人对产品质量感到自豪。</p><p>在拥有最佳化学反应的组织里，管理人员把自己的精力放在建立和维护这样的健康化学反应上了。团队和部门能够焕发健康的气息，这全是因为管理者在背后推动。因为没有有效的体系理论来总结他们的方法，所以很难分解和分析这些组成部分。但做这种分析仍然值得尝试。</p><ul><li>建立对质量的执著追求</li><li>提供诸多满意的闭环</li><li>建立精英意识</li><li>允许和鼓励差异性</li><li>维护和保护成功团队</li><li>提供战略而不是战术方向</li></ul><h4 id="对质量的执著追求"><a href="#对质量的执著追求" class="headerlink" title="对质量的执著追求"></a>对质量的执著追求</h4><p>“只有完美对我们才足够好”给了团队真正融合的机会。它之所以让团队凝聚起来，是因为它拉远了团队每个人与其余世界的距离。</p><p>你的市场人员、产品使用者、客户和你的上级领导永远不会为高质量而摇旗呐喊，从短期经济回报上分析，追求一流的质量并不合理。若你的团队对质量报以执著追求，他们总是会交付超出市场要求的高质量产品。只有不受短期经济回报的影响，他们才能够这样做。收益会长期回报给你们，大家在质量上的高追求，会驱动他们精益求精，更好地保持对质量的追求。</p><h4 id="结婚时，我告诉她我爱她"><a href="#结婚时，我告诉她我爱她" class="headerlink" title="结婚时，我告诉她我爱她"></a>结婚时，我告诉她我爱她</h4><p>人类自己就是需要不停确认他是否沿着正确的方向前进。人类团队同样如此，在哲学上，这种确认称之为闭环（Closure）。闭环就是整体的每个部分皆需要一致满足的“过程”。</p><p>组织同样需要这样的闭环，这种闭环就是成功完成给定的任务，加上过程中不时地对按计划执行的确认。企业到底需要多少次确认，取决于就此风险需要付出多少投资。有些时候，一个组织可能四年一次闭环就足以满足需求了。</p><p>这里存在的问题是：组织在闭环上的需求远远低于在组织中工作的人们。如果工作了四年，都没有进行一次确认工作是否满意的“过程”，难免会让团队的每个人都忍不住想，“我可能熬不到这件事结束了”。特别是在团队逐步形成的时候，频繁的闭环是很重要。团队成员需要建立一种共同成功和共同认可的习惯，这是能够帮助团队提升士气的一种机制。</p><p>那些建立化学反应的管理者努力把工作分解为小块，同时确保每块工作都能够显式地展示完成后的成果。团队不停地预热，直到那个时刻到来，团队临近最后凝聚，在成功中达到顶峰。它成功为团队的下一步积蓄更新的能量，这会让大家觉得更加紧密。</p><h4 id="精英团队"><a href="#精英团队" class="headerlink" title="精英团队"></a>精英团队</h4><p>那些认为爆米花“不职业”的人，会认为团队的精英意识是右翼颠覆。普遍认为如果团队在某一方面过于标新立异，管理者就没法完成他的份内工作。团队能够遵从企业的统一标准，是管理者管控得当的标志。然而从被管理的员工角度出发，这样的标志是毁灭性的。管理者越是觉得舒适，就越会让团队失去新鲜血液。</p><p>大家都需要一种独特感来体察内心的宁静，从而在宁静之中发酵出团队的凝聚力。即使管理者尝试去抑制独特性，独特性还是会滋生出来。</p><p>团队精英意识带来的真正威胁并非无法管理，而是让管理无所适从。团队可能坚定不移地追求成功，管理者却担心自己被看做是懦夫。普通的管理者没有安全感，以至于走不出管理的陷阱。一流的管理者知道人们不能被任何合理方法控制。成功管理的核心是让大家齐心协力，然后助推大家到一个连管理者自己都无法让他们停止的点。</p><p>一个富有凝聚力的团队能够让大家更加高效，营造出目标驱动的氛围。当团队凝聚时，你确实需要放弃控制，或者放弃这种受控制的假象。团队的独特点并不需要任何基础的东西。不管精英的特点是什么，它都是形成团队标识的基础，这种标识是有凝聚力团队的一个本质要素。</p><p>这里，一个重要的限定条件是团队需要在某些方面感到独特，但并非所有方面。遵守组织规则的团队比比皆是，军事化的团队和大多数体育竞技团队都统一着装。但只要他们能够在一些方面感受到自己的独特，在其他方面就能够去遵守。</p><h4 id="不要拆散洋基队"><a href="#不要拆散洋基队" class="headerlink" title="不要拆散洋基队"></a>不要拆散洋基队</h4><p>如果团队以及凝聚，就不要拆散团队。至少，要给大家一个机会在一起尝试另外的项目。</p><h4 id="团队行为的网络模型"><a href="#团队行为的网络模型" class="headerlink" title="团队行为的网络模型"></a>团队行为的网络模型</h4><p>多数情况下，管理者并不是团队的一员。团队是由平等的个体组成的。大多数情况下，管理者都游离在团队之外，不时为团队提供来自上面的方向，同时清除行政和过程中的障碍。</p><p>在最棒的团队中，不同的个体时不时会展现出领导力，在自己擅长的专业领域带领大家。团队的结构是一个网络，而非分层结构。</p><h4 id="中餐菜谱的选择"><a href="#中餐菜谱的选择" class="headerlink" title="中餐菜谱的选择"></a>中餐菜谱的选择</h4><p>存在一点差异次啊能极大地帮助我们形成一个有凝聚力的团队。一名行动不便的开发人员加入到一个新组建的工作小组中，会让团队团结的几率大大增加。加入一名实习生都能产生同样的效果。不管这种差异的元素是什么，对团队成员来说，象征意义更重要。这是一个明确的信号，不要称为某个人的克隆，也不需要完全统一的“橡胶人”。</p><p>当一个团队真正凝聚起来时，任何代价都是值得的。</p><h2 id="沃土"><a href="#沃土" class="headerlink" title="沃土"></a>沃土</h2><h3 id="自我愈复系统"><a href="#自我愈复系统" class="headerlink" title="自我愈复系统"></a>自我愈复系统</h3><p>有时候，系统背离了最初的设计；有时候，横空出现的设计是有必要的。那些让系统运转的人们忙于修复系统。事情总是如此。</p><h4 id="确定性与非确定性系统"><a href="#确定性与非确定性系统" class="headerlink" title="确定性与非确定性系统"></a>确定性与非确定性系统</h4><p>当你对之前全人工的系统进行自动化时，系统会变成确定性的。新系统只能相应制造者设计的那些显式的命令。于是，自我治愈的能力就丧失了。任何需要被响应的要求都必须预先设计进去。如果需要治愈这样的系统，就只能在系统运行环境之外来处理。维护人员只能对系统进行分解，添加一个乃至更多新的计划好的响应来对其进行重建。</p><p>从一种视角看，去除掉混乱不可控的自我修复能力，是自动化的积极一面。系统会首先被“恰到好处”地规划，在运行时不需要再修修补补。但显而易见，这一做法可能花销很大。如果新系统管理的业务随机变化到一定程度，系统自动化就是一个错误。确定性未必有利，系统会被迫持续不断地进行维护。</p><p>非确定性系统之所以能够毫无痛苦并优雅地完成自我修复，是因为组成系统的人熟知根本的目标。一旦新的形势出现，他们可以立刻获知什么行动才是有意义的。要点在于：让系统变为确定性会导致它失去治愈自身的能力。</p><p>在某种意义上，你工作或管理的组织就是一个系统。它是互相协作的人为达成某种目标的过程的混合物。</p><h4 id="方法学的隐蔽含义"><a href="#方法学的隐蔽含义" class="headerlink" title="方法学的隐蔽含义"></a>方法学的隐蔽含义</h4><p>方法学是一种通用的系统原理，阐述了思想密集型的工作该如何管理。编撰方法学的人们都很聪明，落实这些方法的人则可能是笨伯。他们从来不需要开动自己的大脑，所有能做的就是照本宣科，从工作开始到成功结束。方法学会做出所有决策，而大家什么决策都不用做。组织这样完全变得确定化了。这样的团队也会丧失自我愈复能力，到了一定程度就变得确定。</p><p>项目成员是最熟悉项目范围的人，如果给定的方向对他们没有意义，方法就不会奏效。</p><p>大型方法学与小型方法学之间存在巨大差异，小型方法学是完成某项工作的基本途径。这样的方法学包括两个方面：定制的计划和使计划有效的必备技能。</p><p>大型方法学试图进行集中式思考，所有有意义的决策都必须由方法学的构建者做出，而不是由真正做事情的人来决定。</p><h4 id="疯狂的方法学"><a href="#疯狂的方法学" class="headerlink" title="疯狂的方法学"></a>疯狂的方法学</h4><p>大型方法学可能会极大地影响那些完全胜任的员工，通过强迫他们工作在一个固定的模子里，从而确保</p><ul><li>泥沼般没完没了的文案</li><li>少的可怜的真正可行方法</li><li>从来没有的责任心</li><li>消磨殆尽的热情</li></ul><p>文案：大型方法学鼓励大家去编写文档而不是开展工作，这种对文档的痴迷应该源于偏执的防御性思考。<strong>事无巨细的文档引入的是问题，而非解决方案。</strong></p><p>方法：在时下的技术萌芽期，对我们从事的多数工作而言，还处于缺乏完整方法的阶段。当出现真正的选择方案时，人们必须了解和掌握它们中的所有方法。对一种方法进行标准化，就是排除其他方法。这种观点认为知识弥足珍贵，我们应该珍惜使用。</p><p>责任心：要是某种方法学不生效，应归咎于方法学本事，而不是苛责于人。在这种环境下，人们愿意承担责任。</p><p>热情：实施一种方法学的决策给每个人传递着同样的信息，没有什么比得起管理者认为自己的员工无能更让大家丧气的了。</p><h4 id="恶意合规问题"><a href="#恶意合规问题" class="headerlink" title="恶意合规问题"></a>恶意合规问题</h4><p>在多种经济环境中引入方法学就可能产生按规工作的行为。大家可能真的会一板一眼地按照方法学里写的来，工作就会被拖延到几乎停滞。</p><h4 id="鸡和鸡蛋"><a href="#鸡和鸡蛋" class="headerlink" title="鸡和鸡蛋"></a>鸡和鸡蛋</h4><p>大多数方法学声称的好处实际是方法收敛的好处。在一定程度上，不同的人做同样的工作，若运用相同的方法且运用得当，确实存在一些优势。方法收敛是一件好事，但它并非唯一达到收敛的途径。方法学制定法规来强制收敛，这就带来了不可避免的副作用，一边是维法者强力的推进，一边是脑力劳动者强烈的自主意识。更好的收敛途径：</p><ul><li>培训：人们做他们知道该如何做的事。倘若你让他们知道方法的核心，他们就会去尝试使用。</li><li>工具：一些建模、设计、实现或测试的自动化工具能够让你得到比法规更多的方法上的收敛。</li><li>同行评审：在执行了有效的同行评审机制的组织里（质量管理、走查、验收、技术研讨），自然就会有收敛的趋势。</li></ul><p>只有当这种自然引导的收敛完成后，你才能去想着发布一个标准。在没有形成事实上的标准之前，是没有办法做声明的。</p><h4 id="再谈高科技假象"><a href="#再谈高科技假象" class="headerlink" title="再谈高科技假象"></a>再谈高科技假象</h4><p>在工作环境中，对于大型方法学的痴迷是高科技假象的另一种表现。这来源于对技术的崇拜，相信只有技术才真正具有意义。即使完全没有指导，大家也不会总是做出错误的决定。</p><p>相反的做法是为每一种新措施实施一个试点项目。在试点项目里，不需要遵循已有的标准，而且团队不能用以前的标准方法来完成工作。标准要求至少工作部分的内容要采用非标准的方式开展。人们在尝试新事物的时候表现会更好。</p><p>所有的生产力提升都源自于<a href="https://www.zhihu.com/question/304499279" target="_blank" rel="noopener"><strong>霍桑效应</strong></a>。为了让霍桑效应能够发挥作用，你不得不对法规采取非标准化。不管什么标准，实施时都应该简单而温和，加在你员工身上的所有标准加起来不应该超过10页纸。即使在这样的松散指导下，你还是应该准备好为特例让路，这样才能创造出一个百花齐放、百家争鸣的开发环境。</p><h3 id="与风险共舞"><a href="#与风险共舞" class="headerlink" title="与风险共舞"></a>与风险共舞</h3><p>要是风险没有得到妥善处理，原因很可能就出在组织制度和文化上。</p><h4 id="不要逃避风险"><a href="#不要逃避风险" class="headerlink" title="不要逃避风险"></a>不要逃避风险</h4><p>项目风险是一件好事情，说明项目是有价值的。在项目运行过程中，很多事情都可能出错，管理这些风险就是你工作的主要部分。</p><h4 id="我们几乎从不管理的一种风险"><a href="#我们几乎从不管理的一种风险" class="headerlink" title="我们几乎从不管理的一种风险"></a>我们几乎从不管理的一种风险</h4><p>我们习惯性地不去管理的风险是我们自己的失败。之所以没有将其列举到你的风险清单上，是因为它会让你自己看起来很糟，像个失败者。</p><p><strong>不是让所有风险都消失，而是确保风险发生时有相应的应对措施。</strong>应对措施应该提前就经过规划和演练了。</p><p>当风险发生、系统无法按期交付时，才来计划应对措施已经太晚了。</p><p>倘若一项风险出现的几率极低，那么不去管理还情有可原，但只是因为结果“想起来太可怕了”而不去管理这项风险，那就实在是没有道理了。</p><h4 id="为什么不达标的风险总是没有得到管理"><a href="#为什么不达标的风险总是没有得到管理" class="headerlink" title="为什么不达标的风险总是没有得到管理"></a>为什么不达标的风险总是没有得到管理</h4><p>当需要完成的任务被视为挑战时，进取精神往往取代了风险管理。越是时间紧张，大家越是倾向性地不愿将更多的时间花在制定应对措施计划上。</p><p>这并非完全是坏事，如果一位管理者和他的团队都不进行风险管理，那一定会有其他人需要进行风险管理。中层管理者和决策者往往善于将期望获得的结果说成是挑战。他们把挑战塑造为一种卓越的证明。但很多时候，他们并不是要指引团队去追求卓越，而是让团队尽可能廉价地完成项目。</p><p>虚假的挑战项目都有共同的特点：边际收益（因为组织回避风险，它们并非存在真正的技术风险），但时间安排的巨大风险基本是不受管理的。</p><h3 id="会议、独白和交流"><a href="#会议、独白和交流" class="headerlink" title="会议、独白和交流"></a>会议、独白和交流</h3><p>一些组织开会开到上瘾，以至于把工作放到了第二位。他们组织会议没啥目的性，也没明确定义说明是会议结束。</p><h4 id="神经硬化"><a href="#神经硬化" class="headerlink" title="神经硬化"></a>神经硬化</h4><p>当任何行动的参与方人数增加时，会议就会变得越来越流行。会议可以带来更多的信息透明，为了信息透明来参会的恶人更多会寻求发言机会。最糟糕的会议就像是一堆空谈者的集会，没有人听别人说什么，每个人都只顾着表达自己的意见或者等着表达。因为与这么多人需要发言，会议时间自然被拖长到不受控制了。</p><p>复杂度巨大这个提法当然是让每个人都感觉能够接受，因为一旦这成了会议的正当理由，就没有人会去思考另外一种可能：竞争性的空谈。</p><h4 id="“科技手段增强”的会议"><a href="#“科技手段增强”的会议" class="headerlink" title="“科技手段增强”的会议"></a>“科技手段增强”的会议</h4><p>在会议上广泛使用的科技（如笔记本电脑）对召开会议一点用处都没有；这些科技仅仅是为参会的人们逃离毫无意义的会议提供了便利。科技增强带来了会议的沉闷可怕。</p><h4 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h4><p>理论依据是站着会让大家都不太舒服，所以不抬可能空谈。这样的会议会精短一些，因而大有裨益。</p><p>即便是这样的站立会议，如果没有目标和主题也会拖组织效率的后腿，那么会议的目标和主题应该是什么呢？这就取决于会议的种类了。</p><h4 id="基本的健康会议"><a href="#基本的健康会议" class="headerlink" title="基本的健康会议"></a>基本的健康会议</h4><p>为完成一件事情而专门组织的会议可以称为工作会议。举办一次典型的工作会议就是为了要达到一个决议。需要谁参会呢？那些对决议点头的人，其他人就不需要了。为了保证大家都不会茫然，工作会议需要一个相关的日程安排，有明确的目标并且能够执行。这样可以保证即使不参会的人也能知道会议安排，不在日程上的话题是不会被讨论的。没人需要带着防御心理去参会。</p><p>工作会议有一个吸引人的特质，你知道会议何时完成。一旦达成决定，就不需要继续开会了。反之也是一样：如果你们能够确定结束会议的条件，那么这就是一个工作会议；否则就不是。</p><h4 id="仪式"><a href="#仪式" class="headerlink" title="仪式"></a>仪式</h4><p>迫于时间而结束的会议是一种仪式。这种会议的目的不是达到某个特定的决议，都是FYI（for your information，仅供参考）。</p><p>仪式是一系列的对话，对话本身是件好事。不好的是那些没有真正倾听的人被关在了对话发生的屋子里。那些相信这样的会议应该被对话取代的人，很容易观察到这样的一对一可以在其他地方发生，从而放开其他人让他们去做真正的工作。</p><p>工作环境中不时会有真正需要这样仪式的时候。仪式可能是庆祝某次成功、给大家讲解战略方向的改变，活着评估一个即将结束的项目。这些正当的仪式都有些不同寻常之处，这些不同寻常之处也是为什么正当的原因。常见仪式的一个例子就是每周/每天的项目状态会，会上，十几二十几个被锁到一间屋子里轮流向老板汇报工作。</p><h4 id="太多参与者"><a href="#太多参与者" class="headerlink" title="太多参与者"></a>太多参与者</h4><p>工作会议的参与者仅局限于利益相关的人，人数越少越好。仪式会议的参与者就没有限制了，只要负责人认为有价值参加的人都可以来，人数多一点更好。</p><p><strong>会议的成本直接取决于参会人员的多少。</strong>有一名管理者，每次开会前都会让一个人离场，她允许那个离场员工在离场前进行简短的陈词。她清楚地告诉大家选择的标准并不是这个员工相应的能力，而是他用会议时间可以完成工作的重要性。真正从释放一名员工身上得到的收益并不大，但这种行为传递的信号却不可或缺。</p><h4 id="开放空间社交"><a href="#开放空间社交" class="headerlink" title="开放空间社交"></a>开放空间社交</h4><p>会议和演讲都是烦琐的事物，真正的价值体验在那些间隙时间，一段演讲开始或结束等待的公共区、茶歇休息、午餐排队、与其他参会者一起饮茶或聚餐的时间。基于这些事实，一些有思想的人开始形成“开放空间”的想法。一次开放空间的会议完全就是茶歇和午餐。没有真正的会议，只是一个长时间的间隙。</p><h4 id="治愈会议上瘾组织的处方"><a href="#治愈会议上瘾组织的处方" class="headerlink" title="治愈会议上瘾组织的处方"></a>治愈会议上瘾组织的处方</h4><p>你改变不了你的上级，但你可以改变你的地盘，还有那些和你一起工作的同事和下属。这种改变总是知易行难，你的目标是消灭大多数仪式性的会议，而将时间花在一对一的交流上，通过运用“会议怎样才算结束？”的测试来限制每次参与工作会议的人数。要是需要什么仪式，则鼓励大家用开放空间社交来创造非结构化的自发互动。最重要的是，消减你自己需要用仪式会议来做确认的需求。</p><h3 id="终极管理罪恶得主是…"><a href="#终极管理罪恶得主是…" class="headerlink" title="终极管理罪恶得主是…"></a>终极管理罪恶得主是…</h3><p>终极的管理罪恶是浪费大家的时间。作为管理者，你有一些你自己的诉求，这些诉求会让你做出的事情与合理利用你手下员工的时间相悖。</p><h4 id="项目状态会议之关于状态"><a href="#项目状态会议之关于状态" class="headerlink" title="项目状态会议之关于状态"></a>项目状态会议之关于状态</h4><p>召开一次真正的工作会议，原因是需要所有被邀请的人一起来处理某种问题。会议的目的是达成一致，这样的会议在定义上就一定具有临时性。随之带来的就是这种会议不太可能遵循常规计划。如此推理，任何常规规划的聚会更多的可能是出于仪式目的，而要多过专注于达成一致性的目标。周例会就是一个典型的例子。看起来例会的目的是报告状态，但实际上真正的目的是状态的确认，并且不是针对工作状态，而是老板的状态。</p><p>当老板特别关注时，这些如仪式般造成负担的状态更新会议可能发展到无法控制的地步。</p><h4 id="早期超编"><a href="#早期超编" class="headerlink" title="早期超编"></a>早期超编</h4><p>会议并非是唯一浪费大家时间的地方，当过多人在项目初期就加入时，基本上总是会浪费大家的时间。项目开始于计划与设计，这些活动最好由小团队来完成。当设计很重要时，可能需要占到整个项目周期的一般。人力规划：</p><p><img src="/images/peopleware/p-03.jpg" alt="p-03.jpg"></p><p>当项目迫于紧张的时间压力下时，这一问题就凸显出来了。如果客户和高层管理下大了命令，例如这项工作一年时间，这个限制就会缩短项目预期的结束时间。</p><p><img src="/images/peopleware/p-04.jpg" alt="p-04.jpg"></p><p>很自然的，一种倾向就是把因为缩短时间而压缩的人力投入到前期去。这就是典型的早期超编：</p><p><img src="/images/peopleware/p-05.jpg" alt="p-05.jpg"></p><p>要是你知道项目无论如何都会延期，那么子啊高层倾向于在项目早期多投入的情况下，你最好考虑一下如果不再添加额外忍受是显得更好还是更糟。因为这种因素造成的项目早期超编，这种情况非常普遍。</p><h4 id="再说碎片化"><a href="#再说碎片化" class="headerlink" title="再说碎片化"></a>再说碎片化</h4><p>还有一种对时间的浪费却很可能是无法察觉的，因而没法改进。这跟之前提到的碎片化有关，这里的重点在于脑力劳动者的时间被多个同时进行的任务碎片化，这种碎片化必然导致此人会工作在不同小组里，而这样的工作组是不可能凝聚成真正团队的。</p><p>时间碎片化几乎都会带来团队自毁，除此之外还会浪费个人的时间。一个同时兼具多项任务的员工每天必然会花费一部分时间用在工作准备上，这些时间根本就看不到。</p><p>当两项任务需要的工作习惯本质上不相同时，碎片化尤为有害。持续重启造成的时间浪费只会让员工感到沮丧。</p><h4 id="尊重你自己的投资"><a href="#尊重你自己的投资" class="headerlink" title="尊重你自己的投资"></a>尊重你自己的投资</h4><p>你投入到工作中的人力资本也代表了不少钱。</p><h4 id="“邪恶”电邮"><a href="#“邪恶”电邮" class="headerlink" title="“邪恶”电邮"></a>“邪恶”电邮</h4><p>我们都习惯于海量的协调沟通邮件。这样做真的好吗？</p><p>双边关系中的一方如果过度表现，另一方就一定会表现不足。同事之间的自组织与相互协调才是良好团队协作的重要表现。一个好的教练知道自己的工作不是去协调队员的互动而是帮助大家进行自组织。因此大部分邮件就是问题的一部分，而非解决方案。</p><h4 id="公司内垃圾邮件"><a href="#公司内垃圾邮件" class="headerlink" title="公司内垃圾邮件"></a>公司内垃圾邮件</h4><p>大部分垃圾邮件都来自于同事，任何发给一个同事却传送多于半打人的邮件都可能是垃圾。</p><p>一个简单的测试企业内部垃圾邮件的方法是采用安全组织的思考方式。当安全至为关键时，信息传播应根据需要进行筛选。</p><h4 id="“FYI”到底啥意思？"><a href="#“FYI”到底啥意思？" class="headerlink" title="“FYI”到底啥意思？"></a>“FYI”到底啥意思？</h4><p>把你加为抄送人的发件人当时在想什么呢？很有多可能，很多并不值得我们赞赏：</p><ul><li>“如果我不多抄送些人，谁知道我在工作啊？”</li><li>“我不敢不发，因为如果发生什么事大家会抱怨为什么他们不知道。”</li><li>“这是一个开放的组织，所以每个人应该看到所有事情。”</li><li>“我希望大家都看看我是多么好的一个写手。”</li></ul><h4 id="是开放型组织，还是公社？"><a href="#是开放型组织，还是公社？" class="headerlink" title="是开放型组织，还是公社？"></a>是开放型组织，还是公社？</h4><p>“开放型组织”暗示大家都为自己的工作感到自豪，而且很乐意别人看到自己的工作。我们都希望跟这样的团队一起工作，但我们需要更理性：大家允许你通过拉动的方式了解他们做的工作是好的；但如果大家用推送的方式把所有信息都给你，这就不好了。</p><blockquote><p>人生短暂，如果你需要知道所有才能工作，你可能走不了多远。</p></blockquote><h4 id="撤销被动的同意"><a href="#撤销被动的同意" class="headerlink" title="撤销被动的同意"></a>撤销被动的同意</h4><p>有一条不成文规定：沉默等于同意。如果你发现自己每天花费大量时间子啊阅读没有价值的东西时，很可能就是因为你在被抄送人员里，担心被视为默认。</p><p>你需要撤销这样的规则。有效的撤销——确立只有显式同意才算同意。</p><h4 id="建立一个少垃圾邮件、自我协调的组织"><a href="#建立一个少垃圾邮件、自我协调的组织" class="headerlink" title="建立一个少垃圾邮件、自我协调的组织"></a>建立一个少垃圾邮件、自我协调的组织</h4><p>不仅要测试收到的邮件是否需要知道，对于你希望发出的邮件也要做同样的测试。每次当你想要发一封协调邮件给你的同事或为你工作的员工时，考虑一下你需要让这个人变得自我协调步骤。</p><p>告诉一个人该做什么确实简单，但让这个人逐渐形成自我协调的能力，那就太复杂了。但是从长远看，这种努力是会得到回报的。</p><h3 id="让改变成为可能"><a href="#让改变成为可能" class="headerlink" title="让改变成为可能"></a>让改变成为可能</h3><p>大家对改变的排斥不是针对某一特定的改变，而是拒绝任何改变。根源就是大家天性讨厌改变。</p><h4 id="现在，聆听另一位著名顾问的几句话"><a href="#现在，聆听另一位著名顾问的几句话" class="headerlink" title="现在，聆听另一位著名顾问的几句话"></a>现在，聆听另一位著名顾问的几句话</h4><blockquote><p>我们应该认识到：没有什么事情比让一个人成为新秩序的导入者更难驾驭，更难确定成功，更难管理风险的了。因为所有收益于旧秩序的人都将成为他的敌人；而那些也许会受益于新秩序的人只可能成为他缺乏热情的保卫者。——马基雅弗利</p></blockquote><p>围绕改变的天平两端是不平衡的。一边是那些熟知旧规则的人将成为你的敌人——你将迫使他们重新成为不适应的新手——而你从即将获益的那些人里只能获得极少的支持。原因就在于大家讨厌改变。当我们开始改变时，是否能获得成功，我们心里并没有底。这种不确定性比起潜在获益更能深入人心。</p><h4 id="老板，这想法很妙。我马上着手进行"><a href="#老板，这想法很妙。我马上着手进行" class="headerlink" title="老板，这想法很妙。我马上着手进行"></a>老板，这想法很妙。我马上着手进行</h4><p>“改变阻力连续区”：</p><p><img src="/images/peopleware/p-06.jpg" alt="p-06.jpg"></p><p>每个人对改变的反应都处于这个连续区中。</p><p>我们首先要意识到“盲目遵从”带来的危险。他们盯着新潮的流行东西，观点瞬息万变，瞬间就会放弃对你的支持。</p><p>“相信但保持质疑”的人才是唯一拥护改变的真正盟友。两个极端，无论是“盲目遵从”，还是“激励反对”，都是真正的敌人。<strong>改变能否成功，取决于你怎样管理那些“相信但保持质疑”的人。</strong>不要指望靠逻辑思维来作为你的王牌：那些抱观望态度无所谓观点的同盟者从来都不会受理性讨论的影响，即使讨论证明了建议的新方式要比现有方法好得多。当安排你去推进改变时，如下事情需得自我重复。</p><blockquote><p>对改变的基本反应并非逻辑思考得来的，而是情绪化的。</p></blockquote><p>作为系统开发人员，我们身处冷静、平静、理性的世界。编译器是不会为我们感到高兴或愤怒的，可能这就是为什么我们倾向于运用逻辑作为解决问题的主要方法。</p><p>在《管理转型》（Managing Transitions）中，威廉.布瑞琦（William Bridges）建议我们不要贬低旧的方式。相反，我们需要用感恩旧方式的方法来帮助推动改变。</p><h4 id="一个更好的变化模型"><a href="#一个更好的变化模型" class="headerlink" title="一个更好的变化模型"></a>一个更好的变化模型</h4><p>我们大多数人对改变的认知：</p><p><img src="/images/peopleware/p-07.jpg" alt="p-07.jpg"></p><p>在这样的认知中，一个突发奇想的电子引起了一种从旧到新的直接改变。但坦白说，事情没那么简单。家庭治疗师维吉尼亚.萨提亚提出对待改变的模式：</p><p><img src="/images/peopleware/p-08.jpg" alt="p-08.jpg"></p><p>外来元素的引入会成为改变的催化剂催生出改变。如果没有这种催化剂，就不会有渴求改变的认知。</p><p>当你尝试去驾驭改变时，遭遇的第一件事情就是混乱。经历混乱是绝对必要的，而且没有捷径可以跨越。</p><p>对于处于混乱中的人们，可以利用转型的想法为大家带来痛苦即将结束的希望。</p><p>实践与整合（Practice-and-Integration）阶段出现在学习曲线上扬处。由于新方式下的熟练程度还不够，你们还不能完全适应，但已经意识到新方式开始发挥作用或者有成功的希望。</p><h4 id="安全第一"><a href="#安全第一" class="headerlink" title="安全第一"></a>安全第一</h4><p>除非大家都感到安全，否则就不要发起改变。而且，只有大家清楚自己不会因为提出改变或经历改变遭遇贬低或降级时，他们才会感到安全。</p><p>改变只有在容忍失败——至少是一点失败——的情况下才有机会成功。</p><h3 id="组织型学习"><a href="#组织型学习" class="headerlink" title="组织型学习"></a>组织型学习</h3><h4 id="经验与学习"><a href="#经验与学习" class="headerlink" title="经验与学习"></a>经验与学习</h4><p>组织型学习并不能和经验的单纯积累画等号。高科技公司可以以惊人的速度积累经验，但是他们依然无法保证如何学习跟上这种速度。</p><p>当一个组织开始考虑经验的表现形式时，此时，经验便能转换为学习。这个过程存在两种迥然不同的形式：<strong>*该组织将新的技能传授给自己的员工</strong>，或者<strong>该组织以另一种不同的方式来运作。</strong></p><p>对于第一种形式，变化会直接带来人力资本的增加，如果接受培训的员工离开了，投资旧泡汤了，知识的传授也随之付诸东流。若是第二种形式，变化会临时性地存储在那些实施了再设计的人的大脑中。最终，它将变成整个组织的知识储备。然而由于在过渡时期，知识掌握在少数人手中，如果这些关键人物离开，整个组织的学习活动也将受到伤害。</p><p>无论采取哪种形式，组织都将面临以下风险：<strong>学习受限于一个组织留住员工的能力</strong>。</p><h4 id="组织型学习的关键问题"><a href="#组织型学习的关键问题" class="headerlink" title="组织型学习的关键问题"></a>组织型学习的关键问题</h4><p>组织型学习的关键问题不在于如何开展学习，而在于在何处开展。</p><p>那些处于组织顶层的人们并不会将心思放在日常的工作事物中，与之相反，底层的人们通常受限于他们所在的组织边界，可能会对一些重要的时机视而不见，很少能主导实际的改变。如果关键的学习既没有在顶层，也没有在底层发生，那就可能二者取其中。这意味着在许多组织中，多数自然而然产生的学习中心都发生在位于组织中间的管理层。成功的学习下组织通常都拥有一支非常强大的中间管理层。</p><h4 id="管理团队"><a href="#管理团队" class="headerlink" title="管理团队"></a>管理团队</h4><p>通过消除中间管理层来碾平组织结构图的确是减少学习的秘方。但是反过来却未必正确：依赖于中间管理层自身并不能让学习取得成功。为了形成一个重要的学习中心，中层管理者需要相互交流，并子啊一起高效融洽地工作。这是一个极为罕见的现象。在多数情况下，“管理团队”就是一个让人遗憾的误称。管理团队中的成员在项目状态会上虽然会集中坐在一起，轮流向上级汇报工作，但是他们彼此很少合作。</p><h4 id="空白地带的危险"><a href="#空白地带的危险" class="headerlink" title="空白地带的危险"></a>空白地带的危险</h4><p>在任何规模的组织中，最适宜的学习中心通常都位于中层管理者之间的空白地带。倘若这样的空白地带成为重要的交流渠道，倘若中层管理者能够作为组织的重新设计者协同工作，共同承担，那么学习的益处便由可能获得。</p><h3 id="构建社区"><a href="#构建社区" class="headerlink" title="构建社区"></a>构建社区</h3><h4 id="偏离公司政治"><a href="#偏离公司政治" class="headerlink" title="偏离公司政治"></a>偏离公司政治</h4><p>社区并不会从工作过程中自然形成，它需要被创建出来。如何创建社区，如何使其健康发展以及满足更多人的需求，这便是政治。</p><p>亚里士多德将政治学作为组成哲学的五种高尚科学之一：</p><ul><li>形而上学：对于存在、宇宙及其中事物本质的研究；</li><li>逻辑学：我们认识事物的方式，基于我们的认知能力所得出的结论，以及演绎和推理的原则；</li><li>伦理学：我们对人类的认识，以及由此推断出的人与人之间的交互准则；</li><li>政治学：我们如何将伦理学应用到更大的人类族群当中，政治学便是关于创建并管理这样的人类族群的科学，它要求作为形而上学主题的人类在伦理行为和逻辑认知上具有一致性；</li><li>美学：对超自然实体中富豪和图像的欣赏，美学告诉我们伦理学和政治学之间的和谐美。</li></ul><p>亚里士多德政治学是高效管理的关键性实践，拒绝了它，你将损失惨重，因为这才是管理者真正的职责。相似的，资深员工也应该承担构建社区的职责。</p><h4 id="为什么需要社区"><a href="#为什么需要社区" class="headerlink" title="为什么需要社区"></a>为什么需要社区</h4><p>能够成功构建社区的组织更能留住人。当员工有了足够的社区意识时，他们就不想离开了。你对人力资本的投资由此也得到了回报，进而愿意投资更多，再进而你的员工将会表现更好，也更喜欢你的公司。这种正面的增强会形成一种良性循环。</p><p>在未来，你会觉得在公司成功创建的社区才是人们真正喜欢的、尊重的，并付出自己忠诚的。这就是你的成就。</p><h4 id="没有魔法"><a href="#没有魔法" class="headerlink" title="没有魔法"></a>没有魔法</h4><p>与任何一种艺术一样，创建一个成功的社区需要天分、勇气和创造力。同时你需要付出很多时间。你的创造形式应该是与众不同的。</p><h2 id="快乐地工作"><a href="#快乐地工作" class="headerlink" title="快乐地工作"></a>快乐地工作</h2><p>所谓工作，就是要使员工的效率最大化，而这已经足以剥夺他们的快乐了。当然没人直截了当地说工作本不应该快乐，然而事实却是如此。</p><h3 id="混乱与秩序"><a href="#混乱与秩序" class="headerlink" title="混乱与秩序"></a>混乱与秩序</h3><p>我们经常将混乱视为自己的特殊领域，我们认为让一切井然有序就是我们的工作。开放的管理者却有一套截然不同的方法。他们愿意给其他人保留一小部分的混乱。采用这种方法，管理者的工作就是将混乱分成不同的部分，分发给下面的人搭理。</p><h4 id="进步是我们最大的问题"><a href="#进步是我们最大的问题" class="headerlink" title="进步是我们最大的问题"></a>进步是我们最大的问题</h4><p>混乱的程度一直在下降，特别是在新的技术领域。我们都渴望改进我们的工作方式，使软件开发这个行业能够更加有序，这是一种进步。在这个过程中，某些疯狂的乐趣就丢失了，而一个人的快乐可能正是另一个人的痛苦。无论如何，向着更加有秩序、更可控的方向前进正是大势所趋。深谋远虑的管理者不会阻止这种趋势，但也可能会适当地尝试逆势而为，从而给工作注入更多的能量。这就使得我们可以采取某种策略，建设性地重新引入少量无序。</p><p>实现该策略的几种方法：</p><ul><li>试点项目</li><li>战争游戏</li><li>头脑风暴</li><li>激发性训练</li><li>培训、旅游、会议、庆祝和撤退</li></ul><p>当然限制不必如此严格。</p><h4 id="试点项目"><a href="#试点项目" class="headerlink" title="试点项目"></a>试点项目</h4><p>在试点项目中，我们可以抛开常规，尝试一些新的未经证明的技术。改变总是有成本的，另一方面，生产效率会随着我们采用的新技术而提高。这种总体上产生的正面效应就是霍桑效应（Hawthorne Effect），即人们在尝试新颖的东西时，所激发的能量与兴趣可以促进人们的生产下来。</p><p>根据我们的经验，采用了任何改进方法的试点项目，带来的生产效率都要大大高于平均值。这意味着，如果你选择在试点项目中采用某些新技术，可以降低你的投入。</p><p>在任何情况下，比起没有试点项目，将所有项目做成试点项目都是大有裨益的。</p><p>对于试点项目的一个警告是：在任何一个项目中不要试验超过一种类型的开发技术。虽然总是谈到标准的重要性，让人惊讶的是，很多项目管理者在试点项目中却彻头彻尾地抛弃了所有的项目标准。他们通常在同一额项目中尝试使用新的硬件、新的软件、新的质量控制过程和新的原型技术等。</p><p>实施试点项目的合理做法是每次只允许对开发过程的一个组成部分进行细微的调整。在一个最健康的环境中，项目人员应该知道，对于每一个试点项目，鼓励试验一个技术点，同时还需哟啊遵循其他的项目标准。</p><h4 id="战争游戏"><a href="#战争游戏" class="headerlink" title="战争游戏"></a>战争游戏</h4><p>有时一些具有竞争性但又无所谓输赢的活动可以带来具有建设意义的无序性。战争游戏可以帮助你评估自己的相对优势和劣势，进而帮助企业评估自己的整体优势与劣势。</p><p>最有效的战争游戏方式是将参与人员分成不同的团队：</p><ul><li>选择一个小的开发项目或者一个人物划分清楚的项目作为实验用的小白鼠。最好能够选择公司中的一个实际项目，1～2人月的工作量。然后，选择一个新的、具有挑战性的问题。当然这个问题应该能够应用到员工的开发技能。</li><li>通过发布工作的具体声明使项目以正式的方式运转。</li><li>正式宣布在即将到来的周末将有一个24小时的项目锦标赛。确保所有人都能理解，将比赛安排在周末是使团队有个属于他们自己的地方进行比赛。鼓励每个团队由四个人组成，比赛完全基于自愿原则。</li><li>事先发布工作声明，并且规定游戏规则和目标。</li><li>锦标赛开始当天，仅参赛人员出场，提供他们之所需。让所有团队都做相同的工作，以确保他们之间的确属于竞争关系。</li><li>为比赛安排组织者，他们的职责是确保每个人都遵循那些基本的原则，防止致命问题的发生。如有团队取得阶段性成功，应营造出锣鼓喧天的欢庆感觉。</li><li>寻找机会让每个人都能在某种程度获胜。要大声宣布任何团队取得的任何成就。</li><li>安装获胜产品，或者同时安装多个获胜产品。小心记录产品稳定性、缺陷数量、用户接受程度、改变所需成本等任何有可能影响产品成功的信息。然后，将这些数据报告给开发团队。</li></ul><p>需要注意：首先，这些事情是要花钱的；其次，可以多花些时间凸显项目中的问题，使组织者活跃起来，进而引入更多的检查点和阶段性成果。再次，根据项目所需时间来准确地界定项目范围。最后，在食物上要显得慷慨一点。</p><p>通宵进行比赛往往会带来更多的乐趣，人们总是喜欢共患难，精疲力竭，让每个人都能看到其他人头发凌乱、不修边幅的邋遢样子。</p><h4 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h4><p>头脑风暴没有多少规则，我们的目的就是要在整个过程中制造混乱。在头脑风暴中，负责人应该保证整个过程既是无序的，又是愉快的，而且能够产生出实际的成果。作为组织者，你需要强调的是点子的数量而不是质量，要让整个过程非常松散，甚至有些愚蠢。我们不在过程中对征集的点子进行评判，而是在之后做这样的事情。作为组织者，当发现大家没有什么点子可出时，可以采取以下措施：</p><ul><li>类比思考（大自然是如何处理整个相似问题的？）</li><li>反其道而行之（我们所要达到目标的反面是什么？）</li><li>身临其境（如果是你，你会如何解决？）</li></ul><h4 id="培训、旅行、会议、庆祝和撤退"><a href="#培训、旅行、会议、庆祝和撤退" class="headerlink" title="培训、旅行、会议、庆祝和撤退"></a>培训、旅行、会议、庆祝和撤退</h4><p>特别是对于正在成长的团队来说，值得花钱让他们走出办公室。毫无疑问，好的秩序是我们日常工作之所需。但是，我们依然希望能够看到一些冒险和一些适当的具有建设意义的无序性。</p><h3 id="自由电子"><a href="#自由电子" class="headerlink" title="自由电子"></a>自由电子</h3><h4 id="小作坊现象"><a href="#小作坊现象" class="headerlink" title="小作坊现象"></a>小作坊现象</h4><p>作坊式创业者，他们要么编写程序要么从事设计工作，要么负责管理，想什么时候工作就什么时候工作，每做完一个项目都会休上两三个月的假。他们拥有更多的自由，更多的休假时间，更多的选择工作的机会。他们工作得更加愉快，挣钱也更多。</p><h4 id="同事、大师、内部创业者"><a href="#同事、大师、内部创业者" class="headerlink" title="同事、大师、内部创业者"></a>同事、大师、内部创业者</h4><p>企业面临巨大的压力，他们需要向那些最优秀的员工提供更好的工作环境，以防止这些员工转行到作坊产业。其中一种途径便是创造一些职责比较松散的职位，工作在这些职位上的员工有更大的话语权来决定自己的工作。极端情况下，他们的任务甚至可能是一个空头支票。</p><p>增加“自由电子”式职位的作用远远不止于应对作坊产业这么简单。在现代企业中，之所以存在如此之多的大师、内部创业者和内部咨询者，是因为这些企业的盈利依赖于他们。这些“自由电子”以不成正比的方式为公司创造着效力。他们被这种工作方式所激励，从而积极思考如何反过来回报自己的公司。</p><h4 id="没有前车之鉴"><a href="#没有前车之鉴" class="headerlink" title="没有前车之鉴"></a>没有前车之鉴</h4><p>在西方世界中，西方人认为事情都应该由本人自己处理，或者他们可以自行决定从什么地方获取建议。但是这种自由主义到了工作场所便销声匿迹了。在工作中，我们认为每个人都需要一个确切的方向，这个方向是由我们的上层制定的。大多数人把从老板哪里获得工作计划，然后按时完成该计划当作成功。</p><p>最好的管理者就在于有能力找出少数几个关键的苗子，这些苗子既成熟稳重，又视野开阔。找到后，就放手让他们去干。</p><h3 id="霍尔加-丹斯克"><a href="#霍尔加-丹斯克" class="headerlink" title="霍尔加.丹斯克"></a>霍尔加.丹斯克</h3><p>即便只是针对组织内部进行的单个具有实质性的改变，也会给企业带来巨大的好处。</p><h4 id="然而，为什么是我？"><a href="#然而，为什么是我？" class="headerlink" title="然而，为什么是我？"></a>然而，为什么是我？</h4><p>即便只是做出单个改变，单纯利用一个人的力量也会很困难。在我们主张的这些改变中，成功的关键就在于你不要去尝试和公牛进行搏斗。事实上你也没有强大到可以做到这一点。</p><p>一个人若是单独行动，那就没办法产生出有意义的变化，而且你也没有必要这样单独行动。</p><h4 id="沉睡巨人"><a href="#沉睡巨人" class="headerlink" title="沉睡巨人"></a>沉睡巨人</h4><p>霍尔加.丹斯克——丹麦传说中的“沉睡巨人”，在国家处于和平时，他安静地睡着。但是一旦国家处于危险中，他便会苏醒，面目是否狰狞。</p><p>要是企业内部存在太多的熵，太缺乏常识，就濒临危险了。你的那些同事和下属平时极为理性，一旦耐性耗尽忍无可忍，他们可能就化身为巨人了。无论他们是不是在为全局着想，只要他们看到一些愚蠢的事情时，就会直接指出。而一些损害工作环境的行为的的确确是彻头彻尾的蠢行。</p><h4 id="醒来吧，霍尔加-丹斯克"><a href="#醒来吧，霍尔加-丹斯克" class="headerlink" title="醒来吧，霍尔加.丹斯克"></a>醒来吧，霍尔加.丹斯克</h4><p>要唤醒这样的巨人并不难，如果我们所做的傻事太过明显，只需要一根很小的导火索就能唤醒他们。</p><hr><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>豆瓣：<a href="https://book.douban.com/subject/25956450/" target="_blank" rel="noopener">https://book.douban.com/subject/25956450/</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《人件》（Peopleware，第三版）读书笔记（下）&quot;&gt;&lt;a href=&quot;#《人件》（Peopleware，第三版）读书笔记（下）&quot; class=&quot;headerlink&quot; title=&quot;《人件》（Peopleware，第三版）读书笔记（下）&quot;&gt;&lt;/a&gt;《人件》（
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://blog.michealwayne.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
