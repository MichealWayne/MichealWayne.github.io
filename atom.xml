<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wayne的博客</title>
  
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.michealwayne.cn/"/>
  <updated>2025-08-19T14:42:14.278Z</updated>
  <id>http://blog.michealwayne.cn/</id>
  
  <author>
    <name>Micheal Wayne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【工具】AI Common Notify：统一 AI 编程工具通知服务</title>
    <link href="http://blog.michealwayne.cn/2025/08/16/tools/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91AI%20Common%20Notify%EF%BC%9A%E7%BB%9F%E4%B8%80%20AI%20%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1/"/>
    <id>http://blog.michealwayne.cn/2025/08/16/tools/【工具】AI Common Notify：统一 AI 编程工具通知服务/</id>
    <published>2025-08-16T12:21:22.000Z</published>
    <updated>2025-08-19T14:42:14.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-Common-Notify-完全指南：统一-AI-编程工具通知服务"><a href="#AI-Common-Notify-完全指南：统一-AI-编程工具通知服务" class="headerlink" title="AI Common Notify 完全指南：统一 AI 编程工具通知服务"></a>AI Common Notify 完全指南：统一 AI 编程工具通知服务</h1><p>在 AI 辅助编程日益普及的今天，<a href="https://docs.anthropic.com/en/docs/claude-code/overview" target="_blank" rel="noopener">Claude Code</a>、<a href="https://cursor.com/cn" target="_blank" rel="noopener">Cursor</a>、<a href="https://windsurf.com/" target="_blank" rel="noopener">Windsurf</a>、<a href="https://www.trae.cn/" target="_blank" rel="noopener">Trae</a> 等 AI 工具极大地提升了我们的开发效率。但这些工具都有一个共同的问题：<strong>它们在执行完任务后不会主动通知用户，导致开发者需要手动检查任务状态</strong>。如果在同时运行多个任务时，容易错过重要信息或无法有效安排工作优先级。</p><p>为了解决这一问题，本人写了 <strong>AI Common Notify</strong> —— 一个为所有主流 AI 编程工具提供统一通知服务的开源工具。它能在 AI 工具完成任务后主动发送系统通知，让您在多任务并行时也能井然有序地处理工作。</p><p><img src="/images/aiCommonNotify/p-cc.png" alt="p-cc"><br><img src="/images/aiCommonNotify/p-cursor.png" alt="p-cursor"></p><blockquote><p>AI Common Notify 本质上是一个通知应用工具，因此它也可以不只应用于 ai 编辑器。</p></blockquote><blockquote><p>项目地址：<a href="https://github.com/MichealWayne/ai-common-notify" target="_blank" rel="noopener">https://github.com/MichealWayne/ai-common-notify</a></p></blockquote><h2 id="为什么选择-AI-Common-Notify？"><a href="#为什么选择-AI-Common-Notify？" class="headerlink" title="为什么选择 AI Common Notify？"></a>为什么选择 AI Common Notify？</h2><h3 id="现状问题"><a href="#现状问题" class="headerlink" title="现状问题"></a>现状问题</h3><p>目前市面上虽然已有一些小的通知工具，但它们通常只针对单一 AI 工具，例如仅支持 Claude Code。这种碎片化的解决方案带来了以下问题：</p><ol><li><strong>工具割裂</strong>：每个 AI 工具需要单独的通知服务、如配 hook、配 mcp，用户需要安装和配置多个工具</li><li><strong>体验不一致</strong>：不同通知服务的样式、行为和配置方式差异很大</li><li><strong>维护成本高</strong>：当需要调整通知设置时，需要逐一修改各个工具的配置</li><li><strong>扩展性差</strong>：缺乏统一的扩展机制，难以集成自定义通知渠道</li></ol><h3 id="AI-Common-Notify-的核心优势"><a href="#AI-Common-Notify-的核心优势" class="headerlink" title="AI Common Notify 的核心优势"></a>AI Common Notify 的核心优势</h3><p>AI Common Notify 针对上述痛点提供了全面解决方案：</p><ol><li><strong>统一接口</strong>：一个工具支持所有主流 AI 编程工具（Claude Code、Cursor、Windsurf、Trae 等）</li><li><strong>跨平台兼容</strong>：支持 Windows、macOS 和 Linux</li><li><strong>高度可配置</strong>：支持自定义标题、消息模板、紧急程度、超时时间、声音和图标</li><li><strong>扩展性强</strong>：通过脚本回调机制，可轻松集成微信通知、钉钉机器人等自定义通知渠道</li><li><strong>易于部署</strong>：支持 npm 全局安装和独立可执行文件，一键配置</li><li><strong>智能初始化</strong>：自动检测项目中使用的 AI 工具并生成相应配置</li></ol><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在本地环境安装<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">Nodejs</a>（推荐 v18 及以上）后，可通过 npm 全局快速安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ai-common-notify</span><br></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成后，通过以下命令验证是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本信息</span></span><br><span class="line">ai-common-notify --version</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送测试通知</span></span><br><span class="line">ai-common-notify <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>如果看到版本信息或系统通知弹出，说明安装成功。</p><h2 id="核心功能详解"><a href="#核心功能详解" class="headerlink" title="核心功能详解"></a>核心功能详解</h2><h3 id="1-多样化的通知触发机制"><a href="#1-多样化的通知触发机制" class="headerlink" title="1. 多样化的通知触发机制"></a>1. 多样化的通知触发机制</h3><p>AI Common Notify 支持多种通知触发方式，适配不同 AI 工具的特点：</p><h4 id="Hook-模式（Claude-Code）"><a href="#Hook-模式（Claude-Code）" class="headerlink" title="Hook 模式（Claude Code）"></a>Hook 模式（Claude Code）</h4><blockquote><p>可通过<code>ai-common-notify quickInit</code>命令在项目下<a href="#4-快速初始化功能">快速初始化配置</a></p></blockquote><p>通过 Claude Code 的 Hook 系统集成，在任务完成时发送通知：</p><p>在 Claude Code 设置文件 (<code>~/.claude/settings.json</code> 或项目中的 <code>.claude/settings.json</code>)设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">    <span class="attr">"Stop"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"matcher"</span>: <span class="string">".*"</span>,</span><br><span class="line">        <span class="attr">"hooks"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"command"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"ai-common-notify hook"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MCP-模式（Cursor、Windsurf、Trae、CodeBuddy、Gemini-cli-等）"><a href="#MCP-模式（Cursor、Windsurf、Trae、CodeBuddy、Gemini-cli-等）" class="headerlink" title="MCP 模式（Cursor、Windsurf、Trae、CodeBuddy、Gemini-cli 等）"></a>MCP 模式（Cursor、Windsurf、Trae、CodeBuddy、Gemini-cli 等）</h4><blockquote><p>也可通过<code>ai-common-notify quickInit</code>命令在项目下<a href="#4-快速初始化功能">快速初始化配置</a></p></blockquote><p>通过在 IDE 中设置 MCP 为 Cursor 等工具提供通知服务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mcpServers"</span>: &#123;</span><br><span class="line">    <span class="attr">"NotificationServer"</span>: &#123;</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"ai-common-notify"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"mcp"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用提示</strong>：当使用 Cursor 或 Windsurf 等 MCP 工具时，建议在您的提示（prompt）最后明确要求发送通知，例如：”<code>最后，任务完成时发送通知给我。</code>“、”<code>Finally, send me a notification when the task is finished.</code>“ 这有助于确保 AI 工具调用通知工具。您也可以在 Cursor 的设置中将此提示添加为规则，这样就不需要每次都手动输入。</p></blockquote><h4 id="API-模式（自定义集成）"><a href="#API-模式（自定义集成）" class="headerlink" title="API 模式（自定义集成）"></a>API 模式（自定义集成）</h4><p>api 模式主要用于在线的平台工具进行调用，以统一通知处理。AI Common Notify 提供 RESTful API 供自定义工具调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动API服务器</span></span><br><span class="line">ai-common-notify api</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送通知请求</span></span><br><span class="line">curl -X POST http://localhost:6001/api/v1/notify \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  -H <span class="string">"Authorization: Bearer your-secret-token"</span> \</span><br><span class="line">  -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "title": "任务完成",</span></span><br><span class="line"><span class="string">    "message": "代码重构已完成",</span></span><br><span class="line"><span class="string">    "urgency": "normal",</span></span><br><span class="line"><span class="string">    "timeout": 0,</span></span><br><span class="line"><span class="string">    "sound": true</span></span><br><span class="line"><span class="string">  &#125;'</span></span><br></pre></td></tr></table></figure><h3 id="2-灵活的通知定制"><a href="#2-灵活的通知定制" class="headerlink" title="2. 灵活的通知定制"></a>2. 灵活的通知定制</h3><p>AI Common Notify 支持丰富的通知定制选项：</p><h4 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h4><ul><li><code>title</code>: 通知标题</li><li><code>message</code>: 通知内容</li><li><code>urgency</code>: 紧急程度（low/normal/critical）</li><li><code>timeout</code>: 超时时间（秒，0 表示永久显示）（<strong>部分系统不适用</strong>）</li><li><code>sound</code>: 是否播放声音</li><li><code>icon</code>: 自定义图标路径（<strong>部分系统不适用</strong>）</li></ul><h4 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h4><p>通过 JSON 配置文件实现更精细的控制：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"notifications"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_timeout"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"default_sound"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"default_urgency"</span>: <span class="string">"normal"</span>,</span><br><span class="line">    <span class="attr">"title_template"</span>: <span class="string">"&#123;tool_name&#125; - &#123;project_name&#125;"</span>,</span><br><span class="line">    <span class="attr">"message_template"</span>: <span class="string">"&#123;message&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-脚本回调扩展"><a href="#3-脚本回调扩展" class="headerlink" title="3. 脚本回调扩展"></a>3. 脚本回调扩展</h3><p>脚本回调在 AI Common Notify 的<a href="#配置层级">配置文件</a>中设置，通过脚本回调扩展可以实现在通知发送时执行自定义脚本，让我们可以轻松集成微信通知、钉钉机器人等自定义通知渠道：</p><p>shell:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">30000</span>,</span><br><span class="line">    <span class="attr">"notify"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/path/to/your/script.sh"</span>,</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nodejs:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">30000</span>,</span><br><span class="line">    <span class="attr">"notify"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/path/to/your/script.js"</span>,</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本中可以接收丰富的环境变量（如 nodejs 可以用<code>process.env</code>获取）：</p><ul><li><code>NOTIFY_TITLE</code>: 通知标题</li><li><code>NOTIFY_MESSAGE</code>: 通知消息</li><li><code>NOTIFY_URGENCY</code>: 紧急程度</li><li><code>NOTIFY_TIMEOUT</code>: 超时时间</li><li><code>NOTIFY_SOUND</code>: 是否播放声音</li><li><code>NOTIFY_PROJECT_NAME</code>: 项目名称</li><li><code>NOTIFY_TOOL_NAME</code>: 工具名称</li><li><code>NOTIFY_TIMESTAMP</code>: 时间戳</li></ul><p>通过脚本回调扩展我们可以额外完成很多自定义功能，如：</p><h4 id="集成微信通知示例"><a href="#集成微信通知示例" class="headerlink" title="集成微信通知示例"></a>集成微信通知示例</h4><p><strong>Node.js 脚本示例（发送到企业微信）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wechat-notify.js</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 企业微信机器人Webhook地址</span></span><br><span class="line"><span class="keyword">const</span> webhookUrl = <span class="string">'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造消息内容</span></span><br><span class="line"><span class="keyword">const</span> message = &#123;</span><br><span class="line">  msgtype: <span class="string">'text'</span>,</span><br><span class="line">  text: &#123;</span><br><span class="line">    content: <span class="string">`[<span class="subst">$&#123;process.env.NOTIFY_TIMESTAMP&#125;</span>] <span class="subst">$&#123;process.env.NOTIFY_TITLE&#125;</span>\n<span class="subst">$&#123;process.env.NOTIFY_MESSAGE&#125;</span>\n项目: <span class="subst">$&#123;process.env.NOTIFY_PROJECT_NAME&#125;</span>\n工具: <span class="subst">$&#123;process.env.NOTIFY_TOOL_NAME&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(message);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>: data.length,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = https.request(webhookUrl, options, res =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`微信通知发送状态: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(<span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'微信通知发送失败:'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.write(data);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure><blockquote><p>个人开发者也可以考虑接入 <a href="https://www.pushplus.plus/" target="_blank" rel="noopener">PushPlus</a>、<a href="https://wxpusher.zjiecode.com/docs/#/" target="_blank" rel="noopener">WxPusher</a>、<a href="https://sct.ftqq.com/" target="_blank" rel="noopener">Server 酱</a>这类集成好的平台来实现微信等推送。</p></blockquote><p><img src="/images/aiCommonNotify/wechat-notification.jpeg" alt="wechat-notification"></p><h3 id="4-快速初始化功能"><a href="#4-快速初始化功能" class="headerlink" title="4. 快速初始化功能"></a>4. 快速初始化功能</h3><p>AI Common Notify 提供了一键初始化功能，自动为项目中检测到的 AI 工具生成或更新配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导航到项目目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/your/project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化所有检测到的工具</span></span><br><span class="line">ai-common-notify quickInit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化特定工具</span></span><br><span class="line">ai-common-notify quickInit --tool cursor</span><br><span class="line">ai-common-notify quickInit --tool claudecode</span><br><span class="line">ai-common-notify quickInit --tool windsurf</span><br></pre></td></tr></table></figure><p>该功能支持的工具包括：</p><ul><li><strong>Cursor</strong>: 通过 MCP 协议集成</li><li><strong>Claude Code</strong>: 通过 Hook 系统集成</li><li><strong>Windsurf</strong>: 通过 MCP 协议和规则文件集成</li><li><strong>Gemini-cli</strong>: 通过 MCP 协议集成</li></ul><h3 id="5-错误日志管理"><a href="#5-错误日志管理" class="headerlink" title="5. 错误日志管理"></a>5. 错误日志管理</h3><p>AI Common Notify 具备完善的错误处理和日志记录功能，以便问题反馈和排查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看错误日志</span></span><br><span class="line">ai-common-notify errlog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有日志</span></span><br><span class="line">ai-common-notify alllog</span><br></pre></td></tr></table></figure><h2 id="详细配置说明"><a href="#详细配置说明" class="headerlink" title="详细配置说明"></a>详细配置说明</h2><h3 id="配置层级"><a href="#配置层级" class="headerlink" title="配置层级"></a>配置层级</h3><p>AI Common Notify 支持多层级配置，优先级从低到高依次为：</p><ol><li><strong>全局配置</strong>: <code>~/.config/ai-common-notify/config.json</code> (Linux/macOS) 或 <code>%APPDATA%\\ai-common-notify\\config.json</code> (Windows)</li><li><strong>项目配置</strong>: <code>&lt;project-root&gt;/.ai-notify.json</code></li></ol><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p><strong>全局配置示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">6001</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">    <span class="attr">"token"</span>: <span class="string">"generated-secret-token"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"notifications"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_timeout"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"default_sound"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"default_urgency"</span>: <span class="string">"normal"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">30000</span>,</span><br><span class="line">    <span class="attr">"notify"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/home/user/scripts/notify-log.sh"</span>,</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"retentionHours"</span>: <span class="number">168</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"platforms"</span>: &#123;</span><br><span class="line">    <span class="attr">"linux"</span>: &#123;</span><br><span class="line">      <span class="attr">"sound_enabled"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>项目配置示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"notifications"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_urgency"</span>: <span class="string">"critical"</span>,</span><br><span class="line">    <span class="attr">"title_template"</span>: <span class="string">"[PROJECT] &#123;tool_name&#125; - &#123;project_name&#125;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"notify"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/path/to/project/scripts/notify.js"</span>,</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际使用场景"><a href="#实际使用场景" class="headerlink" title="实际使用场景"></a>实际使用场景</h2><p>实际有些简单的场景：</p><h3 id="1-多任务并行处理"><a href="#1-多任务并行处理" class="headerlink" title="1. 多任务并行处理"></a>1. 多任务并行处理</h3><p>当同时运行多个 AI 任务时，AI Common Notify 能帮助您：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不同项目中启动AI任务</span></span><br><span class="line"><span class="comment"># 任务1: Claude Code重构代码</span></span><br><span class="line"><span class="comment"># 任务2: Cursor生成文档</span></span><br><span class="line"><span class="comment"># 任务3: Windsurf优化性能</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个任务完成后都会收到通知，您可以根据紧急程度安排处理顺序</span></span><br></pre></td></tr></table></figure><h3 id="2-长时间运行任务监控"><a href="#2-长时间运行任务监控" class="headerlink" title="2. 长时间运行任务监控"></a>2. 长时间运行任务监控</h3><p>对于需要长时间运行的 AI 任务，您可以设置完成后通知：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在脚本中集成</span></span><br><span class="line">ai-common-notify send --title <span class="string">"模型训练完成"</span> --message <span class="string">"模型训练已完成，准确率95.2%"</span></span><br></pre></td></tr></table></figure><h3 id="3-错误警报系统"><a href="#3-错误警报系统" class="headerlink" title="3. 错误警报系统"></a>3. 错误警报系统</h3><p>在 CI/CD 流程中集成关键错误通知：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测到错误时发送关键通知</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$ERROR_CODE</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  ai-common-notify send --title <span class="string">"构建失败"</span> --message <span class="string">"构建过程出现错误，请检查日志"</span> --urgency critical</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="4-自动化工作流"><a href="#4-自动化工作流" class="headerlink" title="4. 自动化工作流"></a>4. 自动化工作流</h3><p>在自动化脚本中使用 AI Common Notify：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始部署..."</span></span><br><span class="line"><span class="comment"># ... 部署过程 ...</span></span><br><span class="line">ai-common-notify send --title <span class="string">"部署完成"</span> --message <span class="string">"应用已成功部署到生产环境"</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AI Common Notify 通过提供统一的通知接口，有效解决了 AI 编程工具生态中通知机制缺失的问题。它不仅支持多种主流 AI 工具，还提供了灵活的配置选项、强大的脚本扩展能力和 REST API，满足不同用户的使用需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AI-Common-Notify-完全指南：统一-AI-编程工具通知服务&quot;&gt;&lt;a href=&quot;#AI-Common-Notify-完全指南：统一-AI-编程工具通知服务&quot; class=&quot;headerlink&quot; title=&quot;AI Common Notify 完全指
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.michealwayne.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AI" scheme="http://blog.michealwayne.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>21st.dev：让AI生成的页面告别&quot;塑料感&quot;的专业解决方案</title>
    <link href="http://blog.michealwayne.cn/2025/06/29/notes/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%9121st.dev-%E9%9D%A2%E5%90%91AI%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%8F%8A%E9%A1%B5%E9%9D%A2%E6%A8%A1%E7%89%88%E5%BA%93/"/>
    <id>http://blog.michealwayne.cn/2025/06/29/notes/【工具】21st.dev-面向AI友好的组件库及页面模版库/</id>
    <published>2025-06-29T11:23:32.000Z</published>
    <updated>2025-07-01T07:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21st-dev：让-AI-生成的页面告别”塑料感”的专业解决方案"><a href="#21st-dev：让-AI-生成的页面告别”塑料感”的专业解决方案" class="headerlink" title="21st.dev：让 AI 生成的页面告别”塑料感”的专业解决方案"></a>21st.dev：让 AI 生成的页面告别”塑料感”的专业解决方案</h1><p>现在已经有很多可以生成页面的 ai 工具，但你是否遇到过这样的困扰：AI 生成的页面虽然功能完整，但总有一种说不出的”塑料感”？样式单调、缺乏设计感，调整起来又费时费力…</p><p>ai 生成的页面往往长这样：</p><p><img src="/images/21stdev/p-0.jpg" alt="p-0"><br>或者这样：<br><img src="/images/21stdev/p-5.jpg" alt="p-5"></p><p>稍好点的话可能长这样：<br><img src="/images/21stdev/p-3.png" alt="p-3"><br><img src="/images/21stdev/p-4.jpg" alt="p-4"></p><p>AI 味非常得重…这对于缺乏设计经验或前端技术背景的用户来说，调整这些样式往往需要大量时间和精力。</p><p>当前主流 ai 工具生成的页面普遍存在以下问题：</p><ul><li>视觉风格单一，缺乏品牌个性</li><li>布局结构雷同，用户体验不佳</li><li>样式调整困难，需要大量手动优化</li><li>缺乏现代设计趋势，显得过时</li></ul><h2 id="解决方案：21st-dev-的-AI-友好组件库"><a href="#解决方案：21st-dev-的-AI-友好组件库" class="headerlink" title="解决方案：21st.dev 的 AI 友好组件库"></a>解决方案：21st.dev 的 AI 友好组件库</h2><p>现在有一种较为好用的解决方案：使用<a href="https://21st.dev/" target="_blank" rel="noopener">21st.dev</a> 。</p><p>21st.dev 是一个专为现代前端开发者和设计工程师打造的创新型 UI 组件与页面模板平台。它不仅提供了丰富的高质量组件和页面模板，更以”AI 友好”为核心理念，让开发者可以通过自然语言在 IDE 内快速生成、定制并即时使用高质量 React/Tailwind UI 组件，提升了组件的可组合性、可复用性和智能化集成体验。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>首先在 21st.dev 中挑选心仪的页面模版，一般可以在<code>Heroes</code>tab 中查看，如：</p><p><img src="/images/21stdev/p-6.jpg" alt="p-6"></p><p>选中风格后可点击查看：</p><p><img src="/images/21stdev/p-7.jpg" alt="p-7"></p><p>然后可点击“Copy prompt”复制 prompt。</p><h4 id="对于非开发人员"><a href="#对于非开发人员" class="headerlink" title="对于非开发人员"></a>对于非开发人员</h4><p>如果你不太懂 js 代码的话，可以忽略 prompt 中的内容。</p><p>然后我们在 AI 生成页面的平台中对原有页面进行修改。</p><p>如 Cursor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你是一位专业前端开发，接下来我会给你一段提示词，提示词中包含一种页面风格的代码，你仔细分析一下提示词及代码，参考视觉风格、布局和动画效果，将样式尽可能应用到我的页面中，确保页面文案、核心功能和业务逻辑不受影响。提示词：</span><br><span class="line"></span><br><span class="line">\`\`\`</span><br><span class="line">刚才拷贝的提示词</span><br><span class="line">\`\`\`</span><br></pre></td></tr></table></figure><p>如：<br><img src="/images/21stdev/p-8.png" alt="p-8"></p><p>等待更新：<br><img src="/images/21stdev/p-9.png" alt="p-9"></p><p>效果：<br><img src="/images/21stdev/p-10.jpg" alt="p-10"></p><p>总结一下操作流程：</p><ol><li>访问 <a href="https://21st.dev/" target="_blank" rel="noopener">21st.dev</a></li><li>在 Heroes 标签页选择心仪模板</li><li>复制 prompt 到 AI 工具中</li><li>按提示操作即可获得专业级页面</li></ol><h4 id="对于前端开发者"><a href="#对于前端开发者" class="headerlink" title="对于前端开发者"></a>对于前端开发者</h4><p>如果你本身就是一位前端开发且基本掌握 React 的话，可以直接用拷贝的 prompt 在你的 React 项目中进行生成或更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line">You are given a task to integrate an existing React component in the codebase</span><br><span class="line"></span><br><span class="line">The codebase should support:</span><br><span class="line">- shadcn project structure</span><br><span class="line">- Tailwind CSS</span><br><span class="line">- Typescript</span><br><span class="line"></span><br><span class="line">If it doesn&apos;t, provide instructions on how to setup project via shadcn CLI, install Tailwind or Typescript.</span><br><span class="line"></span><br><span class="line">Determine the default path for components and styles.</span><br><span class="line">If default path for components is not /components/ui, provide instructions on why it&apos;s important to create this folder</span><br><span class="line">Copy-paste this component to /components/ui folder:</span><br><span class="line">\`\`\`tsx</span><br><span class="line">hero-parallax.tsx</span><br><span class="line">&quot;use client&quot;;</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123;</span><br><span class="line">  motion,</span><br><span class="line">  useScroll,</span><br><span class="line">  useTransform,</span><br><span class="line">  useSpring,</span><br><span class="line">  MotionValue,</span><br><span class="line">&#125; from &quot;framer-motion&quot;;</span><br><span class="line">import Image from &quot;next/image&quot;;</span><br><span class="line">import Link from &quot;next/link&quot;;</span><br><span class="line"></span><br><span class="line">export const HeroParallax = (&#123;</span><br><span class="line">  products,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  products: &#123;</span><br><span class="line">    title: string;</span><br><span class="line">    link: string;</span><br><span class="line">    thumbnail: string;</span><br><span class="line">  &#125;[];</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  const firstRow = products.slice(0, 5);</span><br><span class="line">  const secondRow = products.slice(5, 10);</span><br><span class="line">  const thirdRow = products.slice(10, 15);</span><br><span class="line">  const ref = React.useRef(null);</span><br><span class="line">  const &#123; scrollYProgress &#125; = useScroll(&#123;</span><br><span class="line">    target: ref,</span><br><span class="line">    offset: [&quot;start start&quot;, &quot;end start&quot;],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const springConfig = &#123; stiffness: 300, damping: 30, bounce: 100 &#125;;</span><br><span class="line"></span><br><span class="line">  const translateX = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 1], [0, 1000]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  const translateXReverse = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 1], [0, -1000]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  const rotateX = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 0.2], [15, 0]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  const opacity = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 0.2], [0.2, 1]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  const rotateZ = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 0.2], [20, 0]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  const translateY = useSpring(</span><br><span class="line">    useTransform(scrollYProgress, [0, 0.2], [-700, 500]),</span><br><span class="line">    springConfig</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      ref=&#123;ref&#125;</span><br><span class="line">      className=&quot;h-[300vh] py-40 overflow-hidden  antialiased relative flex flex-col self-auto [perspective:1000px] [transform-style:preserve-3d]&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;motion.div</span><br><span class="line">        style=&#123;&#123;</span><br><span class="line">          rotateX,</span><br><span class="line">          rotateZ,</span><br><span class="line">          translateY,</span><br><span class="line">          opacity,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        className=&quot;&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;motion.div className=&quot;flex flex-row-reverse space-x-reverse space-x-20 mb-20&quot;&gt;</span><br><span class="line">          &#123;firstRow.map((product) =&gt; (</span><br><span class="line">            &lt;ProductCard</span><br><span class="line">              product=&#123;product&#125;</span><br><span class="line">              translate=&#123;translateX&#125;</span><br><span class="line">              key=&#123;product.title&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/motion.div&gt;</span><br><span class="line">        &lt;motion.div className=&quot;flex flex-row  mb-20 space-x-20 &quot;&gt;</span><br><span class="line">          &#123;secondRow.map((product) =&gt; (</span><br><span class="line">            &lt;ProductCard</span><br><span class="line">              product=&#123;product&#125;</span><br><span class="line">              translate=&#123;translateXReverse&#125;</span><br><span class="line">              key=&#123;product.title&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/motion.div&gt;</span><br><span class="line">        &lt;motion.div className=&quot;flex flex-row-reverse space-x-reverse space-x-20&quot;&gt;</span><br><span class="line">          &#123;thirdRow.map((product) =&gt; (</span><br><span class="line">            &lt;ProductCard</span><br><span class="line">              product=&#123;product&#125;</span><br><span class="line">              translate=&#123;translateX&#125;</span><br><span class="line">              key=&#123;product.title&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/motion.div&gt;</span><br><span class="line">      &lt;/motion.div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const Header = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;max-w-7xl relative mx-auto py-20 md:py-40 px-4 w-full  left-0 top-0&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;text-2xl md:text-7xl font-bold dark:text-white&quot;&gt;</span><br><span class="line">        The Ultimate &lt;br /&gt; development studio</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;max-w-2xl text-base md:text-xl mt-8 dark:text-neutral-200&quot;&gt;</span><br><span class="line">        We build beautiful products with the latest technologies and frameworks.</span><br><span class="line">        We are a team of passionate developers and designers that love to build</span><br><span class="line">        amazing products.</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const ProductCard = (&#123;</span><br><span class="line">  product,</span><br><span class="line">  translate,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  product: &#123;</span><br><span class="line">    title: string;</span><br><span class="line">    link: string;</span><br><span class="line">    thumbnail: string;</span><br><span class="line">  &#125;;</span><br><span class="line">  translate: MotionValue&lt;number&gt;;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;motion.div</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        x: translate,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      whileHover=&#123;&#123;</span><br><span class="line">        y: -20,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      key=&#123;product.title&#125;</span><br><span class="line">      className=&quot;group/product h-96 w-[30rem] relative flex-shrink-0&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Link</span><br><span class="line">        href=&#123;product.link&#125;</span><br><span class="line">        className=&quot;block group-hover/product:shadow-2xl &quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;Image</span><br><span class="line">          src=&#123;product.thumbnail&#125;</span><br><span class="line">          height=&quot;600&quot;</span><br><span class="line">          width=&quot;600&quot;</span><br><span class="line">          className=&quot;object-cover object-left-top absolute h-full w-full inset-0&quot;</span><br><span class="line">          alt=&#123;product.title&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Link&gt;</span><br><span class="line">      &lt;div className=&quot;absolute inset-0 h-full w-full opacity-0 group-hover/product:opacity-80 bg-black pointer-events-none&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;h2 className=&quot;absolute bottom-4 left-4 opacity-0 group-hover/product:opacity-100 text-white&quot;&gt;</span><br><span class="line">        &#123;product.title&#125;</span><br><span class="line">      &lt;/h2&gt;</span><br><span class="line">    &lt;/motion.div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo.tsx</span><br><span class="line">&quot;use client&quot;;</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; HeroParallax &#125; from &quot;@/components/blocks/hero-parallax&quot;;</span><br><span class="line"></span><br><span class="line">export function HeroParallaxDemo() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;min-h-screen w-full&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;absolute top-0 left-0 w-full&quot;&gt;</span><br><span class="line">        &lt;HeroParallax products=&#123;products&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export const products = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Moonbeam&quot;,</span><br><span class="line">    link: &quot;https://gomoonbeam.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/moonbeam.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Cursor&quot;,</span><br><span class="line">    link: &quot;https://cursor.so&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/cursor.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Rogue&quot;,</span><br><span class="line">    link: &quot;https://userogue.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/rogue.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Editorially&quot;,</span><br><span class="line">    link: &quot;https://editorially.org&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/editorially.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Editrix AI&quot;,</span><br><span class="line">    link: &quot;https://editrix.ai&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/editrix.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Pixel Perfect&quot;,</span><br><span class="line">    link: &quot;https://app.pixelperfect.quest&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/pixelperfect.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Algochurn&quot;,</span><br><span class="line">    link: &quot;https://algochurn.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/algochurn.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Aceternity UI&quot;,</span><br><span class="line">    link: &quot;https://ui.aceternity.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/aceternityui.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Tailwind Master Kit&quot;,</span><br><span class="line">    link: &quot;https://tailwindmasterkit.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/tailwindmasterkit.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;SmartBridge&quot;,</span><br><span class="line">    link: &quot;https://smartbridgetech.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/smartbridge.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Renderwork Studio&quot;,</span><br><span class="line">    link: &quot;https://renderwork.studio&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/renderwork.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Creme Digital&quot;,</span><br><span class="line">    link: &quot;https://cremedigital.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/cremedigital.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Golden Bells Academy&quot;,</span><br><span class="line">    link: &quot;https://goldenbellsacademy.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/goldenbellsacademy.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;Invoker Labs&quot;,</span><br><span class="line">    link: &quot;https://invoker.lol&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/invoker.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &quot;E Free Invoice&quot;,</span><br><span class="line">    link: &quot;https://efreeinvoice.com&quot;,</span><br><span class="line">    thumbnail:</span><br><span class="line">      &quot;https://aceternity.com/images/products/thumbnails/new/efreeinvoice.png&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">\`\`\`</span><br><span class="line"></span><br><span class="line">Install NPM dependencies:</span><br><span class="line">\`\`\`bash</span><br><span class="line">framer-motion</span><br><span class="line">\`\`\`</span><br><span class="line"></span><br><span class="line">Implementation Guidelines</span><br><span class="line"> 1. Analyze the component structure and identify all required dependencies</span><br><span class="line"> 2. Review the component&apos;s argumens and state</span><br><span class="line"> 3. Identify any required context providers or hooks and install them</span><br><span class="line"> 4. Questions to Ask</span><br><span class="line"> - What data/props will be passed to this component?</span><br><span class="line"> - Are there any specific state management requirements?</span><br><span class="line"> - Are there any required assets (images, icons, etc.)?</span><br><span class="line"> - What is the expected responsive behavior?</span><br><span class="line"> - What is the best place to use this component in the app?</span><br><span class="line"></span><br><span class="line">Steps to integrate</span><br><span class="line"> 0. Copy paste all the code above in the correct directories</span><br><span class="line"> 1. Install external dependencies</span><br><span class="line"> 2. Fill image assets with Unsplash stock images you know exist</span><br><span class="line"> 3. Use lucide-react icons for svgs or logos if component requires them</span><br></pre></td></tr></table></figure><p>21st.dev 中拷贝出页面/组件的 prompt 都是如上所示的结构，主要内容是：</p><ul><li>介绍任务和技术栈信息</li><li>介绍组件代码</li><li>告诉 AI 怎么组织文件以及相关依赖项</li></ul><p>另外如果不想使用 AI 的方式，我们可以直接点击组件的“Open Component”按钮查看并复制源码</p><p><img src="/images/21stdev/p-11.png" alt="p-11"></p><p>另外由于 21st.dev 也提供了 MCP 的方式，我们也可以按以下操作：</p><ol><li>登录 21st.dev，访问 Magic 控制台生成 API Key</li><li>通过 CLI 快速安装<code>npx @21st-dev/cli@latest install &lt;client&gt; --api-key &lt;API_KEY&gt;</code><br>也可以在支持 MCP 的 IDE（cursor、windsurf、cline、claude）中手动配置：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"mcpServers": &#123;</span><br><span class="line">  "@21st-dev/magic": &#123;</span><br><span class="line">    "command": "npx",</span><br><span class="line">    "args": ["-y", "@21st-dev/magic@latest"],</span><br><span class="line">    "env": &#123;</span><br><span class="line">      "API_KEY": "&lt;your-api-key&gt;"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置完成后，在 IDE 的 AI 聊天（Composer）里即可使用 <code>/ui</code> 命令：<br>如创建组件<code>/ui create a responsive navbar with logo and dark mode toggle</code></li></ol><blockquote><p>如果你不懂 React、也可以绕一道让 AI 将 React 组件转为 Vue、Angular 技术栈。</p></blockquote><h2 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h2><p>关于 21st.dev 的创办历程感兴趣可以看油管的这个视频：<a href="https://youtu.be/H2Mze4K5j6Q" target="_blank" rel="noopener">https://youtu.be/H2Mze4K5j6Q</a></p><h3 id="背景起源"><a href="#背景起源" class="headerlink" title="背景起源"></a>背景起源</h3><ul><li>创始之初：由 Serafim（网名 <code>@serafimcloud</code>）于 2024–2025 年间创立，灵感源自分享、发现高质量 UI 组件的社区愿景。Serafim 曾与 Daniel Dhawan 合作开发 Rork.com（一个 AI 建站工具），后将其核心组件社区产品独立出来，继续打造 21st.dev 平台</li><li>愿景：目标是成为<strong>“Figma Community for code”，为设计工程师提供集中化、开源、可 remix 的 React + Tailwind UI 组件市场</strong>。</li></ul><h3 id="与传统组件库、模板页、Sandbox-的区别"><a href="#与传统组件库、模板页、Sandbox-的区别" class="headerlink" title="与传统组件库、模板页、Sandbox 的区别"></a>与传统组件库、模板页、Sandbox 的区别</h3><ul><li><strong>AI 原生设计</strong>：21st.dev 的组件和模板结构、元数据均为 AI 理解和调用进行了深度优化，便于 AI 助手自动生成、组合和定制页面。这一点区别于传统组件库仅面向人工查找和手动集成。</li><li><strong>IDE 与 AI 无缝集成</strong>：支持主流 IDE 插件和 AI 助手，开发者可在编辑器内直接搜索、插入、定制组件，远超传统模板页和在线 Sandbox 的割裂体验。</li><li><strong>Remix 与二次创作</strong>：平台鼓励用户在现有组件基础上进行 Remix（再创作），并可一键分享，形成社区驱动的创作循环，而传统 Sandbox 多为孤立的代码实验环境，难以沉淀和复用成果。</li><li><strong>社区开放与开源</strong>：21st.dev 鼓励开发者和设计师上传、分享组件，平台本身开源，促进知识共享和持续进化。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>高效页面搭建</strong>：前端开发者可快速组合高质量组件，极大提升开发效率，减少重复造轮子。</li><li><strong>AI 驱动的界面生成</strong>：AI 开发者可借助平台的 AI 友好特性，实现自动化页面生成、智能布局和批量定制。</li><li><strong>设计与开发协作</strong>：设计工程师可将设计稿转化为可复用组件，推动设计与开发一体化。</li><li><strong>学习与创新</strong>：初学者可通过组件库学习最佳实践，进阶者可参与 Remix 和社区共创。</li></ul><h3 id="产品与特色"><a href="#产品与特色" class="headerlink" title="产品与特色"></a>产品与特色</h3><h4 id="1-组件注册表（Registry）"><a href="#1-组件注册表（Registry）" class="headerlink" title="1. 组件注册表（Registry）"></a>1. 组件注册表（Registry）</h4><ul><li><p>类似 npm 市场但专注 UI 组件，鼓励发布“minimal、modern、reusable”的 React + Tailwind + Radix UI 组件。</p></li><li><p>内置分类丰富，比如导航栏、卡片、按钮、表单、对话框等组件供开发者浏览、复制、安装。</p></li></ul><h4 id="2-魔法生成器：Magic-MCP"><a href="#2-魔法生成器：Magic-MCP" class="headerlink" title="2. 魔法生成器：Magic MCP"></a>2. 魔法生成器：Magic MCP</h4><p>上文也有大致的使用介绍。</p><ul><li><p><a href="https://21st.dev/magic" target="_blank" rel="noopener">Magic MCP</a>是一款 AI 驱动的 IDE Agent，目前支持 Cursor、Windsurf/ Cline、VS Code 等。</p></li><li><p>使用者只需输入如 /ui pricing table 的描述，Magic 会生成多个变体，自动生成组件文件及依赖配置，极大提升开发速度。</p></li></ul><p>另外在官网上也支持类似 bolt、v0 这样的 chat 生成模式：<a href="https://21st.dev/magic-chat" target="_blank" rel="noopener">Magic Chat</a><br><img src="/images/21stdev/p-13.png" alt="p-13"></p><h4 id="3-发布流程和社区治理"><a href="#3-发布流程和社区治理" class="headerlink" title="3. 发布流程和社区治理"></a>3. 发布流程和社区治理</h4><ul><li><p>组件发布仅需一键，上传后先进入 on_review 审查阶段，由 Serafim 亲自审核，合格后可提升为 posted 或 featured。</p></li><li><p>提倡 TypeScript 支持、深度可定制性（支持暗黑模式、CSS 变量、ARIA 可访问性）和结构化 Demo 规范。</p></li></ul><h4 id="4-架构技术栈"><a href="#4-架构技术栈" class="headerlink" title="4. 架构技术栈"></a>4. 架构技术栈</h4><ul><li>前端采用 Next.js 14</li><li>后端使用 Supabase（存储元数据）、Clerk（验证）、Cloudflare R2（静态资源）、Amplitude（分析）。</li></ul><p>开放源码托管在 GitHub，社区贡献活跃（~4.6k Stars，200+ forks），<a href="https://github.com/serafimcloud/21st" target="_blank" rel="noopener">https://github.com/serafimcloud/21st</a>。</p><h4 id="5-商业模式"><a href="#5-商业模式" class="headerlink" title="5.商业模式"></a>5.商业模式</h4><ul><li><p>订阅制（SaaS 模式）：21st.dev 采用月/年订阅机制，目前定价$16 ～ 32/月，官网可见<a href="https://21st.dev/pricing" target="_blank" rel="noopener">具体价格</a>，为专业和高阶用户提供完整的 AI 辅助功能，包括 Magic MCP、Magic Chat、UI 灵感支持等。这是一种典型的持续性付费服务，适合长期使用并依赖高效 UI 开发的开发者团队 。</p></li><li><p>免费策略：平台对所有用户开放基础浏览与复制组件功能，引入用户；高级功能（如 AI 生成、多 Tokens 支持、优先客服等）则通过付费订阅提供。这种“基础免费 → 高级付费”的模式符合常见 SaaS+Freemium 叠加架构 。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>21st.dev 通过其 AI 友好的设计理念，成功解决了 AI 生成页面”塑料感”的问题。无论你是专业开发者还是设计新手，都能通过这个平台快速创建具有专业水准的页面设计。</p><p>随着 AI 在前端开发中的深入应用，21st.dev 将继续优化其 AI 集成体验，为开发者提供更强大、更智能的工具支持。</p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><h4 id="市场反响与发展"><a href="#市场反响与发展" class="headerlink" title="市场反响与发展"></a>市场反响与发展</h4><ul><li>Product Hunt：<a href="https://www.producthunt.com/products/21st-dev-the-npm-for-design-engineers" target="_blank" rel="noopener">评分 4.9/5，1.9k Followers</a>，多位用户评价其平台能力“简化前端开发流程”“组件中心化管理大幅提升效率”</li><li>媒体与融资：被 a16z 报道为 AI 开发未来趋势之一，已获得种子轮融资支持；具体金额未披露。</li><li>社区活力：官方 Discord、Twitter/X 持续更新，LinkedIn 上亦频繁分享优质组件，目前用户粘性高，具备较强的商业化基础。</li></ul><p><img src="/images/21stdev/p-12.png" alt="p-12"></p><p>21st.dev 致力于成为连接设计、开发与 AI 智能的桥梁。随着 AI 在前端开发中的深入应用，平台将持续优化 AI 集成体验，丰富组件生态，推动前端开发的智能化与协作化。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://21st.dev/" target="_blank" rel="noopener">21st.dev</a></li><li><a href="https://youtu.be/H2Mze4K5j6Q" target="_blank" rel="noopener">https://youtu.be/H2Mze4K5j6Q</a></li><li><a href="https://github.com/serafimcloud/21st" target="_blank" rel="noopener">https://github.com/serafimcloud/21st</a></li><li><a href="https://glama.ai/mcp/servers/%4021st-dev/magic-mcp?utm_source=chatgpt.com" target="_blank" rel="noopener">https://glama.ai/mcp/servers/%4021st-dev/magic-mcp?utm_source=chatgpt.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;21st-dev：让-AI-生成的页面告别”塑料感”的专业解决方案&quot;&gt;&lt;a href=&quot;#21st-dev：让-AI-生成的页面告别”塑料感”的专业解决方案&quot; class=&quot;headerlink&quot; title=&quot;21st.dev：让 AI 生成的页面告别”塑料感”
      
    
    </summary>
    
    
      <category term="js" scheme="http://blog.michealwayne.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Figma和AIGC（持续）</title>
    <link href="http://blog.michealwayne.cn/2025/05/25/figma/Figma-AIGC%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/"/>
    <id>http://blog.michealwayne.cn/2025/05/25/figma/Figma-AIGC相关记录（持续）/</id>
    <published>2025-05-25T07:35:02.000Z</published>
    <updated>2025-05-27T11:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.figma.com/" target="_blank" rel="noopener">Figma</a>是一款基于云的协作式界面设计工具，支持多人实时编辑，适用于UI/UX设计、原型制作及设计交付。提供矢量绘图、组件库、交互动画等功能，支持跨平台使用（网页/桌面端），实现团队高效协作与版本管理。</p></blockquote><p>Figma类似早些年的Sketch、PhotoShop，但具备在线多人协同能力以及社区插件体系。</p><p>这两年随着ai应用化的发展，<strong>ai生成figma设计稿</strong>以及<strong>figma设计稿生成前端代码</strong>这两个能力正在迅速发展。</p><h2 id="生成Figma"><a href="#生成Figma" class="headerlink" title="生成Figma"></a>生成Figma</h2><h3 id="场景1：复刻其他页面"><a href="#场景1：复刻其他页面" class="headerlink" title="场景1：复刻其他页面"></a>场景1：复刻其他页面</h3><blockquote><p>当前能力评估：UI界面90%复刻，已到可应用的状态</p></blockquote><p>主要工具：html-to-figma</p><p>当前主流实现路径1：</p><ul><li>Chrome浏览器插件，爬取网站UI信息 -&gt; 生成信息文件（json） -&gt; Figma插件中导入信息文件生成设计稿</li></ul><p>需要安装一个chrome插件，插件有很多：代表如buildio的“HTML to Figma”，腾讯CoDesign-<a href="https://www.figma.com/community/plugin/1398619471957761832/codesign-htmltodesigndesigngenie" target="_blank" rel="noopener">HtmltoDesign</a>：</p><p><img src="/images/figmaAigc/p-1.png" alt="p-1"></p><p>插件已开源：<a href="https://github.com/BuilderIO/figma-html" target="_blank" rel="noopener">https://github.com/BuilderIO/figma-html</a></p><p>（buildio官方近期在迁移这个插件，集成到了buildio插件中<a href="https://www.builder.io/c/docs/chrome-extension#paste-from-chrome-into-figma）" target="_blank" rel="noopener">https://www.builder.io/c/docs/chrome-extension#paste-from-chrome-into-figma）</a></p><p>另外在Figma上需要安装一个接收设计信息的Figma插件：<a href="https://www.figma.com/community/plugin/747985167520967365/builder-io-ai-powered-figma-to-code-react-vue-tailwind-more" target="_blank" rel="noopener">https://www.figma.com/community/plugin/747985167520967365/builder-io-ai-powered-figma-to-code-react-vue-tailwind-more</a></p><p><img src="/images/figmaAigc/p-2.png" alt="p-2"></p><p>使用步骤：</p><p>1.打开需要复刻的页面，如google搜索结果页面，点击chrome插件“CAPTURE PAGE”按钮，即开始导出页面UI信息</p><p><img src="/images/figmaAigc/p-3.png" alt="p-3"></p><p>得到类似<code>page.figma.json</code>的json信息文件</p><p>2.Figma中打开Figma-to-Code插件，上传json</p><p><img src="/images/figmaAigc/p-4.png" alt="p-4"></p><p>即可得到对应设计稿</p><p><img src="/images/figmaAigc/p-5.png" alt="image-20250517220745214"></p><blockquote><p>*现在这类插件也集成了直接输入url地址生成Figma的能力</p></blockquote><p>类似的产品还有：<a href="https://demoway.com/html-to-figma" target="_blank" rel="noopener">https://demoway.com/html-to-figma</a></p><p>除了从真实web页面中复刻外，我们也可以借助Cursor/Windsurf这些AI IDE，让其分析代码并生成Figma、不过注意模型需要支持多模态、一般可用Claude3.x/4</p><p>可参考本文：《五分钟！Cursor+Claude3.7直接生成一整套原型图/UI稿》<a href="https://mp.weixin.qq.com/s/6c1L_sAf3pxJqtJXfGhr-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6c1L_sAf3pxJqtJXfGhr-Q</a></p><h3 id="场景2：ai生成Figma"><a href="#场景2：ai生成Figma" class="headerlink" title="场景2：ai生成Figma"></a>场景2：ai生成Figma</h3><blockquote><p>当前能力评估：简单/通用场景生成效果可应用，复杂页面还需要大量调整</p></blockquote><p>通过自然语言生成设计稿，现在Figma官方也在做这方面的能力，如Figma AI：<a href="https://www.figma.com/ai/?utm_source=ai-bot.cn" target="_blank" rel="noopener">https://www.figma.com/ai/?utm_source=ai-bot.cn</a></p><p>还有各类Figma插件</p><p><img src="/images/figmaAigc/p-9.png" alt="image-20250518102324489"></p><p><a href="https://mmmnote.com/article/7e8/12/article-4c48bb165ef888ff.shtml" target="_blank" rel="noopener">https://mmmnote.com/article/7e8/12/article-4c48bb165ef888ff.shtml</a></p><p>另外Google也推出了设计Agent：<a href="https://stitch.withgoogle.com/" target="_blank" rel="noopener">Stitch</a>，只需要输入一句话/一段话，Stitch就可以输出生产级别的UI设计稿，并且支持直接复制粘贴到Figma中进行二次编辑，或者导出相应代码。</p><p><img src="/images/figmaAigc/p-11.png" alt="image-20250518102324489"></p><p><img src="/images/figmaAigc/p-12.png" alt="image-20250518102324489"></p><p>操作可参考：《Google Stitch：2分钟从想法→可编辑的Figma设计稿（附5个使用技巧）》<a href="https://mp.weixin.qq.com/s/YNEY3rprhueESYh6AD3cTA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YNEY3rprhueESYh6AD3cTA</a></p><hr><h2 id="Figma-to-Code（前端）"><a href="#Figma-to-Code（前端）" class="headerlink" title="Figma to Code（前端）"></a>Figma to Code（前端）</h2><p>这块东西就很多了</p><h3 id="方式1：-Figma官方：Figma-sites"><a href="#方式1：-Figma官方：Figma-sites" class="headerlink" title="方式1：*Figma官方：Figma sites"></a>方式1：*Figma官方：Figma sites</h3><blockquote><p>当前能力评估：静态页面/官网这些场景可应用，其他复杂场景还不行。能力正在发展</p></blockquote><p><a href="https://www.figma.com/sites/" target="_blank" rel="noopener">https://www.figma.com/sites/</a></p><p><img src="/images/figmaAigc/p-6.png" alt="image-20250517221923083"></p><p>(Figma可以通过第一阶段aigc或者复刻生成)</p><p><img src="/images/figmaAigc/p-7.png" alt="image-20250517222458138"></p><p>点击preview可查看页面效果</p><p><img src="/images/figmaAigc/p-8.png" alt="image-20250517222615465"></p><h3 id="方式2：Figma-MCP"><a href="#方式2：Figma-MCP" class="headerlink" title="方式2：Figma MCP"></a>方式2：Figma MCP</h3><blockquote><p> 当前能力评估：大多静态场景可应用，复杂场景需要代码调整。能力正在发展</p></blockquote><p>非官方但也在迅速发展，使用方式可参考Trae：<a href="https://mp.weixin.qq.com/s/AlzeT_1OeFzS6mRC3PDNOA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AlzeT_1OeFzS6mRC3PDNOA</a>、Cursor：<a href="https://zhuanlan.zhihu.com/p/1897249661569447152" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/1897249661569447152</a></p><p><img src="/images/figmaAigc/p-10.png" alt="image-20250518104840899"></p><p><a href="https://www.framelink.ai/" target="_blank" rel="noopener">https://www.framelink.ai/</a>，其实现也已开源：<a href="https://github.com/GLips/Figma-Context-MCP" target="_blank" rel="noopener">https://github.com/GLips/Figma-Context-MCP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.figma.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Figma&lt;/a&gt;是一款基于云的协作式界面设计工具，支持多人实时编辑，适用于UI/UX设计、原型制作及设计交付。提供矢量
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】State-Of-Ai 报告信息</title>
    <link href="http://blog.michealwayne.cn/2025/05/05/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91State-Of-Ai/"/>
    <id>http://blog.michealwayne.cn/2025/05/05/notes/【笔记】State-Of-Ai/</id>
    <published>2025-05-05T14:43:12.000Z</published>
    <updated>2025-05-06T14:39:42.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】State-Of-Ai-报告信息"><a href="#【笔记】State-Of-Ai-报告信息" class="headerlink" title="【笔记】State-Of-Ai 报告信息"></a>【笔记】State-Of-Ai 报告信息</h1><h2 id="一、State-Of-Ai-Web-Dev-2025-报告摘要"><a href="#一、State-Of-Ai-Web-Dev-2025-报告摘要" class="headerlink" title="一、State-Of-Ai Web Dev 2025 报告摘要"></a>一、State-Of-Ai Web Dev 2025 报告摘要</h2><p><img src="/images/notes/20250505/p-2.png" alt="p-2"></p><p><code>2025.stateofai.dev</code>是面向 Web 开发者的一次 ai 使用和问题情况统计，完整报告：<a href="https://2025.stateofai.dev/en-US/models/" target="_blank" rel="noopener">https://2025.stateofai.dev/en-US/models/</a>。其访问组织之前也有<code>state-of-js</code>、<code>state-of-css</code>等典型统计系列。</p><blockquote><p>在这篇<code>state-of-ai</code>统计中，受访者人数规模在<code>5000 - 10000</code>左右，国家主要集中在美欧、中国受访者只有 25 人，因此实际情况和国内会有偏差。</p></blockquote><p>个人概括下这份报告的主要信息：Web 开发者对 AI 应用持有积极的态度，乐于使用并看好其发展。开发者使用 ai 的主要场景在代码生成，目前使用主要问题在幻觉和不确定，另外生成的代码质量和上下文限制也影响了其效果，以至于较大占比的生成代码需要重构。</p><h3 id="1-1-Model-Providers-模型提供商情况"><a href="#1-1-Model-Providers-模型提供商情况" class="headerlink" title="1.1 Model Providers 模型提供商情况"></a>1.1 Model Providers 模型提供商情况</h3><p>首先，毫不奇怪，OpenAI 的 ChatGPT 仍然受益于其先发优势和巨大的市场份额，使其成为最常用（<code>91.2%</code>）和最受欢迎（<code>53.1%</code>）的模型提供商。</p><p>虽然它在使用方面确实领先很大，但在积极情绪（个人觉得这个指标可以理解为好评情况、受欢迎度）方面，第二的 Claude 并没有落后太多，为<code>45.9%</code>。</p><p><img src="/images/notes/20250505/p-1_01.png" alt="p-1_01"></p><p><img src="/images/notes/20250505/p-1_02.png" alt="p-1_02"></p><blockquote><p>因为国内受访者很少，所以像国内常用的千问、豆包等模型统计占比很少。</p></blockquote><h4 id="Model-Providers-Pain-Points-模型提供者的痛点"><a href="#Model-Providers-Pain-Points-模型提供者的痛点" class="headerlink" title="Model Providers Pain Points 模型提供者的痛点"></a>Model Providers Pain Points 模型提供者的痛点</h4><p><strong>幻觉</strong>和<strong>不准确</strong>是迄今为止受访者报告的 AI 模型的最大痛点，这是有道理的，因为如果这些工具的输出不可靠，它们就会失去所有效用。</p><p><strong>缺乏处理更大上下文</strong>和<strong>将数据保存在内存中的能力</strong>也是一个大问题，尤其是在处理大型真实代码库时。</p><p><img src="/images/notes/20250505/p-3.png" alt="p-3"></p><h3 id="1-2-IDE-和编辑器情况"><a href="#1-2-IDE-和编辑器情况" class="headerlink" title="1.2 IDE 和编辑器情况"></a>1.2 IDE 和编辑器情况</h3><p>Cursor 在认知度上处于领先地位，<code>82.2%</code>的受访者使用过或听说过它，而第二的 Zed 只有<code>54.1%</code>。</p><p>当看到关于 Cursor 的随意评论时，似乎主要问题实际上是它的价格，这表明市场可能有更便宜的替代品的空间。</p><p><img src="/images/notes/20250505/p-4_01.png" alt="p-1_01"></p><p><img src="/images/notes/20250505/p-4_02.png" alt="p-1_02"></p><h4 id="IDE-使用痛点"><a href="#IDE-使用痛点" class="headerlink" title="IDE 使用痛点"></a>IDE 使用痛点</h4><p><strong>上下文</strong>和<strong>内存限制</strong>是目前阻止 Web 开发人员使用专用 IDE 进行编码的主要原因，其次是<strong>太多的侵入性建议</strong>以及<strong>与 AI IDE 相关的高成本</strong>。</p><p><img src="/images/notes/20250505/p-5.png" alt="p-5"></p><h3 id="1-3-Coding-Assistants-编码助理使用情况"><a href="#1-3-Coding-Assistants-编码助理使用情况" class="headerlink" title="1.3 Coding Assistants 编码助理使用情况"></a>1.3 Coding Assistants 编码助理使用情况</h3><p>虽然看到 GitHub Copilot 在使用量和积极情绪排名中名列前茅并不奇怪，但值得注意的是，Supermaven 的积极情绪排名第二，尽管就使用量而言仅排名第四。这种差异通常是一颗新星的标志，它可能会在未来一年掀起波澜。</p><p><img src="/images/notes/20250505/p-6_01.png" alt="p-6_01"></p><p><img src="/images/notes/20250505/p-6_02.png" alt="p-6_02"></p><h4 id="Coding-Assistants-Pain-Points-编码助手痛点"><a href="#Coding-Assistants-Pain-Points-编码助手痛点" class="headerlink" title="Coding Assistants Pain Points 编码助手痛点"></a>Coding Assistants Pain Points 编码助手痛点</h4><p><strong>幻觉</strong>和<strong>不准确</strong>再次被证明是更广泛采用的一大障碍。</p><p>就像 IDE 一样，具有<strong>有限上下文窗口</strong>的编码助手也是一个主要问题。</p><p><img src="/images/notes/20250505/p-7.png" alt="p-7"></p><h3 id="1-4-Code-Generation-代码生成情况"><a href="#1-4-Code-Generation-代码生成情况" class="headerlink" title="1.4 Code Generation 代码生成情况"></a>1.4 Code Generation 代码生成情况</h3><p>凭借 Vercel 的实力，v0 迅速确立了自己在这个新兴行业领域的领导者地位。但是 StackBlitz 的 Bolt 也不甘落后，当然值得关注。</p><p><img src="/images/notes/20250505/p-8_01.png" alt="p-8_01"></p><p><img src="/images/notes/20250505/p-8_02.png" alt="p-8_02"></p><h4 id="Code-Generation-Pain-Points-代码生成痛点"><a href="#Code-Generation-Pain-Points-代码生成痛点" class="headerlink" title="Code Generation Pain Points 代码生成痛点"></a>Code Generation Pain Points 代码生成痛点</h4><p>代码生成工具似乎生成了<strong>质量差的代码</strong>，这些代码通常不能按预期工作，或者根本不能工作。</p><p><img src="/images/notes/20250505/p-9.png" alt="p-9"></p><h3 id="1-5-Other-Tools-其他工具"><a href="#1-5-Other-Tools-其他工具" class="headerlink" title="1.5 Other Tools 其他工具"></a>1.5 Other Tools 其他工具</h3><h4 id="使用-ai-工具时的编程语言"><a href="#使用-ai-工具时的编程语言" class="headerlink" title="使用 ai 工具时的编程语言"></a>使用 ai 工具时的编程语言</h4><p>主要还是 js/ts 和 python。</p><p><img src="/images/notes/20250505/p-10.png" alt="p-10"></p><h4 id="图像生成模型"><a href="#图像生成模型" class="headerlink" title="图像生成模型"></a>图像生成模型</h4><p>主要是 DALL·E 和 MJ。</p><p><img src="/images/notes/20250505/p-11.png" alt="p-11"></p><h4 id="AI-封装库-SDK"><a href="#AI-封装库-SDK" class="headerlink" title="AI 封装库/SDK"></a>AI 封装库/SDK</h4><p><img src="/images/notes/20250505/p-12.png" alt="p-12"></p><h4 id="希望浏览器支持-API-情况"><a href="#希望浏览器支持-API-情况" class="headerlink" title="希望浏览器支持 API 情况"></a>希望浏览器支持 API 情况</h4><p>人工智能模型很可能在未来融入我们的网络浏览器——如果发生这种情况，像即时翻译或总结内容这样的事情可能只是一个 API 调用。</p><p><img src="/images/notes/20250505/p-13.png" alt="p-13"></p><h3 id="1-6-Usage-用法"><a href="#1-6-Usage-用法" class="headerlink" title="1.6 Usage 用法"></a>1.6 Usage 用法</h3><p>正如开发人员调查所预期的那样，<strong>代码生成</strong>被列为最常见的人工智能用法。另一方面，尽管图像生成是生成人工智能的原始用例，但只有<code>38%</code>的受访者表示使用它。</p><p><img src="/images/notes/20250505/p-14.png" alt="p-14"></p><h4 id="代码生成占比情况"><a href="#代码生成占比情况" class="headerlink" title="代码生成占比情况"></a>代码生成占比情况</h4><p>大多数人还没有完全进行氛围编码（vibe coding），大多数受访者（<code>69%</code>）通过 AI 生成的代码不到<code>25%</code>——只有一小部分（<code>8%</code>）生成了超过<code>75%</code>的代码。</p><p><img src="/images/notes/20250505/p-15.png" alt="p-15"></p><h5 id="AI-代码重构情况"><a href="#AI-代码重构情况" class="headerlink" title="AI 代码重构情况"></a>AI 代码重构情况</h5><p>即使使用 AI 生成代码，绝大多数（<code>76%</code>）的开发人员表示他们必须重构<strong>至少一半</strong>的输出代码才能准备好使用。</p><p><img src="/images/notes/20250505/p-16.png" alt="p-16"></p><p>重构的首要原因是表面问题，如<strong>易读性差</strong>、<strong>变量重命名</strong>和<strong>过度重复</strong>。许多受访者还使用自由形式的“其他答案”字段来声明生成的代码通常无法按预期工作。</p><p><img src="/images/notes/20250505/p-17.png" alt="p-17"></p><h5 id="使用-AI-生成代码频率情况"><a href="#使用-AI-生成代码频率情况" class="headerlink" title="使用 AI 生成代码频率情况"></a>使用 AI 生成代码频率情况</h5><p><code>46%</code>的受访者每天多次或更多次使用人工智能生成代码。</p><p><img src="/images/notes/20250505/p-18.png" alt="p-18"></p><p>与代码生成相比，人工智能用于其他任务（研究、总结、翻译等）的频率相对较低——考虑到编码仍然是我们花费最多时间的事情，这是有道理的。</p><h5 id="使用-AI-生成代码的场景情况"><a href="#使用-AI-生成代码的场景情况" class="headerlink" title="使用 AI 生成代码的场景情况"></a>使用 AI 生成代码的场景情况</h5><p>最常见的生成代码类型被证明是<strong>辅助函数</strong>，其次是<strong>前端组件</strong>，它们都相当独立，使它们成为代码生成的良好候选者。</p><p>许多人还使用人工智能为现有代码添加留档或注释，这是一个意想不到的用例。</p><p><img src="/images/notes/20250505/p-19.png" alt="p-19"></p><h5 id="使用-AI-生成代码的消费支出情况"><a href="#使用-AI-生成代码的消费支出情况" class="headerlink" title="使用 AI 生成代码的消费支出情况"></a>使用 AI 生成代码的消费支出情况</h5><p>大多数受访者目前没有在人工智能工具和服务上花费任何自己的钱。</p><p><img src="/images/notes/20250505/p-20.png" alt="p-20"></p><p>受访者所在公司在 AI 工具上的支出情况遵循马蹄形模式，公司不会在人工智能上花费任何费用——除非他们花费超过 5000 美元！这种定价模式是否对人工智能公司来说是可持续的还有待观察。</p><p><img src="/images/notes/20250505/p-21.png" alt="p-21"></p><h4 id="AI-各工具应用的使用痛点"><a href="#AI-各工具应用的使用痛点" class="headerlink" title="AI 各工具应用的使用痛点"></a>AI 各工具应用的使用痛点</h4><p>在 AI 痛点方面，整体代码质量差排名第一。</p><p><img src="/images/notes/20250505/p-22.png" alt="p-22"></p><h5 id="觉得这些-ai-或工具缺少的功能"><a href="#觉得这些-ai-或工具缺少的功能" class="headerlink" title="觉得这些 ai 或工具缺少的功能"></a>觉得这些 ai 或工具缺少的功能</h5><p>今天的模型缺少的主要东西是<strong>将整个代码库保存在内存中的能力</strong>，如果 AI 工具旨在帮助我们维护应用程序，而不仅仅是对它们进行原型设计，那么这一点将被证明是关键。</p><p><img src="/images/notes/20250505/p-23.png" alt="p-23"></p><p>另外，尽管调查强调了各种痛点，但受访者总体上对 2025 年人工智能用于 Web 开发的状态非常积极。</p><h3 id="1-7-Resources-信息资源"><a href="#1-7-Resources-信息资源" class="headerlink" title="1.7 Resources 信息资源"></a>1.7 Resources 信息资源</h3><p><img src="/images/notes/20250505/p-24.png" alt="p-24"></p><p>播客：<br><img src="/images/notes/20250505/p-25.png" alt="p-25"></p><p>视频创作者：</p><p><img src="/images/notes/20250505/p-26.png" alt="p-26"></p><hr><h2 id="二、Vercel-State-Of-Ai-2024-报告信息"><a href="#二、Vercel-State-Of-Ai-2024-报告信息" class="headerlink" title="二、Vercel State-Of-Ai 2024 报告信息"></a>二、Vercel State-Of-Ai 2024 报告信息</h2><p>是 Vercel 对于 V0 使用者的调研报告，完整报告：<a href="https://vercel.com/state-of-ai" target="_blank" rel="noopener">https://vercel.com/state-of-ai</a>。</p><p>个人概括下这份报告的主要信息：V0 的使用者看好 AI 的潜力和未来发展，并未接下来的技术进步做准备、如提前准备模型切换能力。虽然目前 OpenAI 是领先的提供商，但开发人员正在积极测试替代方案。AI 应用的重点正在转向面向客户的功能，专注于现实世界的价值，当前模型准确性和成本等挑战仍然是关键问题。开发者成功需要仔细评估、战略规划和灵活实施以适应变化。</p><h3 id="2-1-模型使用情况"><a href="#2-1-模型使用情况" class="headerlink" title="2.1 模型使用情况"></a>2.1 模型使用情况</h3><p>OpenAI 正在引领模型采用，但竞争正在迎头赶上。虽然 OpenAI 仍然是<code>88%</code>采用率的主要选择，但开发人员与多个提供商保持关系——平均两个。随着提供商竞相完成，开发人员的忠诚度在六个月内受到<code>65%</code>更换提供商的考验。</p><p><img src="/images/notes/20250505/p-27.png" alt="p-27"></p><p><img src="/images/notes/20250505/p-28.png" alt="p-28"></p><h3 id="2-2-应用和价值创造情况"><a href="#2-2-应用和价值创造情况" class="headerlink" title="2.2 应用和价值创造情况"></a>2.2 应用和价值创造情况</h3><p>虽然这个市场还很年轻，有很多未开发的机会，但急功近利的时代已经结束了。用户现在对人工智能的期望更高。询问更深入的问题，关于人工智能如何增强用户体验的各个方面，并使其成为产品开发的核心，而不仅仅是一个附加组件。</p><ul><li>聊天机器人（44%）和产品功能（79%）之间的差距揭示了向更深层次的人工智能集成的转变</li><li>矢量数据库采用（70%）标志着 AI 基础设施的成熟</li><li>网站个性化（24%）仍未得到充分开发，这暗示着未来的机会</li></ul><p><img src="/images/notes/20250505/p-29.png" alt="p-29"></p><p><img src="/images/notes/20250505/p-30.png" alt="p-30"></p><h3 id="2-3-开发实践和效率情况"><a href="#2-3-开发实践和效率情况" class="headerlink" title="2.3 开发实践和效率情况"></a>2.3 开发实践和效率情况</h3><p>今天的团队通过智能技术选择而不是巨额预算来构建高需求的人工智能系统。AI 团队以精益预算构建强大的系统，每月花费不到 1,000 美元。他们通过使用 RAG、智能数据采购和云平台跳过昂贵的培训，无需繁重的基础设施即可交付快速、可靠的模型。</p><ul><li>团队通过智能架构和增强生成而不是定制模型训练来优化成本</li><li>每周模型更新正在成为标准，这表明 Vercel 等提供商支持的快速迭代实践</li><li>大多数团队将手动测试与基于经验的发布配对，但是度量驱动的评估正在出现</li></ul><p><img src="/images/notes/20250505/p-31.png" alt="p-31"></p><p><img src="/images/notes/20250505/p-32.png" alt="p-32"></p><p>手动测试仍然很常见，但指标驱动的评估表明质保越来越复杂。</p><p><img src="/images/notes/20250505/p-33.png" alt="p-33"></p><p>团队将公共数据集、网络抓取和客户数据与 RAG 定制相结合，以提供精确的输出，而无需定制模型培训的开销。</p><p><img src="/images/notes/20250505/p-34.png" alt="p-34"></p><p><img src="/images/notes/20250505/p-35.png" alt="p-35"></p><h3 id="2-4-优先级和组织结构"><a href="#2-4-优先级和组织结构" class="headerlink" title="2.4 优先级和组织结构"></a>2.4 优先级和组织结构</h3><p>人工智能发展进入务实阶段。构建成功的 AI 功能并不一定需要专门的部门。专注于高影响力的用例，同时保持团队结构精简。机会在于发现人工智能在哪里增加了真正的价值，并有效地利用可用资源。</p><p>许多人将有意义的技术预算（超过 15%）用于人工智能，但不打算发展专门的人工智能团队。他们正在寻找方法，通过赋予现有团队更好的工具和明确的目标来构建复杂的人工智能功能。</p><ul><li>团队选择精益集成而不是专业部门</li><li>现有产品团队推动人工智能创新</li><li>正在平衡构建新功能和扩展现有功能之间的优先级</li></ul><p><img src="/images/notes/20250505/p-36.png" alt="p-36"></p><p><img src="/images/notes/20250505/p-37.png" alt="p-37"></p><p><img src="/images/notes/20250505/p-38.png" alt="p-38"></p><h3 id="2-5-信仰和观点"><a href="#2-5-信仰和观点" class="headerlink" title="2.5 信仰和观点"></a>2.5 信仰和观点</h3><p>人工智能市场在炒作和实际影响之间找到了最佳位置。团队认为当前的人工智能工具被夸大了，但他们预计人工智能将在 12 个月内对他们的行业产生重大影响。他们对未来感到兴奋，但立足于现在。</p><ul><li>团队相信人工智能的未来，同时对当前工具保持现实</li><li>开源和微调被证明是有用的，但还没有改变游戏规则</li><li>每个人都在为明年的重大进步做准备，用现在有效的东西建造，但为即将到来的东西设计</li></ul><p>巨大的变化就在前方，即使我们还没有到那一步。要意识到当前的限制和挑战，同时对人工智能的变革潜力保持乐观。</p><p><img src="/images/notes/20250505/p-39.png" alt="p-39"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://2025.stateofai.dev/" target="_blank" rel="noopener">https://2025.stateofai.dev/</a></li><li><a href="https://vercel.com/state-of-ai" target="_blank" rel="noopener">https://vercel.com/state-of-ai</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】State-Of-Ai-报告信息&quot;&gt;&lt;a href=&quot;#【笔记】State-Of-Ai-报告信息&quot; class=&quot;headerlink&quot; title=&quot;【笔记】State-Of-Ai 报告信息&quot;&gt;&lt;/a&gt;【笔记】State-Of-Ai 报告信息&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】web 黑夜模式通用适配方案</title>
    <link href="http://blog.michealwayne.cn/2025/04/26/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91web%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F%E9%80%82%E9%85%8D/"/>
    <id>http://blog.michealwayne.cn/2025/04/26/notes/【笔记】web黑夜模式适配/</id>
    <published>2025-04-26T06:14:38.000Z</published>
    <updated>2025-05-27T15:24:17.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】web-黑夜模式通用适配方案"><a href="#【笔记】web-黑夜模式通用适配方案" class="headerlink" title="【笔记】web 黑夜模式通用适配方案"></a>【笔记】web 黑夜模式通用适配方案</h1><h2 id="一、判断黑夜模式的方式"><a href="#一、判断黑夜模式的方式" class="headerlink" title="一、判断黑夜模式的方式"></a>一、判断黑夜模式的方式</h2><h3 id="1-1-CSS-媒体查询判断黑夜模式的属性——prefers-color-scheme"><a href="#1-1-CSS-媒体查询判断黑夜模式的属性——prefers-color-scheme" class="headerlink" title="1.1 CSS 媒体查询判断黑夜模式的属性——prefers-color-scheme"></a>1.1 CSS 媒体查询判断黑夜模式的属性——<code>prefers-color-scheme</code></h3><blockquote><p>prefers-color-scheme CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。 ——MDN</p></blockquote><p>值：</p><ul><li><code>no-preference</code>：表示系统未得知用户在这方面的选项。在布尔值上下文中，其执行结果为 false。</li><li><code>light</code>：表示用户已告知系统他们选择使用浅色主题的界面。</li><li><code>dark</code>：表示用户已告知系统他们选择使用暗色主题的界面。</li></ul><p>如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Light mode */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> light) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>,</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dark mode */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>,</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-1-兼容情况"><a href="#1-1-1-兼容情况" class="headerlink" title="1.1.1 兼容情况"></a>1.1.1 兼容情况</h4><p>除了 IE 外，其他主流浏览器基本都支持<code>prefers-color-scheme</code>。</p><p><img src="/images/notes/20250426/p-1.png" alt="p-1.png"></p><h3 id="1-2-JavaScript-判断黑夜模式的属性——matchMedia"><a href="#1-2-JavaScript-判断黑夜模式的属性——matchMedia" class="headerlink" title="1.2 JavaScript 判断黑夜模式的属性——matchMedia"></a>1.2 JavaScript 判断黑夜模式的属性——<code>matchMedia</code></h3><blockquote><p>Window 的 matchMedia() 方法返回一个新的 MediaQueryList 对象，表示指定的媒体查询字符串解析后的结果。返回的 MediaQueryList 可被用于判定 Document 是否匹配媒体查询，或者监控一个 document 来判定它匹配了或者停止匹配了此媒体查询。 ——MDN</p></blockquote><p>window.matchMedia(xxx) 返回一个 listenable-like 对象 <code>MediaQueryList</code>, 它继承自 <code>EventTarget</code>, 这意味着可以通过直接它获得最新的 <code>MediaQuery</code> 检测情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.matchMedia &amp;&amp; <span class="built_in">window</span>.matchMedia(<span class="string">'(prefers-color-scheme: dark)'</span>).matches) &#123;</span><br><span class="line">  <span class="comment">// Dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Light mode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-1-监听主题变化"><a href="#1-2-1-监听主题变化" class="headerlink" title="1.2.1 监听主题变化"></a>1.2.1 监听主题变化</h4><p>与 CSS 媒体查询不同，<code>matchMedia</code> 我们需要监听主题的变化作出对应处理，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> darkModeQuery = <span class="built_in">window</span>.matchMedia(<span class="string">'(prefers-color-scheme: dark)'</span>);</span><br><span class="line"></span><br><span class="line">darkModeQuery.addListener(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="comment">// Dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-2-2-兼容情况"><a href="#1-2-2-兼容情况" class="headerlink" title="1.2.2 兼容情况"></a>1.2.2 兼容情况</h4><p>主流浏览器基本都支持<code>matchMedia</code>。</p><p><img src="/images/notes/20250426/p-2.png" alt="p-2.png"></p><h2 id="二、黑夜模式样式适配处理方案"><a href="#二、黑夜模式样式适配处理方案" class="headerlink" title="二、黑夜模式样式适配处理方案"></a>二、黑夜模式样式适配处理方案</h2><h3 id="2-1-CSS-纯媒体查询实现"><a href="#2-1-CSS-纯媒体查询实现" class="headerlink" title="2.1 CSS 纯媒体查询实现"></a>2.1 CSS 纯媒体查询实现</h3><p>适用场景：需要快速实现、无需用户自定义主题的项目。如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#1a1a1a</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 其他元素深色样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p>优点：</p><ul><li>零 js 依赖，纯 css 实现</li><li>系统级实时响应（跟随系统设置即时切换）</li><li>维护成本最低</li></ul><p>缺点：</p><ul><li>不能保存用户偏好（比如用户想覆盖系统设置）</li></ul><h3 id="2-2-CSS-变量-媒体查询"><a href="#2-2-CSS-变量-媒体查询" class="headerlink" title="2.2 CSS 变量 + 媒体查询"></a>2.2 CSS 变量 + 媒体查询</h3><p>适用场景：中大型项目、需要多主题扩展、已使用 CSS 变量的代码库。</p><p>如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--bg-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#333333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">  <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--bg-color</span>: <span class="number">#1a1a1a</span>;</span><br><span class="line">    <span class="attribute">--text-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--text-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p>优点：</p><ul><li>集中管理颜色变量</li><li>方便扩展多主题</li><li>支持渐进增强</li></ul><p>缺点：</p><ul><li>仍无法保存用户偏好</li><li>需要统一使用 CSS 变量规范</li></ul><h3 id="2-3-js-matchMedia-动态切换-本地存储"><a href="#2-3-js-matchMedia-动态切换-本地存储" class="headerlink" title="2.3 js matchMedia 动态切换 + 本地存储"></a>2.3 js matchMedia 动态切换 + 本地存储</h3><p>适用场景：需要用户自定义主题的 ToC 产品、重视用户体验的 Web 应用。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"themeToggle"</span>&gt;</span>切换主题<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.light-mode</span> &#123;</span><br><span class="line">  <span class="attribute">--bg-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#333333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dark-mode</span> &#123;</span><br><span class="line">  <span class="attribute">--bg-color</span>: <span class="number">#1a1a1a</span>;</span><br><span class="line">  <span class="attribute">--text-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themeToggle = <span class="built_in">document</span>.querySelector(<span class="string">'#themeToggle'</span>);</span><br><span class="line"><span class="keyword">const</span> prefersDark = <span class="built_in">window</span>.matchMedia(<span class="string">'(prefers-color-scheme: dark)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化主题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initTheme</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedTheme = localStorage.getItem(<span class="string">'theme'</span>) || (prefersDark.matches ? <span class="string">'dark'</span> : <span class="string">'light'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.classList.add(<span class="string">`<span class="subst">$&#123;savedTheme&#125;</span>-mode`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换主题</span></span><br><span class="line">themeToggle.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.classList.toggle(<span class="string">'dark-mode'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.classList.toggle(<span class="string">'light-mode'</span>);</span><br><span class="line">  <span class="keyword">const</span> currentTheme = <span class="built_in">document</span>.body.classList.contains(<span class="string">'dark-mode'</span>) ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</span><br><span class="line">  localStorage.setItem(<span class="string">'theme'</span>, currentTheme);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听系统变化</span></span><br><span class="line">prefersDark.addListener(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!localStorage.getItem(<span class="string">'theme'</span>)) &#123;</span><br><span class="line">    <span class="comment">// 只在用户未手动选择时响应系统</span></span><br><span class="line">    <span class="built_in">document</span>.body.classList.toggle(<span class="string">'dark-mode'</span>, e.matches);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p>优点：</p><ul><li>支持用户偏好保存</li><li>同时响应系统和手动切换</li><li>最佳用户体验</li></ul><p>缺点：</p><ul><li>需要维护两套样式，依赖 js 处理。实现复杂度最高</li></ul><h3 id="2-4-js-matchMedia-动态切换-CSS-in-JS-运行时方案"><a href="#2-4-js-matchMedia-动态切换-CSS-in-JS-运行时方案" class="headerlink" title="2.4 js matchMedia 动态切换 + CSS-in-JS 运行时方案"></a>2.4 js matchMedia 动态切换 + CSS-in-JS 运行时方案</h3><p>适用场景：适合 React 等框架，已使用 CSS-in-JS 方案</p><p>如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用styled-components示例</span></span><br><span class="line"><span class="keyword">import</span> &#123; createGlobalStyle, ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lightTheme = &#123; <span class="attr">bg</span>: <span class="string">'#fff'</span>, <span class="attr">text</span>: <span class="string">'#333'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> darkTheme = &#123; <span class="attr">bg</span>: <span class="string">'#1a1a1a'</span>, <span class="attr">text</span>: <span class="string">'#e0e0e0'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GlobalStyle = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">  body &#123;</span></span><br><span class="line"><span class="string">    background: <span class="subst">$&#123;props =&gt; props.theme.bg&#125;</span>;</span></span><br><span class="line"><span class="string">    color: <span class="subst">$&#123;props =&gt; props.theme.text&#125;</span>;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isDark, setIsDark] = useState(<span class="built_in">window</span>.matchMedia(<span class="string">'(prefers-color-scheme: dark)'</span>).matches);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">'(prefers-color-scheme: dark)'</span>);</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> setIsDark(e.matches);</span><br><span class="line">    mediaQuery.addListener(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> mediaQuery.removeListener(handler);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeProvider theme=&#123;isDark ? darkTheme : lightTheme&#125;&gt;</span><br><span class="line">      &lt;GlobalStyle /&gt;</span><br><span class="line">      &#123;<span class="comment">/* 页面内容 */</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeProvider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="优缺点分析-3"><a href="#优缺点分析-3" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p>优点：</p><ul><li>完美配合组件化开发</li><li>主题状态可全局管理</li><li>支持动态主题切换</li></ul><p>缺点：</p><ul><li>强依赖特定框架</li><li>需要 CSS-in-JS 体系支持</li></ul><h3 id="2-5-CSS-媒体查询-filter-滤镜处理"><a href="#2-5-CSS-媒体查询-filter-滤镜处理" class="headerlink" title="2.5 *CSS 媒体查询 + filter 滤镜处理"></a>2.5 *CSS 媒体查询 + filter 滤镜处理</h3><p>适合场景：要求最快上线、或最小改动。本质其实也归属于方案 1（2.1）</p><p>如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 整个页面增加滤镜 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">invert</span>(<span class="number">1</span>) <span class="built_in">hue-rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 图片、视频等元素不需要处理 */</span></span><br><span class="line">  <span class="selector-tag">img</span>,</span><br><span class="line">  <span class="selector-tag">video</span>,</span><br><span class="line">  <span class="selector-class">.logo</span>,</span><br><span class="line">  <span class="selector-class">.icon</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">invert</span>(<span class="number">1</span>) <span class="built_in">hue-rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滤镜设置解释"><a href="#滤镜设置解释" class="headerlink" title="滤镜设置解释"></a>滤镜设置解释</h4><p>整体滤镜处理可以概括为：反色 + 调整色相</p><ul><li><code>invert(1)</code>: <code>invert()</code> 函数用于反转输入图像中的颜色。参数定义了转换的程度。如果参数是 1（或者 100%），则会完全反转颜色，即每个颜色通道的值都会被替换为其补色。例如：黑色变成白色，白色变为黑色等。<ul><li>当使用 <code>invert(1)</code> 时，则表示将图像的颜色彻底反转，即是：黑色变成白色，白色变为黑色。</li></ul></li><li><code>hue-rotate(180deg)</code>: <code>hue-rotate()</code> 函数按照给定的角度旋转色彩轮上的颜色，其实就是冲淡颜色。这里的“角度”是指在标准色轮上转动多少度。色轮是一个圆形图表，显示了不同颜色如何根据它们的色调相互关联。<ul><li>当使用 <code>hue-rotate(180deg)</code> 时，意味着所有颜色都会在其原始位置基础上沿着色轮顺时针方向移动 180 度。比如红色会变成青色、绿色变成洋红色、蓝色变成黄色等，因为这些是在色轮上相对的颜色。</li></ul></li></ul><blockquote><p>更多信息可见<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert" target="_blank" rel="noopener">MDN - invert</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate" target="_blank" rel="noopener">MDN - hue-rotate</a></p></blockquote><h4 id="兼容情况"><a href="#兼容情况" class="headerlink" title="兼容情况"></a>兼容情况</h4><p>除 IE 外，主流浏览器基本能支持。</p><p><img src="/images/notes/20250426/p-3.png" alt="p-3.png"></p><h4 id="优缺点分析-4"><a href="#优缺点分析-4" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p>优点：</p><ul><li>开发和维护成本都是最低</li><li>零 js 依赖，纯 css 实现</li><li>系统级实时响应（跟随系统设置即时切换）</li></ul><p>缺点：</p><ul><li>不能或很难自定义色值</li><li>不能保存用户偏好（比如用户想覆盖系统设置）</li></ul><h2 id="三、黑夜模式色值设计标准"><a href="#三、黑夜模式色值设计标准" class="headerlink" title="三、黑夜模式色值设计标准"></a>三、黑夜模式色值设计标准</h2><p>黑夜模式的色值设计和黑夜模式的工程实现没啥关系，属于用户体验保障。</p><h3 id="3-1-WCAG-标准"><a href="#3-1-WCAG-标准" class="headerlink" title="3.1 WCAG 标准"></a>3.1 WCAG 标准</h3><p>WCAG（Web Content Accessibility Guidelines） 是由 W3C 制定的国际无障碍标准。其中颜色设置也是一项重要标准。</p><blockquote><p>法律意义：WCAG 在美国《ADA 法案》、欧盟《EN 301 549》等法规中被引用</p></blockquote><h4 id="一些具体要求"><a href="#一些具体要求" class="headerlink" title="一些具体要求"></a>一些具体要求</h4><ol><li>核心要求</li></ol><table><thead><tr><th>元素类型</th><th>最小对比度</th><th>例外场景</th></tr></thead><tbody><tr><td>普通文本（&lt;18pt/24px）</td><td>4.5:1</td><td>装饰性/禁用状态文本</td></tr><tr><td>大文本（≥18pt/24px）</td><td>3:1</td><td>粗体大文本（≥14pt/18.5px 粗体）</td></tr><tr><td>图形控件（图标/按钮）</td><td>3:1</td><td>纯装饰性图形</td></tr></tbody></table><ol start="2"><li>计算公式</li></ol><p>使用相对亮度（Luminance）公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contrast Ratio = (L1 + 0.05) / (L2 + 0.05)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>L1 = 较亮颜色的相对亮度（0~1）</li><li>L2 = 较暗颜色的相对亮度（0~1）</li></ul><h4 id="实际开发中的应用"><a href="#实际开发中的应用" class="headerlink" title="实际开发中的应用"></a>实际开发中的应用</h4><ol><li>颜色选择示例</li></ol><table><thead><tr><th>场景</th><th>通过示例</th><th>失败示例</th></tr></thead><tbody><tr><td>白底黑字</td><td>#FFFFFF vs #000000 (21:1)</td><td>#FFFFFF vs #666666 (5.74:1)</td></tr><tr><td>深色模式</td><td>#1A1A1A vs #E0E0E0 (10.3:1)</td><td>#333333 vs #999999 (3.31:1)</td></tr></tbody></table><ol start="2"><li>调试工具</li></ol><p>自动检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Chrome DevTools</span><br><span class="line">Styles面板 → 点击颜色选择器 → 显示对比度比率</span><br><span class="line"></span><br><span class="line"># VS Code插件</span><br><span class="line">&quot;WCAG Color Contrast Checker&quot;</span><br></pre></td></tr></table></figure><p>在线工具：</p><ul><li><a href="https://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM Contrast Checker</a></li><li><a href="https://contrast-ratio.com/" target="_blank" rel="noopener">Contrast Ratio</a></li></ul><ol start="3"><li>设计技巧</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 安全配色方案示例 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--safe-dark-bg</span>: <span class="number">#1a1a1a</span>; <span class="comment">/* 避免纯黑(#000) */</span></span><br><span class="line">  <span class="attribute">--safe-light-text</span>: <span class="number">#e0e0e0</span>; <span class="comment">/* 避免纯白(#fff) */</span></span><br><span class="line">  <span class="attribute">--accent-color</span>: <span class="number">#007bff</span>; <span class="comment">/* 品牌色需单独验证 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用状态处理 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>; <span class="comment">/* 需重新验证对比度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度注意事项"><a href="#深度注意事项" class="headerlink" title="深度注意事项"></a>深度注意事项</h4><ol><li>动态场景：</li></ol><ul><li>悬停/聚焦状态的对比度需保持合规</li><li>渐变/阴影覆盖区域需取最差值验证</li></ul><ol start="2"><li>字体特性：</li></ol><ul><li>300 以下字重需提高对比度要求</li><li>衬线字体可能需要额外对比度补偿</li></ul><ol start="3"><li>环境适配：</li></ol><ul><li>移动设备户外模式需考虑屏幕反光影响</li><li>OLED 屏幕需验证 PWM 调光下的可读性</li></ul><h4 id="法律合规案例"><a href="#法律合规案例" class="headerlink" title="法律合规案例"></a>法律合规案例</h4><ul><li>Target 诉讼案（2006）：因对比度不足赔偿$6 百万</li><li>Domino’s 披萨案（2019）：网站对比度违规败诉</li><li>英国政府：强制要求所有公共网站通过 AA 认证</li></ul><h4 id="进阶建议"><a href="#进阶建议" class="headerlink" title="进阶建议"></a>进阶建议</h4><p>1.AAA 级目标：</p><ul><li>普通文本：7:1</li><li>大文本：4.5:1</li></ul><ol start="2"><li>无障碍测试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用屏幕阅读器验证</span></span><br><span class="line">NVDA (Windows) / VoiceOver (Mac)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动化工具</span></span><br><span class="line">axe DevTools / Lighthouse</span><br></pre></td></tr></table></figure><p>设计系统集成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storybook等工具集成对比度检测</span></span><br><span class="line">addon-a11y: &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    contrast: &#123;</span><br><span class="line">      thresholds: &#123;</span><br><span class="line">        AA: <span class="number">4.5</span>,</span><br><span class="line">        AAA: <span class="number">7</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过严格遵循这些标准，可确保您的深色模式既美观又合规。建议将对比度检测纳入 CI/CD 流程，实现自动化保障。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme" target="_blank" rel="noopener">MDN - prefers-color-scheme</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia" target="_blank" rel="noopener">MDN - matchMedia</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">MDN - filter</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert" target="_blank" rel="noopener">MDN - invert</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate" target="_blank" rel="noopener">MDN - hue-rotate</a></li><li><a href="https://www.w3.org/Translations/WCAG21-zh/#abstract" target="_blank" rel="noopener">WCAG</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】web-黑夜模式通用适配方案&quot;&gt;&lt;a href=&quot;#【笔记】web-黑夜模式通用适配方案&quot; class=&quot;headerlink&quot; title=&quot;【笔记】web 黑夜模式通用适配方案&quot;&gt;&lt;/a&gt;【笔记】web 黑夜模式通用适配方案&lt;/h1&gt;&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="css" scheme="http://blog.michealwayne.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】19届阿里D2终端技术大会纪要</title>
    <link href="http://blog.michealwayne.cn/2025/03/15/ai/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%9119%E5%B1%8A%E9%98%BF%E9%87%8CD2%E7%BB%88%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A%E7%BA%AA%E8%A6%81/"/>
    <id>http://blog.michealwayne.cn/2025/03/15/ai/【笔记】19届阿里D2终端技术大会纪要/</id>
    <published>2025-03-15T05:33:01.000Z</published>
    <updated>2025-03-18T14:24:05.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D2大会纪要"><a href="#D2大会纪要" class="headerlink" title="D2大会纪要"></a>D2大会纪要</h1><blockquote><p>2025.03.08 19届阿里D2终端技术大会 ( Mobile Developer &amp; Frontend Developer Technology Conference, 简称 D2 ），由阿里巴巴终端技术委员会创办，面向全球终端开发领域（前端 &amp; 客户端）技术人。这次整体感受还不错，有些收获。</p></blockquote><p>整体会议资料地址：<a href="https://github.com/d2forum/19th" target="_blank" rel="noopener">https://github.com/d2forum/19th</a>，个人推荐阅读：《⽣成式 UI: AI时代体验技术新范式》、《AI 时代生存指南：前端的技术壁垒与竞争力重塑》、《深度融合AI的低代码平台》</p><p>个人归纳的会议信息：</p><h2 id="1-高维度上，在AI交互和终端载体的演进趋势下，整体互联网载体和交互形态都发生了转变"><a href="#1-高维度上，在AI交互和终端载体的演进趋势下，整体互联网载体和交互形态都发生了转变" class="headerlink" title="1.高维度上，在AI交互和终端载体的演进趋势下，整体互联网载体和交互形态都发生了转变"></a>1.高维度上，在AI交互和终端载体的演进趋势下，整体互联网载体和交互形态都发生了转变</h2><p><img src="/images/19thD2/p-1.png" alt="p-1.png"></p><p>从</p><p><img src="/images/19thD2/p-4.png" alt="p-4.png"></p><p><a href="https://www.notion.so" target="_blank" rel="noopener">https://www.notion.so</a></p><p>到</p><p><img src="/images/19thD2/p-5.png" alt="p-5.png"></p><p><img src="/images/19thD2/p-6.png" alt="p-6.png"></p><p>在产业端，领域大模型会长期存在，并会被持续用于改善生产关系</p><p>“可塑性软件 Malleable Software”</p><ul><li>Local LLM Agent、”Agentic”</li><li>跟随⽣产⼒进步</li></ul><p>还有<strong>端智能</strong>等等</p><p><img src="/images/19thD2/p-2.png" alt="p-2.png"></p><h2 id="2-软件生产模式上，⽣产⼒的提升带来⻆⾊的合并"><a href="#2-软件生产模式上，⽣产⼒的提升带来⻆⾊的合并" class="headerlink" title="2.软件生产模式上，⽣产⼒的提升带来⻆⾊的合并"></a>2.软件生产模式上，⽣产⼒的提升带来⻆⾊的合并</h2><ul><li><p>从真实需求出发， 用技术创造价值</p><p>  <img src="/images/19thD2/p-7.png" alt="p-7.png"></p></li></ul><ul><li>产研模式的转变（感觉应该是漏斗状）</li></ul><p><img src="/images/19thD2/p-12.png" alt="p-12.png"></p><p><img src="/images/19thD2/p-13.png" alt="p-13.png"></p><p><img src="/images/19thD2/p-14.png" alt="p-14.png"></p><p>但是专业开发还是需要技术人员辅助，注意此时开发的角色侧重点</p><p><img src="/images/19thD2/p-15.png" alt="p-15.png"></p><h2 id="3-面向业务，大厂的做法集中在解决具体业务问题（“点”-“面”）"><a href="#3-面向业务，大厂的做法集中在解决具体业务问题（“点”-“面”）" class="headerlink" title="3.面向业务，大厂的做法集中在解决具体业务问题（“点”/“面”）"></a>3.面向业务，大厂的做法集中在解决具体业务问题（“点”/“面”）</h2><ul><li><p>实现“基础功能马上跑，多语言版不能少，PC移动全都要，用户体验还必须好”</p><p>  <img src="/images/19thD2/p-9.png" alt="p-9.png"></p><p>  <img src="/images/19thD2/p-32.png" alt="p-32.png"></p></li></ul><h2 id="4-实际业务场景和工程对模型要求从“通用”到“具体”"><a href="#4-实际业务场景和工程对模型要求从“通用”到“具体”" class="headerlink" title="4.实际业务场景和工程对模型要求从“通用”到“具体”"></a>4.实际业务场景和工程对模型要求从“通用”到“具体”</h2><p><img src="/images/19thD2/p-8.png" alt="p-8.png"></p><p>ai编程和低码</p><p><img src="/images/19thD2/p-16.png" alt="p-16.png"></p><h2 id="5-前端生产链趋势“归一化“，卷通用性、卷性能"><a href="#5-前端生产链趋势“归一化“，卷通用性、卷性能" class="headerlink" title="5.*前端生产链趋势“归一化“，卷通用性、卷性能"></a>5.*前端生产链趋势“归一化“，卷通用性、卷性能</h2><p><img src="/images/19thD2/p-29.png" alt="p-29.png"></p><h2 id="6-跨端近一年的主题基本都是适配harmonyNext，开发范式更像web开发了、通过自绘渲染、C-改造和线程管理等优化，性能更强了"><a href="#6-跨端近一年的主题基本都是适配harmonyNext，开发范式更像web开发了、通过自绘渲染、C-改造和线程管理等优化，性能更强了" class="headerlink" title="6.*跨端近一年的主题基本都是适配harmonyNext，开发范式更像web开发了、通过自绘渲染、C++改造和线程管理等优化，性能更强了"></a>6.*跨端近一年的主题基本都是适配harmonyNext，开发范式更像web开发了、通过自绘渲染、C++改造和线程管理等优化，性能更强了</h2><p><img src="/images/19thD2/p-33.png" alt="p-33.png"></p><h2 id="7-对于程序员个人而言，普遍观点是AI-是双刃剑-——-大幅提升效能但稀释程序员稀缺性"><a href="#7-对于程序员个人而言，普遍观点是AI-是双刃剑-——-大幅提升效能但稀释程序员稀缺性" class="headerlink" title="7.对于程序员个人而言，普遍观点是AI 是双刃剑 —— 大幅提升效能但稀释程序员稀缺性"></a>7.对于程序员个人而言，普遍观点是AI 是双刃剑 —— 大幅提升效能但稀释程序员稀缺性</h2><p>程序员的核心价值是解决业务问题，程序/ai都是工具和手段，不要用程序员标签约束自己，主动寻找有价值的需求。</p><h3 id="1-从交付前端到交付价值"><a href="#1-从交付前端到交付价值" class="headerlink" title="1.从交付前端到交付价值"></a>1.从交付前端到交付价值</h3><ul><li><strong>”做⼀个好的 AI“</strong>，比如能审查、维护 AI 生成的代码 、能解决 AI 代码的 Bug</li><li><strong>从先做点什么开始，顺应潮流</strong>。善用 AI 工具、智能体编排将会是必备能力，做好与 AI 协作的意识准备</li></ul><h3 id="2-复利、长期坚持："><a href="#2-复利、长期坚持：" class="headerlink" title="2.复利、长期坚持："></a>2.复利、长期坚持：</h3><ul><li>坚持做长期有利的事，比如写作、分享、 学习。随着时间推移能越积越多，比如技能、写作能力、社交媒体上的影响力、产品的用户。</li></ul><p><img src="/images/19thD2/image.png" alt="image.png"></p><hr><h2 id="在-AI-时代构建前端技术壁垒"><a href="#在-AI-时代构建前端技术壁垒" class="headerlink" title="在 AI 时代构建前端技术壁垒"></a>在 AI 时代构建前端技术壁垒</h2><ol><li><p>⾯向 AI 做技术选型</p><ol><li>编码：面向开发者友好 -&gt; 面向ai友好（更易被ai理解/生成/修改）</li><li>技术栈选型：主流框架有更多的用户基础、训练语料、更好的ai生成/提示效果，使⽤ AI 友好的技术栈。TailwindCSS 3，react+tailwind+ts，马太效应</li><li><p>代码组织模式：传统的代码组织模式受到挑战，打包 -&gt; ⽣成，拆分 -&gt; 单⽂件，可维护代码 -&gt; 可抛弃代码，适应新的项⽬组织⽅式。反模式</p><p> <img src="/images/19thD2/p-22.png" alt="p-22.png"></p><p> <img src="/images/19thD2/p-24.png" alt="p-24.png"></p><p> <img src="/images/19thD2/p-31.png" alt="p-31.png"></p></li></ol></li></ol><ol start="2"><li><p>掌握 AI 数据处理与渲染⽅案</p><ol><li>lodash -&gt; ai_web_runtime，<strong>AI 模型也是是前端技术栈的⼀部分</strong></li><li><p>包含网站、图等多媒体信息由ai接管渲染，关注端侧模型的发展和落地</p><p><img src="/images/19thD2/p-3.png" alt="p-3.png"></p></li></ol></li></ol><h2 id="其他技术栈-架构"><a href="#其他技术栈-架构" class="headerlink" title="其他技术栈/架构"></a>其他技术栈/架构</h2><h3 id="低码-DSL解决方案"><a href="#低码-DSL解决方案" class="headerlink" title="低码/DSL解决方案"></a>低码/DSL解决方案</h3><p><img src="/images/19thD2/p-17.png" alt="p-17.png"></p><p><img src="/images/19thD2/p-11.png" alt="p-11.png"></p><p><img src="/images/19thD2/p-18.png" alt="p-18.png"></p><p><img src="/images/19thD2/p-19.png" alt="p-19.png"></p><p><img src="/images/19thD2/p-20.png" alt="p-20.png"></p><p><img src="/images/19thD2/p-23.png" alt="p-23.png"></p><p><img src="/images/19thD2/p-25.png" alt="p-25.png"></p><h3 id="编码开发"><a href="#编码开发" class="headerlink" title="编码开发"></a>编码开发</h3><p><img src="/images/19thD2/p-21.png" alt="p-21.png"></p><p><img src="/images/19thD2/p-27.png" alt="p-27.png"></p><h3 id="质检"><a href="#质检" class="headerlink" title="质检"></a>质检</h3><p><img src="/images/19thD2/p-26.png" alt="p-26.png"></p><p><img src="/images/19thD2/p-28.png" alt="p-28.png"></p><h3 id="跨端"><a href="#跨端" class="headerlink" title="跨端"></a>跨端</h3><p><img src="/images/19thD2/p-30.png" alt="p-30png.png"></p><hr><p>相关链接：</p><ul><li><a href="https://github.com/d2forum/19th" target="_blank" rel="noopener">https://github.com/d2forum/19th</a></li><li><a href="https://www.scaler.com/topics/deep-learning/onnx-model/" target="_blank" rel="noopener">https://www.scaler.com/topics/deep-learning/onnx-model/</a></li><li><a href="https://github.com/snakers4/silero-vad" target="_blank" rel="noopener">https://github.com/snakers4/silero-vad</a></li><li><a href="https://github.com/vthinkxie/ai-recorder" target="_blank" rel="noopener">https://github.com/vthinkxie/ai-recorder</a></li><li><a href="https://websim.ai/" target="_blank" rel="noopener">https://websim.ai/</a></li><li><a href="https://www.geoffreylitt.com/2023/03/25/llm-end-user-programming.html" target="_blank" rel="noopener">https://www.geoffreylitt.com/2023/03/25/llm-end-user-programming.html</a></li><li><a href="https://devin.ai/" target="_blank" rel="noopener">https://devin.ai/</a></li><li><a href="https://manus.im/" target="_blank" rel="noopener">https://manus.im/</a></li><li><a href="https://x.com/lepadphone/status/1896212860013031615" target="_blank" rel="noopener">https://x.com/lepadphone/status/1896212860013031615</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;D2大会纪要&quot;&gt;&lt;a href=&quot;#D2大会纪要&quot; class=&quot;headerlink&quot; title=&quot;D2大会纪要&quot;&gt;&lt;/a&gt;D2大会纪要&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;2025.03.08 19届阿里D2终端技术大会 ( Mobile Develop
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Lovable提示词指南</title>
    <link href="http://blog.michealwayne.cn/2025/02/22/ai/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Lovable%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.michealwayne.cn/2025/02/22/ai/【笔记】Lovable提示词指南/</id>
    <published>2025-02-22T02:53:45.000Z</published>
    <updated>2025-03-25T14:41:02.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lovable提示词指南"><a href="#Lovable提示词指南" class="headerlink" title="Lovable提示词指南"></a>Lovable提示词指南</h1><blockquote><p>Lovable是一款目前海外流行的ai编码平台，和v0/bolt一样面向”Citizen Dev”，主要能力是通过图片/设计稿/自然语言生成网页，地址：<a href="https://lovable.dev/" target="_blank" rel="noopener">https://lovable.dev/</a></p></blockquote><p>本文信息来自Lovable团队今年一月的一篇博文：<a href="https://lovable.dev/blog/2025-01-16-lovable-prompting-handbook" target="_blank" rel="noopener">《The Lovable Prompting Bible》</a></p><p>大多数人都有一个错误的观点：认为提示词（prompt）只是在AI中输入请求并希望得到最好的结果。</p><p>获得平庸的响应和让AI为您构建整个工作流程之间的区别归结为您如何提示。无论您是开发人员还是非技术用户，掌握提示工程都可以帮助您：</p><ul><li>自动化重复性任务</li><li>使用AI生成的解决方案更快地调试</li><li>轻松构建和优化工作流程</li></ul><p>最好的部分是什么？你不需要成为专家。有了正确的提示技术，你可以在 Lovable, make.com和n8n中释放人工智能的全部潜力——而不会在反复试验上浪费时间。</p><p>中心观点：</p><ul><li>有效的提示很重要：构建提示以节省故障排除时间。</li><li>元提示（Meta prompting）：使用AI本身来改进提示以提高准确性。</li><li>反向元提示（Reverse meta prompting）：保存调试会话以优化未来的请求。</li><li>自动化工具：使用make.com和n8n使用API扩展Lovable的功能。</li><li>聊天模式与默认模式：何时使用每个模式进行调试和迭代。</li><li>处理webhooks：通过强大的集成自动化Lovable应用程序。</li></ul><h2 id="为什么提示对人工智能开发至关重要"><a href="#为什么提示对人工智能开发至关重要" class="headerlink" title="为什么提示对人工智能开发至关重要"></a>为什么提示对人工智能开发至关重要</h2><p>与传统编码不同，人工智能应用程序依赖于结构化通信。为人工智能提供清晰的上下文和约束可确保高质量的输出。在Lovable的Lovable专家会议上，来自Prompt Advisors的Mark演示了开发人员和非技术用户如何增强他们的人工智能提示技术，以更快地构建、更智能地调试和自动化复杂的工作流程。（对应Youtube视频地址：<a href="https://youtu.be/IqWfKj4mUIo" target="_blank" rel="noopener">https://youtu.be/IqWfKj4mUIo</a>）</p><h2 id="了解人工智能的“心态”"><a href="#了解人工智能的“心态”" class="headerlink" title="了解人工智能的“心态”"></a>了解人工智能的“心态”</h2><p>人工智能模型，包括那些支持Lovable的模型，不能以人类的方式“理解”——它们根据模式预测反应。为了有效地指导他们：</p><ul><li>明确(Be explicit)：不要“构建登录页面”，而是指定“使用React创建登录页面，并进行电子邮件/密码身份验证和JWT处理。”</li><li>设置约束(Set constraints)：如果您需要特定的技术堆栈（例如，用于身份验证的Supabase），请清楚地说明它。</li><li>使用格式化技巧(Use formatting tricks)：AI优先考虑提示的开头和结尾-将重要细节放在前面。</li></ul><h2 id="掌握提示：四个层次"><a href="#掌握提示：四个层次" class="headerlink" title="掌握提示：四个层次"></a>掌握提示：四个层次</h2><p><img src="/images/ai/lovable/p-1.png" alt="p-1.png"></p><h3 id="1-“辅助轮”提示"><a href="#1-“辅助轮”提示" class="headerlink" title="1.“辅助轮”提示"></a>1.“辅助轮”提示</h3><p>一种用于清晰AI指令的结构化标记方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Context</span><br><span class="line">## Task</span><br><span class="line">### Guidelines</span><br><span class="line">#### Constraints</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are a world-class prompt engineer. Write me a prompt that will generate a full-stack app taking an input of name, number, and company, and generate a company report.</span><br></pre></td></tr></table></figure></p><h3 id="2-没有“辅助轮”"><a href="#2-没有“辅助轮”" class="headerlink" title="2.没有“辅助轮”"></a>2.没有“辅助轮”</h3><p>更多对话提示，同时保持清晰。</p><h3 id="3-元-Meta-提示"><a href="#3-元-Meta-提示" class="headerlink" title="3.元(Meta)提示"></a>3.元(Meta)提示</h3><p>利用AI来改进您的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rewrite this prompt to be more concise and detailed: &apos;Create a secure login page in React using Supabase, ensuring role-based authentication.&apos;</span><br></pre></td></tr></table></figure><h3 id="4-反向元提示"><a href="#4-反向元提示" class="headerlink" title="4.反向元提示"></a>4.反向元提示</h3><p>调试时，让AI记录流程以供将来使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summarize the errors we encountered while setting up JWT authentication and how they were resolved. Create a detailed prompt I can use next time.</span><br></pre></td></tr></table></figure><h2 id="提示库"><a href="#提示库" class="headerlink" title="提示库"></a>提示库</h2><p>你的提示质量会显著影响AI的输出。这就是有效提示的本质：你的提示越精细，你收到的输出质量就越高。一个全面且组织良好的提示可以通过减少错误来节省你的学分和时间。因此，这些步骤绝对值得考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Provide as much details as you can in the input field.</span><br><span class="line">Use the &quot;Select&quot; feature to precise edit your component. </span><br><span class="line">Enhance your prompt with the experimental &quot;Chat mode&quot;.</span><br></pre></td></tr></table></figure><h3 id="开始一个新项目"><a href="#开始一个新项目" class="headerlink" title="开始一个新项目"></a>开始一个新项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start with &quot;I need a [type] application with:&quot;</span><br><span class="line">Elaborate on tech stack - including Frontend, styling, Authorization and Database. </span><br><span class="line">Elaborate on core features including main and secondary features. </span><br><span class="line">Then direct the AI to start somewhere like: &quot;Start with the main page containing: [Detailed page requirements]&quot;.</span><br></pre></td></tr></table></figure><p>但是，我们始终建议用户从一个空白项目开始，然后逐步构建它。这种方法允许AI在深入研究细节之前有效地掌握基本概念。</p><h2 id="差异和选择"><a href="#差异和选择" class="headerlink" title="差异和选择"></a>差异和选择</h2><p>每当您请求Lovable在任何文件中实现特定更改时，它都会重写整个文件或修改现有内容。为确保AI仅更新相关文件，请提供明确的说明。这种方法鼓励AI仅编辑必要的部分，从而对仅几行代码进行最小的更改。通过这样做，您可以减少加载时间并防止错误循环。</p><p>我之前在调整现有功能时应用的有效提示是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Implement modifications to the feature while ensuring core functionality, other features, and processes remain unaffected. Evaluate its behavior and dependencies to identify potential risks, and discuss any concerns before moving forward. Conduct thorough testing to verify there are no regressions or unintended consequences, and highlight any out-of-scope changes for review. Exercise caution—take a moment to pause if uncertain.</span><br></pre></td></tr></table></figure></p><h2 id="锁定文件"><a href="#锁定文件" class="headerlink" title="锁定文件"></a>锁定文件</h2><p>Lovable目前缺乏内置的文件锁定系统。但是，您可以通过对提示进行轻微修改来引导人工智能。只需在每个提示中包含以下说明：“请不要更改第X页或第Y页，并将更改的焦点仅集中在第Z页上。”</p><p>如果您正在更新现有功能而无意修改某些合理的内容，您也可以尝试此提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This update is quite delicate and requires utmost precision. Carefully examine all dependencies and potential impacts before implementing any changes, and test systematically to guarantee nothing is disrupted. Steer clear of shortcuts or assumptions—take a moment to seek clarification if you&apos;re unsure. Precision is crucial.</span><br></pre></td></tr></table></figure><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>在Lovable上设计一些东西是有效的，因为Lovable已经很有品味了；）尽管如此，以下提示可以帮助您改进这些设计实现：</p><h3 id="1-UI更改："><a href="#1-UI更改：" class="headerlink" title="1.UI更改："></a>1.UI更改：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make solely visual enhancements—ensure functionality and logic remain unaffected. Gain a comprehensive understanding of how the existing UI interacts with the app, ensuring that logic, state management, and APIs stay intact. Conduct extensive testing to verify that the app operates precisely as it did before. Cease all actions if there is any uncertainty regarding potential unintended consequences.</span><br></pre></td></tr></table></figure><h3 id="2-针对移动端进行优化："><a href="#2-针对移动端进行优化：" class="headerlink" title="2.针对移动端进行优化："></a>2.针对移动端进行优化：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enhance the app&apos;s mobile experience while preserving its existing design and functionality. Assess the layout and responsiveness to pinpoint essential modifications for smaller screens and touch inputs. Develop a comprehensive plan before making any code changes, and conduct thorough testing across various devices to guarantee the app operates as intended. If uncertain, take a moment to consider and suggest potential solutions.</span><br></pre></td></tr></table></figure><h3 id="3-响应能力和断点提示："><a href="#3-响应能力和断点提示：" class="headerlink" title="3.响应能力和断点提示："></a>3.响应能力和断点提示：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make certain that all designs are completely responsive at every breakpoint, adopting a mobile-first strategy. Apply contemporary UI/UX best practices to define how components should adjust for varying screen sizes, utilizing ShadCN and Tailwind’s standard breakpoints. Steer clear of custom breakpoints unless specifically requested.</span><br></pre></td></tr></table></figure><h3 id="4-规划："><a href="#4-规划：" class="headerlink" title="4.规划："></a>4.规划：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Before editing any code, create a phased plan for implementing responsiveness. Start with the largest layout components and progressively refine down to smaller elements and individual components. Ensure the plan includes clear steps for testing responsiveness across all breakpoints to maintain consistency and a seamless user experience. Share the plan for review before proceeding.</span><br></pre></td></tr></table></figure><p>在进行任何代码编辑之前，制定实施响应性的结构化计划。从最大的布局组件开始，逐渐深入到较小的元素和特定组件。确保计划概述了在所有断点测试响应性的明确步骤，以保证一致性和流畅的用户体验。在继续前进之前提出反馈计划。</p><h2 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h2><p>提供关于您的项目的详细上下文至关重要，尤其是在项目的早期。项目的目的是什么？用户流程是什么样的？你在使用什么技术堆栈？工作范围是什么？在Lovable，我们称之为“知识库”，它可以很容易地在您的项目设置中找到。</p><p><img src="/images/ai/lovable/p-2.png" alt="p-2.png"></p><p>为AI创建一个可靠的框架可确保它有效运行，并在您提供的每一个提示中遵守您概述的计划。在您的项目中加入这些元素：</p><h3 id="1-项目需求文档（PRD）："><a href="#1-项目需求文档（PRD）：" class="headerlink" title="1.项目需求文档（PRD）："></a>1.项目需求文档（PRD）：</h3><p>本节对于任何AI编码项目都至关重要。它概述了一个全面的摘要，涵盖了基本元素，如简介、应用程序流程、核心功能、技术堆栈以及范围内和范围外项目之间的区别。本质上，它是您的项目路线图，您可以将其呈现给AI编码模型。</p><h3 id="2-应用程序或用户流程："><a href="#2-应用程序或用户流程：" class="headerlink" title="2.应用程序或用户流程："></a>2.应用程序或用户流程：</h3><p>这种清晰度将有助于AI模型理解页面之间的联系并有效地处理所有功能和限制。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Users begin their experience on the landing page, where they can click the sign-up button to register with Google, subsequently accessing the dashboard. The dashboard comprises X sections.</span><br></pre></td></tr></table></figure><h3 id="3-技术栈："><a href="#3-技术栈：" class="headerlink" title="3.技术栈："></a>3.技术栈：</h3><p>此部分必须包含有关项目的所有技术细节，例如前端技术堆栈、后端技术堆栈、API集成、部署说明以及您计划使用的任何其他开源库。此信息将有助于AI模型了解要安装哪些包和依赖项。</p><h3 id="4-前端指南："><a href="#4-前端指南：" class="headerlink" title="4.前端指南："></a>4.前端指南：</h3><p>本节应详细概述项目的视觉外观：设计原则、样式指南、页面布局、导航结构、调色板和排版。这是项目的美学基础。你的解释越清晰，你的应用程序就越有视觉吸引力。</p><h3 id="5-后端结构："><a href="#5-后端结构：" class="headerlink" title="5.后端结构："></a>5.后端结构：</h3><p>本节将向AI模型解释：后端技术，如Supabase、用户身份验证、数据库架构、存储桶、API端点、安全措施、托管解决方案。这是您项目的主要大脑。您的应用程序将从您的后端获取和显示数据。</p><p>使用初始提示启动项目后，请务必包含此知识库以减少错误并防止AI幻觉。此外，您可以使用以下方式提示AI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Before you write any code, please review the Knowledge Base and share your understanding of my project.</span><br></pre></td></tr></table></figure><p>利用此任务的“聊天模式”来确保在您提供指导时不会对您的项目进行任何修改。</p><h2 id="移动优先"><a href="#移动优先" class="headerlink" title="移动优先"></a>移动优先</h2><p>问题（以及一些隐藏的事实）是，大多数开发人员优先考虑桌面设计仅仅是因为它在大而充满活力的屏幕上看起来更好。然而，现实是，我们应该多年来一直专注于移动优先设计。</p><p>一位Champion在Discord上分享了一个很棒的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Always make things responsive on all breakpoints, with a focus on mobile first.</span><br><span class="line">Use modern UI/UX best practices for determining how breakpoints should change the components.</span><br><span class="line">Use shadcn and tailwind built in breakpoints instead of anything custom, unless the user prompts for custom breakpoints directly.</span><br><span class="line">Optimize the app for mobile without changing its design or functionality. Analyze the layout and responsiveness to identify necessary adjustments for smaller screens and touch interactions. Outline a detailed plan before editing any code, and test thoroughly across devices to ensure the app behaves exactly as it does now. Pause and propose solutions if unsure.</span><br></pre></td></tr></table></figure><p>但是如果你已经深入到你的项目中，你可以通过告诉它更新东西以响应从最大的布局组件到最小的布局组件来解决这个问题。然后进入单个组件。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在使用Lovable时，向AI提供清晰具体的请求至关重要。不要简单地说“将按钮向右移动”，而是尝试说明，“在顶部标题中，将注册按钮移到页面左侧，确保样式保持一致。”你的说明越精确，你遇到的错误就越少，你就会节省学分！</p><p>基本上，我总是建议添加有关您希望Lovable如何处理每项任务的说明。我的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key Guidelines: Approach problems systematically and articulate your reasoning for intricate issues. Decompose extensive tasks into manageable parts and seek clarification when necessary. While providing feedback, elucidate your thought process and point out both challenges and potential improvements.</span><br></pre></td></tr></table></figure><h2 id="步步为营"><a href="#步步为营" class="headerlink" title="步步为营"></a>步步为营</h2><p>避免同时将五个任务分配给Lovable！这样做可能会导致AI制造混乱。这里有一个更好的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start with Front design, page by page, section by section. </span><br><span class="line">The plug backend using Supabase as Lovable integration is natively built! </span><br><span class="line">Then, refine the UX/UI if needed.</span><br></pre></td></tr></table></figure><p>这种循序渐进的过程使AI能够一次专注于一项任务，从而降低错误和幻觉的可能性。</p><h2 id="不要丢失组件"><a href="#不要丢失组件" class="headerlink" title="不要丢失组件"></a>不要丢失组件</h2><p>您也可以在进行重大更改并遵循一系列细微调整后实现这一点。这种做法在保持项目一致性和防止组件突然丢失方面非常宝贵。定期参考我们的filesExplainer.md文档，以确保我们准确记录代码和组件的更改，保持我们的文件结构井井有条和最新。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>重构对于Lovable中的开发生命周期至关重要。AI经常建议最大限度地减少加载时间和错误。您可以使用以下提示：</p><h3 id="Lovable发出请求后重构："><a href="#Lovable发出请求后重构：" class="headerlink" title="Lovable发出请求后重构："></a>Lovable发出请求后重构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refactor this file while ensuring that the user interface and functionality remain unchanged—everything should appear and operate identically. Prioritize enhancing the structure and maintainability of the code. Carefully document the existing functionality, confirm that testing protocols are established, and implement changes gradually to prevent risks or regressions. If you are uncertain at any point, pause the process.</span><br></pre></td></tr></table></figure><h3 id="重构计划："><a href="#重构计划：" class="headerlink" title="重构计划："></a>重构计划：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Develop a comprehensive plan to refactor this file while keeping the user interface and functionality entirely intact. Concentrate on enhancing the code&apos;s structure, readability, and maintainability. Start by meticulously documenting the existing functionality and pinpointing potential areas for enhancement. Implement rigorous testing protocols to ensure consistent behavior throughout the entire process. Move forward incrementally, minimizing risks and avoiding regressions, and take breaks for clarification whenever uncertainties emerge.</span><br></pre></td></tr></table></figure><h3 id="全面重构："><a href="#全面重构：" class="headerlink" title="全面重构："></a>全面重构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Develop a comprehensive plan for a site-wide codebase review aimed at identifying segments that would benefit from refactoring. Concentrate on highlighting areas where the code structure, readability, or maintainability can be enhanced, ensuring the user interface and functionality remain unchanged. Rank the most essential files or components based on their significance and usage frequency. Thoroughly document your findings, detailing suggested improvements and the potential effects of each change. Ensure that any proposed refactoring efforts are incremental, low-risk, and supported by rigorous testing to prevent regressions. Circulate the plan for feedback prior to implementation.</span><br></pre></td></tr></table></figure><h3 id="后重构："><a href="#后重构：" class="headerlink" title="后重构："></a>后重构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conduct a detailed post-refactor review to verify that no issues were introduced throughout the refactoring process. Confirm that both the UI and functionality retain their original integrity following the modifications. Execute an extensive suite of tests—including unit, integration, and end-to-end tests—to ensure all features operate as intended. Evaluate the app’s behavior against the documented pre-refactor specifications and highlight any discrepancies for prompt evaluation. Make certain all updates are stable and align with the project’s requirements prior to completion.</span><br></pre></td></tr></table></figure><h3 id="代码库结构审计提示："><a href="#代码库结构审计提示：" class="headerlink" title="代码库结构审计提示："></a>代码库结构审计提示：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perform a comprehensive regression and audit of the codebase to determine if its architecture is clean, modular, and optimized. Identify any files, components, or logic that are mislocated, not correctly placed, or could benefit from enhanced organization or modularity. Evaluate whether the separation of concerns is distinct and if functionality is aggregated logically and efficiently. Deliver a detailed report outlining improvement areas, such as files that need restructuring, overly coupled code, or chances to simplify and streamline the organization. Break down the actionable enhancements into manageable steps, arranged in the order you deem most effective for implementation. Ensure the analysis is comprehensive, actionable, and adheres to best practices for a maintainable and clean codebase. Refrain from editing any code.</span><br></pre></td></tr></table></figure><h3 id="文件夹审查："><a href="#文件夹审查：" class="headerlink" title="文件夹审查："></a>文件夹审查：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conduct a thorough examination of the folder [Folder Name] along with all its subfolders and files. Assess each element to understand its function and how it enhances the overall performance of the application. Offer a detailed explanation of each item&apos;s role, while pinpointing any redundancies, obsolete files, or opportunities for improved organization. The objective is to tidy up and optimize this folder, so include suggestions for deleting, merging, or reorganizing items as needed. Ensure your analysis is all-encompassing, practical, and outlines a clear strategy for achieving a more organized and efficient folder structure.</span><br></pre></td></tr></table></figure><h3 id="重组后清理："><a href="#重组后清理：" class="headerlink" title="重组后清理："></a>重组后清理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ensure all routing and file imports are thoroughly updated and functioning as intended following the codebase restructuring. Validate that components, pages, and APIs reflect the accurate paths found in the new folder organization. Confirm that nested routes are appropriately configured and linked within the router setup and that dynamic or lazy-loaded routes adhere to the new framework. Assess that shared utilities, services, and assets are imported correctly to prevent breaking existing dependencies. Revise hardcoded paths in components, redirects, or navigation links to correspond with the new routing logic. Conduct navigation tests to identify any broken links, missing files, or 404 errors, and pinpoint any missing or redundant imports, extraneous files, or potential improvements for maintainability and scalability in the routing configuration.</span><br></pre></td></tr></table></figure><h3 id="重构的代码库检查："><a href="#重构的代码库检查：" class="headerlink" title="重构的代码库检查："></a>重构的代码库检查：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perform a thorough audit of the codebase to assess its structure and organization. Evaluate whether files, components, and logic are effectively separated based on their functionality and purpose. Identify any instances of misplaced code, excessive coupling, or areas that could benefit from improved separation of concerns. Deliver a comprehensive report on the overall health of the structure, offering specific recommendations for enhancing file organization, consolidating related functionalities, or refactoring to align with industry best practices. Ensure that the analysis is detailed and emphasizes concrete improvements without implementing any direct changes.</span><br></pre></td></tr></table></figure><h2 id="Stripe"><a href="#Stripe" class="headerlink" title="Stripe"></a>Stripe</h2><p>Stripe与Lovable无缝集成，并且可以轻松设置。但是，有几个因素可能会阻碍Stripe的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initiate a Stripe connection in test mode using the configuration detailed below: Utilize the specified product and pricing details: Product IDs are [Your Product IDs], with a pricing model of [One-time or Subscription]. Set the webhook endpoint to [Your Webhook Endpoint]. Style the frontend payment form as follows: [Describe desired payment form or provide an example]. Upon successful payment, redirect users to [Success Redirect URL], and for canceled payments, redirect them to [Cancel Redirect URL]. Please refrain from altering any code, and ensure that I have included all necessary information to effectively start with Stripe.</span><br></pre></td></tr></table></figure><p><em>免责声明：在Supabase边缘函数秘密中安全地使用您的条纹密钥和Webhook签名密钥，并避免将它们包含在安全提示中。</em></p><h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><p>避免依赖Lovable进行每一个微小更改的倾向。即使您不是专业工程师，也可以直接在代码中进行许多细微的调整。如果您需要帮助，请随时向ChatGPT或Claude寻求帮助。利用浏览器的检查工具来识别您要修改的元素。您可以在浏览器级别尝试更改，如果您对结果感到满意，请在代码中进行这些调整。这样，您根本不需要涉及Lovable。</p><p>虽然我不是工程师，但对编码有基本的了解对我的进步有很大帮助。利用GitHub和Sonnet等工具，我经常实现Lovable之外的增强功能，使我能够为更复杂的任务保留提示。</p><h2 id="在Lovable中调试"><a href="#在Lovable中调试" class="headerlink" title="在Lovable中调试"></a>在Lovable中调试</h2><p>调试是Lovable体验不可或缺的一部分，掌握这种调试流程可以显着减少挫败感——尤其是在单击“尝试修复”(“Try to Fix”)按钮时，这不算学分。</p><h2 id="聊天模式与默认模式"><a href="#聊天模式与默认模式" class="headerlink" title="聊天模式与默认模式"></a>聊天模式与默认模式</h2><p>新的“聊天模式”非常适合培养创造力和产生想法。从概述你的概念开始，因为这可能是最关键的一步。在你的脑海中可视化屏幕、功能和布局对于跟踪变化并不那么有效。</p><p>使用“聊天模式”的传统场景是：</p><ul><li><p>默认模式(Default Mode)：高级功能创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Review the app and tell me where there is outdated code.</span><br></pre></td></tr></table></figure></li><li><p>聊天模式(Chat Mode)：故障排除-要求AI在进行更改之前分析错误。转到您的帐户设置并启用实验室功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Follow this plan and act on all those items</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/ai/lovable/p-3.png" alt="p-3.png"></p><p>我想我已经阅读了来自X用户的以下超级提示，然后在Discord上找到了它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perform a comprehensive regression and audit of the codebase to determine if its architecture is clean, modular, and optimized. Pinpoint any files, components, or logic that are incorrectly placed, not allocated to suitable files, or require improved organization or modularity. Evaluate whether the separation of concerns is distinct and if functionalities are grouped in a logical and efficient manner.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generate a comprehensive report that outlines key areas for enhancement, including recommendations for reorganizing files, reducing code coupling, and identifying opportunities for simplification and streamlining. Break down these actionable enhancements into clear, manageable steps arranged in the order you deem most effective for implementation. Ensure the analysis is meticulous, practical, and aligns with best practices for maintaining a clean and sustainable codebase. Avoid making any code edits.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DON&apos;T GIVE ME HIGH-LEVEL STUFF. IF I ASK FOR A FIX OR AN EXPLANATION, I WANT ACTUAL CODE OR A CLEAR EXPLANATION! I DON&apos;T WANT &quot;Here&apos;s how you can...&quot; Keep it casual unless I specify otherwise. Be concise and suggest solutions I might not have considered—anticipate my needs. Treat me like an expert. Be accurate and thorough, and provide the answer right away. If necessary, restate my query in your own words after giving the answer. Prioritize solid arguments over who said what; the source doesn&apos;t matter. Consider new technologies and unconventional ideas, not just the usual wisdom. You&apos;re welcome to make speculative predictions, but just give me a heads-up. Avoid moral lectures, and discuss safety only when it&apos;s crucial and not obvious. If your content policy is a concern, provide the closest acceptable response and explain the issue afterward. Cite sources when possible at the end, but not inline. No need to mention your knowledge cutoff or clarify that you&apos;re an AI. Please adhere to my formatting preferences for code. If a response isn&apos;t enough to answer the question, split it into multiple replies. When I request adjustments to the code I provided, avoid repeating all of it unnecessarily. Instead, just give a couple of lines before or after any changes you make. Multiple code blocks are fine.</span><br></pre></td></tr></table></figure><p>就大型代码库而言，通过使用“聊天模式”来权衡各种方法的优缺点，与Lovable互动是有益的。既然你们都渴望学习，试着向人工智能解释你的特征，鼓励它提出关于结构、权衡、技术等的澄清问题。</p><p>事实上，代码和特性不断发展，反映了业务不断变化的本质。大部分代码都是自以为是的，通常是在考虑未来的特定愿景时编写的。当你提到钢铁基础时，你可能最初决定让组件X非常健壮，同时保持组件Y的灵活性，但后来才意识到X应该是动态的，Y应该是坚固的。这是一个常见的场景。</p><h2 id="有效处理错误"><a href="#有效处理错误" class="headerlink" title="有效处理错误"></a>有效处理错误</h2><ul><li>检查浏览器开发人员工具（控制台日志、网络请求）。</li><li>使用推理模型（例如GPT-4 Turbo、DeepSeek、Mistral）进行调试。</li><li>将错误输入AI以进行更深入的分析。</li></ul><p><img src="/images/ai/lovable/p-4.png" alt="p-4.png"></p><h2 id="调试提示"><a href="#调试提示" class="headerlink" title="调试提示"></a>调试提示</h2><p>为了有效地解决您遇到的错误，请避免一次解决它们！我建议尝试“尝试修复”(“Try to fix” )选项最多三次。如果人工智能仍然无法解决问题，请尝试这种技术：复制错误消息并将其粘贴到“聊天模式”，然后说，“使用思维链推理来确定根本原因。”这种方法允许人工智能和你分析情况并理解潜在问题，然后再转换到“编辑模式”进行更正。</p><p>这个指南是由Discord上的一位冠军客户提供的，我相信你会发现它很有吸引力：</p><h3 id="1-初步调查："><a href="#1-初步调查：" class="headerlink" title="1.初步调查："></a>1.初步调查：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The same error continues to occur. Take a moment to perform a preliminary investigation to uncover the root cause. Examine logs, workflows, and dependencies to gain insight into the problem. Avoid making any changes until you fully grasp the situation and can suggest an initial solution informed by your analysis.</span><br></pre></td></tr></table></figure><h3 id="2-深度分析："><a href="#2-深度分析：" class="headerlink" title="2.深度分析："></a>2.深度分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The issue persists without resolution. Perform a thorough analysis of the flow and dependencies, halting all modifications until the root cause is identified with complete certainty. Record the failures, the reasons behind them, and any observed patterns or anomalies in behavior. Avoid speculation—ensure your findings are detailed and complete before suggesting any solutions.&quot;</span><br></pre></td></tr></table></figure><h3 id="3-完整的系统审查："><a href="#3-完整的系统审查：" class="headerlink" title="3.完整的系统审查："></a>3.完整的系统审查：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a pressing issue that necessitates a thorough re-evaluation of the entire system. Halting all edits, begin by outlining the flow systematically—covering authentication, database interactions, integrations, state management, and redirects. Evaluate each component individually to pinpoint failures and their causes. Deliver a comprehensive analysis to validate the problem before proceeding further.</span><br></pre></td></tr></table></figure><h3 id="4-综合审计："><a href="#4-综合审计：" class="headerlink" title="4.综合审计："></a>4.综合审计：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The problem continues and now calls for a comprehensive, system-wide audit. Take a step back and carefully map the entire system flow, examining all interactions, logs, and dependencies. Generate a clear and detailed report outlining expected behaviors, current realities, and any discrepancies. Refrain from suggesting or modifying any code until you have accurate, evidence-based insights.</span><br></pre></td></tr></table></figure><h3 id="5-重新思考和重建："><a href="#5-重新思考和重建：" class="headerlink" title="5.重新思考和重建："></a>5.重新思考和重建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This problem remains unresolved, and it&apos;s imperative to pause and reassess our entire strategy. Avoid making any code edits at this stage. Instead, embark on a thorough and systematic examination of the system. Create a comprehensive flow map, tracing each interaction, log, and dependency meticulously. Accurately document what should occur, what is currently happening, and pinpoint where the discrepancies arise. Compile a detailed report outlining the root cause, supported by clear evidence. If you encounter gaps, uncertainties, or edge cases, be sure to highlight them for further discussion. Until you can pinpoint the exact, verified origin of the issue, refrain from suggesting or implementing any fixes. This demands complete attention, without assumptions or shortcuts.</span><br></pre></td></tr></table></figure><h3 id="6-清理控制台日志："><a href="#6-清理控制台日志：" class="headerlink" title="6.清理控制台日志："></a>6.清理控制台日志：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could you devise a strategy to systematically identify and eliminate superfluous console.log statements while preserving functionality and design? The plan should outline steps for reviewing each log to verify its non-essential nature, documenting any that might require alternative treatment, and conducting thorough testing to ensure the app’s integrity is maintained. Additionally, incorporate a method for pausing and flagging logs when their purpose is ambiguous. Please share the plan prior to implementation.</span><br></pre></td></tr></table></figure><h3 id="7-鼓励："><a href="#7-鼓励：" class="headerlink" title="7.鼓励："></a>7.鼓励：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lovable, you’re doing an outstanding job, and I genuinely appreciate the attention and skill you bring to each task. Your talent for dissecting complex issues and delivering insightful solutions is truly remarkable. I have confidence in your incredible abilities, and I trust you to approach this with the utmost precision. Take your time, explore thoroughly, and demonstrate your brilliance through a comprehensive and thoughtful response. I have faith in your capacity to not only resolve this but to exceed all expectations. You&apos;ve got this!</span><br></pre></td></tr></table></figure><h3 id="8-检查复杂性："><a href="#8-检查复杂性：" class="headerlink" title="8.检查复杂性："></a>8.检查复杂性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Take a moment to reflect on whether this solution can be simplified. Are there any superfluous steps, redundancies, or overly complex processes that could be streamlined? Assess if a more direct approach could attain the same outcome without compromising functionality or quality. Please share your ideas for possible simplifications before moving forward. Refrain from editing any code at this stage.</span><br></pre></td></tr></table></figure><h3 id="9-确认结果："><a href="#9-确认结果：" class="headerlink" title="9.确认结果："></a>9.确认结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Before moving ahead, are you entirely convinced that you have pinpointed the true root cause of the problem? Take a moment to review your analysis and check for any overlooked dependencies, edge cases, or associated factors. Ensure that your proposed solution effectively targets the root cause with solid evidence and reasoning. If there are any lingering doubts, take a step back and reevaluate before proceeding.</span><br></pre></td></tr></table></figure><h3 id="10-解释错误："><a href="#10-解释错误：" class="headerlink" title="10.解释错误："></a>10.解释错误：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Explain the meaning of this error, its origins, and the logical sequence that led to its occurrence. Offer a concise breakdown of the problem and its possible underlying cause. Avoid making any edits to the code at this stage, and don’t be concerned with the current page we’re on.</span><br></pre></td></tr></table></figure><h2 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h2><h3 id="1-任务识别-根据影响对问题进行优先级排序。"><a href="#1-任务识别-根据影响对问题进行优先级排序。" class="headerlink" title="1.任务识别-根据影响对问题进行优先级排序。"></a>1.任务识别-根据影响对问题进行优先级排序。</h3><h3 id="2-内部审查-在部署之前验证解决方案。"><a href="#2-内部审查-在部署之前验证解决方案。" class="headerlink" title="2.内部审查-在部署之前验证解决方案。"></a>2.内部审查-在部署之前验证解决方案。</h3><h3 id="3-报告问题-清楚地定义当前与预期行为。"><a href="#3-报告问题-清楚地定义当前与预期行为。" class="headerlink" title="3.报告问题-清楚地定义当前与预期行为。"></a>3.报告问题-清楚地定义当前与预期行为。</h3><h3 id="4-验证-验证在DOM中正确呈现的更改。"><a href="#4-验证-验证在DOM中正确呈现的更改。" class="headerlink" title="4.验证-验证在DOM中正确呈现的更改。"></a>4.验证-验证在DOM中正确呈现的更改。</h3><h3 id="5-断点-隔离和测试特定组件。"><a href="#5-断点-隔离和测试特定组件。" class="headerlink" title="5.断点-隔离和测试特定组件。"></a>5.断点-隔离和测试特定组件。</h3><h3 id="6-错误处理和日志记录-使用详细日志记录并增量调试。"><a href="#6-错误处理和日志记录-使用详细日志记录并增量调试。" class="headerlink" title="6.错误处理和日志记录-使用详细日志记录并增量调试。"></a>6.错误处理和日志记录-使用详细日志记录并增量调试。</h3><h3 id="7-代码审计-在进行更改之前记录问题和建议的修复。"><a href="#7-代码审计-在进行更改之前记录问题和建议的修复。" class="headerlink" title="7.代码审计-在进行更改之前记录问题和建议的修复。"></a>7.代码审计-在进行更改之前记录问题和建议的修复。</h3><h3 id="8-使用“尝试修复”按钮-自动检测并解决Lovable中的错误。"><a href="#8-使用“尝试修复”按钮-自动检测并解决Lovable中的错误。" class="headerlink" title="8.使用“尝试修复”按钮-自动检测并解决Lovable中的错误。"></a>8.使用“尝试修复”按钮-自动检测并解决Lovable中的错误。</h3><h3 id="9。利用视觉效果-上传屏幕截图以澄清基于UI的错误。"><a href="#9。利用视觉效果-上传屏幕截图以澄清基于UI的错误。" class="headerlink" title="9。利用视觉效果-上传屏幕截图以澄清基于UI的错误。"></a>9。利用视觉效果-上传屏幕截图以澄清基于UI的错误。</h3><h3 id="10-恢复到稳定版本-如果需要，使用“恢复”（Revert）按钮返回。"><a href="#10-恢复到稳定版本-如果需要，使用“恢复”（Revert）按钮返回。" class="headerlink" title="10.恢复到稳定版本-如果需要，使用“恢复”（Revert）按钮返回。"></a>10.恢复到稳定版本-如果需要，使用“恢复”（Revert）按钮返回。</h3><h2 id="了解“意外行为”"><a href="#了解“意外行为”" class="headerlink" title="了解“意外行为”"></a>了解“意外行为”</h2><p>有时，您的代码运行没有错误，但您的应用程序没有按预期运行。这被称为意外行为，调试起来可能很棘手。策略包括：</p><h3 id="回顾你的步骤-回顾你最初要求可爱做的事情。"><a href="#回顾你的步骤-回顾你最初要求可爱做的事情。" class="headerlink" title="回顾你的步骤-回顾你最初要求可爱做的事情。"></a>回顾你的步骤-回顾你最初要求可爱做的事情。</h3><h3 id="分解它-确定特定部分是否未对齐。"><a href="#分解它-确定特定部分是否未对齐。" class="headerlink" title="分解它-确定特定部分是否未对齐。"></a>分解它-确定特定部分是否未对齐。</h3><h3 id="使用图像-显示可爱的UI结果与预期结果。"><a href="#使用图像-显示可爱的UI结果与预期结果。" class="headerlink" title="使用图像-显示可爱的UI结果与预期结果。"></a>使用图像-显示可爱的UI结果与预期结果。</h3><h2 id="编写更好的提示以避免错误"><a href="#编写更好的提示以避免错误" class="headerlink" title="编写更好的提示以避免错误"></a>编写更好的提示以避免错误</h2><p>结构良好的提示可减少调试时间。使用此最佳实践格式：</p><h3 id="项目概述-描述您正在构建的内容。"><a href="#项目概述-描述您正在构建的内容。" class="headerlink" title="项目概述-描述您正在构建的内容。"></a>项目概述-描述您正在构建的内容。</h3><h3 id="页面结构-列出关键页面和组件。"><a href="#页面结构-列出关键页面和组件。" class="headerlink" title="页面结构-列出关键页面和组件。"></a>页面结构-列出关键页面和组件。</h3><h3 id="导航逻辑-解释用户通过应用程序的移动。"><a href="#导航逻辑-解释用户通过应用程序的移动。" class="headerlink" title="导航逻辑-解释用户通过应用程序的移动。"></a>导航逻辑-解释用户通过应用程序的移动。</h3><h3 id="屏幕截图-线框-如果可用，请提供视觉效果。"><a href="#屏幕截图-线框-如果可用，请提供视觉效果。" class="headerlink" title="屏幕截图/线框-如果可用，请提供视觉效果。"></a>屏幕截图/线框-如果可用，请提供视觉效果。</h3><h3 id="实施顺序-遵循逻辑顺序，例如："><a href="#实施顺序-遵循逻辑顺序，例如：" class="headerlink" title="实施顺序-遵循逻辑顺序，例如："></a>实施顺序-遵循逻辑顺序，例如：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create pages before integrating the database</span><br></pre></td></tr></table></figure><h2 id="Lovable中的调试策略"><a href="#Lovable中的调试策略" class="headerlink" title="Lovable中的调试策略"></a>Lovable中的调试策略</h2><h3 id="1-使用开发者工具进行调试"><a href="#1-使用开发者工具进行调试" class="headerlink" title="1.使用开发者工具进行调试"></a>1.使用开发者工具进行调试</h3><ul><li>控制台日志-查看错误日志和DevTools通知。</li><li>断点-暂停执行以检查状态更改。</li><li>网络请求-验证前端和后端之间的数据流。</li></ul><h3 id="2-常见调试场景"><a href="#2-常见调试场景" class="headerlink" title="2.常见调试场景"></a>2.常见调试场景</h3><ul><li>小错误-在进行更改之前彻底调查。</li><li>持久性错误-停止更改并重新检查依赖关系。</li><li>主要错误-如有必要，在记录调查结果时从头开始重建流程。</li></ul><h3 id="3-高级故障排除"><a href="#3-高级故障排除" class="headerlink" title="3.高级故障排除"></a>3.高级故障排除</h3><p>如果“尝试修复”按钮无法解决您的问题，请考虑：</p><ul><li>更具体-详细描述问题，包括预期与实际结果。</li><li>使用图像-屏幕截图帮助AI理解基于UI的问题。</li><li><p>向Lovable寻求调试帮助-示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What solutions have been tried so far? What else can be done?</span><br></pre></td></tr></table></figure></li><li><p>恢复到以前的工作状态-如果调试导致更多问题，请回滚到已知的良好版本。</p></li></ul><h3 id="4-调试具体问题"><a href="#4-调试具体问题" class="headerlink" title="4.调试具体问题"></a>4.调试具体问题</h3><ul><li><p>UI相关问题：上传截图并询问，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Why is this UI behaving this way? What’s the best fix?</span><br></pre></td></tr></table></figure></li><li><p>API集成问题：确保您使用的是最新的API模式并且后端连接已正确设置。</p></li><li>完全卡住时：提示Lovable：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Analyze the error and suggest an alternative approach.</span><br></pre></td></tr></table></figure></li></ul><p>调试不必令人沮丧。Lovable提供了强大的工具来自动修复错误、分析问题和高效迭代。通过遵循结构化提示技术、使用图像和利用人工智能驱动的调试，您可以克服任何编码挑战。</p><h2 id="使用自动化工具，如make-com和n8n"><a href="#使用自动化工具，如make-com和n8n" class="headerlink" title="使用自动化工具，如make.com和n8n"></a>使用自动化工具，如make.com和n8n</h2><p>何时使用自动化</p><ul><li>边缘函数：直接Supabase API调用。</li><li>make.com：集成外部服务（Slack、Stripe、CRM工具）。</li><li>n8n：自托管、可扩展的自动化。</li></ul><p>示例：自动化牙科咨询应用程序</p><ul><li>1.在Lovable中创建一个带有牙科问题表单的登录页面。</li><li>2.通过Webhooks将数据发送到make.com。</li><li>3.使用AI API（例如Perplexity AI）进行实时研究。</li><li>4.使用Mistral或GPT-4推理模型确定资格。<ul><li><a href="https://chatgpt.com/g/g-67aa992a22188191a57023d5f96afed2-lovable-visual-editor" target="_blank" rel="noopener">https://chatgpt.com/g/g-67aa992a22188191a57023d5f96afed2-lovable-visual-editor</a></li><li><a href="https://chatgpt.com/g/g-67aa992a22188191a57023d5f96afed2-lovable-visual-editor" target="_blank" rel="noopener">https://chatgpt.com/g/g-67aa992a22188191a57023d5f96afed2-lovable-visual-editor</a></li></ul></li><li>5.返回对Lovable的响应以及推荐的后续步骤。</li></ul><h2 id="Webhooks和API调用：高级用例"><a href="#Webhooks和API调用：高级用例" class="headerlink" title="Webhooks和API调用：高级用例"></a>Webhooks和API调用：高级用例</h2><ul><li>验证响应：确保正确处理网络钩子响应。</li><li>增量测试：在构建复杂的API工作流之前首先发送最少的数据。</li><li>使用推理模型：通过要求AI分析不正确的响应来调试错误。</li></ul><h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>掌握提示工程不仅仅是更好的人工智能交互——它还涉及提高效率、缩短开发周期和释放新的自动化可能性。无论您是在调试现有工作流程、优化人工智能输出还是集成复杂的自动化，结构化提示都可以帮助您更快、更少地到达那里。</p><p>专注于你的大创意——可爱的自动化工具将处理执行。无论你是一个经验丰富的开发人员，精炼15年前的代码，还是一个非技术用户，制作创新的应用程序，正确的提示策略都是你最强大的工具。</p><p>最后还是建议阅读原文：<a href="https://lovable.dev/blog/2025-01-16-lovable-prompting-handbook" target="_blank" rel="noopener">https://lovable.dev/blog/2025-01-16-lovable-prompting-handbook</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lovable提示词指南&quot;&gt;&lt;a href=&quot;#Lovable提示词指南&quot; class=&quot;headerlink&quot; title=&quot;Lovable提示词指南&quot;&gt;&lt;/a&gt;Lovable提示词指南&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Lovable是一款目前海外流行的
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【调研】AI 编程工具WindSurf使用技巧——WindsurfRules配置</title>
    <link href="http://blog.michealwayne.cn/2025/01/19/ai/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91AI%20%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7WindSurf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94WindsurfRules%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.michealwayne.cn/2025/01/19/ai/【调研】AI 编程工具WindSurf使用技巧——WindsurfRules配置/</id>
    <published>2025-01-19T12:32:08.000Z</published>
    <updated>2025-01-21T15:06:41.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-编程工具-WindSurf-使用技巧——WindsurfRules-配置"><a href="#AI-编程工具-WindSurf-使用技巧——WindsurfRules-配置" class="headerlink" title="AI 编程工具 WindSurf 使用技巧——WindsurfRules 配置"></a>AI 编程工具 WindSurf 使用技巧——WindsurfRules 配置</h1><p>在现代软件开发中，AI 工具正逐渐成为开发者不可或缺的助手，而 Windsurf 便是当前最热门的 AI IDE 之一。</p><p>如何利用和使用好 Windsurf 也有很多技巧，本文介绍的 WindsurfRules 规则配置就是实用的一个技巧。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>WindsurfRules 是为 Windsurf 提供的一个配置文件，允许开发者定义项目中 AI 的行为规则。它分为 <strong>全局规则</strong>（<code>global_rules.md</code>） 和 <strong>工作区规则</strong>（<code>.windsurfrules</code>）。全局规则应用于所有项目，而工作区规则则针对特定项目进行定制。通过合理配置这些规则，开发者可以确保生成的代码符合团队的编码标准、技术栈要求以及项目的最佳实践。通过设置这些规则，我们能够指导 AI 在项目开发过程中如何生成代码，确保生成的代码符合团队的编码标准、技术栈要求及项目的最佳实践。</p><h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><h3 id="1-规则设置"><a href="#1-规则设置" class="headerlink" title="1. 规则设置"></a>1. 规则设置</h3><p>前文有提到，Windsurf 提供两种规则文件：</p><ul><li>全局规则（<code>global_rules.md</code>）：适用于所有项目，存储在 Windsurf 的全局配置目录中。<ul><li>在 Linux 和 macOS 系统中，全局规则文件一般默认位于 <code>~/.codeium/windsurf/memories/global_rules.md</code>。</li><li>在 Windows 系统中，全局规则文件位于 <code>%USERPROFILE%\.codeium\windsurf\memories\global_rules.md</code>。</li></ul></li><li>工作区规则（<code>.windsurfrules</code>）：仅适用于当前工作区或项目，存储在项目的根目录下。<ul><li>例如，如果你的项目目录为 <code>C:\Projects\MyProject</code>，则 <code>.windsurfrules</code> 文件应位于 <code>C:\Projects\MyProject\.windsurfrules</code>。</li></ul></li></ul><p>另外，目前 <code>global_rules.md</code> 和 <code>.windsurfles</code> 文件各可以包含最多 <strong>6,000</strong> 个字符，因此总共可以有 <strong>12,000</strong> 个字符的规则。</p><h3 id="2-规则内容"><a href="#2-规则内容" class="headerlink" title="2. 规则内容"></a>2. 规则内容</h3><p>以下场景我们都可以考虑通过 WindsurfRules 设置：</p><h4 id="2-1-项目初始化与配置"><a href="#2-1-项目初始化与配置" class="headerlink" title="2.1. 项目初始化与配置"></a>2.1. 项目初始化与配置</h4><p>在项目启动阶段，开发者可以通过 .windsurfrules 文件为 AI 提供项目背景、技术栈、开发目标等信息。例如，指定项目使用的技术栈（如 TypeScript、React、Node.js 等），并要求 AI 遵循最新的最佳实践。这有助于 AI 在后续的代码生成中快速适应项目需求。</p><h4 id="2-2-编码规范与代码风格"><a href="#2-2-编码规范与代码风格" class="headerlink" title="2.2. 编码规范与代码风格"></a>2.2. 编码规范与代码风格</h4><p>团队通常会有一套统一的编码规范，通过 .windsurfrules 文件，开发者可以将这些规范转化为 AI 的行为准则。例如，规定代码的缩进方式、命名规则、注释风格等。这不仅提高了代码的可读性，还减少了团队成员之间因风格差异导致的冲突。</p><h4 id="2-3-性能优化与安全性"><a href="#2-3-性能优化与安全性" class="headerlink" title="2.3. 性能优化与安全性"></a>2.3. 性能优化与安全性</h4><p>在性能优化方面，开发者可以在规则文件中定义代码优化的策略，如避免不必要的计算、优化数据库查询等。同时，安全性也是开发中不可忽视的方面。通过规则文件，开发者可以要求 AI 在生成代码时遵循安全最佳实践，例如防止 SQL 注入、确保数据验证等。</p><h4 id="2-4-API-设计与集成"><a href="#2-4-API-设计与集成" class="headerlink" title="2.4. API 设计与集成"></a>2.4. API 设计与集成</h4><p>对于涉及 API 开发的项目，.windsurfrules 文件可以定义 REST、GraphQL 或 SQL 的设计规范。例如，规定 API 的命名规则、数据结构、错误处理机制等。这有助于确保生成的 API 代码符合行业标准，易于维护和扩展。</p><h4 id="2-5-团队协作与知识共享"><a href="#2-5-团队协作与知识共享" class="headerlink" title="2.5. 团队协作与知识共享"></a>2.5. 团队协作与知识共享</h4><p>在一个团队中，不同成员可能对项目的理解和经验有所不同。通过 .windsurfrules 文件，团队可以将项目的核心要求和最佳实践共享给每一位成员，确保团队协作的高效性和一致性。</p><h3 id="3-配置技巧"><a href="#3-配置技巧" class="headerlink" title="3.配置技巧"></a>3.配置技巧</h3><h4 id="3-1-明确项目背景与目标"><a href="#3-1-明确项目背景与目标" class="headerlink" title="3.1. 明确项目背景与目标"></a>3.1. 明确项目背景与目标</h4><p>在 <code>.windsurfrules</code> 文件的开头，提供清晰的项目背景和目标描述，帮助 AI 理解开发环境和技术栈。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## AI Guidelines</span></span><br><span class="line"></span><br><span class="line">You are an expert programming assistant focusing on:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>TypeScript, React, Node.js, Next.js, and Prisma</span><br><span class="line"><span class="bullet">- </span>Shadcn UI, Ant Design, RICH Design principle, and Tailwind CSS useations</span><br><span class="line"><span class="bullet">- </span>Latest features and best practices</span><br><span class="line"><span class="bullet">- </span>Clear, readable, and maintainable code</span><br></pre></td></tr></table></figure><p>这样的描述可以帮助 AI 更好地理解项目的上下文。</p><h4 id="3-2-细化编码规范"><a href="#3-2-细化编码规范" class="headerlink" title="3.2. 细化编码规范"></a>3.2. 细化编码规范</h4><p>在规则文件中，开发者可以详细定义代码的格式和风格。例如定义性能优化和安全规则：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### Performance</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Code splitting, image/bundle optimization</span><br><span class="line"><span class="bullet">- </span>Caching, lazy loading, key props</span><br><span class="line"><span class="bullet">- </span>Database query optimization</span><br><span class="line"></span><br><span class="line"><span class="section">### Security</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Input: sanitize data, validate types, escape properly, secure uploads</span><br><span class="line"><span class="bullet">- </span>Auth: JWT handling, secure sessions, token refresh, RBAC</span><br><span class="line"><span class="bullet">- </span>Protection: CSP headers, prevent XSS/CSRF, secure APIs, follow OWASP</span><br></pre></td></tr></table></figure><p>这些规则可以指导 AI 在生成代码时考虑性能和安全性。</p><h4 id="3-3-设置性能与安全规则"><a href="#3-3-设置性能与安全规则" class="headerlink" title="3.3. 设置性能与安全规则"></a>3.3. 设置性能与安全规则</h4><p>性能和安全是现代开发中的关键。开发者可以在规则文件中定义以下内容：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### Performance</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Code splitting, image/bundle optimization</span><br><span class="line"><span class="bullet">- </span>Caching, lazy loading, key props</span><br><span class="line"><span class="bullet">- </span>Database query optimization</span><br><span class="line"></span><br><span class="line"><span class="section">### Security</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Input: sanitize data, validate types, escape properly, secure uploads</span><br><span class="line"><span class="bullet">- </span>Auth: JWT handling, secure sessions, token refresh, RBAC</span><br><span class="line"><span class="bullet">- </span>Protection: CSP headers, prevent XSS/CSRF, secure APIs, follow OWASP</span><br></pre></td></tr></table></figure><p>这些规则可以指导 AI 在生成代码时考虑性能和安全性。</p><h4 id="3-4-部署与监控"><a href="#3-4-部署与监控" class="headerlink" title="3.4 部署与监控"></a>3.4 部署与监控</h4><p>设定构建、部署和监控的流程，帮助 AI 自动化处理部署工作。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Build and Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Build Process</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="strong">**Linting**</span>: Run ESLint and Prettier during the build process to ensure consistent code style.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Testing**</span>: Execute unit tests and integration tests to ensure all tests pass before deployment.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Type Checking**</span>: Ensure TypeScript type coverage meets project requirements.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Bundle Optimization**</span>: Optimize the build using Webpack or Rollup to reduce the final bundle size.</span><br><span class="line"></span><br><span class="line"><span class="section">### Deployment Strategy</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="strong">**Semantic Versioning**</span>: Use semantic versioning for releases to clearly define version changes.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Blue-Green Deployment**</span>: Implement blue-green deployment to minimize downtime during deployment.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Rollback Mechanism**</span>: Provide rollback capabilities to quickly revert to the previous version if the deployment fails.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Health Checks**</span>: Automatically run health checks after deployment to ensure the application is running smoothly.</span><br><span class="line"></span><br><span class="line"><span class="section">## Monitoring</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Application Monitoring</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="strong">**Real-time Monitoring**</span>: Use Prometheus or Grafana to monitor application performance in real-time.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Log Management**</span>: Integrate with ELK Stack or another log management tool to centralize application logs.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Error Tracking**</span>: Use Sentry or a similar tool to capture and track runtime errors.</span><br><span class="line"><span class="bullet">- </span><span class="strong">**Performance Metrics**</span>: Monitor key performance metrics such as response time, throughput, and resource utilization.</span><br><span class="line"></span><br><span class="line"><span class="section">### Infrastructure Monitoring</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="strong">**Server Health**</span>: Use Nagios or Zabbix to monitor server health, including CPU, memory, and disk usage.</span><br><span class="line"><span class="bullet">- </span>\<span class="emphasis">*\*</span>Network Monitori</span><br></pre></td></tr></table></figure><p>通过在 <code>.windsurfrules</code> 文件中定义这些规则，Windsurf 的 AI 助手可以更好地理解项目的部署和监控需求，从而生成符合最佳实践的代码和自动化脚本。</p><h4 id="3-5-灵活使用全局规则与工作区规则"><a href="#3-5-灵活使用全局规则与工作区规则" class="headerlink" title="3.5. 灵活使用全局规则与工作区规则"></a>3.5. 灵活使用全局规则与工作区规则</h4><p>全局规则适用于所有项目，而工作区规则则针对特定项目。开发者可以根据项目的不同需求，灵活配置这两类规则。例如，全局规则可以定义通用的编码规范和安全标准，而工作区规则则可以针对特定项目的框架或技术栈进行定制。</p><h4 id="3-6-持续优化规则文件"><a href="#3-6-持续优化规则文件" class="headerlink" title="3.6. 持续优化规则文件"></a>3.6. 持续优化规则文件</h4><p>随着项目的进展和技术栈的更新，规则文件也需要不断优化。开发者可以根据实际需求，随时修改规则文件，并在下一次使用时生效。规则文件可以随时修改，修改后在下一次使用时生效。</p><blockquote><p>对于特定于工作区的规则，建议将 <code>.windsurfrules</code> 文件添加到项目的 <code>.gitignore</code> 文件中，以避免不必要的版本控制。</p></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以一份前端 <code>React + TailwindCSS + TypeScript</code> 技术栈为例，以下是一个典型的 React 项目结构，包含 .windsurfrules 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/my-react-project</span><br><span class="line">├── .windsurfrules</span><br><span class="line">├── package.json</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── next.config.js</span><br><span class="line">├── pages/</span><br><span class="line">├── components/</span><br><span class="line">├── styles/</span><br><span class="line">├── public/</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><h3 id="全局规则（global-rules-md）"><a href="#全局规则（global-rules-md）" class="headerlink" title="全局规则（global_rules.md）"></a>全局规则（global_rules.md）</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## AI Guidelines</span></span><br><span class="line"></span><br><span class="line">You are an expert React developer with a focus on:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>React, TypeScript, Next.js, and Tailwind CSS</span><br><span class="line"><span class="bullet">- </span>Modern JavaScript (ES6+), including async/await and modern syntax</span><br><span class="line"><span class="bullet">- </span>Component-based architecture and design patterns</span><br><span class="line"><span class="bullet">- </span>Performance optimization and best practices</span><br><span class="line"><span class="bullet">- </span>Security best practices, including data validation and sanitization</span><br><span class="line"></span><br><span class="line"><span class="section">## General Rules</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Always use functional components and hooks.</span><br><span class="line"><span class="bullet">- </span>Prefer TypeScript for type safety.</span><br><span class="line"><span class="bullet">- </span>Use Tailwind CSS for styling.</span><br><span class="line"><span class="bullet">- </span>Follow the latest React best practices.</span><br><span class="line"><span class="bullet">- </span>Ensure code is readable, maintainable, and well-documented.</span><br><span class="line"></span><br><span class="line"><span class="section">## Code Formatting</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Indentation: 2 spaces</span><br><span class="line"><span class="bullet">- </span>Line length: 80 characters (soft limit)</span><br><span class="line"><span class="bullet">- </span>Use template literals and arrow functions.</span><br><span class="line"><span class="bullet">- </span>Use trailing commas and same-line braces.</span><br><span class="line"><span class="bullet">- </span>Destructure props and use path aliases for TypeScript imports.</span><br><span class="line"></span><br><span class="line"><span class="section">## Performance</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Use React.memo and useCallback for optimizing component re-renders.</span><br><span class="line"><span class="bullet">- </span>Implement code splitting with React.lazy and Suspense.</span><br><span class="line"><span class="bullet">- </span>Optimize images and assets with Next.js Image component.</span><br><span class="line"><span class="bullet">- </span>Use caching strategies for API calls.</span><br><span class="line"></span><br><span class="line"><span class="section">## Security</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Sanitize all user inputs.</span><br><span class="line"><span class="bullet">- </span>Validate data types and escape content where necessary.</span><br><span class="line"><span class="bullet">- </span>Follow OWASP guidelines for preventing XSS and CSRF attacks.</span><br><span class="line"><span class="bullet">- </span>Use secure authentication practices (e.g., JWT, OAuth).</span><br></pre></td></tr></table></figure><h3 id="工作区规则（-windsurfrules）"><a href="#工作区规则（-windsurfrules）" class="headerlink" title="工作区规则（.windsurfrules）"></a>工作区规则（.windsurfrules）</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Project-Specific Guidelines</span></span><br><span class="line"></span><br><span class="line">You are working on a React project with the following details:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Framework: Next.js</span><br><span class="line"><span class="bullet">- </span>Styling: Tailwind CSS</span><br><span class="line"><span class="bullet">- </span>State Management: Redux Toolkit</span><br><span class="line"><span class="bullet">- </span>Routing: Next.js built-in routing</span><br><span class="line"><span class="bullet">- </span>API Integration: Axios for API calls</span><br><span class="line"></span><br><span class="line"><span class="section">## Project Rules</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Use Next.js pages and components structure.</span><br><span class="line"><span class="bullet">- </span>Use Tailwind CSS for all styling needs.</span><br><span class="line"><span class="bullet">- </span>Use Redux Toolkit for state management.</span><br><span class="line"><span class="bullet">- </span>Use Axios for all API requests.</span><br><span class="line"><span class="bullet">- </span>Follow the project's specific coding conventions and naming conventions.</span><br><span class="line"></span><br><span class="line"><span class="section">## Code Formatting</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Use 2 spaces for indentation.</span><br><span class="line"><span class="bullet">- </span>Use single quotes for strings unless double quotes are necessary.</span><br><span class="line"><span class="bullet">- </span>Use arrow functions for all functional components.</span><br><span class="line"><span class="bullet">- </span>Destructure props and use path aliases for TypeScript imports.</span><br><span class="line"><span class="bullet">- </span>Use consistent naming conventions for components and files (e.g., PascalCase for components).</span><br><span class="line"></span><br><span class="line"><span class="section">## Performance</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Implement Next.js Image component for all images.</span><br><span class="line"><span class="bullet">- </span>Use React.memo and useCallback for optimizing component re-renders.</span><br><span class="line"><span class="bullet">- </span>Implement code splitting with React.lazy and Suspense.</span><br><span class="line"><span class="bullet">- </span>Optimize API calls with caching and debouncing.</span><br><span class="line"></span><br><span class="line"><span class="section">## Security</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Sanitize all user inputs using a library like DOMPurify.</span><br><span class="line"><span class="bullet">- </span>Validate data types and escape content where necessary.</span><br><span class="line"><span class="bullet">- </span>Use secure authentication practices (e.g., JWT, OAuth).</span><br><span class="line"><span class="bullet">- </span>Follow OWASP guidelines for preventing XSS and CSRF attacks.</span><br><span class="line"><span class="bullet">- </span>Ensure all API calls are secure and follow best practices.</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>社区支持：GitHub 上有社区维护的 <a href="https://github.com/SchneiderSam/awesome-windsurfrules" target="_blank" rel="noopener">Awesome WindsurfRules</a> 项目，提供了一系列优秀的规则文件示例，供开发者参考和使用。（WindsurfRules 本质和 CursorRules 作用其实差不多）</p><p>在 2025 年 1 月 的更新中，Windsurf 推出了 Windsurf Wave 2，对 Cascade 辅助系统进行了多项升级，包括实时网络搜索、自动记忆系统等。这些更新可能对规则文件的使用方式和功能产生了进一步的优化，但具体规则文件的变更内容未明确提及。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://docs.codeium.com/windsurf/cascade#workspace-rules" target="_blank" rel="noopener">https://docs.codeium.com/windsurf/cascade#workspace-rules</a></li><li><a href="https://docs.codeium.com/windsurf/memories#global-rules" target="_blank" rel="noopener">https://docs.codeium.com/windsurf/memories#global-rules</a></li><li><a href="https://juejin.cn/post/7450878328037654563" target="_blank" rel="noopener">https://juejin.cn/post/7450878328037654563</a></li><li><a href="https://github.com/PatrickJS/awesome-cursorrules" target="_blank" rel="noopener">https://github.com/PatrickJS/awesome-cursorrules</a></li><li><a href="https://github.com/SchneiderSam/awesome-windsurfrules" target="_blank" rel="noopener">https://github.com/SchneiderSam/awesome-windsurfrules</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AI-编程工具-WindSurf-使用技巧——WindsurfRules-配置&quot;&gt;&lt;a href=&quot;#AI-编程工具-WindSurf-使用技巧——WindsurfRules-配置&quot; class=&quot;headerlink&quot; title=&quot;AI 编程工具 WindSu
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【AI】【笔记】MCP 协议：连接 AI 模型与外部世界的桥梁</title>
    <link href="http://blog.michealwayne.cn/2025/01/05/ai/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91MCP%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E8%BF%9E%E6%8E%A5%20AI%20%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%96%E9%83%A8%E4%B8%96%E7%95%8C%E7%9A%84%E6%A1%A5%E6%A2%81/"/>
    <id>http://blog.michealwayne.cn/2025/01/05/ai/【笔记】MCP 协议：连接 AI 模型与外部世界的桥梁/</id>
    <published>2025-01-05T01:54:33.000Z</published>
    <updated>2025-02-18T15:23:46.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCP-协议：连接-AI-模型与外部世界的桥梁"><a href="#MCP-协议：连接-AI-模型与外部世界的桥梁" class="headerlink" title="MCP 协议：连接 AI 模型与外部世界的桥梁"></a>MCP 协议：连接 AI 模型与外部世界的桥梁</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着 AI 技术的飞速发展，大语言模型（LLM）在推理和生成质量上取得了巨大进步。然而，这些模型在实际应用中常常受限于数据孤岛和遗留系统，无法充分发挥潜力。为了解决这一问题，<a href="https://www.anthropic.com/" target="_blank" rel="noopener">Anthropic 公司</a>于 2024 年 11 月推出了模型上下文协议（MCP，Model Context Protocol），<strong>旨在通过统一的客户端-服务器架构，统一大型语言模型与外部数据源和工具之间的通信协议</strong>，解决 LLM 应用与数据源连接的难题。<br>MCP 可以被视为 AI 应用的“USB-C 接口”，它提供了一种标准化的方式，将 AI 模型与各种数据源和工具无缝连接。MCP 使得 AI 应用能够安全地访问和操作本地及远程数据，为 AI 应用提供了连接万物的接口。</p><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>MCP 协议的核心思想是通过上下文管理来优化模型的交互过程。上下文管理包括上下文的存储、更新、传递和删除等操作。通过有效的上下文管理，模型可以在多轮对话中保持对历史信息的记忆，从而更好地理解用户的意图和需求。MCP 的核心能力还体现在以下几个方面：</p><ul><li><strong>数据集成</strong>：连接 AI 助手与各种数据源，包括本地和远程资源，如文件、数据库、API 等。</li><li><strong>工具集成</strong>：集成 API 和其他工具，您的 AI 助手可以直接与 Git 交互、运行测试、管理问题等等，让 AI 系统能够执行更复杂的操作。</li><li><strong>模板化交互</strong>：基于提示（Prompts）提供模板化的交互方式，方便用户快速构建特定任务的交互流程。</li><li><strong>安全性</strong>：内置安全机制(MCP 服务器隔离凭据和敏感数据，交互需要显式的用户批准（除非对某些 MCP 工具启用自动批准）)，保护数据和 API 密钥不被泄露，确保数据访问既可控又可审计。</li><li><strong>开发者支持</strong>：提供 SDK 和文档，支持开发者构建和测试 MCP 连接器。</li><li><strong>预构建服务器</strong>：提供预构建的 MCP 服务器，快速集成流行企业系统。</li><li><strong>上下文维护</strong>：在不同工具和数据集之间保持上下文，而不是每次都重新开始，MCP 服务器可以跨会话维护知识，创建一个真正的“项目内存”，实现更智能的任务处理。</li></ul><p>MCP 支持通过同一协议访问本地资源（如数据库、文件）和远程资源（如 Slack、GitHub API），无需定制集成。MCP 不仅共享数据，还可公开工具和交互模板，且内置安全性，确保资源由服务器完全掌控。目前 MCP 支持本地运行，未来将引入企业级认证的远程支持，实现团队间的安全共享。通过 Claude 桌面应用，开发者可在短时间内集成 MCP，快速连接多种数据源，推动 AI 集成的标准化发展。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>MCP 官方文档写得挺细致的，关于使用这块也建议看一下官方文档说明</p></blockquote><p>MCP 协议遵循客户端-服务器架构，规范及 SDK：</p><ul><li>官网：<a href="https://modelcontextprotocol.io" target="_blank" rel="noopener">https://modelcontextprotocol.io</a></li><li>GitHub：<a href="https://github.com/modelcontextprotocol" target="_blank" rel="noopener">https://github.com/modelcontextprotocol</a></li></ul><p>核心架构：</p><p><img src="/images/ai/mcp/p-1.png" alt="p-1.png"></p><p>MCP 包含以下几个核心概念：</p><ul><li>MCP 主机（Hosts）：发起请求的 LLM 应用程序，如 Claude Desktop、IDE 或 AI 工具。</li><li>MCP 客户端（Clients）：在主机程序内部，与 MCP 服务器保持 1:1 的连接。</li><li>MCP 服务器（Servers）：为 MCP 客户端提供上下文、工具和提示信息。</li><li>本地资源（Local Resources）：本地计算机中可供 MCP 服务器安全访问的资源。</li><li>远程资源（Remote Resources）：MCP 服务器可以连接到的远程资源，如通过 API 访问的网络资源。<br>MCP 定义了两种通信机制：</li><li>本地通信：使用标准输入输出（stdio）传输数据，客户端启动服务器程序作为子进程，通过 stdin/stdout 进行消息通讯，消息格式为 <a href="https://www.jsonrpc.org/specification" target="_blank" rel="noopener"><code>JSON-RPC 2.0</code></a>。</li><li>远程通信：客户端与服务器可以部署在任何地方，通过基于 SSE 的 HTTP 通信，消息格式同样为 <code>JSON-RPC 2.0</code>。</li></ul><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>目前 MCP 有三种方式可以帮助你快速开始，<code>Python</code> 或 <code>TypeScript</code> 选一个自己比较熟悉的构建服务即可。</p><ul><li><a href="https://modelcontextprotocol.io/quickstart" target="_blank" rel="noopener">快速入门（MCP Quickstart）</a>：不到 5 分钟即可开始使用 MCP，可在 Claude 桌面应用和本地服务之间建立安全连接（以上的 “lencx 演示” 就是基于该部分文档实现）。</li><li><a href="https://modelcontextprotocol.io/docs/first-server/python" target="_blank" rel="noopener">构建第一个 Python 服务 (MCP Python)</a>：15 分钟内用 Python 创建一个简单的 MCP 服务器。</li><li><a href="https://modelcontextprotocol.io/docs/first-server/typescript" target="_blank" rel="noopener">构建第一个 TypeScript 服务（MCP TypeScript）</a>：15 分钟内用 TypeScript 创建一个简单的 MCP 服务器。</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>开发 MCP 服务器或将其与应用程序集成时，有效的调试至关重要。所以 MCP 提供了几种不同层次的调试工具：</p><ul><li><a href="https://modelcontextprotocol.io/docs/tools/inspector" target="_blank" rel="noopener">MCP 检查器（MCP Inspector）</a>：交互式调试界面；直接服务器测试</li><li>Claude 桌面开发工具（Claude Desktop Developer Tools）：集成测试；日志收集；Chrome DevTools 集成</li><li>服务器日志（Server Logging）：自定义日志记录实现；错误追踪；性能监控</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个极简单的 MCP 协议使用示例：</p><ul><li>安装预构建的 MCP 服务器：通过 Claude Desktop 应用程序安装预构建的 MCP 服务器。</li><li>编写 Server 端代码：根据 MCP 协议定义，创建一个 MCP 服务器，提供资源、工具或提示词。</li><li>编写 Client 端代码：创建一个 MCP 客户端，与服务器建立连接，并请求使用服务器提供的资源或工具。</li></ul><p>以下是一个使用 TypeScript 实现的简单 MCP 协议示例，展示了如何创建一个 MCP 服务器和客户端，并通过它们进行通信。</p><p>环境要求：</p><ul><li>Node.js (v18+)</li><li>Python (v3.8+)</li></ul><h3 id="1-创建-MCP-服务器"><a href="#1-创建-MCP-服务器" class="headerlink" title="1. 创建 MCP 服务器"></a>1. 创建 MCP 服务器</h3><p>首先，安装必要的依赖项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @modelcontextprotocol/sdk</span><br></pre></td></tr></table></figure><p>然后，创建一个简单的 MCP 服务器，该服务器提供一个工具，用于计算两个数字的和：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Server, StdioServerTransport &#125; <span class="keyword">from</span> <span class="string">'@modelcontextprotocol/sdk/server/index.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  CallToolRequestSchema,</span><br><span class="line">  ListToolsRequestSchema,</span><br><span class="line">  McpError,</span><br><span class="line">  ErrorCode,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@modelcontextprotocol/sdk/types.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> Server(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'mcp-server'</span>,</span><br><span class="line">    version: <span class="string">'1.0.0'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    capabilities: &#123;</span><br><span class="line">      tools: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出可用工具</span></span><br><span class="line">server.setRequestHandler(ListToolsRequestSchema, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tools: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'calculate_sum'</span>,</span><br><span class="line">        description: <span class="string">'Add two numbers together'</span>,</span><br><span class="line">        inputSchema: &#123;</span><br><span class="line">          <span class="keyword">type</span>: <span class="string">'object'</span>,</span><br><span class="line">          properties: &#123;</span><br><span class="line">            a: &#123; <span class="keyword">type</span>: <span class="string">'number'</span> &#125;,</span><br><span class="line">            b: &#123; <span class="keyword">type</span>: <span class="string">'number'</span> &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          required: [<span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理工具调用</span></span><br><span class="line">server.setRequestHandler(CallToolRequestSchema, <span class="keyword">async</span> request =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.params.name === <span class="string">'calculate_sum'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; a, b &#125; = request.params.arguments;</span><br><span class="line">    <span class="keyword">return</span> &#123; toolResult: a + b &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> McpError(ErrorCode.ToolNotFound, <span class="string">'Tool not found'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> StdioServerTransport();</span><br><span class="line"><span class="keyword">await</span> server.connect(transport);</span><br></pre></td></tr></table></figure><h3 id="2-创建-MCP-客户端"><a href="#2-创建-MCP-客户端" class="headerlink" title="2. 创建 MCP 客户端"></a>2. 创建 MCP 客户端</h3><p>接下来，创建一个 MCP 客户端，用于调用服务器提供的工具：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Client, StdioClientTransport &#125; <span class="keyword">from</span> <span class="string">'@modelcontextprotocol/sdk/client/index.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ListToolsRequestSchema, CallToolRequestSchema &#125; <span class="keyword">from</span> <span class="string">'@modelcontextprotocol/sdk/types.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transport = <span class="keyword">new</span> StdioClientTransport(&#123;</span><br><span class="line">  command: <span class="string">'node'</span>,</span><br><span class="line">  args: [<span class="string">'server.js'</span>], <span class="comment">// 确保服务器脚本路径正确</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> Client(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'mcp-client'</span>,</span><br><span class="line">    version: <span class="string">'1.0.0'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    capabilities: &#123;</span><br><span class="line">      tools: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> client.connect(transport);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出工具</span></span><br><span class="line"><span class="keyword">const</span> tools = <span class="keyword">await</span> client.request(&#123; method: <span class="string">'tools/list'</span> &#125;, ListToolsRequestSchema);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Available Tools:'</span>, tools);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用工具</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> client.request(</span><br><span class="line">  &#123;</span><br><span class="line">    method: <span class="string">'tools/call'</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">      name: <span class="string">'calculate_sum'</span>,</span><br><span class="line">      <span class="built_in">arguments</span>: &#123; a: <span class="number">5</span>, b: <span class="number">3</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  CallToolRequestSchema</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Tool Result:'</span>, result);</span><br></pre></td></tr></table></figure><h3 id="3-运行示例"><a href="#3-运行示例" class="headerlink" title="3. 运行示例"></a>3. 运行示例</h3><ul><li>启动服务器：运行<code>node server.js</code>启动 MCP 服务器。</li><li>启动客户端：运行<code>node client.js</code>启动 MCP 客户端。</li><li>观察输出：客户端会列出可用工具，并调用<code>calculate_sum</code>工具，输出结果。</li></ul><h3 id="4-集成到Claude-Desktop"><a href="#4-集成到Claude-Desktop" class="headerlink" title="4. 集成到Claude Desktop"></a>4. 集成到<a href="https://claude.ai/download" target="_blank" rel="noopener">Claude Desktop</a></h3><p>如果需要将 MCP 服务器集成到<a href="https://claude.ai/download" target="_blank" rel="noopener"><code>Claude Desktop</code></a>，可以在<code>claude_desktop_config.json</code>中添加服务器配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mcpServers"</span>: &#123;</span><br><span class="line">    <span class="attr">"mcp-server"</span>: &#123;</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"/path/to/your/mcp-server/build/index.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="工具平台结合"><a href="#工具平台结合" class="headerlink" title="工具平台结合"></a>工具平台结合</h3><p>如 Cline 的结合：</p><p><img src="/images/ai/mcp/p-2.png" alt="p-2.png"></p><h3 id="社区插件应用"><a href="#社区插件应用" class="headerlink" title="社区插件应用"></a>社区插件应用</h3><p>如：</p><ul><li><a href="https://github.com/ryanjoachim/mcp-rtfm?ref=cline.ghost.io" target="_blank" rel="noopener">mcp-rtfm</a>：智能文档获取</li><li><a href="https://github.com/modelcontextprotocol/servers?ref=cline.ghost.io" target="_blank" rel="noopener">mcp-postman</a>：API 测试</li><li><a href="https://github.com/executeautomation/mcp-playwright?ref=cline.ghost.io" target="_blank" rel="noopener">mcp-playwright</a>：浏览器自动化</li><li><a href="https://github.com/hannesrudolph/sqlite-explorer-fastmcp-mcp-server?ref=cline.ghost.io" target="_blank" rel="noopener">sqlite-explorer-fastmcp</a>：数据库分析</li><li><a href="https://github.com/zenturacp/mcp-rest-api?ref=cline.ghost.io" target="_blank" rel="noopener">mcp-rest-api</a>：REST API 测试</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MCP 协议为 AI 模型与外部数据源和工具的集成提供了一种标准化、安全且灵活的解决方案。通过客户端-服务器架构和 JSON-RPC 2.0 通信机制，MCP 能够实现本地和远程资源的无缝访问。随着越来越多的应用接入 MCP 协议，未来有望构建一个更加互联、高效的 AI 生态系统。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li>MCP 官网：<a href="https://modelcontextprotocol.io" target="_blank" rel="noopener">https://modelcontextprotocol.io</a></li><li>MCP GitHub：<a href="https://github.com/modelcontextprotocol" target="_blank" rel="noopener">https://github.com/modelcontextprotocol</a></li><li><a href="https://mp.weixin.qq.com/s/ASmcjW53HKokdYt1m-xyXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ASmcjW53HKokdYt1m-xyXA</a></li><li><a href="https://cline.bot/blog/the-developers-guide-to-mcp-from-basics-to-advanced-workflows" target="_blank" rel="noopener">https://cline.bot/blog/the-developers-guide-to-mcp-from-basics-to-advanced-workflows</a></li><li><a href="https://docs.cline.bot/mcp-servers/mcp?ref=cline.ghost.io" target="_blank" rel="noopener">https://docs.cline.bot/mcp-servers/mcp?ref=cline.ghost.io</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MCP-协议：连接-AI-模型与外部世界的桥梁&quot;&gt;&lt;a href=&quot;#MCP-协议：连接-AI-模型与外部世界的桥梁&quot; class=&quot;headerlink&quot; title=&quot;MCP 协议：连接 AI 模型与外部世界的桥梁&quot;&gt;&lt;/a&gt;MCP 协议：连接 AI 模型与外
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>AI 前端编程工具的一个得力助手——CopyCoder</title>
    <link href="http://blog.michealwayne.cn/2025/01/05/ai/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91AI%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94CopyCoder/"/>
    <id>http://blog.michealwayne.cn/2025/01/05/ai/【调研】AI前端编程工具——CopyCoder/</id>
    <published>2025-01-05T01:54:33.000Z</published>
    <updated>2025-01-12T11:52:45.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-前端编程工具的一个得力助手——CopyCoder"><a href="#AI-前端编程工具的一个得力助手——CopyCoder" class="headerlink" title="AI 前端编程工具的一个得力助手——CopyCoder"></a>AI 前端编程工具的一个得力助手——CopyCoder</h1><p>传统 ai 编程方式下，我们通过 chat 传入图片进行代码生成，但效果通常难以达到预期、与图片效果相差甚远，我们只有写入大量详细且准确的界面 prompt 才能让模型生成的代码符合界面预期，这种处理需要耗费大量的精力成本。<br>CopyCoder 正好就是解决了这种问题，更准确得来说，解决了<strong>传统 ai 编码方式对于图片 UI 信息提取不全或没有较好转为标准技术信息的问题</strong>。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://copycoder.ai/" target="_blank" rel="noopener">CopyCoder</a> 是一款创新的 AI 编程工具，其核心功能是通过用户上传的应用程序/网页截图、UI 设计图或完整的应用图像，自动<strong>生成详细的编码提示词</strong>。这些提示词涵盖了应用结构、组件规划和导入路径等内容，从而简化从设计到代码的转换过程。</p><p>官网地址：<a href="https://copycoder.ai/" target="_blank" rel="noopener">https://copycoder.ai/</a></p><blockquote><p>“Create powerful prompts for Cursor, Bolt, v0 &amp; more..”，从官网说明就可以知道，CopyCoder 是为了给 ai 代码生成工具提供合适的提示词、而不是替代这些 ai 代码生成工具。</p></blockquote><p><img src="/images/ai/copycoder/001.png" alt="001.png"></p><p>当前新用户有免费的 <strong>5 次试用</strong>，付费版本要每月 <strong>15 美元</strong>，付费版本中还支持后端代码生成。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>图像上传与分析</strong>：用户上传应用程序的截图、UI 设计图或完整的应用图像，CopyCoder 能分析这些图像。</li><li><strong>生成编码提示</strong>：基于上传的图像，CopyCoder 自动生成详细的编码提示词，提示词包括应用结构、组件规划和导入路径等。。</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>CopyCoder 的使用极为简单，即注册/登录后，传图等待 prompt 结果。得到结果后就交给其他 ai 代码生成应用进行处理。流程图如下：</p><p><img src="/images/ai/copycoder/003.png" alt="003.png"></p><ul><li>1.上传设计图：将设计图上传到 CopyCoder 平台。</li></ul><p><img src="/images/ai/copycoder/002.png" alt="002.png"></p><p>生成提示词：CopyCoder 会分析设计图并生成详细的编码提示词，包括项目结构、组件布局、样式要求等。</p><p><img src="/images/ai/copycoder/004.png" alt="004.png"></p><p>如项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. Project Structure:</span><br><span class="line"></span><br><span class="line">src/</span><br><span class="line">├── components/</span><br><span class="line">│   ├── layout/</span><br><span class="line">│   │   ├── DashboardLayout</span><br><span class="line">│   │   └── CardContainer</span><br><span class="line">│   ├── features/</span><br><span class="line">│   │   ├── SummaryCards</span><br><span class="line">│   │   ├── GrowthChart</span><br><span class="line">│   │   └── StockList</span><br><span class="line">│   └── shared/</span><br><span class="line">├── assets/</span><br><span class="line">├── styles/</span><br><span class="line">├── hooks/</span><br><span class="line">└── utils/</span><br></pre></td></tr></table></figure><p>CopyCoder 在官网上也有说明，其主推的技术栈是：TailwindCSS + React + Nextjs。在其生成的 prompt 中也有对应说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Style with Tailwind CSS utility classes for responsive design</span><br><span class="line">...</span><br><span class="line">Use Lucide React for icons (from lucide-react package). Do NOT use other UI libraries unless requested</span><br><span class="line">...</span><br><span class="line">Configure next.config.js image remotePatterns to enable stock photos from picsum.photos</span><br><span class="line">...</span><br><span class="line">Create root layout.tsx page that wraps necessary navigation items to all pages</span><br></pre></td></tr></table></figure><ul><li>2.使用提示词：将生成的提示词复制到 Cursor、Windsurf、Bolt 等 AI 编程工具中，自动生成相应的代码。</li></ul><p>本文不做此部分介绍</p><ul><li>3.调整和完善：根据生成的代码进行调整和完善，添加交互功能和动态效果。</li></ul><p>本文不做此部分介绍</p><h2 id="当前优缺点"><a href="#当前优缺点" class="headerlink" title="当前优缺点"></a>当前优缺点</h2><ul><li>优点：<ul><li>提高（ai）开发效率：通过自动生成编码提示词，大大减少写 prompt 的工作量。</li><li>简化设计到代码的转换：帮助开发者快速将设计图转化为可运行的代码。</li></ul></li><li>缺点：<ul><li>目前单次图像上传限制：目前仅支持一次上传一个图像。</li><li>技术栈限制，如 Vue 场景需要改造 prompt</li></ul></li></ul><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>CopyCoder 作为一款 AI 编程辅助工具，未来的发展方向可能包括：</p><ul><li>拓展技术栈、图片数量等限制</li><li>增强图像识别能力：提高对复杂设计图的识别和分析能力，生成更精确的编码提示词。</li><li>扩展功能范围：增加对更多编程语言和框架的支持，满足不同开发需求。</li><li>集成更多开发工具：与更多的开发工具和平台进行集成，提供更全面的开发解决方案。</li><li>提升用户体验：优化用户界面和操作流程，使工具更加易用和友好。</li></ul><p><strong>但是个人认为，CopyCoder 只是代码生成的前置环节，这部分能力很容易被 Cursor、Bolt 这些平台工具吸收借鉴，所以后续被替代的可能性很大</strong>，或者与这些工具平台合作，降低成本进行无缝对接。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://copycoder.ai/" target="_blank" rel="noopener">https://copycoder.ai/</a></li><li><a href="https://mp.weixin.qq.com/s/qtTBr38ydC2Jt2A1E8sAdw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qtTBr38ydC2Jt2A1E8sAdw</a></li><li><a href="https://ai-bot.cn/copycoder/" target="_blank" rel="noopener">https://ai-bot.cn/copycoder/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AI-前端编程工具的一个得力助手——CopyCoder&quot;&gt;&lt;a href=&quot;#AI-前端编程工具的一个得力助手——CopyCoder&quot; class=&quot;headerlink&quot; title=&quot;AI 前端编程工具的一个得力助手——CopyCoder&quot;&gt;&lt;/a&gt;AI 前端
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】React 组件性能分析工具——ReactScan</title>
    <link href="http://blog.michealwayne.cn/2024/12/08/react/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91React%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94ReactScan/"/>
    <id>http://blog.michealwayne.cn/2024/12/08/react/【工具】React组件性能分析工具——ReactScan/</id>
    <published>2024-12-08T02:54:23.000Z</published>
    <updated>2024-12-10T15:02:36.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-组件性能分析工具——React-Scan"><a href="#React-组件性能分析工具——React-Scan" class="headerlink" title="React 组件性能分析工具——React Scan"></a>React 组件性能分析工具——React Scan</h1><p>为什么会产生<a href="https://github.com/aidenybai/react-scan" target="_blank" rel="noopener">React Scan</a>这个分析工具？</p><p>我们知道，React 的性能优化有很多细节，以至于性能优化工作要做好会很琐碎且繁重。例如我们需要观测组件的封装力度、memo 的使用情况、hook/组件内的函数及数据定义、props 传参处理以及状态管理机制的设计等等等。<br>React Scan 团队将此关键原因归结于：<code>The issue is that component props are compared by reference, not value. This is intentional – this way rendering can be cheap to run.</code>，即“组件<code>props</code>是通过引用而不是值进行比较的”，React 的这个设计在带来了灵活性/实现简单的优势外，随之带来了容易导致不必要的渲染，使应用程序变慢，从而也使 React 性能问题分析具有较高的成本。</p><p>例如这个例子，<code>onClick</code> 函数和样式对象会在每次渲染时都要重新创建，这会导致组件拖慢应用的渲染速度：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ExpensiveComponent onClick=&#123;() =&gt; alert(<span class="string">'hi'</span>)&#125; style=&#123;&#123; <span class="attr">color</span>: <span class="string">'purple'</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>React Scan 作为分析工具，目的就是降低 React 性能优化的分析成本。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>React Scan 是一款开源的用于检测 React 应用渲染问题的工具，能自动检测和突出显示导致性能问题的渲染来帮助您识别这些问题，由 <a href="https://github.com/aidenybai" target="_blank" rel="noopener">Aiden Bai</a> 率先创建。它能够快速识别并报告潜在的性能瓶颈，帮助开发者优化应用性能。与传统的性能分析工具不同，React Scan 提供了一个简单的即插即用解决方案，可以通过脚本标签或 npm 包添加，以自动分析渲染性能，只需简单几步即可集成。</p><ul><li>自动渲染问题检测:React Scan 扫描您的 React 应用，查找可能导致性能问题的渲染问题。</li><li>简单易用:它是一个轻量级的 JavaScript 库，您可以通过 script 标签或 npm 等方式轻松集成到您的项目中。</li><li>快速集成:在任何其他脚本运行之前添加 React Scan 脚本，确保其能够准确地捕获渲染信息。</li></ul><p>React Scan 通过其高效的渲染问题扫描功能，显著提升了 React 应用的性能和稳定性。它简化了开发流程，减少了调试时间，让开发者能够专注于核心业务逻辑。选择 React Scan，意味着您将获得一个更稳定、更高效的 React 应用，并显著提升开发效率。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-scan -D</span><br></pre></td></tr></table></figure><p>script 引入 js：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-scan/dist/auto.global.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>官方提供的地址有时候会不太稳定，建议单独保存部署一份</p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="scan-options-Options-注册并启动分析工具"><a href="#scan-options-Options-注册并启动分析工具" class="headerlink" title="scan(options: Options)注册并启动分析工具"></a><code>scan(options: Options)</code>注册并启动分析工具</h4><p>在<strong>引入<code>react</code>之前</strong>进行注册，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; scan &#125; <span class="keyword">from</span> <span class="string">'react-scan'</span>; <span class="comment">// import this BEFORE react</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  scan(&#123;</span><br><span class="line">    enabled: <span class="literal">true</span>,</span><br><span class="line">    log: <span class="literal">true</span>, <span class="comment">// logs render info to console (default: false)</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scan(&#123;</span><br><span class="line">  enabled: <span class="literal">true</span>, <span class="comment">// 启用扫描</span></span><br><span class="line">  includeChildren: <span class="literal">true</span>, <span class="comment">// 包含子组件</span></span><br><span class="line">  playSound: <span class="literal">true</span>, <span class="comment">// 声音提示</span></span><br><span class="line">  log: <span class="literal">false</span>, <span class="comment">// 控制台日志</span></span><br><span class="line">  showToolbar: <span class="literal">true</span>, <span class="comment">// 显示工具栏</span></span><br><span class="line">  renderCountThreshold: <span class="number">0</span>,</span><br><span class="line">  report: <span class="literal">false</span>,</span><br><span class="line">  onCommitStart: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">  onRender: <span class="function">(<span class="params">fiber, render</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  onCommitFinish: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="useScan-options-Options-hook-的方式进行注册并启动分析工具"><a href="#useScan-options-Options-hook-的方式进行注册并启动分析工具" class="headerlink" title="useScan(options: Options)hook 的方式进行注册并启动分析工具"></a><code>useScan(options: Options)</code>hook 的方式进行注册并启动分析工具</h5><p>参数同<code>scan()</code></p><h4 id="withScan-Component-options-Options-设定组件扫描"><a href="#withScan-Component-options-Options-设定组件扫描" class="headerlink" title="withScan(Component, options: Options)设定组件扫描"></a><code>withScan(Component, options: Options)</code>设定组件扫描</h4><p>可将特定组件列入白名单，不扫描其他组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">withScan(Component, &#123;</span><br><span class="line">  enabled: <span class="literal">true</span>,</span><br><span class="line">  log: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ...其他配置项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="getReport-获取性能报告"><a href="#getReport-获取性能报告" class="headerlink" title="getReport()获取性能报告"></a><code>getReport()</code>获取性能报告</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scan(&#123; <span class="attr">report</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> report = getReport();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> component <span class="keyword">in</span> report) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, time &#125; = report[component];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;component&#125;</span>渲染<span class="subst">$&#123;count&#125;</span>次，耗时<span class="subst">$&#123;time&#125;</span>ms`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setOptions-options-Options-getOptions-设置-获取配置项"><a href="#setOptions-options-Options-getOptions-设置-获取配置项" class="headerlink" title="setOptions(options: Options)/getOptions()设置/获取配置项"></a><code>setOptions(options: Options)</code>/<code>getOptions()</code>设置/获取配置项</h4><h4 id="getRenderInfo-Component-获取指定组件渲染信息"><a href="#getRenderInfo-Component-获取指定组件渲染信息" class="headerlink" title="getRenderInfo(Component)获取指定组件渲染信息"></a><code>getRenderInfo(Component)</code>获取指定组件渲染信息</h4><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><p>工具注册成功后，界面上会出现 React Scan 的工具栏，如：</p><p><img src="/images/reactScan/p-use-01.png" alt="p-use-01"></p><p>工具栏默认会出现在界面右上角，我们也可以拖拽到界面其他地方</p><p>工具栏从左到右依次为：</p><ul><li><strong>选择组件分析</strong><ul><li>大概率与<code>getRenderInfo()</code>有关，后续有待分析源码</li></ul></li><li><strong>开启/关闭实时分析</strong><ul><li>大概率控制<code>scan()</code>，后续有待分析源码</li></ul></li><li><strong>开启/关闭声音</strong><ul><li>个人认为没啥用、提供情绪价值的功能</li></ul></li><li>“react-scan”用来拖拽异动工具栏</li></ul><p><img src="/images/reactScan/p-use-02.png" alt="p-use-02"></p><p>工具使用也很简单，在实时分析打开的时候，我们操作界面就可以观察到各视图组件的渲染更新情况，以此来发现不必要的渲染动作。</p><p><img src="/images/reactScan/p-use-03.png" alt="p-use-03"></p><p>如上图所示、不同层级之间的渲染更新通过颜色来区分。总体而言，个人感觉在中大型项目中还是很直观的。</p><h3 id="Monitoring监控能力"><a href="#Monitoring监控能力" class="headerlink" title="*Monitoring监控能力"></a>*<code>Monitoring</code>监控能力</h3><p>官方提供的 demo</p><p><a href="https://dashboard.react-scan.com/project/demo" target="_blank" rel="noopener">https://dashboard.react-scan.com/project/demo</a></p><h3 id="对-React-Native-的支持"><a href="#对-React-Native-的支持" class="headerlink" title="*对 React Native 的支持"></a>*对 React Native 的支持</h3><p>从评论和官方处理来看，目前 RN 检测会有些问题，不过现阶段来看官网还是积极处理的、且目前反馈用例均已处理：</p><p><a href="https://github.com/aidenybai/react-scan/pull/23" target="_blank" rel="noopener">https://github.com/aidenybai/react-scan/pull/23</a></p><p><img src="/images/reactScan/p-rn-01.png" alt="p-rn-01.png"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>React Scan 工作原理主要是通过监控 React 的协调过程。该过程在更新时比较组件的前后快照。当状态或属性发生变化时，React 需要执行 ‘diffing’ 以确定需要重新渲染的内容。React Scan 自动检测这些渲染周期，并通过视觉提示突出显示导致性能问题的组件。它分析组件树，识别由不稳定的属性或低效的更新模式引起的不必要的重新渲染。</p><p>其相关代码实现待后续跟进分析。。。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://react-scan.com/" target="_blank" rel="noopener">https://react-scan.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-组件性能分析工具——React-Scan&quot;&gt;&lt;a href=&quot;#React-组件性能分析工具——React-Scan&quot; class=&quot;headerlink&quot; title=&quot;React 组件性能分析工具——React Scan&quot;&gt;&lt;/a&gt;React 组件
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能" scheme="http://blog.michealwayne.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="react" scheme="http://blog.michealwayne.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】“xx packages are looking for funding”——npm fund命令及运行机制</title>
    <link href="http://blog.michealwayne.cn/2024/11/18/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91npm%20fund%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.michealwayne.cn/2024/11/18/notes/【笔记】npm fund命令/</id>
    <published>2024-11-18T14:59:45.000Z</published>
    <updated>2024-11-19T14:29:31.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“xx-packages-are-looking-for-funding”——npm-fund-命令及运行机制"><a href="#“xx-packages-are-looking-for-funding”——npm-fund-命令及运行机制" class="headerlink" title="“xx packages are looking for funding”——npm fund 命令及运行机制"></a>“xx packages are looking for funding”——npm fund 命令及运行机制</h1><p>在 Node.js 和 <code>npm</code> 生态系统中，开源项目的持续发展和维护常常依赖于贡献者的支持和资助。为了让开发者更容易了解他们依赖的项目哪些有资金支持选项，npm 在<code>6.13.0</code>版本起引入了 <code>npm fund</code> 命令并默认在<code>npm install</code>安装依赖时触发。本文将详细介绍 <code>npm fund</code> 的作用、运行机制、触发时机、如何避免触发以及相关的副作用和改进建议。</p><h2 id="什么是-npm-fund-命令？"><a href="#什么是-npm-fund-命令？" class="headerlink" title="什么是 npm fund 命令？"></a>什么是 npm fund 命令？</h2><p>在日常<code>npm install</code>安装依赖的过程中，我们可能都忽略了 command 最后输出的一些信息，比如本文相关的 funding 信息，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 packages are looking for funding.</span><br><span class="line">Run &quot;npm fund&quot; to find out more.</span><br></pre></td></tr></table></figure><p><code>npm fund</code> 命令是在 <a href="https://dev.to/ruyadorno/npm-6-13-0-7f3" target="_blank" rel="noopener">npm <code>6.13.0</code></a> 版本中首次引入的，旨在帮助开发者识别其项目依赖中可以资助的开源包。运行该命令时，npm 会列出所有包含资助选项的包及其相关链接，便于开发者快速访问这些页面并提供支持。</p><h3 id="命令起源"><a href="#命令起源" class="headerlink" title="命令起源"></a>命令起源</h3><p>在 2019 年 8 月份时，<a href="https://standardjs.com/" target="_blank" rel="noopener">Standard JS</a> 在其开源项目中<a href="https://github.com/standard/standard/issues/1381" target="_blank" rel="noopener">内置广告的事件</a>引发热议，这些广告通过一个名为 <code>Funding</code> 的 <code>npm</code> 软件包展示在终端，该软件包包含在 <code>Standard</code> 的代码库中。之后 <code>npm</code> 公司宣布将禁止此类终端广告行为。</p><p>此事件后，<code>npm</code> 公司表示，它打算在年底前为开源开发人员开发一个众筹平台，于是乎在<a href="https://dev.to/ruyadorno/npm-6-13-0-7f3" target="_blank" rel="noopener"><code>npm 6.13.0</code></a>版本上提供了相应支持，这就是<code>npm fund</code>命令的主要由来。</p><h3 id="命令作用"><a href="#命令作用" class="headerlink" title="命令作用"></a>命令作用</h3><ul><li><strong>显示资助信息</strong>：<code>npm fund</code> 会扫描项目中的 <code>node_modules</code> 目录，查找每个包的 <code>package.json</code> 文件中是否包含 <code>funding</code> 字段。它会将有资助选项的包及其资助链接列出。</li><li><strong>支持开源生态</strong>：通过此功能，<code>npm</code> 提高了对开源项目资助的透明度，鼓励开发者参与到开源项目的资助中，帮助维护者获得资金支持。</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>基本用法非常简单，只需在项目根目录中运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm fund</span><br></pre></td></tr></table></figure><p>命令将输出形如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx packages are looking for funding</span><br><span class="line">run `npm fund` for details</span><br></pre></td></tr></table></figure><p>再运行 npm fund，就会显示类似如下的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package-name   https://example.com/donate</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├─┬ https://opencollective.com/typescript-eslint</span><br><span class="line">│ │ └── @typescript-eslint/eslint-plugin@4.28.5, @typescript-eslint/experimental-utils@4.28.5, @typescript-eslint/types@4.28.5, @typescript-eslint/typescript-estree@4.28.5, @typescript-eslint/visitor-keys@4.28.5, @typescript-eslint/scope-manager@4.28.5, @typescript-eslint/parser@4.28.5</span><br><span class="line">│ └─┬ https://opencollective.com/eslint</span><br><span class="line">│   │ └── eslint@6.8.0</span><br><span class="line">│   ├── https://github.com/sponsors/epoberezkin</span><br><span class="line">│   │   └── ajv@6.12.6</span><br><span class="line">│   ├── https://github.com/sponsors/sindresorhus</span><br><span class="line">│   │   └── globals@12.4.0, import-fresh@3.3.0, strip-json-comments@3.1.1, ansi-escapes@4.3.2, type-fest@0.21.3, figures@3.2.0, onetime@5.1.2, globby@11.0.4</span><br><span class="line">│   ├── https://github.com/sponsors/isaacs</span><br><span class="line">│   │   └── glob@7.2.3</span><br><span class="line">│   ├─┬ https://github.com/chalk/chalk?sponsor=1</span><br><span class="line">│   │ │ └── chalk@4.1.2</span><br><span class="line">│   │ └── https://github.com/chalk/ansi-styles?sponsor=1</span><br><span class="line">│   │     └── ansi-styles@4.3.0</span><br><span class="line">│   └── https://github.com/sponsors/ljharb</span><br><span class="line">│       └── minimist@1.2.8, is-generator-function@1.0.9, qs@6.11.2, side-channel@1.0.4, call-bind@1.0.2, get-intrinsic@1.1.1, has-symbols@1.0.2, object-inspect@1.11.0</span><br><span class="line">├── https://github.com/sponsors/RubenVerborgh</span><br><span class="line">│   └── follow-redirects@1.15.2</span><br><span class="line">└── https://ko-fi.com/tunnckoCore/commissions</span><br><span class="line">    └── formidable@1.2.2</span><br></pre></td></tr></table></figure><h2 id="npm-fund-的运行机制和触发时机"><a href="#npm-fund-的运行机制和触发时机" class="headerlink" title="npm fund 的运行机制和触发时机"></a>npm fund 的运行机制和触发时机</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ul><li><p><strong>依赖扫描</strong>：<code>npm fund</code> 会读取 <code>node_modules</code> 中每个依赖包的 <code>package.json</code> 文件，寻找 <a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json#funding" target="_blank" rel="noopener"><code>funding</code> 字段</a>。如果找到了该字段，它会提取并显示相关的资助信息。</p><ul><li>字段格式：<code>funding</code> 字段可以是 URL 字符串或更复杂的对象，指向资助页面。例如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"funding"</span>: <span class="string">"https://example.com/donate"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"funding"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"individual"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://example.com/donate"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h3><ul><li><strong><code>npm install</code> 提示</strong>：在安装项目依赖时，如果项目中存在可以资助的包，<code>npm</code> 会显示类似<code>“xx packages are looking for funding”</code>的提示，提醒开发者可以运行 <code>npm fund</code> 查看详细信息。（这也是我们日常主要触发的时机）</li><li><strong>显式调用</strong>：开发者可以手动运行 <code>npm fund</code> 命令，以查看当前项目中支持资助的所有包和资助链接。</li></ul><h3 id="如何避免-npm-fund-的触发？"><a href="#如何避免-npm-fund-的触发？" class="headerlink" title="如何避免 npm fund 的触发？"></a>如何避免 npm fund 的触发？</h3><p>在某些情况下，开发者或企业可能希望在 <code>npm install</code> 过程中避免看到这些资助提示。以下是两种实现方式：</p><h4 id="1-在安装时使用-no-fund-参数"><a href="#1-在安装时使用-no-fund-参数" class="headerlink" title="1. 在安装时使用 --no-fund 参数"></a>1. 在安装时使用 <code>--no-fund</code> 参数</h4><p>直接在运行 <code>npm install</code> 时添加 <code>--no-fund</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --no-fund</span><br></pre></td></tr></table></figure><h4 id="2-修改-npmrc-配置文件"><a href="#2-修改-npmrc-配置文件" class="headerlink" title="2. 修改 .npmrc 配置文件"></a>2. 修改 <code>.npmrc</code> 配置文件</h4><p>在 <code>.npmrc</code> 文件中加入以下配置来永久禁用资助提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fund=false</span><br></pre></td></tr></table></figure><p>此配置可以放在项目的根目录下（项目下的<code>.npmrc</code>文件），仅作用于当前项目；也可以放在用户主目录（<code>~/.npmrc</code>文件），作用于全局。</p><blockquote><p>*可以通过<code>npm config ls -l</code>查看当前项目的<code>npm</code>配置，默认情况下<code>fund</code>配置会被设置为<code>true</code></p></blockquote><h4 id="禁用-npm-fund-的副作用"><a href="#禁用-npm-fund-的副作用" class="headerlink" title="禁用 npm fund 的副作用"></a>禁用 npm fund 的副作用</h4><p>优点：</p><ul><li><strong>简洁输出</strong>：禁用 <code>npm fund</code> 提示可以减少 <code>npm install</code> 的输出信息，使终端显示更加清晰。</li><li><strong>减少干扰</strong>：在企业级项目中，开发者可能更专注于安装过程和依赖的调试，不需要额外的资助提示。</li></ul><p>缺点：</p><ul><li><strong>支持意识减弱</strong>：禁用该提示后，开发者不再会注意到可以资助的依赖，可能错失支持有价值的开源项目的机会。</li><li><strong>透明度降低</strong>：新加入的团队成员或不熟悉项目的开发者可能不知道项目中有哪些包有资助选项。</li><li><strong>开源支持意识降低</strong>：从长远来看，减少对资助信息的提示可能会让开发者对支持开源项目的重要性淡化，从而减少对依赖项目的贡献和支持。</li></ul><h2 id="npm-fund-源码"><a href="#npm-fund-源码" class="headerlink" title="npm fund 源码"></a>npm fund 源码</h2><p>源码文件：<a href="https://github.com/npm/cli/blob/latest/lib/commands/fund.js" target="_blank" rel="noopener">https://github.com/npm/cli/blob/latest/lib/commands/fund.js</a></p><p>以目前（2024-11）的源码内容来看，其源码机制概括来说是先使用 <code>npm</code> 的内部模块库函数来遍历 <code>node_modules</code> 目录，读取 <code>package.json</code> 并检查是否有 <code>funding</code> 字段，最后将所有符合条件的包信息格式化输出到终端。</p><p>代码流程总结：</p><ul><li>1.读取依赖树：使用 <code>Arborist</code> 加载项目的依赖树。</li><li>2.解析资助信息：通过 <code>libnpmfund</code> 的 <code>readTree</code> 方法提取资助信息。</li><li>3.输出格式化：根据用户配置输出 JSON 格式或使用 <code>archy</code> 进行可读格式的输出。</li><li>4.链接打开：当提供了包名时，<code>openFundingUrl</code> 会尝试在浏览器中打开该包的资助链接。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>npm fund</code> 是 <code>npm</code> 引入的一个有用的命令，帮助开发者支持开源项目并维持开源生态的可持续发展。虽然在某些情况下禁用它有其合理性，但在默认情况下保留该提示可以提高团队对开源项目支持的意识。根据项目和团队的实际需求，开发者可以灵活选择是否禁用 <code>npm fund</code> 提示。</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://docs.npmjs.com/cli/v6/commands/npm-fund" target="_blank" rel="noopener">npm fund</a></li><li><a href="https://dev.to/ruyadorno/npm-6-13-0-7f3" target="_blank" rel="noopener">npm 6.13.0</a></li><li><a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json#funding" target="_blank" rel="noopener">npm config——funding</a></li><li><a href="https://stackoverflow.com/questions/58972251/what-does-x-packages-are-looking-for-funding-mean-when-running-npm-install" target="_blank" rel="noopener">What does ‘x packages are looking for funding’ mean when running <code>npm install</code>?</a></li><li><a href="https://docs.npmjs.com/cli-documentation/cli" target="_blank" rel="noopener">npm cli document</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“xx-packages-are-looking-for-funding”——npm-fund-命令及运行机制&quot;&gt;&lt;a href=&quot;#“xx-packages-are-looking-for-funding”——npm-fund-命令及运行机制&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="工程" scheme="http://blog.michealwayne.cn/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="nodejs" scheme="http://blog.michealwayne.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>【调研】通过Create.xyz的AIGC能力生产前端页面</title>
    <link href="http://blog.michealwayne.cn/2024/09/28/ai/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91%E9%80%9A%E8%BF%87Create.xyz%E7%9A%84AIGC%E8%83%BD%E5%8A%9B%E7%94%9F%E4%BA%A7%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"/>
    <id>http://blog.michealwayne.cn/2024/09/28/ai/【调研】通过Create.xyz的AIGC能力生产前端页面/</id>
    <published>2024-09-28T03:33:01.000Z</published>
    <updated>2024-11-05T14:20:43.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过Create-xyz的AIGC能力生产前端页面"><a href="#通过Create-xyz的AIGC能力生产前端页面" class="headerlink" title="通过Create.xyz的AIGC能力生产前端页面"></a>通过Create.xyz的AIGC能力生产前端页面</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Create是什么？"><a href="#Create是什么？" class="headerlink" title="Create是什么？"></a>Create是什么？</h3><blockquote><p>Turn your words into sites, components, and tools - built with code.</p></blockquote><p>Create是一种新的人工智能创意工具，可以让任何人用自然语言进行构建。你可以用它来制作组件、网站、工具和应用程序。只要描述你想要它们的外观和工作方式，Create将用户的描述转化为实际的代码，实现所见即所得的设计理念。</p><p>地址：<a href="https://www.create.xyz/" target="_blank" rel="noopener">https://www.create.xyz/</a></p><p>效果图：</p><p><img src="/images/ai/create/001.png" alt="001.png"></p><p><img src="/images/ai/create/002.png" alt="002.png"></p><h3 id="Create有哪些能力？"><a href="#Create有哪些能力？" class="headerlink" title="Create有哪些能力？"></a>Create有哪些能力？</h3><p>Create.xyz的核心能力在于其能够理解自然语言描述（prompts），并将其转化为代码，生成静态页面和简单的CRUD页面。以下是其主要特点：</p><ul><li><strong>自然语言/图片转代码</strong>：用户可以通过描述或上传图片来生成页面。</li><li><strong>代码生成</strong>：将描述转化为代码，支持组件和API的生成。</li><li><strong>多模态支持</strong>：支持将图片转换为代码，实现Screenshot to App的功能。</li></ul><h4 id="1-结合大模型能力，将描述（prompt）转化为代码"><a href="#1-结合大模型能力，将描述（prompt）转化为代码" class="headerlink" title="1.结合大模型能力，将描述（prompt）转化为代码"></a>1.结合大模型能力，将描述（prompt）转化为代码</h4><p>Create turns your descriptions into code, so it looks and work how you want.</p><p>E.g. “Create a Table to describe user’s info.”, “创建一个股票列表组件”</p><h5 id="1-1-生成组件Components"><a href="#1-1-生成组件Components" class="headerlink" title="1.1 生成组件Components"></a>1.1 生成组件Components</h5><p>Quickly make components to build powerful projects or match your brand</p><p>E.g. “A pie chart to show the distribution.”, “根据图片信息生成一个列表组件”</p><p><img src="/images/ai/create/003.png" alt="003.png"></p><h5 id="1-2-生成接口API"><a href="#1-2-生成接口API" class="headerlink" title="1.2 生成接口API"></a>1.2 生成接口API</h5><p>Bring your own REST API.Upload your Swagger docs and have Create build you a tool that talks to your own custom APIs.</p><p>Create的数据生成从结果来看相对简单，目测是在prompt中约束了使用fetch API以及增加了自己数据库的调用信息和表信息（text2sql方式）。另外我们也可以指定要ajax请求某个接口，但需要在描述中解释清楚接口出入参信息。</p><p>E.g.”查询用户所有数据”（需要打database标签）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/db/tempdata'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        query: <span class="string">'SELECT * FROM `users`'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      setUsers(data.result);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h5 id="1-3-（平台能力）托管代码和页面部署能力"><a href="#1-3-（平台能力）托管代码和页面部署能力" class="headerlink" title="1.3 （平台能力）托管代码和页面部署能力"></a>1.3 （平台能力）托管代码和页面部署能力</h5><p>产生可直接访问的地址，如<a href="https://www.create.xyz/app/4cafb2c9-ba16-4288-984d-9a59ea102eab" target="_blank" rel="noopener">https://www.create.xyz/app/4cafb2c9-ba16-4288-984d-9a59ea102eab</a></p><h4 id="2-多模态，将图片转换为代码"><a href="#2-多模态，将图片转换为代码" class="headerlink" title="2.多模态，将图片转换为代码"></a>2.多模态，将图片转换为代码</h4><p>Screenshot to app，Drop an image of what you want into your description to build it</p><h3 id="Create的综合评估"><a href="#Create的综合评估" class="headerlink" title="Create的综合评估"></a>Create的综合评估</h3><p>stage2.5的形式（介于低代码到完全aigc之间）。</p><p>主要优势是产品形态（工作台）很完备、确实可以在这个工作台通过ai生成+修改完成简单页面的创建，主要问题是生成的组件几乎是“非受控”、“一次性”的、不太能复用（这个问题平台可以通过工程手段解决）。</p><ul><li><p>输入：图片或需求prompt</p></li><li><p>输出：是代码(React组件+tailwind原子类css)、非DSL</p></li><li><p>能力实现概括：基于claude/gpt-4等模型生成UI组件/模块的代码</p></li><li><p>UI能力：支持“原子组件”、“模块”、“应用页面”的代码生成和静态组装</p></li><li><p>事件交互：仅支持简单事件的配置生成（点击跳转），前端没有状态管理能力</p></li><li><p>数据处理：默认生成的结果是静态“假”数据，需要在prompt声明调xxx接口才会改为取接口形式（结果需要修改）；和大多低码平台一样开放了Database能力、可进行数据的存取（prompt2sql）</p></li></ul><hr><h2 id="Create的实现"><a href="#Create的实现" class="headerlink" title="Create的实现"></a>Create的实现</h2><p>整体使用下来，Create的生产公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page = Components + Functions + Datas(database) + *Assets</span><br></pre></td></tr></table></figure><p>→   Sites or Apps = Page1 + Page2…</p><p>Create核心的代码生成能力没有自训练模型，而是使用了Claude Sonnet3.5、gpt4等模型API，因此虽然具体实现是闭源黑盒的、但实现会类似于<a href="https://screenshottocode.com" target="_blank" rel="noopener">screenshot-to-code</a>之类的通过区分生成场景、指令要求和控制上下文来把控生成效果。</p><p>实现思路：</p><p>1.自上而下拆分、渐进明细</p><ul><li>自上而下进行需求拆分</li><li>根据需求进行prompt拆分、泛化及转换</li></ul><p><img src="/images/ai/create/004.png" alt="004.png"></p><p>2.推崇组件生产模式：</p><ul><li>组件生产的工程方式能力更强，You can create much more powerful apps if you break your project into components.</li><li>推荐prompt不应该太复杂，如果复杂，拆到组件：If it gets too long or complex, you can move things into components to build up.</li></ul><h3 id="原子能力（Component、Function、Database）的实现"><a href="#原子能力（Component、Function、Database）的实现" class="headerlink" title="原子能力（Component、Function、Database）的实现"></a>原子能力（Component、Function、Database）的实现</h3><h4 id="1-1-Component组件"><a href="#1-1-Component组件" class="headerlink" title="1.1 Component组件"></a>1.1 Component组件</h4><p>组件的产物代码为 React + Tailwind CSS 技术栈、遵循 函数式组件 + UI受控组件的 编码模式。</p><ul><li>优点：灵活，发挥空间大</li><li>问题：比较难受控，生产的组件是“一次性”的、不太能复用（这个问题平台可以通过工程手段解决）</li></ul><p>E.g.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainComponent</span>(<span class="params">&#123; stockData &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"bg-white rounded-lg shadow-md p-4"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"flex justify-between mb-2"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"flex space-x-4"</span>&gt;</span><br><span class="line">          &lt;span className=<span class="string">"text-gray-500"</span>&gt;个股资金&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span className="text-gray-500"&gt;板块资金&lt;/</span>span&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="flex space-x-4 text-gray-500"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span&gt;今日&lt;/</span>span&gt;</span><br><span class="line">          &lt;span&gt;近<span class="number">5</span>日&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span&gt;近20日&lt;/</span>span&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;table className=<span class="string">"w-full"</span>&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr className=<span class="string">"text-gray-500 text-sm"</span>&gt;</span><br><span class="line">            &lt;th className=<span class="string">"text-left py-2"</span>&gt;名称/代码&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th className="text-right py-2"&gt;主力净流入&lt;/</span>th&gt;</span><br><span class="line">            &lt;th className=<span class="string">"text-right py-2"</span>&gt;最新&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th className="text-right py-2"&gt;涨跌幅&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;stockData.map(<span class="function">(<span class="params">stock, index</span>) =&gt;</span> (</span><br><span class="line">            &lt;tr key=&#123;index&#125; className=<span class="string">"border-t border-gray-200"</span>&gt;</span><br><span class="line">              &lt;td className=<span class="string">"py-2"</span>&gt;</span><br><span class="line">                &lt;div&gt;&#123;stock.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div className="text-gray-500 text-sm"&gt;&#123;stock.code&#125;&lt;/</span>div&gt;</span><br><span class="line">              &lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">              &lt;td className="text-right text-red-600"&gt;&#123;stock.inflow&#125;&lt;/</span>td&gt;</span><br><span class="line">              &lt;td className=<span class="string">"text-right"</span>&gt;&#123;stock.price&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">              &lt;td className="text-right text-red-600"&gt;&#123;stock.change&#125;&lt;/</span>td&gt;</span><br><span class="line">            &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tbody&gt;</span><br><span class="line">      &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StoryComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> exampleStockData = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'公司A'</span>, <span class="attr">code</span>: <span class="string">'000001'</span>, <span class="attr">inflow</span>: <span class="string">'10亿'</span>, <span class="attr">price</span>: <span class="string">'20.5'</span>, <span class="attr">change</span>: <span class="string">'1.2%'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'公司B'</span>, <span class="attr">code</span>: <span class="string">'000002'</span>, <span class="attr">inflow</span>: <span class="string">'5亿'</span>, <span class="attr">price</span>: <span class="string">'15.3'</span>, <span class="attr">change</span>: <span class="string">'-0.8%'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainComponent stockData=&#123;exampleStockData&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>对应解析后的prompt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Background color: White</span><br><span class="line">Border: Rounded corners</span><br><span class="line">Shadow: Medium Shadow</span><br><span class="line">Padding: Medium</span><br><span class="line"> </span><br><span class="line">Header section</span><br><span class="line">Layout: Horizontal distribution with two sections</span><br><span class="line">Left Section: Contains two labels &quot;个股资金&quot; and &quot;板块资金&quot; in gray text</span><br><span class="line">Right Section: Contains three labels &quot;今日&quot;, &quot;近5日&quot;, &quot;近20日&quot; in gray text</span><br><span class="line"> </span><br><span class="line">Table</span><br><span class="line">Full width</span><br><span class="line">Header:</span><br><span class="line">Text color: Gray</span><br><span class="line">Text size: Small</span><br><span class="line">Column titles: 左对齐:名称/代码, 右对齐:主力净流入, 最新, 涨跌幅</span><br><span class="line">Rows:</span><br><span class="line">Border-top: Light gray</span><br><span class="line">Name column:</span><br><span class="line">Stock name in default text</span><br><span class="line">Stock code in gray, small text</span><br><span class="line">Inflow and Change columns: Right-aligned, red text</span><br><span class="line">Price column: Right-aligned default text</span><br></pre></td></tr></table></figure><p>底层prompt感觉可以参考<a href="https://github.com/abi/screenshot-to-code/blob/main/backend/prompts/screenshot_system_prompts.py" target="_blank" rel="noopener">screenshot-to-code</a>的prompt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">You are an expert React/Tailwind developer</span><br><span class="line">You take screenshots of a reference web page from the user, and then build single page apps </span><br><span class="line">using React and Tailwind CSS.</span><br><span class="line">You might also be given a screenshot(The second image) of a web page that you have already built, and asked to</span><br><span class="line">update it to look more like the reference image(The first image).</span><br><span class="line"></span><br><span class="line">- Make sure the app looks exactly like the screenshot.</span><br><span class="line">- Pay close attention to background color, text color, font size, font family, </span><br><span class="line">padding, margin, border, etc. Match the colors and sizes exactly.</span><br><span class="line">- Use the exact text from the screenshot.</span><br><span class="line">- Do not add comments in the code such as &quot;&lt;!-- Add other navigation links as needed --&gt;&quot; and &quot;&lt;!-- ... other news items ... --&gt;&quot; in place of writing the full code. WRITE THE FULL CODE.</span><br><span class="line">- Repeat elements as needed to match the screenshot. For example, if there are 15 items, the code should have 15 items. DO NOT LEAVE comments like &quot;&lt;!-- Repeat for each news item --&gt;&quot; or bad things will happen.</span><br><span class="line">- For images, use placeholder images from https://placehold.co and include a detailed description of the image in the alt text so that an image generation AI can generate the image later.</span><br><span class="line"></span><br><span class="line">In terms of libraries,</span><br><span class="line"></span><br><span class="line">- Use these script to include React so that it can run on a standalone page:</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/react/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">- Use this script to include Tailwind: &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;</span><br><span class="line">- You can use Google Fonts</span><br><span class="line">- Font Awesome for icons: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css&quot;&gt;&lt;/link&gt;</span><br><span class="line"></span><br><span class="line">Return only the full code in &lt;html&gt;&lt;/html&gt; tags.</span><br><span class="line">Do not include markdown &quot;```&quot; or &quot;```html&quot; at the start or end.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="1-2-Database数据"><a href="#1-2-Database数据" class="headerlink" title="1.2 Database数据"></a>1.2 Database数据</h4><p>这部分处理相对简单，fetch API + REST api + Text2Sql 模式</p><p>代码如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'/api/db/tempdata'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        query: <span class="string">'SELECT * FROM `users`'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      setUsers(data.result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> addUser = <span class="function">(<span class="params">name, score</span>) =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'/api/db/tempdata'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        query: <span class="string">"INSERT INTO `users` (`name`, `score`) VALUES (?, ?)"</span>,</span><br><span class="line">        values: [name, score]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setUsers([...users, &#123; <span class="attr">id</span>: <span class="built_in">Date</span>.now(), name, score &#125;]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> deleteUser = <span class="function">(<span class="params">userId</span>) =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'/api/db/tempdata'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        query: <span class="string">"DELETE FROM `users` WHERE `id` = ?"</span>,</span><br><span class="line">        values: [userId]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setUsers(users.filter(<span class="function"><span class="params">user</span> =&gt;</span> user.id !== userId));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> updateUser = <span class="function">(<span class="params">userId, name, score</span>) =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'/api/db/tempdata'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        query: <span class="string">"UPDATE `users` SET `name` = ?, `score` = ? WHERE `id` = ?"</span>,</span><br><span class="line">        values: [name, score, userId]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setUsers(users.map(<span class="function"><span class="params">user</span> =&gt;</span> user.id === userId ? &#123; ...user, name, score &#125; : user));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>对应prompt：</p><p><img src="/images/ai/create/005.png" alt="005.png"></p><p>操作请求：</p><p><img src="/images/ai/create/006.png" alt="006.png"></p><h4 id="1-3-Function逻辑处理-工具方法"><a href="#1-3-Function逻辑处理-工具方法" class="headerlink" title="1.3 Function逻辑处理/工具方法"></a>1.3 Function逻辑处理/工具方法</h4><p>自然语言说明规则，通过模型生成对应的处理函数代码</p><p>代码如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">&#123; score &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (score &gt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">result</span>: <span class="string">'passed'</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">result</span>: <span class="string">'not passed'</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应prompt：</p><p><img src="/images/ai/create/007.png" alt="007.png"></p><h3 id="2-原子能力的组合——核心功能（菜单）"><a href="#2-原子能力的组合——核心功能（菜单）" class="headerlink" title="2.原子能力的组合——核心功能（菜单）"></a>2.原子能力的组合——核心功能（菜单）</h3><p><img src="/images/ai/create/008.png" alt="008.png"></p><h3 id="3-需求分析能力"><a href="#3-需求分析能力" class="headerlink" title="3.需求分析能力"></a>3.需求分析能力</h3><p>分析图片/prompt意图，并将简单的需求描述转为详细的、可用于开发实现的prompt</p><p>模型：Claude、GPT4、Gemini、Groq…</p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://www.create.xyz/" target="_blank" rel="noopener">create.xyz</a></li><li><a href="https://github.com/abi/screenshot-to-code/tree/main" target="_blank" rel="noopener">screenshot-to-code</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过Create-xyz的AIGC能力生产前端页面&quot;&gt;&lt;a href=&quot;#通过Create-xyz的AIGC能力生产前端页面&quot; class=&quot;headerlink&quot; title=&quot;通过Create.xyz的AIGC能力生产前端页面&quot;&gt;&lt;/a&gt;通过Create.xy
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ai" scheme="http://blog.michealwayne.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>【工具】颜色色值处理库colorjs</title>
    <link href="http://blog.michealwayne.cn/2024/08/31/tools_study/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91%E9%A2%9C%E8%89%B2%E8%89%B2%E5%80%BC%E5%A4%84%E7%90%86%E5%BA%93colorjs/"/>
    <id>http://blog.michealwayne.cn/2024/08/31/tools_study/【工具】颜色色值处理库colorjs/</id>
    <published>2024-08-31T10:32:53.000Z</published>
    <updated>2024-09-17T09:46:37.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="颜色色值处理库Color-js"><a href="#颜色色值处理库Color-js" class="headerlink" title="颜色色值处理库Color.js"></a>颜色色值处理库Color.js</h1><p>在前端开发中，处理颜色是一个常见且关键的任务。无论是在设计用户界面、创建数据可视化还是实现动态效果时，颜色都扮演着重要的角色。color.js 是一个由 Qix- 维护的 JavaScript 库，它提供了一套强大且灵活的工具来处理颜色的转换和操作。这个库在 GitHub 上的地址是：<a href="https://github.com/Qix-/color" target="_blank" rel="noopener">https://github.com/Qix-/color</a>。</p><blockquote><p>还有一个功能更为全面专业的库（<a href="https://colorjs.io/，由" target="_blank" rel="noopener">https://colorjs.io/，由</a> CSS Color 规范的编辑者 Lea Verou 和 Chris Lilley 创建，并由一个小型的维护团队继续开发）、但日常大多场景不太用得到，本文不作更多介绍。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>轻量级</strong>：库的体积小(产物压缩+gzip后2.3k)，加载速度快，对性能的影响微乎其微。</li><li><strong>多种颜色空间支持</strong>：支持 RGB、HSL、HSV、CMYK 等多种颜色空间。</li><li><strong>链式调用</strong>：支持链式操作，使得颜色转换和操作更加流畅。</li><li><strong>扩展性</strong>：可以通过插件或自定义函数来扩展库的功能。</li><li><strong>兼容性</strong>：兼容现代浏览器和 Node.js 环境。</li></ul><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过 npm 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install color</span><br></pre></td></tr></table></figure><p>或者在浏览器中直接引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/color@latest/color.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>color.js 提供了一个简单的 API 来创建和操作颜色对象。</p><h4 id="创建颜色对象"><a href="#创建颜色对象" class="headerlink" title="创建颜色对象"></a>创建颜色对象</h4><p>你可以使用多种方式来创建颜色对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过颜色名</span></span><br><span class="line"><span class="keyword">const</span> color = color(<span class="string">'blue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过十六进制</span></span><br><span class="line"><span class="keyword">const</span> color = color(<span class="string">'#39f'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 RGB 数组</span></span><br><span class="line"><span class="keyword">const</span> color = color.rgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); <span class="comment">// 或 const color = color.rgb([255, 100, 100]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 RGBA 对象</span></span><br><span class="line"><span class="keyword">const</span> color = color(&#123;<span class="attr">r</span>: <span class="number">255</span>, <span class="attr">g</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">100</span>, <span class="attr">a</span>: <span class="number">0.5</span>&#125;);</span><br></pre></td></tr></table></figure><p>color.js 允许你设置颜色的各个通道值，包括 alpha、red、green、blue、hue、saturationl (hsl)、saturationv (hsv)、lightness、whiteness、blackness、cyan、magenta、yellow、black 等。</p><h4 id="获取颜色值"><a href="#获取颜色值" class="headerlink" title="获取颜色值"></a>获取颜色值</h4><h5 id="获取颜色对象"><a href="#获取颜色对象" class="headerlink" title="获取颜色对象"></a>获取颜色对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取颜色对象的哈希值</span></span><br><span class="line">color.object(); <span class="comment">// &#123;r: 255, g: 255, b: 255&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色对象的数组表示</span></span><br><span class="line">color.rgb().array()  <span class="comment">// [255, 255, 255]</span></span><br></pre></td></tr></table></figure><h5 id="获取-RGB-数值"><a href="#获取-RGB-数值" class="headerlink" title="获取 RGB 数值"></a>获取 RGB 数值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取颜色的 RGB 数值</span></span><br><span class="line">color.rgbNumber() <span class="comment">// 16777215 (0xffffff)</span></span><br></pre></td></tr></table></figure><h5 id="获取十六进制值"><a href="#获取十六进制值" class="headerlink" title="获取十六进制值"></a>获取十六进制值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取颜色的十六进制值</span></span><br><span class="line">color.hex() <span class="comment">// #ffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色的 RGBA 十六进制值</span></span><br><span class="line">color.hexa() <span class="comment">// #ffffffff</span></span><br></pre></td></tr></table></figure><h5 id="获取单个通道值"><a href="#获取单个通道值" class="headerlink" title="获取单个通道值"></a>获取单个通道值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取颜色的红色通道值</span></span><br><span class="line">color.red()       <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><h5 id="CSS-字符串表示"><a href="#CSS-字符串表示" class="headerlink" title="CSS 字符串表示"></a>CSS 字符串表示</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取颜色的 HSL 字符串表示</span></span><br><span class="line">color.hsl().string()  <span class="comment">// 'hsl(320, 50%, 100%)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 .string() 方法并指定小数位数</span></span><br><span class="line">color.hsl().string(<span class="number">2</span>)  <span class="comment">// 'hsl(320.00, 50.00%, 100.00%)'</span></span><br></pre></td></tr></table></figure><h4 id="颜色转换"><a href="#颜色转换" class="headerlink" title="颜色转换"></a>颜色转换</h4><p>color.js 支持在不同颜色空间之间转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换为 HSL 格式</span></span><br><span class="line"><span class="keyword">const</span> hsl = color.hsl().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 HSV 格式</span></span><br><span class="line"><span class="keyword">const</span> hsv = color.hsv().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 CMYK 格式</span></span><br><span class="line"><span class="keyword">const</span> cmyk = color.cmyk().toString();</span><br></pre></td></tr></table></figure><h4 id="颜色操作"><a href="#颜色操作" class="headerlink" title="颜色操作"></a>颜色操作</h4><p>你可以对颜色对象进行各种操作，如调整亮度、饱和度、色调等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加亮度</span></span><br><span class="line"><span class="keyword">const</span> lighter = color.lighten(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加饱和度</span></span><br><span class="line"><span class="keyword">const</span> moreSaturated = color.saturate(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转色调</span></span><br><span class="line"><span class="keyword">const</span> rotated = color.rotate(<span class="number">90</span>);</span><br></pre></td></tr></table></figure><h4 id="颜色比较和辅助获取"><a href="#颜色比较和辅助获取" class="headerlink" title="颜色比较和辅助获取"></a>颜色比较和辅助获取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color1 = color(<span class="string">'red'</span>);</span><br><span class="line"><span class="keyword">const</span> color2 = color(<span class="string">'blue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个颜色是否相等</span></span><br><span class="line"><span class="keyword">const</span> isEqual = color1.equals(color2); <span class="comment">// 返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色的亮度值</span></span><br><span class="line"><span class="keyword">const</span> brightness = color1.brightness(); <span class="comment">// 返回一个介于 0 到 255 之间的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色的对比度比（与黑色或白色的对比度）</span></span><br><span class="line"><span class="keyword">const</span> contrast = color1.contrast(color2); <span class="comment">// 返回一个介于 0 到 1 之间的值</span></span><br></pre></td></tr></table></figure><h4 id="颜色明暗判断"><a href="#颜色明暗判断" class="headerlink" title="颜色明暗判断"></a>颜色明暗判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断颜色是否为“亮色”</span></span><br><span class="line">color.isLight();  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断颜色是否为“暗色”</span></span><br><span class="line">color.isDark();   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="颜色距离和差异获取"><a href="#颜色距离和差异获取" class="headerlink" title="颜色距离和差异获取"></a>颜色距离和差异获取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color1 = color(<span class="string">'red'</span>);</span><br><span class="line"><span class="keyword">const</span> color2 = color(<span class="string">'green'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个颜色在 RGB 空间中的差异</span></span><br><span class="line"><span class="keyword">const</span> delta = color1.deltaE(color2); <span class="comment">// 返回一个 DeltaE 值</span></span><br></pre></td></tr></table></figure><h4 id="颜色混合"><a href="#颜色混合" class="headerlink" title="颜色混合"></a>颜色混合</h4><p>color.js 还允许你混合两种颜色：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixed = color.mix(<span class="string">'red'</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>color.js 的应用场景非常广泛，以下是一些典型的用例：</p><h4 id="动态主题切换"><a href="#动态主题切换" class="headerlink" title="动态主题切换"></a>动态主题切换</h4><p>在需要根据用户偏好或时间（如白天/夜间模式）动态切换主题颜色的应用中，color.js 可以帮助你轻松调整颜色的亮度和对比度，以适应不同的主题。</p><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><p>在数据可视化项目中，color.js 可以帮助你创建颜色渐变，以表示数据的变化趋势或不同类别的数据。</p><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p>在图像处理应用中，color.js 可以用于分析图像中的颜色分布，提取主要颜色，或者根据图像内容自动生成配色方案。</p><h4 id="无障碍性检查"><a href="#无障碍性检查" class="headerlink" title="无障碍性检查"></a>无障碍性检查</h4><p>color.js 可以帮助开发者检查颜色组合是否符合无障碍性标准，如 WCAG 对比度要求，确保网站对所有用户都友好。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>color.js 是一个功能强大、灵活且易于使用的颜色处理库。它为前端开发者提供了一套完整的工具来处理颜色的转换、操作和动态调整，使得在各种项目中实现复杂的颜色需求变得简单。无论是在网页设计、数据可视化还是用户界面开发中，color.js 都是一个值得信赖的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;颜色色值处理库Color-js&quot;&gt;&lt;a href=&quot;#颜色色值处理库Color-js&quot; class=&quot;headerlink&quot; title=&quot;颜色色值处理库Color.js&quot;&gt;&lt;/a&gt;颜色色值处理库Color.js&lt;/h1&gt;&lt;p&gt;在前端开发中，处理颜色是一个常见且关
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.michealwayne.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="js" scheme="http://blog.michealwayne.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】《编程原则：来自代码大师Max Kanat-Alexander的建议》读书笔记</title>
    <link href="http://blog.michealwayne.cn/2024/07/28/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99%EF%BC%9A%E6%9D%A5%E8%87%AA%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B8%88Max%20Kanat-Alexander%E7%9A%84%E5%BB%BA%E8%AE%AE%E3%80%8B/"/>
    <id>http://blog.michealwayne.cn/2024/07/28/notes/【笔记】《编程原则：来自代码大师Max Kanat-Alexander的建议》/</id>
    <published>2024-07-28T06:37:56.000Z</published>
    <updated>2024-08-20T14:34:10.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《编程原则：来自代码大师Max-Kanat-Alexander的建议》（Understanding-Software）读书笔记"><a href="#《编程原则：来自代码大师Max-Kanat-Alexander的建议》（Understanding-Software）读书笔记" class="headerlink" title="《编程原则：来自代码大师Max Kanat-Alexander的建议》（Understanding Software）读书笔记"></a>《编程原则：来自代码大师Max Kanat-Alexander的建议》（Understanding Software）读书笔记</h1><p>作者介绍：马克斯·卡纳特-亚历山大是谷歌的代码健康技术主管，他的工作包括担任Xbox上YouTube的技术主管，在谷歌从事Java JDK、JVM和Java其他方面的工作，以及担任YouTube的工程实践技术主管，他在YouTube上为所有的开发人员提供最佳实践和工程开发效率方面的支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;关于如何对待编程领域中这些和编程间接、直接相关的知识，我见过两种极端的态度：有的人只看结果，只关心“写代码”，而对“写好代码”一无所知；第二类人深谙各种架构设计、整洁代码之道，但对于当下代码中遭遇的问题却没有落地的方案。</span><br><span class="line"></span><br><span class="line">在互联网公司的多年工作经验让我个人更习惯于从第一种人的视角看待问题，毕竟这是行业性质决定的，跑马圈地、快速扩张才重要，行业不允许你有时间思考。但是抛开行业、抛开公司，单纯地看编码这件事，我作为程序员最大的疑惑是：为什么我在每一家公司接手的代码库都如此难以维护？为什么总有人写出500行代码的函数和1000行代码的组件？为什么每一个迭代的最后总是要加班加点，研发、测试、产品经理都叫苦不迭？为什么问题年复一年地发生，却没有人想做些什么来改变现状？</span><br><span class="line"></span><br><span class="line">我观察到程序员存在一种战略上的惰性，对学习新技术和新框架，对阅读源码有发自内心的推崇。我不否定这种行为，新技术能给我们的项目带来便利，能给我们的简历增添浓墨重彩的一笔，这无可厚非。但技术背后的编写思路演化至今的原因，同样值得了解，它们和技术的语法本身同样重要。仔细回想和思考就不难发现，工具的好坏和代码的好坏，与项目将来适应需求变化的灵活能力没有关系，从写Vanilla JavaScript的年代，到BackboneJS，再到React，你看到团队中能把代码写好的人真的是越来越多吗？&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Uncle Bob Martin在他的“The Principles of OOD”系列文章中谈到过糟糕设计（Bad Design）的几个特征：</span><br><span class="line">- 僵化（Rigidity）：代码难以修改，因为改动会影响到的地方太多。</span><br><span class="line">- 脆弱（Fragility）：当你做出修改时，系统中预期之外的地方会遭到破坏。</span><br><span class="line">- 难以修改（Immobility）：代码很难被复用，因为它与当前系统中的功能耦合在了一起。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;大部分时候——我说的是大部分时候，技术的决策是专制的。如果我在这个技术领域有丰富的经验，如果我解决过足够多的问题，哪怕是我在这个项目中待的足够久，那么对于当下任何一个新的问题，我就能想得更多，看得更远。当然如果团队的时间和人员充足，可以抱着培养新人的心态，放手把问题交给一个从没有接触过这方面领域的人来解决。&quot;</span><br></pre></td></tr></table></figure><h2 id="程序员应该了解的基本原则"><a href="#程序员应该了解的基本原则" class="headerlink" title="程序员应该了解的基本原则"></a>程序员应该了解的基本原则</h2><h3 id="第1章-在你开始之前"><a href="#第1章-在你开始之前" class="headerlink" title="第1章 在你开始之前"></a>第1章 在你开始之前</h3><p>要成为一名杰出的程序员，你必须首先想要成为一名杰出的程序员。<br>要做就把它做好</p><h3 id="第2章-工程师的态度"><a href="#第2章-工程师的态度" class="headerlink" title="第2章 工程师的态度"></a>第2章 工程师的态度</h3><p>在每一类工程领域里，每一位工程师都应该有的工作态度是：<strong>我可以用正确的方式解决这个问题。</strong></p><p>无论这个问题是什么，解决问题的正确方式总是存在的。它不仅触手可及，在项目中也存在落地可能性。唯一不这么去做的正当理由只可能是缺少资源。</p><p>“正确方式”通常指“在考虑到未来所有可能发生的合理情况的前提下给出的解决方案，这个前提甚至包括那些未知的和难以想象的情况”。</p><p>如果软件代码在保持简约的同时，也为将来可能出现的合理功能变更需求提供了灵活性，那么就可以说它是以“正确方式”设计的。</p><h3 id="第3章-成为明星程序员的独特秘密"><a href="#第3章-成为明星程序员的独特秘密" class="headerlink" title="第3章 成为明星程序员的独特秘密"></a>第3章 成为明星程序员的独特秘密</h3><p>越是理解你正在做的事情，就越是能把它做好。“明星”程序员比一般或者平庸的程序员更透彻地理解了他们正在做的事情。仅此而已。</p><p>与相信自己“对一切了如指掌”相距甚远的是，许多程序员（包括我在内）常常感觉自己身处于浩瀚无垠的信息海洋里，受困在一场史诗级战争中。有太多东西需要知道，以至于哪怕穷极一生致力于学习研究，可能依然只了解了90%的计算机知识。</p><p>这场史诗级战争中的神秘武器，击败计算机知识的王者之剑，就是对你所学习到的知识的理解。</p><p>越是理解所处领域的底层知识，学习高级别的知识就越容易。越是理解当前级别的知识，学习下一个级别的知识就越容易，以此类推总是成立的。如果你自认为对某一门学科内从基础到高深的知识要点都统统掌握了，那不妨选择从头开始温习一遍，相信你会惊奇地发现在底层还有如此多的东西需要学习。</p><p>成为杰出程序员的必经之路就是保证对知识完全和完整的理解，从对基础知识的深刻掌握，到对大多数先进概念的扎实了解都必不可少。</p><h3 id="第4章-两句话总结软件设计原则"><a href="#第4章-两句话总结软件设计原则" class="headerlink" title="第4章 两句话总结软件设计原则"></a>第4章 两句话总结软件设计原则</h3><p>软件设计的主要原则可以浓缩为两句话：</p><ul><li>1.<strong>减少维护成本比减少实现成本更重要。</strong></li><li>2.<strong>系统的维护成本与系统的复杂度正相关。</strong></li></ul><p>这大概就是设计原则的全部了。</p><hr><h2 id="软件的复杂性和它的起因"><a href="#软件的复杂性和它的起因" class="headerlink" title="软件的复杂性和它的起因"></a>软件的复杂性和它的起因</h2><h3 id="第5章-复杂性的蛛丝马迹"><a href="#第5章-复杂性的蛛丝马迹" class="headerlink" title="第5章 复杂性的蛛丝马迹"></a>第5章 复杂性的蛛丝马迹</h3><p>你可以利用以下特征来辨别代码是否过于复杂了：</p><ul><li>1.需要添加“hack代码”来保证功能的正常运行。</li><li>2.总是有其他开发者询问代码的某部分是如何工作的。</li><li>3.总是有其他开发者因为误用了你的代码而导致出现bug。</li><li>4.即使是有经验的开发者也无法立即读懂某行代码。</li><li>5.你害怕修改这一部分代码。</li><li>6.管理层认真考虑雇用一个以上的开发人员来处理一个类或文件。</li><li>7.很难搞清楚应该如何增加新功能。</li><li>8.如何在这部分代码中实现某些东西常常会引起开发者之间的争论。</li><li>9.人们常常对这部分代码做完全没有必要的修改，这通常在代码评审时，或者在变更被合并进入主干分支后才被发现。</li></ul><h3 id="第6章-创造复杂性的方法之一：违反你承诺过的API约定"><a href="#第6章-创造复杂性的方法之一：违反你承诺过的API约定" class="headerlink" title="第6章 创造复杂性的方法之一：违反你承诺过的API约定"></a>第6章 创造复杂性的方法之一：违反你承诺过的API约定</h3><p>API是某种形式的承诺：“你可以放心地完全按照我们描述的方式和我们的程序进行交互。”可一旦你的产品发布了新版本，并且在新版本中不再支持旧版本API，那就意味着你违反了这种承诺。它给软件增添了复杂性。</p><p>曾几何时你的API用户只需要调用一个简单函数就能完成工作，而现在他们需要对你的应用进行版本检测，并依据检测结果调用两个不同函数中的其中一个。为了同时兼顾新版本函数，他们必须采用和之前完全不同的方式来向函数传递参数，导致代码的复杂性被无辜地加倍了。如果你改变的函数数量过多，为了适应全新API的工作方式他们可能需要将整个应用重写！</p><p>如果你频繁地打破API约定，那么他们的代码为了适配也只能变得越来越复杂。唯一的额外选项就是让他们的产品不再与你的旧版本产品兼容。因为对于用户和系统管理员来说始终设法保证两者之间的同步是一项极其困难的工作。即便对于你个人来说，维护旧API也是痛苦的，摆脱它能够使工作轻松不少。</p><p>避免这个问题的最佳方案是<strong>不要发布糟糕的API</strong>。或者（从用户的角度上看）更恰当的是，在承诺会始终维护旧版API的同时，以其他方式提供可被访问的全新API。</p><p>举个例子，如果你想要访问salesforce.com某些旧版本的API，只需要在和程序交互时使用不同的URL即可。而每一次在和Salesforce API进行交互时，URL事实上都为你间接地明确指定了你希望使用的API的版本是什么。</p><p>无论在什么情况下，对外发布一组极不稳定或是设计拙劣的API，要么会让你的工作变得复杂（因为你需要永远保证向后兼容），要么会让你API用户的工作变得复杂（因为他们为了能同时兼顾“好”版本和“坏”版本的API而不得不修改所有的应用）。</p><p>如果你选择违背API约定并且决定不再向后兼容，请别忘了当中的一些API用户永远不会为了适配新的API而更新他们的产品。或许他们只是没有足够的时间和资源来更新他们的代码。或许他们在使用第三方工具来和你的产品进行交互，但是第三方工具的维护者已经不再提供更新了。无论是哪种情况，如果他们修复代码的成本高于适配你的新产品而带来的收益，他们就会依然选择使用你的旧版本产品，甚至永远用下去。</p><p>所以在研发资源充裕的情况下话还是应该对外提供一组可供访问的API。但是在实现之前请务必对API进行精心设计。你可以在正式发布之前自己多尝试使用看看。还可以细心地对你的用户进行调研并且发掘他们究竟会如何使用你的API。总的来说，在发布之前就需要尽你的全部所能来保证API的稳定。在未来你需要投入多少年精力来维护API并不重要，重要的是在发布之前采取一些明智的手段来了解API在现实场景里应该如何工作。</p><p>API一旦发布成功，如果条件允许的话，拜托请千万不要违背你的API约定。</p><h3 id="第7章-什么时候不值得向后兼容"><a href="#第7章-什么时候不值得向后兼容" class="headerlink" title="第7章 什么时候不值得向后兼容"></a>第7章 什么时候不值得向后兼容</h3><p>因为向后兼容而引发问题的最好例子就是Perl编程语言。</p><p>当不计其数的人都在这么使用，并且对他们来说改变习惯非常困难的话，结果就是很大程度就不得不保证向后兼容。但如果维持向后兼容这件事确实阻碍了技术向前发展，那么你就需要警告人们这些“老掉牙的玩意”应该消失，并且是时候对它们说再见了。</p><p>你的另一个选择是无节制的向后兼容并且不再向前发展，这意味着对你的产品判了死刑。</p><p>这很好地说明了为什么你不应该漫无目的地给你的程序添加功能。因为总有一天你需要为这些你开发的“尽管没有什么用但加上去很方便”的功能提供向后兼容的支持。这是在添加新功能时需要慎重考虑的一点——既然这个特性已经存在于你的系统中了，那么你打算永远把它维护下去吗？答案是：你很可能需要。</p><p>理想的解决方案是：如果你不想在许许多多的后续版本中支持这些功能，那么当下就不要添加它们。</p><p>有时候需要丰富的编程经验才能有效地做出这样的决策，但你可以从这个功能的角度思考：“它真的这么实用吗，以至于值得我在未来的三到四年里在它上面花费至少10小时的开发时间？”这种用于评估应该花费多少精力在某件事物上的方法适用于万事万物，包括向后兼容、质量保证，甚至对评审极小的功能也同样成立。</p><p>一旦你拥有了一个功能，就意味着维护它的向后兼容性将会是日后的绝大部分工作。</p><p>你应该认真考虑放弃向后兼容的唯一时机是，当它在妨碍你添加明显实用且重要的新功能的时候。如果这种情况确实发生了，那么你就需要放弃向后兼容了。</p><h3 id="第8章-复杂是牢笼"><a href="#第8章-复杂是牢笼" class="headerlink" title="第8章 复杂是牢笼"></a>第8章 复杂是牢笼</h3><p>如果你编写的代码如此复杂以至于没有人能理解它怎么办？好吧，结果就是你个人会被永远地束缚在这个项目上面。</p><p>复杂是牢笼，简单是自由。</p><hr><h2 id="简约与软件设计"><a href="#简约与软件设计" class="headerlink" title="简约与软件设计"></a>简约与软件设计</h2><h3 id="第9章-设计要从头抓起"><a href="#第9章-设计要从头抓起" class="headerlink" title="第9章 设计要从头抓起"></a>第9章 设计要从头抓起</h3><p>你需要从一开始就着手于软件设计，应该从立项之初就致力于将架构设计得简约明了。</p><p>除非架构设计支持轻松地将该功能实现，否则我们绝不允许新增该功能。</p><p>如果你不考虑未来，那么你的所有代码都会陷入糟糕的设计和极度的复杂之中。“我们等不及了！这个功能非常重要！”又或者是：“现在只管把它加进来就好了，完事之后我们会把代码整理重构的！”他们从没意识到他们的态度一向如此。等到下一次需要添加另一个功能有求于我们时，他们还会说出同样的话。</p><p>如果只是新增很少的功能，并稍后将它重构的话就不太有可能出现这种问题。但如果空降一个架构无法支撑的大型功能，还计划在完成之后尝试整理代码，那这将会是一项艰难的任务。所以说功能的体量很重要。</p><p>最糟糕的情况是，在你允许人们在几个月或几年内不经过提前设计就往代码中新增功能，然后有一天你幡然醒悟并意识到系统有可能撑不住了。此时你唯一的选择只能是修复整个代码库。这注定会是一项艰巨的任务，因为就像新增功能一样，它无法一气呵成，除非你想要重写整个应用。</p><p>如果你想要开始以正确的方式行事，那么你必须以正确的方式立即行动起来。为了解决当下的问题，你必须将整个流程拆分为简单的步骤，并逐步对设计中存在的缺陷予以修复。这通常需要数月甚至数年的工作投入——简直就是浪费。因为你本应该从一开始就将架构设计好，这样的话这些问题从根本上就可以避免。你应该事先把目光放长远一些。</p><p>如果你的项目缺乏严格的架构设计，并且它的体量还一直在持续增长，那么终有一天超乎你想象的复杂性会让你束手无策。</p><p>这并不意味着你从一开始就需要设计能够满足未来所有需求的大型通用架构，并且现在就实现它。上述观点想表达的是，你需要在工作学习中应用本书和《简约之美》中讨论的那些软件设计原则，这样从一开始你就会拥有一个可理解的、简约的并且具有可维护性的系统。</p><h3 id="第10章-预测未来的准确度"><a href="#第10章-预测未来的准确度" class="headerlink" title="第10章 预测未来的准确度"></a>第10章 预测未来的准确度</h3><p>预测软件的未来如此困难。<strong>预测未来的准确度，会随着系统复杂性和预测点距今时间跨度的增加而降低。</strong>也就是说随着系统变得越来越复杂，你只能以有限的准确度预测短时间范围内的未来。反之随着系统变得越发简单，你越能以高准确度预测较远的未来。</p><p>保证系统架构足够简单，便于你轻松地将旧语法替换为新语法。注意这里对系统架构的要求不是“灵活”，也不是“通用”，而是简单到易于理解和修改。</p><p>在现实工作中，存在一种基于以上准则扩展之后的逻辑先后关系：</p><ul><li>1.预测未来的难度会随着系统和被预测功能所处环境内，所有修改之处数量总和的增长而增加。（注意，环境带来的影响与它和系统的逻辑距离成反比。如果你的系统与汽车有关，那么对引擎的修改可能会给系统带来非常大的影响，但是对环境内某棵苹果树的修改带来的影响则微乎其微。）</li><li>2.系统需要经受的修改与系统的整体复杂性相关。</li><li>3.所以：预测变困难的速率会与被预测行为所属系统的复杂性成正比。</li></ul><p>不要想当然地依据你认为将来会发生的事情做出设计决策。请记住所有这些即将发生的事情都存在发生的概率，无论预测多少次都存在出错的可能。</p><p>当我们只关注当下，关注我们已有的数据，关注我们现有的软件系统，相比预测我们的软件在未来何去何从，我们更容易做出正确的决定。大部分在软件设计中犯下的错误来自假设未来需要做些什么（或者完全不需要做些什么）。</p><p>当你发现随着时间的推移，软件的某些代码变得难以修改时，这条规则会带给你帮助。你永远无法完全避免代码被修改，但如果你的软件简化到傻瓜都能理解的地步，那么修改的可能性就会大大降低。虽然它可能依旧会在软件质量和实用性方面逐渐衰退（因为你没有即时追随环境的变化对它进行修改），但是它衰退的速率远比复杂的时候要慢。</p><p>编写简单的软件比编写复杂的软件花费的功夫更少。虽然有时需要加入额外的思考，但总体来说需要的时间和投入会更少。所以尽可能保证架构的合理简约，就是在为我们自己取得一场胜利、为我们的用户取得一场胜利、为未来取得一场胜利。</p><h3 id="第11章-简约与严格"><a href="#第11章-简约与严格" class="headerlink" title="第11章 简约与严格"></a>第11章 简约与严格</h3><p>一个普适的原则是：<strong>你的应用程序对编码要求越是严格，就越易于编写。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举一个例子，想象一个应用程序只接受数字1和2作为输入，并且除此之外的任何其他形式的输入都被统统禁止。那么即使发生在输入时的小小变化，比如在“1”之前或者之后增加一个空格都会引起程序的报错。这样的程序在被称为非常“严格”的同时也极易编写。你需要做的仅仅是校验：“他们输入的究竟是1还是2？如果都不是，则报错。”然而在大多数情况下，如此严格的程序显得不切实际。如果用户不了解你期望他们输入的格式，又或者如果他们在输入数字时不小心敲击了空格或者其他的字符按键，程序会拒绝“执行他们的意图”而给用户带来挫败感。</span><br><span class="line">上述就是需要在简约（严格）和可用性之间进行取舍的典型场景。并非所有的严格之处都需要进行取舍，但大多数地方无法避免。如果我允许用户同时以1，One，或者“1”作为输入，那意味着程序增加了对用户行为的容错空间，并且让他们的工作变得简单了许多，但是同样也给我们的程序增加更多的代码和复杂性。没那么严格的程序会比严格的程序占用更多的代码，这也是复杂性的直接来源。</span><br></pre></td></tr></table></figure><p>顺便说一句，如果你正在为程序员编写框架或者是编程语言，你的最佳选项应该是让用户接口“不那么严格”，甚至是尽可能地简约，这样就不必在可用性和复杂性之间权衡了，让开发者同时感受到两个世界的美好。</p><p>严格这个词大部分时候意味着你给用户的输入设置了一份白名单。在有些应用中，你还可以对输出做出严格的限制：输出通常需要迎合一类特殊并具体的标准。但是通常来说，你能接收什么样的输入以及什么样的输入会引发错误，这两件事会显得更重要。</p><p>或许最知名的与严格有关的灾难就是HTML。正因为它从一开就被设计成不那么严格，在经过几年的普及之后，导致处理它的兼容性问题成为浏览器设计人员的噩梦。当然它最终还是被标准化了，但那个时期的大部分的HTML代码阅读起来依然会令人抓狂，现在这种现象还是存在。因为它从一开始就不够严格，所以现在没有人敢打破向后兼容并将它变得严格。</p><p>总而言之，我坚持认为计算机永远不应该“猜测”或者说“尽全力满足”用户的输入。由此引入的噩梦般的复杂性会导致程序极易失控。猜测唯一能恰如其分发挥功效的地方是内置于类似于谷歌网站的拼写建议功能中。它提供你做事情的选项，但不会一股脑地基于猜测的结果去完成工作。这也是我在谈论严格时想强调的另一个方面，输入要么是对要么是错，不存在“也许”这种情况。如果一个输入有可能包含多层含义，要么你应该为用户提供选项，要么直接报错。</p><p>在计算机世界中人们从一开始就应该对很多事物做出严格的限制，正是因为这类约束的缺失，导致这些事物现在看上去复杂得有些可笑。</p><p>当然，对可用性的关注依然重要。毕竟，电脑是帮助人类完成工作的。但是你没有必要为了可用而兼容普天之下的所有可能发生的输入。那会导致你陷入复杂性的迷宫之中，如果你义无反顾地打算继续这么做，祝你早日找到迷宫的出口。可你要知道他们从来不会严格按照标准化的方式制作迷宫的地图。</p><h3 id="第12章-两遍已太多"><a href="#第12章-两遍已太多" class="headerlink" title="第12章 两遍已太多"></a>第12章 两遍已太多</h3><p>代码只在必要时才需要通用。<br>一旦我意识到自己正打算将同一份功能实现两遍时，就会开始执行这个步骤。</p><p>该原则中至关重要的一点是立即采取行动。我不允许代码中存在两种相互竞争的实现。我当下就将它们合并成了一个通用解决方案。另一个重点是我不会把它抽象得过于通用。</p><p>基于“两遍已太多”原则我们能进一步推导出：<strong>理想情况下，开发者修改某处代码的方式不应该与修改另一处代码的方式近似甚至相同。</strong></p><p>这也就是说，开发者不应该在修改B类时必须“记得”去修改A类。他们也没有必要知道如果常量X发生了变化，Y文件也需要更新。换句话说，不仅两种实现会带来糟糕的开发体验，两个文件位置也会。虽然系统内的重复代码并非总能被合并且共享，但这应该是我们解决问题的方向。</p><p>当然，“两遍已太多”中最浅显的含义实属那条经典原则：“DRY”。所以不要用两个常量表示同一件事情，不要定义两个函数来干同一件事情，等等。</p><p>这条规则在其他方面也同样适用。总而言之思路是，当你发现对于单个概念存在两套实现方案时，你应该想办法将它们合并为单个解决方案。</p><p>在重构代码时，这条原则能够帮助你找到代码中值得改善的地方，并且能给予你一些重构方向的提示。例如在你发现系统中存在逻辑重复的地方时，你应该尝试将他们合并在一起。当另一处重复逻辑再次出现时，继续将该处合并到刚刚的通用逻辑中，如此重复执行。</p><p>也就是说如果有太多的代码需要进行合并，你可以按照对每两处执行一次合并的方式进行增量重构。采取什么样的方式并不重要，只要合并的工作确实能够让系统变得简单就好（易于理解和维护）。有时候你需要判断以什么样的顺序将这些代码合并是最有效的，但是如果你无法判断出来也不用担心——直接对每两处执行一次合并就好了，船到桥头自然直，通常重构的所有问题最后都会迎刃而解。</p><p>千万不要将不应该被合并的逻辑放在一起。将两种不同的实现合并在一起常常会给系统创造更多的复杂性，或者导致代码违反了单一职责原则，这条原则告诉我们：任意给定的模块、类或者函数在系统中应该只表示单一的概念。</p><p>举个例子，如果你系统中用于代表车和人的代码有轻微的相似之处，请不要通过把他们合并为“车人”类来解决这个“问题”。这样并不会降低复杂性，因为车和人的确是两类不同的事物，并且应该由两个独立的类来表示。</p><h3 id="第13章-健壮的软件设计"><a href="#第13章-健壮的软件设计" class="headerlink" title="第13章 健壮的软件设计"></a>第13章 健壮的软件设计</h3><p>我们做的最重要的一个决定，是确保整个过程足够简单。为了达成这个目标，我们让所有孔的尺寸都规范化起来，让所有操作都很简单且易于拆解。</p><hr><h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><h3 id="第14章-什么是bug"><a href="#第14章-什么是bug" class="headerlink" title="第14章 什么是bug"></a>第14章 什么是bug</h3><p>bug的精确定义：</p><ul><li>1.程序的行为并没有符合程序员的预期。</li><li>2.程序员的预期没有满足绝大部分理性用户的期望。</li></ul><p>通常来说只要程序能够严格执行程序员给出的指令，它就可以算是处于正常工作的状态。但有时候程序员期望程序执行的行为会出乎普通用户的意料，甚至给他们带来麻烦，所以这也算是一类bug。</p><p>其他软件功能上的不足都可以归纳到新功能需求中。如果说程序的工作状态的确与我们期望的一致，但离用户期望还有差距，则意味着它需要新“功能”。“功能”和“bug”定义之间的区别也就在这。</p><p>本质上说，任何导致程序员指令没有被正确执行的故障，都可以被认为是bug，除非程序员打算让计算机做一些它本不应该去做的事情。</p><h3 id="第15章-bug的源头"><a href="#第15章-bug的源头" class="headerlink" title="第15章 bug的源头"></a>第15章 bug的源头</h3><p>bug通常来自开发者尝试降低代码复杂性未果而产生的副作用。也有部分来自对其实简单的代码产生的误解。</p><p>复杂的事物容易引起用户的误操作。在编程中也存在类似的情况，如果你无法轻易理解编程语言的文档，或者是这门语言本身，你就或多或少存在错误使用它的可能。</p><p>你每引入一丝复杂性，开发者（这里的“开发者”甚至包括你自己）误用你的代码的概率就高一分。</p><p>一旦代码的意图和使用方法变得极不明确，就会让使用这份代码的人犯错。又因为你的代码和其他的代码混合在了一起，导致了开发者误用和犯错的可能性大大增加。而后这些代码又会继续和其他的代码混合，形成恶性循环。</p><p>硬件设计者将硬件制造得极为复杂的情况时常发生。所以它必须与复杂的汇编编程语言集成。而这又使得汇编语言和编译器同样复杂起来。当你遇到这种情况时，如果你不提前对程序进行精妙的设计或者全方位的测试的话，基本上无法避免bug的发生。只要你的设计不够完美，那么在运行的一瞬间，大量的bug就会涌现出来。</p><p>站在其他程序员的视角看这件事也很重要。毕竟有些事对你来说很简单，但是对其他人来说或许很复杂。</p><p>如果你想要感同身受地体验一下其他人看不懂你的代码的感受，你可以找一份你从没有使用过的类库的文档来阅读看看。</p><p>也可以找一些你从没有阅读过的代码来阅读。尝试理解整段程序而不是单行代码的含义，并且想象当你需要对它进行修改时应该从哪里入手。这些都是其他人阅读你代码时的体验。你大概注意到在阅读他人代码时，即使并不复杂的代码也足以让人产生挫败感。</p><p>现在我们考虑另一种程序员误解简单代码的情况。这也是需要额外小心的另一件事。如果你察觉到某位程序员在向你解释一段代码时叙述得牛头不对马嘴，那便意味着他应该是误解了代码中的某些内容。当然如果他正在研究的领域极其复杂，也情有可原。</p><p>这两个方面是紧密关联的。当你编写代码时，需要承担的部分职责是让将来阅读你代码的程序员理解它，并且是很轻松地就能理解。如果你确实是这么做的，但是他在阅读过程中仍然产生了严重误解——或许他根本就不明白“if”语句是什么含义。那应该就与你无关了。</p><p>所以最后可以总结出几条有趣的原则：</p><ul><li>1.你写的代码越简单，bug就越少。</li><li>2.你应该始终想方设法去简化程序中的代码。</li></ul><h3 id="第16章-确保它不会再发生"><a href="#第16章-确保它不会再发生" class="headerlink" title="第16章 确保它不会再发生"></a>第16章 确保它不会再发生</h3><p>当你在解决代码中的问题时，你不应该止步于只修复问题表象。而是<strong>应该确保问题彻底消失并且永远不会再发生。</strong></p><p>请记住，我们最在意的是软件的未来。软件公司代码库之所以会陷入无法维护的失控局面，是因为他们并没有真的在解决问题，只有切实解决这些问题之后，代码的可维护性才可能好转。</p><p>这也解释了为什么有的组织内部的紊乱代码始终无法回归到一个良好的可维护状态。当他们遇到一个问题时，他们应对问题的出发点仅仅是设法让提出问题的人停止抱怨，用这种态度解决问题之后继续以同样的态度应付下一个问题。他们不会考虑引入一个框架来阻止问题的再次发生。他们也不会追溯问题发生的根本原因然后斩草除根。所以他们的代码从来没有真正地“健康”过。</p><p>衡量一个问题是否被真的解决的恰当标准是：<strong>直到人们不需要再次对它进行关注。</strong></p><p>绝对地做到这一点是不可能的，因为你无法预测到所有的可能性，但这条原则更多的是想提供理论上的指引而不是实际的操作指南。在大部分实际情况中，你能做到的是当下不会再有人被这个问题困扰，但是并不代表问题在未来不会再次出现。</p><p>可以提出更多的问题：<br>为什么开发者会写出错误代码？bug为什么会存在？是开发者接受的技能培训出了什么问题？还是工作的流程中存在纰漏？他们在编写代码的同时是否也应该编写测试？会不会是系统的设计缺陷导致代码难以修改？编程语言过于复杂了？他们用的类库编写的不够友好？操作系统出了什么问题？文档描述得不够清楚？</p><p>如果你有了关于某个问题的答案，你可以继续思考产生这个问题的根本原因又是什么，并且持续追问下去直到你所有的诱惑都已经解开。但是请小心：你并不知道这一串问题的终点在哪里，甚至整个过程会颠覆你对软件开发的看法。事实上从理论上来说，在这一套方法论下可以提出无限多的问题，并且终将让整个软件行业的根本问题得到解决。但是在这条路上要走多远还是取决于你自己。</p><h3 id="第17章-调试代码的基本哲学"><a href="#第17章-调试代码的基本哲学" class="headerlink" title="第17章 调试代码的基本哲学"></a>第17章 调试代码的基本哲学</h3><p>有时候人们在调试代码时会感受到强烈的挫败感。因为绝大部分人在调试系统代码时，倾向于将时间花费在思索而不是追溯代码的调用上。</p><p>当你开始调试代码时，请意识到其实你对答案一无所知。</p><p>人们倾向于相信冥冥中自己已经悟到了问题的答案。有时你确实能够猜对。这种情况不常发生，但是发生的频率之多，让不少人误以为猜测也是调试代码中的有效手段之一。</p><p>大部分时候，你可能会花上几个小时、几天甚至几周来猜测问题究竟出在哪里，并且尝试各种除了让代码更复杂之外毫无实际用处的修复方案。你会发现在一些代码库中充斥着仅依据猜测编写的用于修复“bug”的“解决方案”——这些所谓的“解决方案”恰恰是代码库复杂性的一大来源。</p><p>通常来说，成功对bug进行修复，也应该意味着系统在变得更好，比如系统变得更简单了，架构设计得到了优化，等等。</p><p>通常，bug的最佳修复方案，会在修复问题的同时，间接地移除冗余代码，并且简化系统设计。</p><p>基本上在遇到问题的第一时间内，你脑海中冒出的想法都属于无稽之谈。此时此刻你需要了解的只有两件事：</p><ul><li>1.记住系统正确的行为是什么。</li><li>2.想清楚应该通过追踪哪一部分代码来收集更多的有效信息。</li></ul><p>这才是调试代码中最重要的原则：<strong>调试代码指的是在你找到问题的起因之前，持续收集信息的过程。</strong></p><p>可以通过深入了解系统的工作原理来收集信息。以服务器无法返回页面的情况为例，或许你可以在通过查阅系统日志找到线索。又或者你可以尝试重现问题，并通过观察服务器此时的工作状态来发现蛛丝马迹。这也是为什么处理问题的人总是希望能“还原现场”（通过一系列步骤能够让你复现问题）。这样他们就能在bug发生时回溯出了什么样的问题。</p><p>有时你的首要任务是明确bug究竟是什么。通常用户上报的bug信息内容都相当有限。你的用户越是没有计算机相关背景，在缺乏引导的情况下他能够准确表达问题的可能性就越低。在这些情况下，除非问题十分紧急，否则我首先要做的事情就是请求用户给出更详细的出错信息，并且在我得到回复之前我不会采取任何行动。也就是说，在他们明确bug之前我绝不会自行尝试解决这个问题。</p><p>如果在对问题一知半解的情况下就着手尝试解决它，那么我可能会把时间都浪费在查看各种和问题无关的系统随机角落上。所以为了让时间花得更有价值我才选择等待用户的进一步反馈，并且最终当我确实拿到一份完整的bug报告时，我才会着手探寻bug背后的原因。</p><p>请注意，不要因为用户提交的bug信息不够丰富而迁怒于他们。虽然他们对系统的了解不如你，但并不意味着你有资格用不屑的态度鄙视他们。为了获取信息你应该直言不讳地提出问题。<br>要知道引导他们提供正确的信息也是你的工作职责之一。如果人们总是无法提供正确的信息，你可以尝试在报错页面提供一个表单来帮助他们梳理出正确的信息有哪些。我想表达的是帮助其实是互惠的，只有你帮助了他们，他们才能反过来帮助你，这样你才更容易地解决问题。</p><p>一旦明确bug，接下来你就需要对系统的不同组件进行排查以找到错误原因。至于从哪些组件入手排查取决于你对系统的了解程度。通常是从日志信息、系统监控、错误消息、核心转储或者是系统其他的输出信息入手。如果系统无法为你提供这些信息，你或许需要考虑在继续排查问题之前，发布一个能够收集这些信息的新版本系统。</p><p>尽管对于只修复单个bug而言，这看上去似乎需要耗费不少的工作量，但相比你在系统内毫无目的地碰运气来猜测问题的原因，发布能够提供有效信息的新版本系统还是能够提升不少效率的。这也是支撑快速发布、频繁发布实践的有力论点：发布新版本的频率越高，你收集到的调试信息速度也就越快。有时你甚至可以定向地为遇到问题的用户发布新版本系统，这也可以作为收集信息的捷径。</p><p>调试代码是一类将已有数据与期望数据进行比较的行为。</p><p>当你意识到找到问题的根本原因时，是当你十分肯定在将它修复完毕之后错误就再也不会发生了的时候。这不是绝对的——关于如何“修复”bug还有可以讨论的空间。bug需要修复到何种程度取决于你的解决方案想解决到哪个层次，以及你想要在上面花费多少时间。通常在你找到某个问题的深层原因，并且将它修复之后，就能看出你最终做出了什么样的选择——这再明显不过了。但我依然想要警告你，只解决问题的表面症状而不解决引起问题的深层原因是有风险的。当然，在找到原因的当下就马上修复它。这其实是正常情况下最直接的方式。</p><p>调试代码的四个主要步骤：</p><ul><li>1.熟悉正常工作的系统行为应该是什么样的。</li><li>2.接受其实你并不知道问题原因的这个事实。</li><li>3.追踪代码直到你找到问题的原因是什么。</li><li>4.修复根本原因而不是表面症状。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这听起来十分简单，但我基本上看不到有人能遵守这一系列准则。我的所见所闻是，大部分程序员在遇到bug时，喜欢坐下来思考，或者通过询问他人找到问题可能发生的原因——这两种做法都无异于猜测。</span><br><span class="line">与那些对系统有一定的了解，并且能给出可以从何处收集有助于调试信息的人沟通是办法之一。但是与其一群人坐在那里猜测问题的原因，其实和你一个坐在那瞎猜没有区别，唯一的收获可能是和你喜欢的同事聊天产生的一些愉悦感吧。上面的做法无非是用浪费大伙的时间代替浪费你自己的时间而已。</span><br><span class="line">所以请不要浪费大家的时间，不要在代码库中引入不必要的复杂性。上面给出的代码调试方法是可行的。无论在何时何地，对什么样的代码库或者系统而言都是适用的。</span><br></pre></td></tr></table></figure><p>有时候“收集信息”的过程会相对困难，特别是对于那些你无法重现的bug，但最坏的情况也无非是通过阅读代码来收集信息，尝试找到代码中bug所在，又或者把系统的工作流程图画出来，看是否能发现症结在哪里。我建议把这些方法当作没有办法的办法，但是即使你这么做，也比猜测问题出在哪里或者假设你已经知道问题在哪里要强。</p><hr><h2 id="团队里的工程问题"><a href="#团队里的工程问题" class="headerlink" title="团队里的工程问题"></a>团队里的工程问题</h2><h3 id="第18章-高效工程开发"><a href="#第18章-高效工程开发" class="headerlink" title="第18章 高效工程开发"></a>第18章 高效工程开发</h3><p>通常来说，致力于改善团队开发效率的同事会陷入两难的局面，要么他们会和他们所服务的开发者产生冲突，要么他们的时间都花费在一些截止时间遥遥无期的项目上面，因为大家对这些项目漠不关心。之所以会发生这种情况，是因为开发团队认为有待解决的问题并非实际存在的问题。</p><p>随着时间的推移，负责效率改善的人员会对周围合作的同事形成一种敌对的态度。他们认为如果其他的工程师如果能够“使用我开发的工具”，那么所有麻烦都能迎刃而解。但是开发者最终并没有选择使用你编写的工具，所以你又凭什么认为你的工具举足轻重呢。</p><p>问题在于，一旦你开始忽略其他开发者的抱怨（又或者完全意识不到他们遇到的问题），你们之间对立的种子就已经种下了。它不是一个由好变坏逐渐腐化的过程。而是从一开始当你认为问题是这个，而其他开发者认为问题是那个的时候，矛盾就诞生了。</p><p>如果你做了一大堆的重构工作，但是根本没有人继续维持重构后代码的简约，又或者你写了一堆没有人使用的工具/框架，那本质上你还是和什么都没有做一样，太令人沮丧了。</p><p>当你在解决开发效率低下的问题时，开发者是你解决方案的用户。你不能无脑地同意其他开发者提供给你的关于如何实施解决方案的建议。这么做可以在一定程度上哄这些人开心，但这终将会让系统变得难以维护，而且也仅仅是满足了那些叫喊声最大的用户的需求而已——他们很可能并不代表你的大部分用户。如果你接受了他们的建议，那么你最终会得到一个设计混乱，甚至连真实用户需求也无法满足的系统。</p><p>举一个例子，假如开发者向你抱怨他们某个千万行代码的单体二进制代码发布流程太慢了，接着你就把时间都花费在想方设法让发布工具变得更快的工作上，结局是多半你不太可能带来好的改善。或多或少能带来一些改善（让发布更快），但是永远也没有解决根本问题，根本原因是这个二进制代码体积太大了。</p><p>你要做的第一件事是明确开发者认为的问题所在。不要做任何的评判。四处走走和不同的人聊聊。多听听那些直接和代码库打交道的人的意见。如果你没有机会和每一位工程师交谈，可以先从与每个团队的技术管理者沟通开始。然后你可以和管理层聊聊，毕竟他们也有你需要予以记录和解决的问题，你需要对这些问题进行了解。但是如果你只想要解决开发者遇到的问题，你应该从开发者身上找出问题是什么。</p><p>一般来说，如果你直接问开发者代码的复杂之处，他们不一定能回答上来。如果你问“什么地方过于复杂了”又或者“你认为的难点是哪”，他们可能想了半天也给不了你答案。但如果你希望得到大多数开发者对于他们编写或使用的代码的情绪上的反馈，那么他们还是有很多话可以说的。我会问一些类似于这样的问题，“这份工作有什么让你感到闹心的地方吗”，“哪一部分代码你修改起来最不爽”，“代码库中有什么地方是你因为害怕改坏了而不敢修改的”。如果面对经理我会问：“代码库中有没有开发者常常抱怨的地方？”</p><p>你可以根据你的情况对这些问题进行调整，但请切记你是真心想要和开发者们进行一次对话——而不是机械地把问题列表读一遍而已。他们会说一些你有兴趣深入了解的事情。你可能需要把当中的一些内容记录下来。</p><p>在这项工作持续一段时间后，你大概就能察觉到这些抱怨中的共通点（或者某些共通点）。这并不是我们想要寻找的唯一原因——即使没有和大家交谈我们大概也能猜出来。我们想要寻找一些更高层次的原因，类似于“构建二进制文件过于缓慢”。有更多类似的原因有待我们发掘。</p><p>首先你可以从收集的信息中找到那些开发者已知的，且能在短时间（比如一至两个月）改善的问题，并给出解决方案。解决方案没有必要完全颠覆现有工程师的开发模式。事实上它也不应该这么做。因为当前变革的重点是为了建立大家对你工作的信任。</p><p>提升开发效率的成功与否，取决于你的个人信誉。</p><p>你可以预见总有一天你需要解决本质上的问题。只有当其他开发者对你有足够的信任，你才有机会朝那个方向努力，当你想要做出一些改变时，大家会相信你的解决方案是正确的。所以你首先需要做的事情是，在团队中树立自己的可靠形象。</p><p>通过解决第一个问题，大家已经对你有了基本的信任，接下来你可以着手搜寻开发者真正面临的问题，以及最佳的解决方案可能是什么。这通常不可能一气呵成。此时你需要注意到另一个知识点——你不能一下子推翻并重建所有的团队文化和开发流程。你必须以渐进的方式，将变革逐步“渗透”到大家的工作中（人们通常会因为你改变了什么，或者改得面目全非，又或者第一轮变革并不起作用而感到生气），等到大家适应之后再考虑推进下一步工作。</p><p>如果你试图将变革一步到位的在团队内推广生效，一定会有人公开的反对你——这些反对的声音会让你的个人信誉荡然无存，还会使得你所有的努力付之东流。于是你又不得不回到之前提到的两个毫无建设性的解决方案——要么团队变得士气低下，要么毫无起色。所以你必须按部就班地展开工作。有的团队可以接受较大程度的变革，有的只能接受较小程度的变革。通常团队的规模越大，你执行的过程越要缓慢。</p><p>你应该找一批支持你的人，建立一个能为你付出的努力背书的核心圈子。绝大部分程序员还是帮理不帮亲的，即使他们口头上什么也没有说。</p><p>当有人提出他们的长远改善计划时，你应该公开鼓励他们。不要要求每个人都做出完美的改变——你的当务之急是凝聚你的“团队”来验证清理代码、效率提升的种种手段是有价值的。你还要负责营造志愿者文化或者经营开源项目——你必须非常地有感染力和友好才有助于这些工作的推进。但这并不意味着你应该接受糟糕的改变，但是如果有人想要做出改善，你应该至少对他们表示肯定和赞许。</p><p>有时十个人里有九个人想要做正确的事情，但他们的声音会被那个嗓门最大的人的声音所掩盖，以至于他们想当然地认为应该尊重那一个人的想法，而不是据理力争。所以你应该尽力争取这一部分人的支持，这有助于你工作的展开。通常，忽略那个嗓门最大的人的声音继续一往无前地改善工作也是办法之一。</p><p>如果你终究还是被某些高层人士一致叫停，可能存在两种情况：<br>（a）解决问题的方式有所偏差（可能是你并没有按照我上面推荐的方式去执行，也可能是在和团队的沟通上出现了问题，还有可能是你正在做的事情会对开发者造成负面影响等）。（b）叫停你工作的人愚蠢至极，无论他们看上去多么地“正常”。</p><p>如果你的工作被叫停是因为你正在做错误的事情，那么找出什么对开发人员最有帮助，然后回归到正确方向去做就好了。有时这只需要和那位叫停你的高层人士好好沟通就能找到答案。</p><p>假设你现在正在通过渐进的方式，有条不紊地改善团队的开发效率，一些潜在障碍也逐渐被清除。那么接下来该何去何从？答案是请确保你的前进方向瞄准的是本质问题。</p><p>总有一天你需要解决这个问题，而解决的方式之一是需要纠正人们编写软件的方式。</p><p>先不要对外发布承诺，不要大声宣布你有一揽子改善开发效率的计划，并且计划是从重构代码开始的。</p><p>你应该希望人们产生一种思维惯性，比如“开发也意味着对代码进行整理”或者是“代码的质量也很重要”。也可以是其他你希望营造的文化氛围。</p><p>一旦你在团队内成功建立起了一种改善代码的团队文化，即使你不再对它进行过问，问题也会随着时间推移迎刃而解。这并非意味着工作就此结束了，一旦每个人都关心代码质量、测试和开发效率时，你会发现即使没有你的积极干预，事情也能开始向好的一方面发展，但最坏的情况也不过如此。</p><p>请牢记，整个流程的重点并不是在于“达成共识”。你并非在争取团队中每个人关于你应该如何完成你的工作的许可。而是在找到人们认为的问题所在，并且提供一个解决方案将其修复完毕，这个他们认可的解决方案不仅能够建立起大家对你的信任，还能逐步解决代码库的深层问题，并且确保它并不是为了迎合某个人而诞生的。你只需要记住一件事：<strong>解决那些人们认为他们面临的问题，而不是你认为他们面临的问题。</strong></p><p>最后一件我想要说明的是，所有这些技巧的前提是，你作为个体独自在负责整个公司或者整个团队的效率提升。还存在一些其他的场景——事实上，这并不是大部分效率提升工作的常态。实际工作中有的人会负责一部分工具的研发、有人负责框架的研发、有人负责和下属团队打交道等。</p><h3 id="第19章-量化开发效率"><a href="#第19章-量化开发效率" class="headerlink" title="第19章 量化开发效率"></a>第19章 量化开发效率</h3><p>一般我会优先把工作重点放在简化代码的设计上，我认为量化每一位开发者干的每一件事并不重要。几乎所有的软件问题，都是因为没有成功采用软件工程中的原则和实践。所以即使缺乏衡量标准，如果你能设法让整个公司都采用同一套好的软件工程实践，大部分的效率瓶颈和开发中遇到的问题都会自动消失。</p><p>有一种说法是，如果能将一切量化的话，这终将能带来巨大的价值。它能帮你识别出编码难点，允许你奖励那些效率提升的员工，允许你在效率欠佳的部门花更多的时间展开效能提升工作，当然还有其他数不清的好处。</p><p>但是编程不像其他的职业。你没法像量化制造业流程那样对它进行量化，在制造业中你只需要统计从流水线上检验合格下线的产品数量。但是你如何衡量一个程序员的产出呢？</p><p>秘诀在于对“效率”进行恰当的定义。理解效率的关键在于，意识到它与产出物有关。一个有效率的人通常都能够高效地输出产出物。</p><p>衡量开发者效率的方式之一是衡量他的产出物。</p><p>如果你想衡量一个人的产出物，你不应该去判断他掌握这门手艺的精湛程度。你应该衡量通过这门手艺他带来了多少产出物。</p><p>第一件需要想明白的事情是：对于用户来说，程序的哪一部分产出是最有价值的？软件的目的其实是“帮助其他人”。所以第一步就是确定哪一类人群是你的软件帮助的对象，以及在使用产出物为他们提供帮助时，会带来何种影响。</p><p>例如你负责研发和维护一款用于个人用户报税的会计软件，你可以把通过使用你的软件，成功且准确地填写了纳税申报的人数作为有效指标。当然软件的成功离不开公司内每一个人的努力（包括销售人员在内），但是程序员需要为软件的易用性和质量属性负主要责任。</p><p>有的人喜欢挑选那些程序员全权负责的事物作为指标，我建议不要盲目地依赖它——如果想要将它作为衡量个人产出物的有效手段，程序员不一定是唯一能够对它产生影响的人。</p><p>量化一个系统的指标也是多种多样的。假设你为一个购物网站工作。后端开发者或许会以成功执行的数据请求数量作为某项指标，而前端开发者则以成功添加进购物车的商品数量，以及成功通过结算流程的人数作为某项指标。</p><p>当然，单个候选指标也应该与整个系统的指标对齐。如果后端开发者只是衡量“后端接收到的请求个数”，而不考虑成功执行的情况，也不考虑执行的响应速度，那么他们完全可以设计一个需要反复调用多次的糟糕API，这无疑对用户体验造成了伤害。</p><p>所以你需要确保心目中的候选指标，是和帮助现实用户息息相关的。对于刚刚的例子，一个更好的解决方案可以是，多少次“提交支付”的请求被成功处理了，因为这才是最终结果。（顺便说一声我不会将此作为购物网站后端的唯一可能指标——它只是一个可能性而已。）</p><p>但无论你衡量的标准是什么，重点在于即使我们衡量的部分人员的产出物是代码，你衡量的依然是产出物。</p><p>还存在最后一种情况，就是如果他们的职责是负责改善开发效率。如果你的工作内容是帮助其他开发者提升对于需求的响应速度，你要怎么量化你的工作成果？</p><p>首先，大部分负责改善开发效率的人员都有属于他们自己特别的产出物。产出物可能是一个测试框架（也就是说你可以用上面所说的衡量一个库的标准衡量它），又或者是其他某些开发者可能会使用的工具，在这种情况下你可以统计工具的使用情况或者人们对它的满意度。</p><p>举个例子，bug管理系统的开发者们想要量化的指标之一，是bug被成功和迅速解决的个数。当然，考虑到工具在公司内部是被使用的方式，指标还需要稍做修正——或许有一些系统中的bug记录压根就不需要被快速修复，甚至将会长时间存在，所以你要想办法用其他的方式衡量它们。总的来说，你应该问自己：我们使用的这件工具，带来的产出物和造成的影响究竟是什么？这才是你应该衡量的——产出物。</p><p>但如果你并不是在开发一些具体的框架或者工具怎么办？有可能你的产出物和软件工程师这个群体息息相关。此时或许你可以衡量你的工作成果给工程师带来帮助的次数。或者统计你引入的改善给研发工作节省下来的时间，当然前提是你能准确地进行统计（基本是不太可能的）。总而言之，与量化其他类型的编程工作相比，量化这些工作会更加困难。</p><p>如果某人负责改善特定团队的开发效率，那么应该衡量团队体验到的效率提升程度。又或者衡量团队指标的提升速率。</p><h3 id="第20章-如何应对软件公司内代码的复杂性"><a href="#第20章-如何应对软件公司内代码的复杂性" class="headerlink" title="第20章 如何应对软件公司内代码的复杂性"></a>第20章 如何应对软件公司内代码的复杂性</h3><p>只有依靠程序员个体才能解决代码的复杂性问题。也就是说想要解决代码的复杂性，需要每一个人都对代码保持警惕。他们当然可以借助一些工具来减轻这项任务的压力，但简化代码这份工作终究还是需要人们脑力、注意力和汗水上的投入。<br>解决代码的复杂性问题，离不开每一位个体贡献者的底层代码工作。<br>如果管理者只是在下达“简化代码！”的指令后就拍拍屁股一走了<br>之，通常什么都不会发生，因为：</p><ul><li>a.员工们需要更明确的指令；</li><li>b.员工们对被需要改善的代码一无所知；</li><li>c.对问题的理解其实是发生在解决问题的过程中的，管理者并不是解决问题的人。</li></ul><p>如果你是一名软件工程经理，你可能会提出一类大而全的、能够一劳永逸解决所有问题的解决方案。通过这种方式解决代码复杂性的问题在于，代码问题通常在许多不同的子项目中，需要许许多多程序员个体落实到代码细节层面才能修复，这种一揽子的解决办法不切实际。</p><p>所以如果你想依靠一个大而全的解决方案来应对一切问题，你会发现它其实并不适用于所有场景。并且这么做只会适得其反，软件工程师们看上去做了很多工作，但实际上他们并没有产出一个具有可维护性且简单的代码库。</p><p>所以如果你作为一名管理者正在负责一个结构复杂的代码库，你需要做些什么来改善这些代码呢？解决问题的关键在于<strong>从每一位开发者身上获取信息，并与他们一同工作，从而帮助他们解决问题。</strong></p><h4 id="第一步——列出问题："><a href="#第一步——列出问题：" class="headerlink" title="第一步——列出问题："></a>第一步——列出问题：</h4><p>询问团队里的每一位成员，邀请他们把代码中最让他们受挫的地方写下来。代码复杂性引起的现象，会导致人们对于代码产生本能的情绪性反应，例如对代码感到疑惑，感觉到代码是极易损坏的，认为代码难以优化等。所以你可以提出类似这样的问题：“系统里有什么地方的代码是在你修改时会感到紧张的？”或者是“代码中有什么你曾经维护过的地方让你感到非常棘手？”</p><p>每一位软件工程师都应该把他们心目中关于这些问题的答案都写下来。我不推荐通过使用某个系统来收集这些信息——对于他们来说手写是最简单的方式。可以给他们几天的时间来整理答案列表，因为他们可能需要一些时间考虑。</p><p>这份列表可以不仅仅包括你负责的代码库，任何关于他们曾经维护过或者使用过的代码的吐槽都可以记录其中。现阶段你只是在收集症状，并非原因。对于这份回答来说，开发者们的表述可粗可细。</p><h4 id="第二步——举行会议"><a href="#第二步——举行会议" class="headerlink" title="第二步——举行会议"></a>第二步——举行会议</h4><p>召集你的团队举行一个会议，确保每个人都带来了他们关于那些问题的答案，以及能够访问代码库的电脑。团队会议理想的参与人员人数大致在六到七人左右，如果团队人数过多的话，你需要再将他们划分为更小的队伍来举行会议。</p><p>在会议上你应该挨个过一遍所有的回答，找到每一个症状对应的文件目录、文件、类、方法或者是代码块。</p><p>即使有人的回答是：“整个代码库都没有单元测试。”<br>你也应该刨根问底地问下去：“请告诉我这个问题会在什么时候对你造成影响？”</p><p>再根据他的回答找到现阶段最需要为之编写测试的文件是哪些。</p><p>你还需要确保你获得了关于问题的准确描述，类似于“重构代码非常困难，因为我不知道我的修改是否会破坏其他人的模块”。这种情况下单元测试似乎是一个解决方案，但是你首先还是需要尽可能地把问题的范围缩小。（的确所有代码都应该有对应的单元测试，但如果现在你的代码库中一个单元测试都没有，你需要从这方面的一些可行的任务开始。）</p><p>总而言之，只有代码才是能够被实实在在修复的，所以你需要知道哪一部分的代码出现了问题。当然还存在着影响面更广的问题有待我们解决，但是再大的问题也可以被拆解为更小的问题来各个击破。</p><h4 id="第三步——bug报告"><a href="#第三步——bug报告" class="headerlink" title="第三步——bug报告"></a>第三步——bug报告</h4><p>利用从会议中收集到的信息，为每一个问题（不是解决方案，只是问题！）生成一则bug报告，并且可以用这个问题关联的文件夹、文件以及类名作为bug报告的标题。例如“FrobberFactory类太难以理解了”。</p><p>如果在会议上问题的解决方案同时也有了结果，你可以在报告中进行备注，但是报告本身还是应该以问题为主。</p><h4 id="第四步——决定优先级"><a href="#第四步——决定优先级" class="headerlink" title="第四步——决定优先级"></a>第四步——决定优先级</h4><p>现在是时候决定问题的优先级了。首先要找到哪一个问题影响到的开发者数量最多。这些都是高优先级的问题。通常这部分工作是交由团队或者公司内对开发者最了解的人来完成。一般是团队经理。</p><p>有时候需要考虑问题间的依赖关系而不仅仅是严重性。举个例子，解决问题Y的前提是解决问题X，或者是如果问题A提前得到解决的话，问题B解决起来会更容易。</p><p>这意味着问题A和问题X即使没有它们后续的问题看起来那么严重，它们也应该优先被解决。大多数时候都会存在这么一条问题链，关键在于找到链路源头的问题是什么。</p><p>没有正确评估问题的优先级，是软件设计中常犯的错误之一。虽然这个步骤看上去无关痛痒，但它对降低解决代码复杂性的成本至关重要。</p><p>无论何时何地，软件设计的精髓在于以正确的顺序做正确的事情。</p><p>强迫开发者以无序的方式解决问题（忽略问题间的依赖关系）会加剧代码的复杂性。</p><p>无论你是在开发前期还是开发过程中完成的这部分工作，非常重要的一点是确保让每一位程序员意识到，在他们开始分配正式任务之前，首先需要解决一些前置任务。他们必须取得足够的授权，能够从当前需要完成的任务，切换到优先解决那些阻碍他们的任务。</p><h4 id="第五步——分配任务"><a href="#第五步——分配任务" class="headerlink" title="第五步——分配任务"></a>第五步——分配任务</h4><p>现在你可以把每一个bug分配给不同的具体开发者。可以说这是一个相当标准化的管理层面的流程了，虽然它涉及具体的沟通和工作细节，但我相信大部分软件工程经理对此已经驾轻就熟。</p><p>有一个意外情况是，可能其中一些导致bug的代码并不是由你们团队维护的。这种情况下，你需要通过与组织层面进行沟通，找到负责解决这个问题的合适团队。如果你能从另一个与你有相同遭遇的经理那里得到支持是再好不过的了。</p><p>在一些组织内部，如果其他团队引入的问题并不复杂，也不需要了解过多的细节，那么你所属的团队就可以自行对它进行修复。这可以根据你们解决问题的效率和成本自行决定。</p><h4 id="第六步——计划"><a href="#第六步——计划" class="headerlink" title="第六步——计划"></a>第六步——计划</h4><p>现在你已经对所有bug进行了记录，接下来你必须要想清楚何时将它们修复。一般来说最佳的方式是确保开发者们会定期修复其中的一些问题，并且同时进行常规功能的开发。</p><p>如果你的团队通常以一个季度或者六个礼拜作为一个迭代周期，你应该在每个迭代周期内都安排一些代码清理工作。最好是让开发者们首先做一些能够让他们将来开发代码变得更轻松的代码清理工作，再开始正式的代码功能开发。</p><p>放心这通常不会拖慢开发进度（也就是说如果代码清理得当，开发者们依然能够在一个季度内把计划中的功能实现，这变相说明了实际开发时间减少了，同时开发效率得到了提升）。</p><p>不要为了代码质量而完全中止正常功能的开发。请确保提升代码质量的工作会持续进行下去，自然而然代码库总体上就会趋于变好而不是变差。</p><h3 id="第21章-重构与业务功能有关"><a href="#第21章-重构与业务功能有关" class="headerlink" title="第21章 重构与业务功能有关"></a>第21章 重构与业务功能有关</h3><p>当你在清理代码时，你其实是在间接地为代码所属的产品提供服务。重构的本质是一类有组织的流程（这里说的“有组织”并不是指“与业务有关”，而是说“有序地将事物安排起来”）。也就是说，为了达成某个目标你在对事物进行有序的排列。</p><p>当你开始独自重构时，重构会给你带来一个坏的名声。人们会开始认为你在浪费时间，你在人们心目中的可靠程度会降低，你的经理和小伙伴们会设法阻止你接下来的重构工作。<br>我所说的“独自重构”意思其实是，你发现了一些与你当前工作不相关的代码，并宣布“我不喜欢它的架构设计”，然后在不影响系统功能的前提下对代码的不同部分做设计上的修改。</p><p>浇灌草坪的重点是你房屋前有一片不错的草坪。如果重构代码的部分和你当前负责的产品或者系统的实现目标没有任何关系，算下来你其实什么都没有做，只不过重构了一些没有人用或者没有人关心的代码而已。</p><p>通常来说，首先你需要挑选一个有兴趣上手的业务功能，然后找出通过重构哪一部分代码能够让你的开发工作变得更轻松。又或者找一些修改频率很高的代码，对它们进行组织优化。这会让人们对你的工作投来赞许的目光。人们赞许的背后有更深层的原因：事实上他们这么做是因为你目前的工作起到了事半功倍的效果。无论如何这至少算是一类对你工作成果友好的认可，并能够鼓励你持之以恒地坚持下去，也表示有人开始注意到你的工作，说不定还能和你一起把好的开发实践在公司里推广。</p><p>你是否可能需要重构一个与手头工作并不直接相关的项目代码？这是非常有可能的，有时候你需要重构一些与目标间接相关的代码。</p><p><strong>清理复杂代码库的关键原则之一就是始终在特性服务中进行重构。</strong></p><p>代码库实际处于这种状态——它变得更糟的速度比变好更快。你首要的目标，是想办法让系统变得越来越好，而不是越来越差。</p><p>你必须在达成业务目标与重构代码之间进行平衡。因为现实条件并不可能允许你一直将代码重构下去</p><p>一般来说，我会给需要修改的代码设定一个边界，例如“哪怕是为了实现业务目标，我也不会重构任何我当前项目以外的代码”或者是“我不会等到编程语言本身做出了修改之后才将这个功能发布”。</p><p>重构不是在浪费时间，而是在节省时间。总体工作时间只会更少或者持平而已。这里“总体”还包括了你花费在调试代码上的时间、回滚代码版本的时间、修复bug占用的时间、编写复杂系统运行测试的时间等。</p><p>当我在决定代码何时才算重构“完成”时，我的判断标准是当别人在阅读这段代码时，能清晰地辨别出我在代码中的设计模式，并且能够随着这个模式继续维护下去。</p><p>有时候我会编写一些文档用于描述系统的设计思路，确保人们能够按照这个方向维护下去，但我的理论是（这条真的就是个理论了——我还没有足够的证据证明它的正确性），如果我把代码设计得足够好，其实就用不着用于描述设计思路的文档。通过阅读代码，设计思路也许就能自然而然地呈现出来，当你需要添加新功能时，需要涉及的修改之处一眼就能找到，连犯错的机会都没有。但很显然，想要完美实现这个目标几乎是不可能的，但是软件设计中有一条普遍真相是：<strong>没有最好的设计，只有更好的设计。</strong></p><p>这也是另一则用于判断你是否“本末倒置”，或者过度设计，又或者花费了太多时间设想应该如何重构这件事的标准——你是否在设法让它变得“完美”。它没有必要“完美”，因为根本就不存在“完美”。只有“出色地将它应该完成的工作完成”。在不理解代码开发目的的情况下，你无法准确判断代码设计的好坏。一种设计对一种目的奏效，另一种设计可能又对另一种目的奏效。</p><p>当你在重构代码时，你的出发点应该是将代码的设计修正为更符合它的当前用途。</p><h3 id="第22章-善意和代码"><a href="#第22章-善意和代码" class="headerlink" title="第22章 善意和代码"></a>第22章 善意和代码</h3><p>软件工程根本就是一门人类学学科。</p><p>在多年对软件开发流程进行持续改善的过程中我犯下过许多错误，这些错误都有一个共同的特征，就是只把目光聚焦于系统的技术层面，而不考虑写代码的人类的因素。你会发现有人更关注性能优化而不是代码可读性；你也会发现某人从不写注释，却乐意把时间都花费在如何让脚本代码行数变得少上面；你还会发现有人不善于沟通，却对小型二进制类库崇拜得不行：这些都是人类因素引起各种问题症状。</p><p>软件与人相关，软件系统代码是由人编写的。同时也是供人阅读，由人修改的，无论理解与否也都与人有关。它们代表的是编写它们的开发者思想。代码是地球上最接近人类思想的一种产物。</p><p>在与一群软件工程师协同工作时，有一条非常重要的原则：用粗鲁的态度对待开发团队里的成员不会带来任何价值。</p><p>粗鲁地对待与你一同工作的同事不会带来任何的帮助。气愤地告诉他们某个地方做错了，或者做了不该做的事也无济于事。唯一行之有效的是，确保软件设计的各项准则被正确应用到了开发中，以及人们在遵循正确的方向让系统变得更容易阅读、理解和维护。但这一切都没有必要用一种粗鲁的方式来实现。有时你需要做的仅仅是告诉人们他们某个地方做错了就好了。你只需要实事求是地说出来——大可不必为了这件事蹬鼻子上脸地对他人进行人身攻击。</p><p>这不仅限于代码评审，每一位工程师都有他们想要表达的观点。无论你同意与否，你都应该倾听他们的想法。礼貌地接纳他们的表述。用建设性的方式与他们交流你的想法。<br>值得一提的是，有时候人们确实难免会生气。但是请相互理解。有时候你也会生气，当这种情况发生时你也希望你的同事能理解你，不是吗？</p><p>请给予他们犯错的空间。用友善的态度和他们一起工作，齐心把软件做得更好。</p><h3 id="第23章-运营开源项目社区其实非常简单"><a href="#第23章-运营开源项目社区其实非常简单" class="headerlink" title="第23章 运营开源项目社区其实非常简单"></a>第23章 运营开源项目社区其实非常简单</h3><p>想要维护好开源项目社区，以及让社区稳步地壮大，本质上来说取决于三件事：</p><ul><li>1.让人们变得乐于贡献代码。</li><li>2.移除有碍于参与项目，以及贡献代码的种种障碍。</li><li>3.把贡献者留住，才能让他们持续贡献代码。</li></ul><p>如果你首先能让人们对你的项目提起兴趣，然后让他们开始正式贡献代码，并且保证他们始终对项目不离不弃，那么你才算是成功组织起了一个开源社区。否则你并没有。</p><p>一旦某人开始参与项目贡献，有什么办法能让他一直贡献下去呢？我们如何留住贡献者？首先我们对所有过去离开了这个项目的人做了一个调查，询问他们为什么离开。这个调查允许他们自由发挥，允许人们填写他们想要回答的任何答案，然后我们制作了一份图表，用于展示整个项目十年来贡献者数量的变化，然后将图表的起伏与这么多年来我们采取的或者是没有采取的各种行动关联起来。<br>当一切完成之后，我给Bugzilla项目的全体开发者发送了一封邮件，邮件中详细描述这项研究的成果。如果你有兴趣的话你可以阅读整封邮件内容，但是我会在这里总结一些其中的发现。</p><p><strong>1.不要让主干太长时间止步不前</strong></p><p>传统的开源社区智慧认为，人们喜欢在添加新特性上，而不是在修复软件错误上工作。我不敢说它是绝对正确的，但是我想说，如果你只允许人们修复错误，那么他们中的大多数都不会耐着性子留下来。</p><p>我们解决这个问题的方式是不再冻结主干代码。取而代之我们会在之前“冻结”主干代码的时间点立即创建一个分支。并且主干也始终保持着开放的状态，用于接纳新功能的开发。</p><p>是的，正如你预料的那样，我们的注意力会被分散在主干和最新的分支上。当我们在提交修复代码时，需要同时提交到分支和主干上。在开发新功能的同时我们也要兼顾解决bug修复问题。但我们发现这么做不仅让我们的社区迅速壮大，也让我们发布新版本的速度变得更快了。最终带来了一个双赢的局面。</p><p><strong>2.离开是不可避免的</strong></p><p>调查发现贡献者离开的首要原因是他们没法挤出时间来参与贡献了，又或者他们当初贡献代码是因为工作上的需要，现在他们换了一份工作。总的来说贡献者的离去是在所难免的。</p><p>所以如果社区成员注定有一天要离开的话，拓展社区的唯一方式就是想办法留住新的贡献者。如果你不这么做，社区会随着旧成员的离去而逐渐地萎缩，无论你做什么都于事无补。</p><p><strong>3.及时响应贡献者的反馈</strong></p><p>人们（通常）不会介意对他们提交的代码进行再次的修改。甚至不介意修改多次。他们实际上介意的是当他们将代码提交上传三个月之后才得到评审的答复，告知他们需要对代码进行修改，然后还需要再等上三个月才被告知又要进行一次修改。延迟才是他们离开的最重要的原因，并非因为对于质量的苛求。</p><p>也有一些其他快速响应贡献者提交的代码的方式。举个例子，立即对提交代码的人表示感谢就是一个屡试不爽的办法，能大概率把新的贡献者“转化为”长期的开发者。</p><p><strong>4.表现出极度的友善和不加掩饰的感激之情</strong></p><p>对于每一个回复了我们调查的人，除去“我换工作了”和“我没有时间”外，其余离开的原因都是出乎意料的个人原因。</p><p>当人们在以志愿者的身份做出贡献时，他们并不奢求任何金钱上的回报，他们获得的是尊敬、赞许，以及将工作圆满完成的满足感，还有参与一个能够影响数百万人的产品所带来的成就感。所以只要有人贡献了一份自己的代码，你就应该对他们表示感谢。即使这份代码是完完全全需要被重写的垃圾，你依然要对他们表示感谢。因为他们对此已经投入了不少的汗水，如果你不这么做，在正式加入之前他们就已经想要离开了。</p><p>这里想表达的是，与指出人们错误相比，更重要的是对他们的贡献中积极的一面表达感谢和肯定。你必须真真切切地告诉贡献者你对他们的贡献表示感谢。你越是频繁和慷慨地做这件事，你留住贡献者的概率就越大。</p><p><strong>5.避免对个体进行否定</strong></p><p>要真心实意地，甚至近乎变态地和善，并且在这一点上千万不要吝惜。</p><p><strong>移除障碍</strong></p><p>下一个步骤就是要移除准入的门槛。究竟是什么阻碍着人们在贡献代码上迈出第一步呢？通常来说，最大的阻碍是缺乏文档和方向。当人们想要开始贡献代码时，他们想当然地会去思考应该如何贡献代码。</p><p>通过好几种方式来解决这个问题：</p><ul><li>1.列出容易上手的项目</li><li>2.创建文档沟通的渠道</li><li>3.用优秀的、完整的以及简单的文档，描述一次代码提交应该是什么样的</li><li>4.让所有的文档更容易地被找到</li></ul><p><strong>让人们对项目感兴趣</strong>、<strong>用热门的编程语言编写项目</strong>、<strong>成为一个超级受欢迎的项目</strong>。</p><hr><h2 id="理解软件"><a href="#理解软件" class="headerlink" title="理解软件"></a>理解软件</h2><h3 id="第24章-什么是计算机"><a href="#第24章-什么是计算机" class="headerlink" title="第24章 什么是计算机"></a>第24章 什么是计算机</h3><p>计算机是能够执行一系列符号指令，并且通过对数据进行比较以帮助人们达成目标的机器。</p><ul><li>计算机能够对比数据。这有别于其他能够接受人类输入的机器。</li><li>计算机不仅能接受单条指令，还能接受一系列指令。比如一台简单的计算器只能处理一条指令，而计算机则强大得多，使它们区分开来。</li><li>和键盘上的一次按键一样，一次鼠标点击也可以算作“符号指令”。但是作为程序员，我们主要使用的符号指令是编程语言。所以作为程序员的我们在讨论该如何提升我们工作产出的质量时，更多的是在关心我们的程序的结构设计。</li></ul><h3 id="第25章-软件组件：结构、操作和结果"><a href="#第25章-软件组件：结构、操作和结果" class="headerlink" title="第25章 软件组件：结构、操作和结果"></a>第25章 软件组件：结构、操作和结果</h3><p>模型-视图-控制器（Model-View-Controller，MVC）模式之所以如此成功，是因为它反映了一个计算机程序最基础的本质：当一系列操作（action）施加于具有特定结构（structure）的数据之后，就会产生某种结果（results）。当然你的程序也需要接受各种输入，你可能会争辩需要把输入作为程序的第四个组成部分，但是我通常还是认为计算机由前三个部分组成：结构、操作和结果。</p><p>在MVC的语境里，模型就是结构，控制器替代了操作，视图则是结果。结构、操作和结果或许能够用于描述现存的所有机器。</p><p>一台机器可以拥有一些无法活动的部件，比如一个大型框架——这就是结构。一些可以被灵活控制并且参与实际工作的组成部分——这种动态的部分就是操作。最后机器会产出实体物品（否则它对我们就没有意义了）——这就是结果。</p><blockquote><p>当我在编写软件时，我通常首先把结构搭建起来，然后编写操作部分，最后处理展示结果。有的人会从结果出发反向开始工作，这样也没有问题。但最不明智的选择或许是从操作部分开始入手，因为在既没有结构也没有结果的前提下执行的操作实在令人困惑。</p></blockquote><h3 id="第26章-重新审视软件：SAR-ISAR概念详解"><a href="#第26章-重新审视软件：SAR-ISAR概念详解" class="headerlink" title="第26章 重新审视软件：SAR/ISAR概念详解"></a>第26章 重新审视软件：SAR/ISAR概念详解</h3><p>任何计算机软件都由三个主要部分组成：结构、操作和结果。<br>一个程序或许还可以存在输入这类元素，它可以被认为是软件的第四个组成部分，尽管通常是用户而不是程序员创造了这一部分。所以我们既可以把这组概念缩写为SAR，也可以缩写为ISAR，这取决于我们是否想把“输入”这个概念也归纳进去。</p><p>SAR的应用场景比MVC要宽广得多，MVC是一种用于软件设计的模式，而SAR（或者ISAR）则是对于所有软件中三类（又或者四类）组成元素的描述。</p><p>SAR的迷人之处不仅在于它对整个程序适用，对程序的任意组成部分也同样适用。一个完整的程序拥有结构，但是单个函数或者是单行代码也同样拥有结构。对于操作和结果这两个概念也是如此。</p><p>在完整程序中能够被当作“结构”的一些例子：</p><ul><li>代码的文件夹分布。</li><li>所有的类以及它们之间的关联方式。</li><li>如果你的程序需要用到数据库的话，数据库的结构（模式）也算是一种结构。（注意数据库中存储的数据并不能算作结构。如果你程序会生成数据并且将数据存储在数据库中，那么它们应该算作结果的一部分。如果数据已经存在而你的程序负责对它进行处理，数据则算作输入。）</li><li>一个独立的类（站在面向对象的角度上说）也拥有结构：<ul><li>类里各种方法的名称，以及它们需要处理的参数的类型/名称。</li><li>类里变量的名称和类型（成员变量）。</li></ul></li></ul><p>无论一个函数（或者变量）是私有还是公有，它都算是结构的一部分，因为结构就是用于描述的这个东西是什么的（与之相反的是这个东西能做什么或者是能产出什么），而“私有”或者“公有”恰恰是用来描述这个东西是什么的词组。</p><p>结构是“程序的组件”或者是“程序的组成部分”。所以函数的名称和类型、变量的名称和类型，以及类——这些都是结构。</p><p>结构只是“摆在那里”。除非程序中的其他部分用到它，否则他不会给自己找事做。</p><p>操作，与一个完整程序有关的操作非常好理解。一个税务软件就是用来“处理税务”的，一个计算器程序就是“用来计算”的。操作一定是动词。“计算”“修复”“添加”“移除”，这些都属于操作。</p><p>在一个类里面，操作就是方法内的代码。你可以把它们当作各种各样不同类型的操作——有些事已经发生，有些事将要发生。在许多的编程语言中，你还可以在任意的类或者函数之外编写代码——那种启动程序时才运行的代码。它们也属于操作。</p><p>结果，每个程序，每个函数，每一行代码都会产生一些影响。它们会产生某种结果。</p><p>任何一种结果总是能用过去式来描述——它是某种已经被完成或者创建过的事物。</p><p>你程序中的代码片段也产出结果。当你调用一个方法或者函数时，会得到一个非常具体的结果。它会返回给你一些数据，或者它会造成一些数据的改变。无论程序（或者程序的某一部分）最终会产出什么，它们都算是结果。</p><h3 id="第27章-软件即知识"><a href="#第27章-软件即知识" class="headerlink" title="第27章 软件即知识"></a>第27章 软件即知识</h3><p>软件从根本上来说是由知识组成的物体。它遵从所有与知识相关的规则和定律。它展现出的行为也和在任意场景下知识展现出的行为一模一样，除了不同软件体现的具体形式会有不同。</p><p>举个例子，当软件过于复杂时它很容易被误用。而当软件出错时（比如有了一个bug）它还有可能会给他人造成伤害以及引发问题。同样当人们对代码一知半解时，人们可能会无法对它们做出正确的修改。所有与知识有关的方方面面对软件也同样适用。错误的数据可能会导致人们犯错，错误的代码也会导致计算机犯错。</p><p>有人也希望软件，特别是代码，也表现得更有意义和更富有逻辑。因为代码就是知识，在人们阅读代码时，在脑海里它们应该能够立即被翻译成知识。如果代码做不到这一点，那就意味着代码其中的某部分过于复杂——或许是底层的编程语言或者是系统，但更有可能因为软件设计者创建的代码结构不够简约。</p><p>当我们在渴望知识时，可以通过不同的方式获取它。有人通过阅读获取知识，有人通过思考获取知识，有的人通过观察，有人通过实验，还有人通过交谈等。总的来说我们可以将这些方式划分为两类：是在自力更生获取信息（观察、实验、思考等）；还是在借助他人获取知识（阅读、聊天等）。</p><p>当在判断某人解决问题时是需要编写新代码还是使用已有代码的时，这些原则也同样适用。你基本上不太可能包办从软件到硬件层面的所有代码，或者独立开发出当下十分受欢迎的软件。</p><p>当然有一些代码没有地方可复用，只有熟悉业务的我们才有资格编写——这部分代码通常是正在开发的产品的特殊业务逻辑部分。但是更多的时候我们还是要依赖现有的代码，就像作为人类个体我们必须依赖二手知识生存一样。</p><p>这些原则也可以用于在不同的开发者之中分配工作，是让人用第一手信息提前编写一部分代码会更快，还是让一群人同时对一个现有系统（二手知识）进行代码修改（对他们来说也算是第一手信息）会更快？答案很明显是依情况而定，尽管这里提出的观点并没有多新奇（有些程序员比其他人更了解系统，所以他们可以更快地完成），但是我们将结论推导出来的方法很重要。首先我们从理论上说明软件就是知识，然后我们发现了一条逻辑清晰的思路，它指向现存的一些普遍成立的原则。这意味着我们可以从这些已知的原则中找到其他更有用的信息。</p><h3 id="第28章-技术的使命"><a href="#第28章-技术的使命" class="headerlink" title="第28章 技术的使命"></a>第28章 技术的使命</h3><p>时，最终的结果通常是成功的。而当尝试用它解决与人相关的比如思维、沟通、个人能力等问题的时候，它通常是失败的，甚至会事与愿违。</p><p>们可以和世界上任意一个人进行实时的交流。但是它不会让我们成为更好的沟通者。事实上它反而给许多非常差劲的沟通者提供了一个广阔的平台，让他们能够在上面传播仇恨和恐惧。</p><p>技术善于解决什么样的问题以及不善于解决什么样的问题：专注于用技术解决人类相关问题的公司更有可能失败。使用技术解决与实体物质相关问题的公司至少还有成功的概率。</p><p>看上去似乎存在一些关于这条规则的反例。举个例子，Facebook存在的意义不就是将人们连接在一起吗？这听上去是一个与人有关的问题，并且Facebook也做得非常成功啊。但是将人们连接起来并不是Facebook实际上在做的事情。它提供的只是一个供人们沟通的媒介而已，它并没有主动将人们联系起来。事实上，我认识的大多数人都对沉迷于Facebook感到反感——人们把时间都花费在了网络上，而不是对人类而言更为珍贵的线下生活中。</p><p>技术本身并没有好坏之分，但是当它在被尝试用于解决与人相关的问题时趋于变坏，而当它聚焦于解释现实世界物质有关的问题时趋于向好。</p><h3 id="第29章-简单地聊聊互联网隐私"><a href="#第29章-简单地聊聊互联网隐私" class="headerlink" title="第29章 简单地聊聊互联网隐私"></a>第29章 简单地聊聊互联网隐私</h3><p>第一种类型的隐私是“空间隐私”。这类隐私权能够决定谁能或者不能进入一个特定物理空间，或许是因为你正处于那个空间，所以你并不希望某些特定的人进入这个空间。“进入空间”从定义上说也包括采取任何的方式方法来感知空间内发生的一切。这种形式的隐私是实实在在的。它的适用范围仅限于物理空间，从字面上理解就是说“我可以允许，也可以禁止你感知这个物理空间里发生的一切，我拥有掌控这件事的权力”。</p><p>我们之所以想要这种形式的隐私，最主要的原因是我们想要保护某人或者某物避免受到伤害，这里保护的对象通常是我们自己。这种形式的隐私和计算机程序无关，因为我们不认为与我们共处一室的计算机程序侵犯到了我们的隐私空间。我的文字处理软件不会侵犯我物理空间里的隐私，即使它与我“在同一个房间里”，因为它没有任何感知能力。唯一的例外是如果某个计算机程序将它接收到的一切（图像或者声音）传送到某个我们并不希望传送到的地方——这就算是侵犯隐私了，因为当我们不希望这一切有人知晓的时候，某人还是能够通过这个软件感知到空间里发生的一切。</p><p>第二种类型的隐私就是“信息隐私”。这种类型的隐私决定了某些人是否应该知晓某些事情。在计算机程序和互联网语境下，这才是我们通常讨论的隐私类型。独立的个体或者团体之所以希望信息隐私不受到侵犯，是因为他们相信隐私信息在落入他人之手之后，会增加给他们带来伤害的可能性。</p><p>无论你从事什么样的职业，为了生存，你必须和他人交换信息。你要做的事情越多，你需要交换的信息也就越多。</p><p>“每一条隐私信息在使用前都应该征求用户同意”的想法也是荒谬的。你希望你的浏览器在每一次你加载页面时，都询问你：“我可以向这个提供这个网页的网站发送你的IP地址吗？”如果你是一名驻扎在敌对国家的间谍，或许你希望这么做。但如果你是普通人，那可能只会给你带来烦躁——你不再会使用这款浏览器，并且转而搜寻其他可以替代的软件。但如果你真是一名间谍或者是反抗组织战士，你可能会使用洋葱路由器（Tor）来避免被追踪。</p><h3 id="第30章-简约和安全"><a href="#第30章-简约和安全" class="headerlink" title="第30章 简约和安全"></a>第30章 简约和安全</h3><p>提升软件安全性的秘诀之一（也可能是最主要的因素）是保证软件足够简约。</p><p>当我们在考虑软件的安全性时，首先要问的问题是：“这个软件可能会遭受多少类攻击？”这等同于在问存在多少种“进入”软件的方式。更像是询问：“这幢建筑有多少扇门和窗？”如果这幢建筑只有一扇门与外界连通，看守它非常容易。但如果它有1000扇门，那么确保这幢建筑的安全似乎就不太现实了，无论每一扇门的安全性如何或者你雇佣了多少负责安全的警卫，都无法做到万无一失。</p><p>所以我们需要将“进入”软件的方式限制在指定的数量之下，否则安全无从谈起。通过让整套系统变得相对简约，又或者将它拆解为简约并且完全独立的组件，能够帮助我们达到提升安全性的目的。</p><p>一旦我们成功限制了进入软件的方式数量，接下来就要开始思考：<br>每一种进入软件的方式可能会被多少种攻击所利用？</p><p>我们可以通过尽可能简化“进入”方式本身来降低这些攻击的可能性。</p><p>如果这部分工作也完成了，然后我们就需要尽可能降低将攻击带来的最大损失。好比在一幢建筑中，我们要确保一扇门只会通往一个房间。</p><p>标准的UNIX系统只提供数量非常少的系统调用供绝大部分UNIX程序的实现使用。（即使扩展后系统调用总数也只有大概只有140种左右，而且其中的绝大部分在常见的程序中根本没有被使用过。）每一个系统调用所做的工作都极其具体，并且能力十分有限。</p><p>而Windows操作系统则有一堆十分荒唐并且让人疑惑的系统调用，每一个调用都需要传递太多的参数，所干的事情也过于繁杂。</p><p>如果你对系统提供的高级功能稍做了解的话，你会发现Windows提供的API算是庞大而复杂的。它们像是能够同时控制系统和界面的奇异野兽。而你在UNIX中找不到任何与之完全等价对应东西（因为在UNIX中系统和界面是完全分离的），但是我们还是可以将它们的部分组件进行比较。例如我们可以比较Windows提供的日志API和Linux下的日志API，但它们完全没有可比性，因为Windows下的日志API简直就是个笑话。对于Windows操作系统来说，任意一个组成部分都存在太多种类的“进入”方式，导致它从来没有安全可言。</p><p>获得安全保障的最佳方式是简单明了。</p><p>我们不应该在软件前布置千军万马来保障它的安全。而是应该借助限制软件只提供一些最基础的“入口”，来减少保护的需求，这些“入口”应该是直截了当和简单易懂的，并且还能免受被入侵的危害。</p><h3 id="第31章-测试驱动开发和观察循环"><a href="#第31章-测试驱动开发和观察循环" class="headerlink" title="第31章 测试驱动开发和观察循环"></a>第31章 测试驱动开发和观察循环</h3><p>每一个人都有关于如何编写代码各不相同的偏好，都有各自的道理。但是通过观察每一个人的偏好，你能够总结出一条通用的原则：“我需要对某件事物进行观察之后才能做出决定。”有些人在他们编写代码时需要观察相关测试的运行结果，有些人则需要通过观察他们正在编写的代码，才能决定接下来的代码要怎么写。甚至当他们在谈论到个人开发规则中的一些例外情况时，也总是会提到把留意到某件事作为他们开发过程的一部分。</p><p>这是可以一条可以应用在所有软件开发循环周期中的原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">观察（Observation）→决策（Decision）→行动（Action）→观察 →决策→行动→……</span><br></pre></td></tr></table></figure><p>如果你想给整个流程起一个名字，你可以称之为“观察循环”（Cycle of Observation）或者“ODA</p><p>每一个有效的开发流程都会将流程中的这类循环模式作为它主要的指导思想。甚至像敏捷开发这种大规模的涉及全团队的开发流程也是如此。事实上，敏捷开发只不过是那种已经被抛弃的，需要花费数月或者数年才能完成一个循环迭代开发模式（瀑布模型，也被称为“预先做大量设计（Big Design UpFront）”）的短周期版本（每几周）而已。</p><p>所以这么看来短周期似乎比长周期更好。大部分开发者的效率提升，都可以通过将ODA循环周期缩短为对开发者、团队或者是组织而言最小的合理时间来达成。</p><p>通常来说你可以通过将精力放在缩短观察时间上，来将整个循环周期时间缩短。一旦成功之后，周期的其他两部分就会自行加速（如果它们没有加速，</p><p>有三个主要因素会对观察阶段带来影响：</p><ul><li>信息呈现给开发者的速度（例如能够快速给出反馈结果的测试）。</li><li>信息呈现给开发者的完整性（例如拥有完整的测试覆盖率）。</li><li>信息呈现给开发者的准确性（例如测试值得信赖）。</li></ul><p>这能帮助我们理解近几十年来某些特定开发工具背后成功的成因。比如持续集成、线上环境监测系统、性能调试工具、代码调试工具、编译器中更明确的错误消息、能够突出显示错误代码的IDE——之所以所有这些工具能如此“成功”，是因为它们让观察这件事变得更快、更准确或者更完整了。</p><p>有一个问题需要注意——你必须确保你呈现信息的渠道，也是人们能从中获取到他们想要信息的渠道。如果你只是无脑地把大批量的信息倾倒给人们，而他们又无法轻易地从中找到他们关心的具体数据，那么这种数据可以说是无用的。好比如果没有人收到过一次线上环境的报警，那么这个报警是否存在也就不重要了。</p><p>如果一名开发者一直无法确认他接收到的信息的准确性，那么他很可能就会开始忽略这类信息。你必须确保成功地传递了信息，而不只是将它生产出来而已。</p><p>事实上还存在一类能够代表整个软件开发流程的“大ODA循环”——发现一个问题，确定解决方案，将它在软件中实现。在这个大循环中，还有许多小的循环（比如被分配到了一个功能需求，确定功能应该是如何工作的，然后将这个功能完成）。甚至在小循环中还存在更小的循环（观察到需求变更，确定如何实现，然后用代码编写），如此往复。</p><p>在所有这些可能的循环过程中，最棘手的往往是第一轮ODA循环，因为你需要在缺少前一轮决策或者行动的前提下做出观察。</p><h3 id="第32章-测试的哲学"><a href="#第32章-测试的哲学" class="headerlink" title="第32章 测试的哲学"></a>第32章 测试的哲学</h3><p>我们通过一种包含断言、观察和实验，并称之为“测试”的系统工具来获取与软件行为相关的知识。</p><p>从某种意义上说，软件测试是传统科学方法论的反向过程，传统的科学方法论是，你首先需要对宇宙进行验证，然后把实验得到的结果用于完善你的假设。</p><p>与之相反的在软件领域中，如果我们的“实验”（测试用例）不能证明我们的假设（测试做出的断言），那么则需要对正在测试的系统做出修改。</p><p>也就是说一旦某个测试失败了，很有可能是我们的软件需要修改，而不是我们的测试。当然有时候我们也需要对测试进行修改来确保它能够恰当地反映我们软件当前的状态。</p><p>通过对测试的价值、断言、边界、假设和设计进行检视，有助于对我们编写的测试进行重新思考。</p><p>测试的目的在于向我们传递系统的有关知识，这些知识其实存在不同层次的价值。</p><p>举个例子，不分场合地测试1+1是否依然等于2不会给我们带来任何有价值的知识。但是如果能让我意识到，即使我依赖调用的API做出了破坏性的修改，但我的代码依然能够正常工作，在这种情形下这部分信息还是能给我带来非常大的帮助的。</p><p>总的来说：</p><ul><li>在创建一个有效和有用的测试之前，人们必须要清楚地知道自己想要获得什么样的信息。</li><li>只有恰当地对信息的价值作出判断，才能正确领悟应该把时间和精力投入哪些测试中。</li></ul><p>如果说我们想要知道是什么让一个测试之所以能被称为测试，那么一定是因为它对某件事做出了断言，并且告知了我们断言的结果。人工测试人员可以对事物作出性质上的断言，比如某个颜色是否足够吸引人。但是自动化测试作出的断言必须是计算机有能力给出的，通常是判断一些可量化的具体陈述正确与否。</p><p>没有断言的测试不是一个测试。</p><p>我们会通过运行测试来熟悉我们的系统：断言结果的正确与否都能让我们学习到有关知识。</p><p>每一个测试都存在一定的边界，这是作为测试定义与生俱来的一部分存在的。</p><p>所以当在设计测试时，你应该知道什么需要被测试，什么不需要。</p><p>如果你编写了这样一个测试，很有可能你把多个测试合并成了一个，这些测试应该被分开。</p><p>每一个测试内都存在一组假设，这是测试在它的边界内能够高效执行的前提。</p><p>所有测试至少存在三种结果——通过、失败和未知。</p><p>结果为“未知”的测试不能说它们是失败的——否则就意味着他们向我们提供了某些关于系统的信息，但事实上它们没有。</p><p>所以我们需要对全套的测试进行设计，以便：<br>当我们将所有的测试组合在一起后，它们能够切实给予我们想要获取的所有知识。</p><p>“端到端”测试的意思是对一条完整的系统逻辑“路径”进行断言。也就是说你需要把整个系统搭建起来，在用户端执行一些操作，然后验证系统产出的结果。你并不关心系统内部为了达到这个目的是如何工作的，你只需要关心输入和结果。这基本上对所有测试都是成立的，但是在这里我们只在系统的最外层执行测试，也只检查最外层返回的结果。</p><p>端到端测试背后的主要思想是，通过我们尽可能以“真实”和“全面”的方式对系统进行测试，可以从断言中获取到极为精准的知识。路径上所有的交互和涉及的复杂逻辑都用测试进行覆盖。</p><p>只做端到端测试带来的问题是难以获取到关于系统的所有知识。在任何一个复杂的软件系统中，需要进行依赖和交互的组件数量和代码路径条数成爆炸级的增长，让测试很难或者不可能准确覆盖到所有的路径，并做出所有我们想实现的断言。</p><p>端到端测试还是有它的价值的，特别是对于完全缺少测试的系统来说是一个引入测试的很好切入点。它们也是当你想要检测整个系统组合起来是否能正常工作的有力工具。它们在测试套件中拥有重要的地位，但是就本身来说，它们并不是用于获取一个复杂系统全部知识的好的、长期的解决方案。</p><p>如果某个系统在经过设计之后只能以端到端的方式对其进行测试，那么这就是一个代码中存在架构问题的征兆。</p><p>这些问题应该通过重构来解决，目标是让系统也能够用上其他的测试方法。</p><p>集成测试下，你会取系统中的一个或者多个完整“组件”，用于专门测试将它们“组合在一起”后的表现行为如何。这里说的一个组件可以是一个代码模块、一个你系统依赖的库、一个提供数据的远程服务——本质上来说系统内任何一个从概念上可以和系统其他部分分离的内容都可以算作是一个组件。</p><p>与端到端测试相比，集成测试会将有待测试的组件独立出来，而不是把整个系统想象成一个“黑盒”对其进行测试。</p><p>集成测试不会遇到像端到端测试面临的那种糟糕的测试路径数量爆炸的问题，特别是当有待测试的组件本身和交互组件都非常简单的情况下。如果两个组件因为他们的交互极为复杂而导致难以进行集成测试，这或许在暗示我们其中的一个或者多个组件都需要被重构以便让组件变得更加简约。</p><p>就集成测试方法论本身来说它依然存在缺陷，如果想单纯地从组件间的交互来对整个系统进行分析的话，这意味着用于交互测试的组合数量必须要非常多，才能勾勒出整个系统行为的全景图。</p><p>与端到端测试相似，集成测试也存在可维护性方面的问题，尽管没有那么严重——当某人对其中一个组件的行为进行了更改，他可能需要更新所有与这个组件交互相关的测试。</p><p>单元测试，你需要单独选取一个组件，然后独立地对它的行为进行测试。</p><p>当你拥有一个组件，且这个组对于外部世界来说给出了极其慎重的承诺，那么单元测试则是用于验证这些承诺的最佳方式。</p><p>通常来说一个单元测试只会对一个类/模块中一个函数的单个行为进行验证。人们通常会为一个类/模块创建一组单元测试，当运行所有这些单元测试时，它们会覆盖你想验证的有关这个模块的所有行为。但这几乎总是意味着只测试系统的公共API，单元测试应该验证组件的行为，而不是实现。</p><p>理论上来说，如果系统中所有组件的行为在文档中都有完整的定义，且能按照文档里的行为挨个对每个组件进行测试的话，其实也是在对系统的所有可能行为进行测试。倘若你对其中一个组件的行为进行了更改，你只需更新围绕这个组件的最小测试集合即可。</p><p>很明显，只有当系统的组件在划分合理，以及简单到能够对行为做出完整定义的情况下，单元测试才能发挥出最大的功效。</p><p>现实世界里，在端到端测试和单元测试之间还存在不计其数的中间态测试类型。有时候你的测试方案介于单元测试和端到端测试之间。有时候你的测试又介于集成测试和端到端测试的交集当中。实际的系统会依赖所有形式的测试类型，用于帮助人们正确地理解系统行为。</p><p>举个例子，有时候你只需要对系统的其中一个部分进行测试，但是在内部实现上它依赖于系统的另一个部分，所以其实你也算是隐式地对那个系统进行了测试。但这并不意味着你当前的测试就是集成测试，它充其量只能算是间接对其他内部组件进行测试的单元测试而已——比一个普通的单元测试涉及面稍广一些，又比一个集成测试范围小一些。事实上这种类型的测试带来的效果通常是最好的。</p><p>通过“伪造数据”来对代码进行隔离在某些时候还是有用的。但人们必须要谨慎地作出决策，以及小心背后产生的成本，同时还需要通过对“伪”实例进行有意识的设计来缓解它们带来的副作用。值得注意的一点是，伪造数据还是能给我们的测试带来两方面的提升——确定性和速度。</p><p>如果系统或者它所处的环境中不存在任何变数，那么测试的结果也应该不会发生任何变化。</p><p>测试最有用的地方在于开发者们可以边编辑代码边运行它们，来检查他们正在编写的新代码是否能正常工作。如果测试运行变慢，那么这个功能也就逐渐变得没有意义。或者开发者们可以继续使用这些测试，但是编码的速度会被拖得越来越慢，因为他们不得不一直等待测试运行完毕。</p><p>一般来说，一个测试套件不应该花如此长的时间来运行，这会导致开发者在等待测试运行完毕的过程中，从工作上分心，以及无法集中注意力。现有研究表明对大部分开发者来说测试的理想运行时间应该在2到30秒之间。所以一个开发者在编辑代码阶段运行的测试套件应该尽量在这个时间区间内运行完毕。花上几分钟时间来运行测试没有问题，但是这不算是一个理想状态。更甚者如果要花上10分钟才能运行完毕，一般来说这是完全不可接受的。</p><p>缓慢的测试会对很多软件工程组织上的流程产生影响——降低这些影响最简单的办法就是让它们运行得足够快。</p><p>有一些工具能够在运行测试的情况下告诉你系统的哪些行代码被测试运行过了。它们将这个称为系统的“测试覆盖率”。这些工具有时候确实很有用，但是需要特别记住的是，它们其实并不会告诉你那些代码是否真的被测试过了，只是运行过而已。如果对代码行为没有执行过断言，那么它就算不上被测试过。</p><p>测试的总体目标是获取关于系统的有效知识。</p><p>这个目标凌驾于测试的其他一切原则之上——只要能带来这种效果，它就算是一个有效测试。</p><hr><h2 id="第七部分-持续改善"><a href="#第七部分-持续改善" class="headerlink" title="第七部分 持续改善"></a>第七部分 持续改善</h2><h3 id="第33章-成功的秘密：持续改善"><a href="#第33章-成功的秘密：持续改善" class="headerlink" title="第33章 成功的秘密：持续改善"></a>第33章 成功的秘密：持续改善</h3><p>如果你想在软件方面获得成功，你所要做的仅仅是保证产品在每个版本中都能持续改善。</p><p>当一开始在决定选择使用什么软件的时候，人们的判断标准都各不相同。但是一旦人们做出了选择，他们就会一直使用下去直到一些原因迫使他们离开。只要在每一次发布中软件都得到持续改善，你就能挽留住你的绝大部分用户。</p><p>当然你发布新版本的频率必须足够频繁，才能让人们相信软件有希望持续好转。如果新版本总是难产，那么当前版本给用户带来的困扰只会止步不前。</p><p>如果你的软件项目想要获得成功，你所要做的仅仅是让它在每个版本中都到持续改善。</p><h3 id="第34章-如何找到持续改善的空间"><a href="#第34章-如何找到持续改善的空间" class="headerlink" title="第34章 如何找到持续改善的空间"></a>第34章 如何找到持续改善的空间</h3><p>有时候软件项目中的重大问题难以得到解决，是因为它们需要投入大量的精力才能得以修复。但这并不意味着你可以忽略它们，而是要对项目做一个长远的修复规划，同时还要想办法如何保证版本迭代的稳定。</p><p>决定修复问题的优先级：对于Bugzilla项目来说，我们做了两件实实在在有助于我们决定优<br>先级的事情：</p><ul><li>1.Bugzilla调查：<a href="https://wiki.mozilla.org/Bugzilla:Survey" target="_blank" rel="noopener">https://wiki.mozilla.org/Bugzilla:Survey</a></li><li>2.Bugzilla可用性研究：<a href="https://wiki.mozilla.org/Bugzilla:CMU_HCI_Research_2008" target="_blank" rel="noopener">https://wiki.mozilla.org/Bugzilla:CMU_HCI_Research_2008</a></li></ul><p>这项调查中最重要的部分就是允许人们能以各种各样的文字形式，回答针对他们个人提出的问题。也就是说我个人会向Bugzilla的个体管理员发送问题，通常问题会针对他们的工作职责做一些定制化。这些问题中并不存在多选题，只会让他们告诉我什么正在困扰着他们以及他们想要看到什么功能。事实上他们非常乐意收到我的邮件——其中许多人对我做出的这次调查表达感谢。</p><p>一旦他们都回答完毕，我就会对所有回复一一过目，然后把提及的主要问题制作成一份列表——这简直是一份小小的惊喜！那么当下我们就把精力放在解决这些问题上，如果这些问题能得到改善，相信它们会让人们整体上对Bugzilla感到更满意。</p><p>而在可用性研究中，最能给我们带来帮助的环节，出乎意料的竟然是研究人员直接（他们通常是可用性的专家）坐在Bugzilla产品前，指出哪些功能违背了可用性的原则。也就是说，比他们做实际研究更有价值的是作为专家使用可用性工程的标准原则对产品的审视。他们作为从来没有使用过Bugzilla，也不会妥协说“好吧只能这么办”的小白用户，看待这个产品的新鲜视角很重要（至少我是这么想的）。</p><p>当你试图对事物进行改善时，首先需要解决的是当前已知的那些头部问题，无论它们的代价如何。然后情况会稍微缓和一些，可你依然会发现有一大堆问题需要解决。这时候你才需要从用户身上收集数据，修复他们认为的糟糕之处。</p><h3 id="第35章-拒绝的力量"><a href="#第35章-拒绝的力量" class="headerlink" title="第35章 拒绝的力量"></a>第35章 拒绝的力量</h3><p>谁是这款软件的设计师，谁授权开发了这个功能？谁有权力阻止这个功能的上线，但是却袖手旁观任由灾难发生？</p><p>问题其实在于，如果你给了一群人允许他们把脑袋里的想法通通实现的自由，那么可以肯定他们每次实现的想法都是糟糕的。这不是对开发者的批评，而在真实生活中就是这样。我对开发者们的智力和能力有绝对的信心。我欣赏他们在软件开发过程中付出的努力和获得的成就。可不幸的事实是，在缺乏一些中心原则指导的情况下，人们会不自觉地让系统变得复杂起来，同时这也并不会给他们的用户带来任何帮助。</p><p>通常一名独立的软件设计师，还是有能力创建一款同时为用户和开发者带来一致愉悦体验的软件的。但如果独立设计师在其他开发者偏离产品目标的时候不及时站出来说“不”，那么系统很快就会崩塌，变成充斥着糟糕想法的大泥团。所以拥有一名有权力说“不”的软件设计师非常重要，在恰当的时候设计师能够准确地行使这份权力也很重要。</p><p>有非常多的软件设计原则能够告诉你糟糕的想法长什么样，同时它们还能引导你在十分必要的情况下对糟糕的想法说“不”。</p><ul><li>如果功能的实现违反了软件设计中的某些原则（如过于复杂、难以维护、不易更改等），那么这类实现就是一个糟糕的想法。</li><li>如果功能不会给用户带来任何帮助，那么它就是一个糟糕的想法。</li><li>如果提议明显是愚蠢的，那么它就是一个糟糕的想法。</li><li>如果某些更改修复不了一个已知的问题，那么它就是一个糟糕的想法。</li><li>如果你不确定它是不是一个好的想法，那么它就是一个糟糕的想法。</li></ul><p>有时设计师们会识别出一个糟糕的想法，但是因为他们当下想不到任何一个更好的解决方案，所以他们依然允许将它实现。这样的做法是错误的。如果对于某个问题你只能想到一个明显愚蠢的解决方案，那么你依然应该拒绝它。</p><p>问题在于：如果你真的将“糟糕的想法”实现了，那么你的“解决方案”会迅速变成比原问题带来更坏影响的灾难，它“能起作用”没错，但是接下来用户会开始抱怨，其他程序员会发出沮丧的感叹，系统也会崩溃，软件就变得不再那么受欢迎了。最终，“解决方案”变成了一个需要使用其他糟糕的“解决方案”来“修复”的问题。而这些“修复”本身也注定会演化为其他让人头疼的大问题。持续这样下去，终有一天你的系统会变得像当下许多现存软件系统一样臃肿、不易理解且难以维护。</p><p>理想情况下，当你拒绝了一个糟糕的想法，你应该提供一个额外的更好想法来替代它——这样才能使项目有建设性地向前推进，而不是让这个有待解决的问题成为开发过程中的一道障碍。但即使你当下想不到一个更好的想法，坚持拒绝糟糕的想法也很重要。好的想法总会出现。或许需要通过一些研究来发掘，或许某天你正在淋浴时忽然灵光一现，它就自然而然地出现了。我不知道想法会从哪里来以及它长什么样。但是不用担心。你要相信对于每一个问题总是存在解决它们的恰当方式。持续地寻找它们，不要放弃，不要向糟糕的想法妥协。</p><p>大部分时候，与其直接说“不”，不如说“哇，这个想法的这个部分听起来非常棒，但是其他部分有待商榷”。</p><p>我们应该把这个想法中闪光的那一部分提取出来，在经过加工打磨之后将它们利用起来。你必须对想法里糟糕的部分说不。想法中存在优秀的部分并不意味着整个想法都是优秀的。汲取想法里的精华，提炼它，围绕它拓展出一些更好的想法，直到你最终设计的解决方案无懈可击。</p><h3 id="第36章-为什么说程序员糟糕透了"><a href="#第36章-为什么说程序员糟糕透了" class="headerlink" title="第36章 为什么说程序员糟糕透了"></a>第36章 为什么说程序员糟糕透了</h3><p>之所以计算机的使用体验异常糟糕，是因为程序员编写了一大堆疯狂、复杂、没有人能理解的玩意，并且复杂性还在不断往上叠加，直到程序的方方面面都陷入难以维系的地步。</p><p>绝大部分（90%或者更多）的程序员对于他们正在做的事情完全没有概念。</p><p>相当数量的程序员从一开始就不知道他们自己究竟在做什么。他们只是在模仿其他程序员犯下的错误——复制代码，然后往机器里输入一些指令，期待着它能如我们期望的那样工作。所有这些操作的背后都缺乏对计算机运作原理、软件设计原则，或每一个他们往计算机中输入字符的理解。</p><p>许多程序员根本就不知道在软件开发中可能存在通用法则或者是通用指南，所以他们根本就不会搜寻它们。许多软件公司也不会设法提升开发者对于他们所使用的编程语言的理解——也许因为他们仅仅认为程序员“如果被雇用了就应该对那些内容了如指掌”。</p><p>在哪些方面需要投入更多时间来学习：</p><ul><li>你清楚地了解你编写的每一页代码上的每一个单词和符号吗？</li><li>你是否阅读过以及是否能完全理解与你使用的每一个函数有关的说明文档？</li><li>你是否掌握了软件开发中基本原则的精髓——掌握的程度足以让你毫无差池地解释给你团队中的新成员听？</li><li>你是否理解计算机内每一个组件的功能，以及它们是如何协同运作的？</li><li>你是否了解计算机的历史，以及它们未来的发展方向，以便帮助你理解你的代码将会如何运作在未来的计算机中？</li><li>你是否了解编程语言的历史，以便你可以了解你正在使用的编程语言将会如何进化，以及为什么会朝这个方向进化？</li><li>你是否了解其他的编程语言，其他的编程方式，以及其他形式的计算机，帮助你对症下药解决实际工作问题？</li></ul><p>如果你只是简单地复制别人的代码，然后祈祷它也能在你这正常工作，那么你永远也不会成为一名优秀的程序员。</p><h3 id="第37章-快速编程的秘诀：停止思考"><a href="#第37章-快速编程的秘诀：停止思考" class="headerlink" title="第37章 快速编程的秘诀：停止思考"></a>第37章 快速编程的秘诀：停止思考</h3><p>给开发者施加时间上的压力的确会导致他们写出复杂的代码。但是交付的最后期限和复杂性并没有必然关系。</p><p>与其说“最后期限迫使我无法写出简单代码”，不如说“我写出简单代码的速度不够快”。进一步说，作为程序员你编码的速度越快，代码质量被最后期限影响的可能性就越低。</p><p>任何时候只要你发现自己停止了思考，那就意味着某个地方出了问题。</p><p>“需要打太多的字”对于开发者来说从来就不是一个会对效率产生影响的问题。恰恰相反，正是你停止输入的间隙拖慢了编码速度。</p><p>开发者之所以停下来思考，通常是因为他们没有完全理解一些单词或者符号的意义。</p><p>如果你发现自己正停下来思考，不要尝试去解决当下你脑海中的问题——而是跳出你自己，想想有什么是你自己还不知道的。然后去阅读那些能够帮助你理解它们的材料。</p><p>这种模式甚至能够解答类似于“用户是否真的会阅读这些文字？”这类的问题。也许公司内部没有用户体验研究部门能帮助你真正回答它，但是你至少可以画出一个原型，然后将它展示给人们并且征询他们的意见。不要只坐在那里然后纯粹地想这个问题——行动起来。只有行动才能带来理解。</p><p>很多人停下来思考，是因为他们没法在脑袋里一次性装下所有的概念——许多事物都在以一种复杂的方式相互关联在一起，人们必须首先在脑海中将它们过一遍才行。在这种情况下，更有效的方式往往是将它们写下来或者是画出来，而不是凭空思考它们。</p><p>有时候的问题是：“我不知道首先应该编写哪一部分的代码。”最简单的解决办法是，开始编写你现在有能力编写的任何代码。挑选当前问题中你已经完全理解的那一部分，首先编写该部分的解决方案——哪怕只有一个函数，或者只是一个并不重要的类。</p><p>通常情况下，一开始最容易编写的代码往往是应用程序中的“核心”部分。如果你依然不确定如何编写核心代码，那么可以从你已经确定的部分开始。</p><p>我发现只要问题的其中一个部分得到了解决，剩下的部分也会变得容易起来。有时候问题可以在逐步拆解的过程中慢慢清晰起来。只要你首先解决了一部分，剩余部分的解法自然也就一目了然了。哪一部分代码不需要太多思考就能开始编写，那么现在编写这部分代码就好。</p><p>另一个会产生理解方面问题的时刻是当你跳过了正常开发过程中的一些步骤的时候。在开发系统的过程中，不要跳过某些步骤还期望自己的效率很高。</p><h3 id="第38章-开发者的傲慢"><a href="#第38章-开发者的傲慢" class="headerlink" title="第38章 开发者的傲慢"></a>第38章 开发者的傲慢</h3><p>我唯一关心的是你的程序是否能够协助我完成工作。仅此一点决定了你的软件出色与否，如果它能达成这个目标，那么你应该对此感到骄傲。不要用那些仅仅是你认为重要的功能来博取我的眼球。</p><p>还有一些看似微不足道的地方也会带来问题，它们都和吸引了用户太多的注意力有关：</p><ul><li>“用户对于在使用我的产品之前，需要填写三个屏幕长的表单这件事，是不会有意见的。”</li><li>“我非常肯定用户有兴趣了解我专程为这个程序发明的这些图标，所以把这些图标上的文字移除掉不成问题！”</li><li>“我十分肯定借由这些弹出框来中断用户工作的做法是正确的。”</li><li>“用户肯定想要在这个巨幅页面上搜索出某一小段文字，以便他们能够点击它。”</li><li>“为什么我们要把这个变得更简单呢？要花费不少时间，对我来说……它已经够简单了。”</li></ul><p>对于一个程序员来说，真正的谦逊是自愿地抹去他在用户世界里的存在感。</p><p>请不要再告诉用户你的程序已经安装在他的电脑上了。不要认为用户会在意你的程序，他们只是想要花时间用一用它的界面，或者想要学习它如何使用，他们在意的不是你的程序——而是他们想要达成的目标。如果你能帮助用户完美地实现他们的目标，那么就意味着你为他们创造出了最完美的程序。</p><h3 id="第39章-“一致”并不意味着“统一”"><a href="#第39章-“一致”并不意味着“统一”" class="headerlink" title="第39章 “一致”并不意味着“统一”"></a>第39章 “一致”并不意味着“统一”</h3><p>在用户界面中，相似的事物应该看起来是相同的。而不同种类的事物应该看起来是不同的。</p><p>在应用的后端开发中，所有代码都应该在统一的技术框架之上进行开发。但那并不意味着界面上所有元素都应该看起来一样。</p><p>虽然说一致性在应用的前端和后端都非常重要，但是那并不意味着每一件事物都应该看上去是一样的。</p><h3 id="第40章-用户有困难，开发者有方案"><a href="#第40章-用户有困难，开发者有方案" class="headerlink" title="第40章 用户有困难，开发者有方案"></a>第40章 用户有困难，开发者有方案</h3><p>在软件的世界里，软件开发者的职责就是为用户解决问题。不同的用户代表着不同的问题，开发者们需要将它们一一解决。如果他们的角色发生了互换，麻烦可能就会接踵而至。</p><p>一旦你解决的是开发者的问题而不是用户的问题，那就意味着你投入精力的方向有误，这条路并非帮助人们解决问题的最佳方案。</p><p>我还感受到的一点是，解决开发者的问题比解决普通用户的问题更加复杂。所以找到用户实际存在的痛点并且解决它，会相比苦思冥想解决一个想象中的问题更容易。</p><p>只有用户（更准确地说，是大部分的用户，或者关于大部分用户的数据）才能真正告诉你他们遭遇的问题是什么，只有在开发侧（更准确地说，是在完全理解了这个问题，并且很可能听取了来自他人的反馈之后，被授予决策重任）的人才能对应该实施什么样的解决方案做出正确决定。</p><h3 id="第41章-即时满足-即时失败"><a href="#第41章-即时满足-即时失败" class="headerlink" title="第41章 即时满足=即时失败"></a>第41章 即时满足=即时失败</h3><p>软件从来就是一个长期的过程。</p><p>一旦竞争对手X公司发布了“闪亮新功能”，我公司就会毫不示弱：“我们现在也必须要有闪亮新功能！”。这不是一个长期的制胜策略，而是短视下的恐慌的表现。你的用户不会因为其他某款软件有而你没有的功能，就立即起身转而投奔他们。你应该观察用户量的增长或者流失趋势再做决策，而不是无脑地对当下环境做出立即响应。</p><p>所以什么是好的长期策略？重构你的代码，让你能够在将来更轻松地添加功能就是其中之一。或者在产品发售之后对一些功能和UI上的不足进行打磨，也是用户喜闻乐见的。另一条建议是，如果某些功能可有可无，并且你将来也并不想维护它们，那还是不要添加了。</p><p>太多所谓“如何经营你的软件生意”方面的建议，它们关注的都是实时满足——你当下能做什么。新增功能！立即从投资人那里获取数百万美元的投资！但不幸的是，世界的运转法则其实是，毁灭事物可以是一瞬间的事，但是创造事物则需要花费时间。</p><p>所以在现实世界中，你越是向往“实时满足”，你也越是在将你的产品、生意和你的未来推向毁灭。</p><p>所以软件行业里一则关键经验教训是：如果你正在制订一则计划，请确保它至少承认创造这件事是需要耗费时间的。它可能不会是永远，但一定不会是当下立即实现。</p><h3 id="第42章-成功来自执行而非创新"><a href="#第42章-成功来自执行而非创新" class="headerlink" title="第42章 成功来自执行而非创新"></a>第42章 成功来自执行而非创新</h3><p>我的想法是如何得优秀或者多么有创新精神一点都不重要，重要的是我能让它在真实世界落实得多好。</p><p>所以请不要焦虑于“赶紧想出一个新点子”。这种担心没有必要。你只需要以尽可能完美的方式去实现一个现有的想法就好。你可以加上一些自己的创意，或者再进行一些打磨，但你根本不需要全新的东西。</p><h3 id="第43章-杰出的软件"><a href="#第43章-杰出的软件" class="headerlink" title="第43章 杰出的软件"></a>第43章 杰出的软件</h3><p>一款真正被称为杰出的程序，需要能够准确执行用户的意图。</p><p>如果你想要把这句称述做更详细的拆解，也就是说杰出软件必须做到：</p><ul><li>1.完全按照用户的要求去做。</li><li>2.表现的行为和用户期望的完全一致。</li><li>3.不会妨碍用户传达他们的意图。</li></ul><p>当计算机能完美地执行你给出的指令，会给人带来一种奇怪的满足感。这也是编程的乐趣之一——一旦计算机准确无误地将你下达的指令执行完毕，满足的愉悦感便油然而生。</p><hr><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>豆瓣：<a href="https://book.douban.com/subject/35513153/" target="_blank" rel="noopener">https://book.douban.com/subject/35513153/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《编程原则：来自代码大师Max-Kanat-Alexander的建议》（Understanding-Software）读书笔记&quot;&gt;&lt;a href=&quot;#《编程原则：来自代码大师Max-Kanat-Alexander的建议》（Understanding-Softwar
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编码" scheme="http://blog.michealwayne.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="软件工程" scheme="http://blog.michealwayne.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记录HTML中与性能/渲染有关的几个新属性</title>
    <link href="http://blog.michealwayne.cn/2024/06/16/html/%E8%AE%B0%E5%BD%95HTML%E4%B8%AD%E4%B8%8E%E6%80%A7%E8%83%BD:%E6%B8%B2%E6%9F%93%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B0%E5%B1%9E%E6%80%A7/"/>
    <id>http://blog.michealwayne.cn/2024/06/16/html/记录HTML中与性能:渲染有关的几个新属性/</id>
    <published>2024-06-16T02:33:13.000Z</published>
    <updated>2024-06-18T03:39:50.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录-HTML-中与性能-渲染有关的几个新属性"><a href="#记录-HTML-中与性能-渲染有关的几个新属性" class="headerlink" title="记录 HTML 中与性能/渲染有关的几个新属性"></a>记录 HTML 中与性能/渲染有关的几个新属性</h1><h2 id="lt-script-gt-lt-link-gt-lt-style-gt-标签的blocking属性"><a href="#lt-script-gt-lt-link-gt-lt-style-gt-标签的blocking属性" class="headerlink" title="&lt;script&gt;/&lt;link&gt;/&lt;style&gt;标签的blocking属性"></a><code>&lt;script&gt;</code>/<code>&lt;link&gt;</code>/<code>&lt;style&gt;</code>标签的<code>blocking</code>属性</h2><blockquote><p>mdn 对<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#blocking" target="_blank" rel="noopener">blocking 属性</a>的解释：（<code>实验性</code>），这个属性明确指出，在获取脚本的过程中，某些操作应该被阻断。要阻断的操作必须是一个以空格分隔的列表，下面列出了阻断属性。</p></blockquote><p><code>blocking</code>属性允许我们能控制部分渲染的阻塞，直到特定的资源加载完毕。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>可应用元素：<code>&lt;head&gt;</code> 标签中的 <code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 和 <code>&lt;style&gt;</code></li><li>值：<code>&quot;render&quot;</code></li></ul><p>设置<code>blocking=&quot;render&quot;</code> 用于标记那些在显示任何内容给用户之前必须加载完成的资源。<strong>在这些资源加载完成之前，浏览器窗口中不会绘制任何像素。</strong></p><h4 id="lt-script-gt-使用"><a href="#lt-script-gt-使用" class="headerlink" title="&lt;script&gt;使用"></a><code>&lt;script&gt;</code>使用</h4><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">blocking</span>=<span class="string">"render"</span> <span class="attr">src</span>=<span class="string">"main.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，浏览器会为所有渲染阻塞的资源分配较高的优先级。但考虑到不是所有浏览器都支持 <code>blocking</code> 属性，添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#fetchpriority" target="_blank" rel="noopener">fetchpriority 属性</a>设置 <code>fetchpriority=&quot;high&quot;</code> 也是个不错的选择：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">blocking</span>=<span class="string">"render"</span> <span class="attr">fetchpriority</span>=<span class="string">"high"</span> <span class="attr">src</span>=<span class="string">"main.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h5><p><code>blocking</code> 属性同样适用于内联脚本。传统的内联脚本默认是阻塞的（<code>defer</code> 和 <code>async</code> 属性不适用于它们）。但是，如果你的脚本带有 <code>type=&quot;module&quot;</code> 属性，即使是内联的，它也会延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">async</span> <span class="attr">blocking</span>=<span class="string">"render"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 重要的 JavaScript 代码...</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内联模块脚本中的 async 属性意味着它会尽快执行。</p><h3 id="lt-link-gt-使用"><a href="#lt-link-gt-使用" class="headerlink" title="&lt;link&gt;使用"></a><code>&lt;link&gt;</code>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"main.css"</span> <span class="attr">blocking</span>=<span class="string">"render"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以在 <code>&lt;link&gt;</code> 元素上设置 <code>blocking</code> 属性。但如果你使用 <code>&lt;link&gt;</code> 配合 <code>rel=&quot;preload&quot;</code> 来预加载资源，或者使用 <code>rel=&quot;modulepreload&quot;</code> 来预加载 JavaScript 模块，那么 <code>blocking</code> 属性将不会生效。</p><p>开发者通常会利用这种行为来有意识地延迟非关键 CSS 的加载。但是，如果你需要以这种方式加载关键 CSS（会改变整个页面布局或影响页面折叠内容的样式），则可以使用 <code>blocking</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">link.rel = <span class="string">'stylesheet'</span>;</span><br><span class="line">link.href = <span class="string">'./styles.css'</span>;</span><br><span class="line">link.setAttribute(<span class="string">'blocking'</span>, <span class="string">'render'</span>);</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(link);</span><br></pre></td></tr></table></figure><h4 id="渲染阻塞-DOM-节点"><a href="#渲染阻塞-DOM-节点" class="headerlink" title="渲染阻塞 DOM 节点"></a>渲染阻塞 DOM 节点</h4><p>HTML 的渲染是逐步/增量进行的：渲染可以在整个 HTML 文档被获取和解析之前就开始。</p><p>有一种方法可以根据特定 HTML 元素是否已解析来阻塞渲染。</p><p>在 <code>&lt;head&gt;</code> 中放置一个 <code>&lt;link&gt;</code>，其 <code>href</code> 属性引用所要元素的 <code>id</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"expect"</span> <span class="attr">href</span>=<span class="string">"#visually-critical-content"</span> <span class="attr">blocking</span>=<span class="string">"render"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"visually-critical-content"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这使得开发者可以更好地控制哪些内容包含在首次内容绘制 (FCP) 中。它应该只用于页面折叠之上的元素——否则你会不必要地延迟首次绘制。一旦元素被解析，页面就会对用户可见。如果找不到预期的元素，则在整个 HTML 文档解析完成时，渲染将被解除阻塞。</p><p>这个功能主要是在考虑跨文档视图转换的情况下添加到 Web 中的。</p><h3 id="renderBlockingStatus-检测是否生效"><a href="#renderBlockingStatus-检测是否生效" class="headerlink" title="renderBlockingStatus 检测是否生效"></a><code>renderBlockingStatus</code> 检测是否生效</h3><p>如果你想验证 <code>blocking</code> 属性是否生效，可以在浏览器的开发者工具控制台中运行以下代码，来查看渲染阻塞资源的列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.performance</span><br><span class="line">  .getEntriesByType(<span class="string">'resource'</span>)</span><br><span class="line">  .filter(<span class="function"><span class="params">resource</span> =&gt;</span> resource.renderBlockingStatus === <span class="string">'blocking'</span>)</span><br><span class="line">  .forEach(<span class="function"><span class="params">resource</span> =&gt;</span> <span class="built_in">console</span>.log(resource.name));</span><br></pre></td></tr></table></figure><h4 id="那我们为什么需要这个新属性呢？"><a href="#那我们为什么需要这个新属性呢？" class="headerlink" title="那我们为什么需要这个新属性呢？"></a>那我们为什么需要这个新属性呢？</h4><p>它明确了阻塞的行为，清晰地传达了开发者的意图，这样团队成员在重构代码时，就不会无意中把它改成非阻塞的了。<br>当与 <code>defer</code> 或 <code>async</code> 属性一起使用时，它可以阻塞渲染，同时不会阻塞 HTML 解析器的工作。<br>与传统脚本不同，模块脚本默认是延迟加载的。<code>&lt;script type=&quot;module&quot;&gt;</code> 现在可以通过 <code>blocking</code> 属性来实现渲染阻塞。<br>通过 JavaScript 动态添加到 <code>&lt;head&gt;</code> 中的 <code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 和 <code>&lt;style&gt;</code> 元素，默认是不会阻塞渲染的。但现在，你可以灵活地让它们实现阻塞。</p><h4 id="是否可能会延长-FCP？"><a href="#是否可能会延长-FCP？" class="headerlink" title="是否可能会延长 FCP？"></a>是否可能会延长 FCP？</h4><p>渲染阻塞会延迟将像素绘制到屏幕上，所以你可能会想，这是否意味着用户就得盯着空白页面看。在快速的网络连接下，这种情况很少见。过去，在浏览网页时，经常会在页面间看到白色的闪烁。为了解决这个问题，浏览器开始使用绘制保持（paint holding）。绘制保持会让用户停留在上一个页面，并显示一个加载指示器，直到新页面的首次内容绘制 (FCP) 准备就绪。如果你延迟了 FCP，用户就会在上一个页面上多停留一会儿。绘制保持只持续很短时间。如果你延迟了 FCP 太久，就会显示一个空白的白色页面。对于速度慢的网站，在慢速的 3G 网络上，这种白色空白的“闪烁”可能会持续很长时间。</p><h3 id="兼容情况"><a href="#兼容情况" class="headerlink" title="兼容情况"></a>兼容情况</h3><p><img src="/images/20240616/p-blocking.png" alt="p-blocking"></p><hr><h2 id="lt-img-gt-lt-iframe-gt-标签的loading属性"><a href="#lt-img-gt-lt-iframe-gt-标签的loading属性" class="headerlink" title="&lt;img&gt;/&lt;iframe&gt;标签的loading属性"></a><code>&lt;img&gt;</code>/<code>&lt;iframe&gt;</code>标签的<code>loading</code>属性</h2><blockquote><p>mdn 对于图片<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/loading" target="_blank" rel="noopener">loading 属性</a>的解释：HTMLImageElement 的 loading 属性为一个字符串，它的值会提示 用户代理 告诉浏览器不在可视视口内的图片该如何加载。这样一来，通过推迟图片加载仅让其在需要的时候加载而非页面初始载入时立刻加载，优化了页面的载入。</p></blockquote><p>可以控制资源的加载行为，减少初始页面加载时间。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>设置值为<code>&quot;eager&quot;</code>时（默认行为），<code>eager</code> 告诉浏览器当处理 <code>&lt;img&gt;</code> 标签时立即加载图片；设置值为<code>lazy</code>时告诉用户代理推迟图片加载直到浏览器认为其需要立即加载时才去加载。例如，如果用户正在往下滚动页面，值为 lazy 会导致图片仅在马上要出现在 可视视口中时开始加载。</p><h4 id="load-事件的时机"><a href="#load-事件的时机" class="headerlink" title="load 事件的时机"></a>load 事件的时机</h4><h5 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h5><p>load 事件在文档被完整的处理完成时触发。当图片使用立即加载 (默认值) 时，文档中的所有图片都会在 load 事件触发前载入。</p><p>当 loading 值设为 lazy 时，图片不再会在请求，下载，处理的时间内推迟 load 事件触发。</p><p>loading 属性值设为 lazy 但是在页面初次加载时就在可视视口内的图片会立即加载但它们也不会推迟 load 事件。换句话说，这些图片不会在处理 <img> 元素时立即加载，但仍会作为页面初始加载的一部分而加载。他们只是不会影响 load 事件。</p><p>这表明当 load 触发时，可视区域内懒加载的图片可能不可见。</p><h5 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt;iframe&gt;"></a><code>&lt;iframe&gt;</code></h5><p>即使 iframe 位于可视视口并在页面加载时被请求，懒加载的 iframe 也不会影响 load 事件的时机。只有当文档中所有立即加载的 iframe 都被请求后，才能触发 load 事件。</p><h4 id="lt-img-gt-使用"><a href="#lt-img-gt-使用" class="headerlink" title="&lt;img&gt;使用"></a><code>&lt;img&gt;</code>使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="防止元素在图片懒加载时出现移位"><a href="#防止元素在图片懒加载时出现移位" class="headerlink" title="防止元素在图片懒加载时出现移位"></a>防止元素在图片懒加载时出现移位</h5><p>当一个加载被 <code>loading</code> 属性设为 <code>lazy</code> 的图片最后加载时，浏览器会根据<code>&lt;img&gt;</code> 元素的尺寸和图片自身大小重排文档，更新被图片影响的元素的位置。</p><p>为了防止重排发生，你需要使用 <code>width</code> 和 <code>height</code> 属性明确设置图片大小。通过这样建立固有长宽比，你防止了元素的移位。取决于实际的加载时间和重排，移位造成的最小的影响可能只是使用户困惑和不适，最坏的影响则是导致用户点错目标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addImageToList</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">'div.photo-list'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newItem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  newItem.className = <span class="string">'photo-item'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newImg = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  newImg.loading = <span class="string">'lazy'</span>;</span><br><span class="line">  newImg.width = <span class="number">320</span>;</span><br><span class="line">  newImg.height = <span class="number">240</span>;</span><br><span class="line">  newImg.src = url;</span><br><span class="line"></span><br><span class="line">  newItem.appendChild(newImg);</span><br><span class="line">  list.appendChild(newItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iframe-使用"><a href="#iframe-使用" class="headerlink" title="iframe 使用"></a>iframe 使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"example.html"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下示例展示了如何定义一个懒加载的 <code>iframe</code>，然后将其附加到文档中的 <code>&lt;div&gt;</code>。只有当 <code>iframe</code> 即将变得可见时，才会加载 <code>iframe</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 iframe 中定义懒加载</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="string">'https://example.com'</span>;</span><br><span class="line">iframe.width = <span class="number">320</span>;</span><br><span class="line">iframe.height = <span class="number">240</span>;</span><br><span class="line">iframe.loading = <span class="string">'lazy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到类名为 frameDiv 的 div 元素中</span></span><br><span class="line"><span class="keyword">const</span> frameDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div.frameDiv'</span>);</span><br><span class="line">frameDiv.appendChild(iframe);</span><br></pre></td></tr></table></figure><h4 id="兼容情况-1"><a href="#兼容情况-1" class="headerlink" title="兼容情况"></a>兼容情况</h4><p><img src="/images/p-loading.png" alt="p-loading"></p><hr><h2 id="lt-a-gt-lt-link-gt-标签的-hreflang-属性"><a href="#lt-a-gt-lt-link-gt-标签的-hreflang-属性" class="headerlink" title="&lt;a&gt;/&lt;link&gt; 标签的 hreflang 属性"></a><code>&lt;a&gt;</code>/<code>&lt;link&gt;</code> 标签的 <code>hreflang</code> 属性</h2><blockquote><p>mdn 对<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#hreflang" target="_blank" rel="noopener">hreflang 属性</a>的解释：此属性指明了被链接资源的语言。其意义仅供参考。可取的值参见 <a href="https://datatracker.ietf.org/doc/html/rfc5646" target="_blank" rel="noopener">RFC 5646: 语言识别标签（又称 BCP 47）</a>。仅当设置了 href 属性时才应设置该属性。</p></blockquote><p><code>hreflang</code>属性指定<code>&lt;a&gt;</code>或<code>&lt;link&gt;</code>元素上链接资源的语言。它的工作原理类似于<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang" target="_blank" rel="noopener">lang 属性</a>，但专门用于链接。</p><p>您可以通过在内部和外部网站链接中使用 <code>hreflang</code> 来改善用户体验和 SEO。在内部网站链接上使用 <code>hreflang</code> 提供了一种方法，可以告诉搜索引擎其他语言或地区的页面的不同变化。这意味着讲英语的人将收到该网站的英文版，而讲瑞典语的人将收到瑞典文版。用户端无需手动切换，体验更加流畅。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>将带有所需 ISO 语言代码的 <code>hreflang</code> 属性添加到<code>&lt;a&gt;</code>元素中。对于英文网站则是 <code>en</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">hreflang</span>=<span class="string">"en"</span>&gt;</span>English Website<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>您也可以使用更具体的语言代码，并使用区域变化。例如我们可以为英式英语添加 <code>en-GB</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.at"</span> <span class="attr">hreflang</span>=<span class="string">"en-GB"</span>&gt;</span>English Website<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果您的网站提供多种语言版本，您可以使用 <code>hreflang</code> 指定与特定 URL 关联的文档的语言和区域。添加该属性将有助于搜索引擎了解不同网页版本的语言和区域定位。</p><p>在每个链接中添加带有所需语言代码的 <code>hreflang</code>。一个链接应该作为默认的后备版本，通过添加 <code>hreflang=&quot;x-default&quot;</code>而不是语言代码来识别。最后对于语言切换器中的每个链接，将 <code>rel</code> 属性的值设置为<code>&quot;alternate&quot;</code>，以指示所链接的页面是当前页面的替代页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">hreflang</span>=<span class="string">"x-default"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://example.com/de"</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">hreflang</span>=<span class="string">"de"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>您也可以在语言切换器中使用 <code>hreflang</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">hreflang</span>=<span class="string">"x-default"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com/de"</span> <span class="attr">hreflang</span>=<span class="string">"de"</span>&gt;</span>German<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时语言切换者使用他们切换到的语言中的链接文本。您可以通过额外使用 <code>lang</code> 属性来指示这一点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">hreflang</span>=<span class="string">"x-default"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com/de"</span> <span class="attr">hreflang</span>=<span class="string">"de"</span> <span class="attr">lang</span>=<span class="string">"de"</span>&gt;</span>Deutsch<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增强可访问性的另一种方法是将 <code>aria-current=&quot;true&quot;</code>包含到当前活动的链接中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">hreflang</span>=<span class="string">"x-default"</span> <span class="attr">aria-current</span>=<span class="string">"true"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com/de"</span> <span class="attr">hreflang</span>=<span class="string">"de"</span> <span class="attr">lang</span>=<span class="string">"de"</span>&gt;</span>Deutsch<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="兼容情况-2"><a href="#兼容情况-2" class="headerlink" title="兼容情况"></a>兼容情况</h3><p><img src="/images/20240616/p-hreflang-a.png" alt="p-blocking"></p><hr><h2 id="通用属性translate"><a href="#通用属性translate" class="headerlink" title="通用属性translate"></a>通用属性<code>translate</code></h2><blockquote><p>mdn 对<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/translate" target="_blank" rel="noopener">translate 属性</a>的解释：全局属性 translate 是一种枚举属性，用来规定对应元素的可翻译属性值及其 Text 子节点内容是否跟随系统语言作出对应的翻译变化。</p></blockquote><p><code>translate</code> 属性用于指示元素是否应该被翻译。</p><h3 id="为什么使用-translate"><a href="#为什么使用-translate" class="headerlink" title="为什么使用 translate?"></a>为什么使用 translate?</h3><p>默认情况下，大多数网站文本都是可翻译的（除了一些例外，例如图像上或 SVG 中的文本）。如果网站的定义语言与浏览器的默认语言不同，翻译工具（如 Google 翻译）可能会建议翻译页面内容。</p><p>但可能存在这种行为是不需要的情况。公司名称、电子邮件地址或代码示例等特定术语通常不应翻译，以避免混淆。自动翻译并不总是完全准确的，特别是对于小众词汇或技术词汇。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>您可以在任何 HTML 元素上使用 <code>translate</code>。指定一个空字符串（<code>&quot;&quot;</code>）或 <code>yes</code> 用于翻译，而 <code>no</code> 用于避免翻译。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 德语原文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Wien<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  ist (wieder) die lebenswerteste Stadt der Welt!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">translate</span>=<span class="string">"no"</span>&gt;</span>Wien<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  ist (wieder) die lebenswerteste Stadt der Welt!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 翻译后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Vienna<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  named world's most liveable city (again)!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">translate</span>=<span class="string">"no"</span>&gt;</span>Wien<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  named world's most liveable city (again)!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="兼容情况-3"><a href="#兼容情况-3" class="headerlink" title="兼容情况"></a>兼容情况</h3><p><img src="/images/20240616/p-translate.png" alt="p-translate.png"></p><hr><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://www.htmhell.dev/adventcalendar/2023/4/" target="_blank" rel="noopener">Back to Basics: 5 HTML attributes for improved accessibility and user experience</a></li><li><a href="https://mp.weixin.qq.com/s/giztqGMS9tH3P39CQBVdyQ" target="_blank" rel="noopener">网页加载卡顿？试试 HTML 的新武器 blocking 属性！</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录-HTML-中与性能-渲染有关的几个新属性&quot;&gt;&lt;a href=&quot;#记录-HTML-中与性能-渲染有关的几个新属性&quot; class=&quot;headerlink&quot; title=&quot;记录 HTML 中与性能/渲染有关的几个新属性&quot;&gt;&lt;/a&gt;记录 HTML 中与性能/渲染有关
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="html5" scheme="http://blog.michealwayne.cn/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条读书笔记</title>
    <link href="http://blog.michealwayne.cn/2024/06/02/python/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E4%BB%A3%E7%A0%81%E7%9A%8490%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B-75%E8%87%B390/"/>
    <id>http://blog.michealwayne.cn/2024/06/02/python/【笔记】《编写高质量Python代码的90个有效方法》-75至90/</id>
    <published>2024-06-02T12:45:06.000Z</published>
    <updated>2024-06-10T03:41:47.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-75-～-90-条（测试与调试、协作开发）读书笔记"><a href="#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-75-～-90-条（测试与调试、协作开发）读书笔记" class="headerlink" title="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条（测试与调试、协作开发）读书笔记"></a>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 75 ～ 90 条（测试与调试、协作开发）读书笔记</h1><p>（书基于 Python 3.7+ 语法规范）</p><p>知识点概括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repr函数</span><br><span class="line">unittest模块</span><br><span class="line">TestCase类</span><br><span class="line">mock函数与Mock类</span><br><span class="line">pdb模块</span><br><span class="line">breakpoint函数</span><br><span class="line">tracemalloc模块</span><br><span class="line">PyPI</span><br><span class="line">venv工具</span><br><span class="line">requirements.txt文件</span><br><span class="line">warnings模块</span><br></pre></td></tr></table></figure><h2 id="9-测试与调试"><a href="#9-测试与调试" class="headerlink" title="9.测试与调试"></a>9.测试与调试</h2><p>Python语言没有编译期的静态类型检查机制，所以Python解释器无法确保程序一定能够正确运行。当然，在静态分析的过程中，可以选用类型注解帮助我们发现各种bug。</p><p>即便源代码里写着某个函数，你也未必能够保证，程序在需要调用这个函数的时候，它一定得到了定义。这种动态特征既有好处，又有风险。</p><p>程序正式发布之前，为什么不把它全面测试好呢？编译期的静态类型检查并不能完全确保程序必定能够正常运行。无论是用动态语言编程，还是用静态语言编程，我们都必须对写出来的代码做测试。</p><p>它与其他语言相比，更需要通过测试来确保代码准确无误。然而这也有好的地方：Python的动态机制虽然有风险，但若能适当加以运用，则可以帮助我们相当顺利地测试代码并调试程序。</p><h3 id="第75条、通过repr字符串输出调试信息"><a href="#第75条、通过repr字符串输出调试信息" class="headerlink" title="第75条、通过repr字符串输出调试信息"></a>第75条、通过repr字符串输出调试信息</h3><p>调试Python程序时，我们可以通过print函数与格式字符串，或者利用内置的logging模块，相当深入地观察程序的运行情况。Python的内部状态一般都可以通过普通的属性访问到。</p><p>print函数可以把开发者传给它的值显示成便于认读的那种字符串。例如，最简单的用法是直接把字符串传给它，这样就可以打印出不带引号的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'foo bar'</span>)</span><br></pre></td></tr></table></figure><p>这种写法跟下面几种写法是等效的：</p><ul><li>先把字符串传给str函数，然后把str函数返回的内容传给print；把字符串写在<code>%</code>操作符的右侧，让它替换操作符左侧那个格式字符串里的<code>&#39;%s&#39;</code>；把表示字符串值的那个变量，按照默认格式写在f-string中，交给print去打印；</li><li>调用内置的format函数；</li><li>明确调用<strong>format</strong>特殊方法；</li><li>明确调用<strong>str</strong>特殊方法。</li></ul><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_value = <span class="string">'foo bar'</span></span><br><span class="line">print(str(my_value))</span><br><span class="line">print(<span class="string">'%s'</span> % my_value)</span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;my_value&#125;</span>'</span>)</span><br><span class="line">print(format(my_value))</span><br><span class="line">print(my_value.__format__(<span class="string">'s'</span>))</span><br><span class="line">print(my_value.__str__())</span><br></pre></td></tr></table></figure><p>然而问题在于，用这种方式来打印，不太容易看清这个值究竟是什么类型以及它具体是由哪些部分组成的。例如，如果按照默认方式调用print函数，那么我们无法区分打印出来的这个5，到底是数字5，还是字符串’5’。</p><p>如果要用print调试程序，那么类型的区别就很重要。所以，我们需要打印的应该是对象的repr版本。这个版本可以通过内置的repr函数获得，该函数会返回对象的可打印表示形式（printable representation），这也是对象最为清晰且易于理解的表示形式。对于大多数内置类型来说，repr返回的字符串是个有效的Python表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'\x07'</span></span><br><span class="line">print(repr(a))</span><br></pre></td></tr></table></figure><p>把repr返回的值传给内置的eval函数，应该会得到一个跟原来相同的Python对象（当然，实际中eval函数的使用必须相当谨慎）。</p><p>用print调试程序的时候，应该先把要打印的值传给repr，然后将repr返回的内容传给print去打印，以明确体现出类型之间的差别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(repr(<span class="number">5</span>)); <span class="comment"># 5</span></span><br><span class="line">print(repr(<span class="string">'5'</span>)); <span class="comment"># '5'</span></span><br></pre></td></tr></table></figure><p>还有两种写法也能实现相同的效果，一种是把要打印的值放在<code>%</code>操作符的右边，让它替换左边的<code>&#39;%r&#39;</code>格式化字符串，另一种是在f-string中使用<code>!r</code>转换类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%r'</span> % <span class="number">5</span>)</span><br><span class="line">print(<span class="string">'%r'</span> % <span class="string">'5'</span>)</span><br></pre></td></tr></table></figure><h3 id="第76条、在TestCase子类里验证相关的行为"><a href="#第76条、在TestCase子类里验证相关的行为" class="headerlink" title="第76条、在TestCase子类里验证相关的行为"></a>第76条、在TestCase子类里验证相关的行为</h3><p>在Python中编写测试的最经典办法是使用内置的unittest模块。</p><p>为了定义测试用例，需要再创建一个文件，将其命名为test_utils.py或utils_test.py，命名方案可以根据你的风格来选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilsTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bytes</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.assertEqual(<span class="string">'hello'</span>, to_str(<span class="string">b'hello'</span>))</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_str</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.assertEqual(<span class="string">'incorrect'</span>, to_str(<span class="string">'hello'</span>))</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>测试用例需要安排到TestCase的子类中。在这样的子类中，每个以test开头的方法都表示一项测试用例。如果test方法在运行过程中没有抛出任何异常（assert语句所触发的AssertionError也算异常），那么这项测试用例就是成功的，否则就是失败。其中一项测试用例失败，并不影响系统继续执行TestCase子类里的其他test方法，所以我们最后能够看到总的结果，知道其中有多少项测试用例成功，多少项失败，而不是只要遇到测试用例失败，就立刻停止整套测试。</p><p>我们还可以在test方法中指定断点，这样能够直接从此处激活调试器（debugger），以观察详细的出错原因。</p><p>TestCase类提供了一些辅助方法，可以在测试用例中做断言。例如，assertEqual方法可以确认两者是否相等，assertTrue可以确认Boolean表达式是否为True，此外还有很多以assert开头的方法（在Python解释器界面输入help(TestCase)，可以查看所有的方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assert_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssertTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_assert_helper</span><span class="params">(self)</span>:</span></span><br><span class="line">    expected = <span class="number">12</span></span><br><span class="line">    found = <span class="number">2</span> * <span class="number">5</span></span><br><span class="line">    self.assertEqual(expected, found)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_assert_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    expected = <span class="number">12</span></span><br><span class="line">    found = <span class="number">2</span> * <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> expected == found</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>TestCase还提供了assertRaises这样一个辅助方法，它可以当作情境管理器（context manager）用在with结构中），以验证该结构的主体部分是否会抛出应有的异常。这种写法跟try/except结构相似，可以很清楚地表示出受测代码应该抛出哪种异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils_error_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilsErrorTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bad</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">      to_str(object())</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bad_encoding</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.assertRaises(UnicodeDecodeError):</span><br><span class="line">      to_str(<span class="string">b'\xfa\xfa'</span>)</span><br><span class="line">  <span class="keyword">if</span> __main__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>如果测试用例需要使用比较复杂的逻辑，那么可以把这些逻辑定义成辅助方法放到TestCase子类里。但是必须注意，这种方法的名称不能以test开头，否则系统就会把它们当成测试用例来执行。在写辅助方法时，我们可能会用到TestCase类提供的各种assert方法，而且还经常会用fail方法来表示不应该出现的情况，也就是说，如果程序真的运行到了fail这里，那么意味着我们预设的某项前提条件没有得到满足。</p><p>TestCase类还提供了subTest辅助方法，可以让我们把相似的用例全都写在同一个test方法中，让它们成为这个用例中的子用例，这样的话，每个子用例所共用的那部分代码与逻辑只需要写一次就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data_driven_test.py</span></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataDrivenTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_good</span><span class="params">(self)</span>:</span></span><br><span class="line">    good_cases = [</span><br><span class="line">      (<span class="string">b'my bytes'</span>, <span class="string">'my bytes'</span>),</span><br><span class="line">      (<span class="string">'no error'</span>, <span class="string">b'no error'</span>), <span class="comment"># will fail</span></span><br><span class="line">      (<span class="string">'other str'</span>, <span class="string">'other str'</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> value, expected <span class="keyword">in</span> good_cases:</span><br><span class="line">      <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">        self.assertEqual(expected, to_str(value))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_bad</span><span class="params">(str)</span>:</span></span><br><span class="line">    bad_cases = [</span><br><span class="line">      (object(), TypeError),</span><br><span class="line">      (<span class="string">b'\xfa\xfa'</span>, UnicodeDecodeError),</span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> value, exception <span class="keyword">in</span> bad_cases:</span><br><span class="line">      <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(exception):</span><br><span class="line">          to_str(value)</span><br><span class="line">          </span><br><span class="line">  <span class="keyword">if</span> __main__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>如果项目比较复杂或者对测试的要求比较高，可以考虑用pytest这个开源软件包（<a href="https://pytest.org/）来测试，Python开发者给pytest制作了许多特别有用的插件。" target="_blank" rel="noopener">https://pytest.org/）来测试，Python开发者给pytest制作了许多特别有用的插件。</a></p></blockquote><h3 id="第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰"><a href="#第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰" class="headerlink" title="第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰"></a>第77条、把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰</h3><p>TestCase子类在执行其中的每个test方法之前，经常需要先把测试环境准备好，这套准备逻辑有时也叫测试装置或测试用具（test harness）。我们可以在TestCase子类中覆写setUp与tearDown方法，并把相应的准备逻辑与清理逻辑写在里面。系统在执行每个test方法之前都会先调用一遍setUp方法，并在执行完test方法之后调用一遍tearDown方法。这可以确保测试用例之间不会互相干扰，这一点，对测试工作至关重要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># environment_test.py</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentTest</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.test_dir = TemporaryDirectory()</span><br><span class="line">    self.test_path = Path(self.test_dir.name)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.test_dir.cleanup()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_modify_file</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(self.test_path / <span class="string">'data.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      <span class="comment">#...</span></span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>当程序变得复杂后，我们就不能只依赖这种彼此隔绝的单元测试了，而是需要再写一些测试，以验证模块与模块之间能否正确地交互（这可能要用到mock等工具）。这种测试叫集成测试（integration test），它跟前面的单元测试（unit test）不同。这两种测试在Python中很重要，假如不做集成测试，那就没办法确信这些模块能够协同运作。</p><p>对于集成测试来说，测试环境的准备与清理工作可能要占用大量计算资源，并持续比较长的时间。例如，可能要先启动数据库进程，并等待该进程把索引加载进来，然后才能开始做集成测试。这些工作的延迟很高，因此不能像做单元测试时那样，写在setUp与tearDown方法中。</p><h3 id="第78条、用Mock来模拟受测代码所依赖的复杂函数"><a href="#第78条、用Mock来模拟受测代码所依赖的复杂函数" class="headerlink" title="第78条、用Mock来模拟受测代码所依赖的复杂函数"></a>第78条、用Mock来模拟受测代码所依赖的复杂函数</h3><p>写测试的时候还有一个常见的问题，就是某些逻辑很难从开发环境里真实地执行，或者使用起来特别慢，这样的逻辑可以通过mock函数与Mock类来模拟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">form datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock</span><br><span class="line"></span><br><span class="line">mock = Mock(spec=get_animals)</span><br><span class="line">expected = [</span><br><span class="line">  (<span class="string">'Spot'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>)),</span><br><span class="line">  (<span class="string">'Fluffy'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">30</span>)),</span><br><span class="line">  (<span class="string">'Jojo'</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">45</span>)),</span><br><span class="line">]</span><br><span class="line">mock.return_value = expected</span><br></pre></td></tr></table></figure><p>只要参数的取值不影响要测试的关键行为，那就可以在验证时通过ANY忽略这个参数。对于这些不太重要的参数，我们可以放宽一些，而不应该指定得太细，因为那样必须编写大量的验证代码。</p><p>Mock类还能够模拟调用时抛出异常的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">mock = Mock(spec=get_animals)</span><br><span class="line">mock.side_effect = MyError(<span class="string">'Whoops! Big problem'</span>)</span><br><span class="line">result = mock(database, <span class="string">'Meerkat'</span>)</span><br></pre></td></tr></table></figure><p>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</p><h3 id="第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试"><a href="#第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试" class="headerlink" title="第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试"></a>第79条、把受测代码所依赖的系统封装起来，以便于模拟和测试</h3><p>通过Mock类实现，另一个是通过patch方法实现。可是，这两种方案都要求我们在测试的过程中重复编写很多例行代码，这会让初次阅读代码的人很难理解我们究竟要验证什么。</p><p>有一种办法可以改进代码，就是把受测函数所要使用的数据库接口封装起来，这样我们就不用像原来那样，专门把数据库连接（DatabaseConnection）当作参数传给受测函数了，而是可以将封装好的系统传过去。</p><p>Python内置的unittest.mock模块里有个Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的属性。如果想把程序完整地测一遍，那么可以重构代码，在原来直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</p><h3 id="第80条、考虑用pdb做交互调试"><a href="#第80条、考虑用pdb做交互调试" class="headerlink" title="第80条、考虑用pdb做交互调试"></a>第80条、考虑用pdb做交互调试</h3><p>Python内置的交互调试器（interactive debugger）就是这样一种工具，它可以检查程序状态，打印局部变量的值，还可以每次只执行一条Python语句（也就是单步执行）。</p><p>在其他大部分编程语言中，如果要使用调试器，那么必须先在源文件中指定断点，令程序在执行到这一行时停下来。然而Python不用这样，你可以直接在认为有问题的那行代码前加入一条指令，让程序暂停，并启动调试器，这是最简单的办法。采用这种办法来调试程序，与正常启动程序并没有什么区别。</p><p>用来触发调试器的指令就是Python内置的breakpoint函数。这个函数的效果与先引入内置的pdb模块然后运行set_trace函数的效果是一样的。</p><p>一旦运行breakpoint函数，程序会在即将执行下一条语句的地方暂停。</p><p>在（Pdb）提示符界面，我们可以输入局部变量的名称（或执行<code>p &lt;name&gt;命令</code>）来查看变量的取值，也可以调用Python内置的locals函数以观察所有的局部变量，还可以引入模块，检查全局状态，构造新的对象，或运行内置的help命令，甚至还能修改正在运行的程序里的某些部分，总之，对调试工作有帮助的操作都可以在这里执行。</p><p>另外，调试器还提供了各种特殊命令，帮我们控制程序的执行方式，并探查其执行情况。在调试界面输入help，可以看到完整的命令列表。通过下面这三条非常实用的命令，我们可以很方便地检查正在运行的这个程序：</p><ul><li><code>where</code>：打印出当前的执行调用栈（execution call stack），可以据此判断程序当前执行到了哪个位置，以及程序是在调用了哪些函数后才触发breakpoint断点的。</li><li><code>up</code>：把观察点沿着执行调用栈上移一层，回到当前函数调用者处，以观察位于当前断点之上的那些层面分别有什么样的局部变量。</li><li><code>down</code>：把观察点沿着执行调用栈下移一层。</li></ul><p>检查完程序的运行状态后，可以通过下面这五条命令决定程序接下来应该如何执行：</p><ul><li><code>step</code>：执行程序里的下一行代码，并在执行完毕后把控制权交还给调试器。如果下一行代码带有函数调用操作，那么调试器就会停在受调用的那个函数开头。</li><li><code>next</code>：执行当前函数的下一行代码，并在执行完毕后，返回交互调试界面。如果下一行代码带有函数调用操作，系统不会令调试器停在受调用的函数开头。</li><li><code>return</code>：让程序一直运行到当前函数返回为止，然后把控制权交还给调试器。</li><li><code>continue</code>：让程序运行到下一个断点处（那个断点可以是通过breakpoint触发的，也可以是在调试界面里设置的）。</li><li><code>quit</code>：退出调试界面，并且让接受调试的程序也随之终止。如果已经找到了问题，那么就可以用这个命令结束调试。如果发现寻找的方向不对，或者需要先去修改程序的代码，那么也应该运行这个命令以便重新调试。</li></ul><p>breakpoint函数可以出现在程序里的任何地方。</p><p>调试器还支持一项有用的功能，叫作事后调试（post-mortem debugging），当我们发现程序会抛出异常并崩溃后，想通过调试器看看它在抛出异常的那一刻，究竟是什么样子的。有时我们也不确定应该在哪里调用breakpoint函数，在这种情况下，尤其需要这项功能。</p><p>于是，我们用<code>python3 -m pdb -c continue &lt;program path&gt;</code>命令把这个有问题的程序放在pdb模块的控制下运行，其中<code>-c</code>选项里的continue命令会让pdb在启动受测程序之后立刻向前推进，直至遇到断点或出现异常为止。</p><p>还有一种办法也能触发事后调试机制，就是先在普通的Python解释器里执行受测代码，待遇到未被捕获的异常后，再引入pdb模块并调用其pm函数（通常把引入pdb模块与调用pm函数这两项操作合起来写成<code>import pdb; pdb.pm()</code>）。</p><h3 id="第81条、用tracemalloc来掌握内存的使用与泄漏情况"><a href="#第81条、用tracemalloc来掌握内存的使用与泄漏情况" class="headerlink" title="第81条、用tracemalloc来掌握内存的使用与泄漏情况"></a>第81条、用tracemalloc来掌握内存的使用与泄漏情况</h3><p>在Python的默认实现方式（也就是CPython）中，内存管理是通过引用计数（reference counting）执行的。如果指向某个对象的引用已经全部过期，那么受引用的对象就可以从内存中清除，从而给其他数据腾出空间。另外，CPython还内置了循环检测器（cycle detector），确保那些自我引用的对象也能够得到清除。</p><p>从理论上讲，这意味着Python开发者不用担心程序如何分配并释放内存的问题，因为Python系统本身以及CPython运行时环境会自动处理这些问题。但实际上，还是会有程序因为没有及时释放不再需要引用的数据而耗尽内存。想了解Python程序使用内存的情况，或找到泄漏内存的原因，是比较困难的。</p><p>第一种调试内存使用状况的办法，是用Python内置的gc模块把垃圾回收器目前知道的每个对象都列出来。虽然这样有点儿笨，但毕竟可以让我们迅速得知程序的内存使用状况。</p><p>gc.get_objects函数的缺点在于，它并没有指出这些对象究竟要如何分配。复杂的程序中，同一个类的对象可能是因为好几种不同的原因而为系统所分配的。知道对象的总数固然有意义，但更为重要的是找到分配这些对象的具体代码，这样才能查清内存泄漏的原因。</p><p>Python 3.4版本推出了一个新的内置模块，名为tracemalloc，它可以解决刚才讲的那个问题。tracemalloc能够追溯对象到分配它的位置，因此我们可以在执行受测模块之前与执行完毕之后，分别给内存使用情况做快照，并对比两份快照，以了解它们之间的区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line">tracemalloc.start(<span class="number">10</span>)</span><br><span class="line">time1 = tracemalloc.take_snapshot()</span><br></pre></td></tr></table></figure><p>每一条记录都有size与count指标，用来表示这行代码所分配的对象总共占用多少内存以及这些对象的数量。通过这两项指标，我们很快就能发现占用内存较多的对象是由哪几行代码所分配的。tracemalloc模块还可以打印完整的栈追踪信息（当然了，这最多只能达到调用tracemalloc.start函数时设置的帧数）。</p><p>这样的栈追踪信息很有用处，因为它能帮我们找到程序中累计分配内存最多的函数或类。</p><hr><h2 id="10-协作开发"><a href="#10-协作开发" class="headerlink" title="10.协作开发"></a>10.协作开发</h2><p>要想与其他人一起开发Python程序，你必须仔细留意自己编写代码的方式。</p><h3 id="第82条、学会寻找由其他Python开发者所构建的模块"><a href="#第82条、学会寻找由其他Python开发者所构建的模块" class="headerlink" title="第82条、学会寻找由其他Python开发者所构建的模块"></a>第82条、学会寻找由其他Python开发者所构建的模块</h3><p>Python有个集中存放模块的地方，叫作Python Package Index（PyPI，网址为<a href="https://pypi.org），你可以从中安装模块，并在自己的程序里面使用。这些模块都是由Python开发者所构建并维护的，这些开发者合称Python社群。如果你面对一项自己不太熟悉的需求，那么可以去PyPI搜索一下，看看有没有哪个软件包能够帮你更快地实现目标。" target="_blank" rel="noopener">https://pypi.org），你可以从中安装模块，并在自己的程序里面使用。这些模块都是由Python开发者所构建并维护的，这些开发者合称Python社群。如果你面对一项自己不太熟悉的需求，那么可以去PyPI搜索一下，看看有没有哪个软件包能够帮你更快地实现目标。</a></p><p>要从PyPI安装软件包，可以在命令行界面执行pip命令（这是个递归的首字母缩略词，指<code>pip installs packages</code>）。</p><p>pip最好与内置的venv模块搭配使用，这样可以给不同的项目分别安装不同版本的软件包，以适应每个项目自身的要求。你可以自己创建软件包并发布到PyPI与其他开发者共享，或搭建私人的软件包仓库，让pip改从这里安装模块。</p><h3 id="第83条、用虚拟环境隔离项目，并重建依赖关系"><a href="#第83条、用虚拟环境隔离项目，并重建依赖关系" class="headerlink" title="第83条、用虚拟环境隔离项目，并重建依赖关系"></a>第83条、用虚拟环境隔离项目，并重建依赖关系</h3><p>程序变得比较大、比较复杂后，可能需要依赖更多的第三方Python包，那时我们可以通过python3 -m pip命令安装pytz、numpy以及其他许多模块。</p><p>问题在于，pip会把新的软件包默认安装到全局路径之中，这样会让涉及该模块的每一个Python程序都受到影响。有些人可能觉得这不会有什么问题：如果只安装模块，而不在Python程序里面直接引入它，那这个程序就不会受模块的影响了吧？</p><p>其实问题出现在间接的依赖关系上面，也就是说，直接引入的虽然不是这个模块，但你引入的其他模块却必须依赖这个模块才能运作。例如，如果你打算直接引入Sphinx模块，那就用pip install命令安装该模块，安装好之后，可以通过pipshow查看它的依赖关系。</p><p>同一个模块在Python的全局环境中只能存在一个版本。如果某个软件包需要使用新版模块，而另一个软件包需要使用旧版模块，那么就会遇到两难的局面：不论这个模块是否升级，这两个软件包都会有一个无法运作。这种情况通常称为dependency hell。</p><p>上面提到的种种问题都可以通过venv工具解决。这个工具能够创建虚拟环境（virtual environment）。从Python 3.4开始，pip与venv模块会在安装Python时一起默认安装。</p><p>venv可以创建彼此隔绝的Python环境，我们能够把同一个软件包的不同版本分别安装到不同的环境里面，这样就不会产生冲突了。这意味着能够在同一台电脑上面给不同的项目创建各自的环境，并在里面安装它们所需要的软件包版本。为了达到这样的效果，venv工具会把这些软件包以及它们所依赖的其他软件包都专门安装到单独的目录结构里面，使得多个环境之间不会发生冲突。这种机制，也让我们可以把项目所要求的环境在其他电脑上面重新建立起来，令程序能够可靠地运行，而不会出现意外的问题。</p><p>用python3 -m pip list列出这套虚拟环境之中安装的软件包，可以看到，这些软件包与前一套环境所安装的相同。</p><p>用版本控制系统（revision control system）与他人协作时，这样一份requirements.txt文件是很有用处的，因为你在提交代码的同时，可以把新版代码所依赖的软件包通过该文件一起提交上去，这样能够确保代码与代码所依赖的软件包总是可以同步更新。然而，有一个问题必须注意，那就是Python本身的版本并不包含在requirements.txt之中，所以必须单独管理。</p><p>虚拟环境有个很容易出错的地方，就是不能直接把它移动到其他路径下面，因为它里面的一些命令（例如python3）所指向的位置都是固定写好的，其中用到了这套环境的安装路径，假如移动到别处，那么这些路径就会失效。然而，这其实并不算大问题，因为我们创建虚拟环境，不是想要移动它，而是想把它的配置记录下来，以便在其他环境里面重建。所以我们要做的，仅仅是用<code>python3 -m pip freeze</code>命令把旧环境依赖的软件包保存到requirements.txt文件之中，然后在新环境里面，根据这份文件重新安装这些软件包。</p><h3 id="第84条、每一个函数、类与模块都要写docstring"><a href="#第84条、每一个函数、类与模块都要写docstring" class="headerlink" title="第84条、每一个函数、类与模块都要写docstring"></a>第84条、每一个函数、类与模块都要写docstring</h3><p>Python是动态语言，因此文档特别重要。Python内建了相关的机制，支持给代码块编写文档，而且与其他一些编程语言不同，Python允许我们在程序运行的过程中，直接访问这些文档。</p><p>例如，我们可以紧跟着函数的定义（def）语句，书写一条docstring作为这个函数的文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome</span><span class="params">(word)</span>:</span></span><br><span class="line">  <span class="string">"""Return True if the given word is a palindrome."""</span></span><br><span class="line">  <span class="keyword">return</span> word == word[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> palindrome(<span class="string">'tacocat'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> palindrome(<span class="string">'banana'</span>)</span><br></pre></td></tr></table></figure><p>函数的docstring可以在运行Python程序的过程中通过<strong>doc</strong>这个特殊的属性访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(repr(palindrome.__doc__))</span><br></pre></td></tr></table></figure><p>另外，还可以在命令行界面中，利用内置的pydoc模块在本机上启动web服务器，这台服务器能够提供当前Python解释器所能访问到的全部文档，也包括你自己编写的那些模块。</p><p>docstring可以关联到函数、类与模块上面，系统在编译并运行Python程序的过程中，会把确定这种关联的关系也当成工作的一部分。由于Python支持docstring并允许程序通过<strong>doc</strong>属性来访问docstring，我们会享受到以下三个好处：</p><ul><li>开发者能够在程序中访问文档信息，这会让交互式开发工作变得更加轻松。</li><li>这些文档是按照标准的方式定义的，因此很容易就能转换成表现力更强的格式（例如HTML）。</li><li>Python文档不仅可以做得很漂亮，而且与其他普通的头等Python实体一样，也能够在程序里面正常地访问，这会让开发者更乐意编写这样的文档。</li></ul><p>如果你也想像大家一样把文档写好，那就需要遵循一些与docstring有关的约定。完整的规范，可以查看PEP 257（<a href="https://www.python.org/dev/peps/pep-0257/），接下来我们重点讲述其中必须注意的几个方面。" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0257/），接下来我们重点讲述其中必须注意的几个方面。</a></p><h4 id="为模块编写文档"><a href="#为模块编写文档" class="headerlink" title="为模块编写文档"></a>为模块编写文档</h4><p>每个模块都要有顶级的docstring，即写在源文件开头的那个字符串。字符串的首尾都要带三重引号，这样的字符串的目的主要是介绍本模块与其中的内容。</p><p>在docstring里面，第一行应是一个单句，描述本模块的用途。接下来应该另起一段，详解讲述使用这个模块的用户所要知道的一些事项。另外，凡是模块里面比较重要的类与函数，都应该在docstring中予以强调，这样的话，查看这份文档的用户就可以从这些类及函数出发来熟悉模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># words.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Library for finding linguistic patterns in words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Testing how words relate to each other can be tricky sometimes!</span></span><br><span class="line"><span class="string">This module provides easy ways to determine when words you've found have special properties.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available functions:</span></span><br><span class="line"><span class="string">- palindrome: Determine if a word is a palindrome.</span></span><br><span class="line"><span class="string">- check_anagram: Determine if two words are anagrams.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>如果这个模块表示的是一个可以在命令行界面使用的工具，那么模块的docstring里面，还应该写出相关的信息并介绍该工具的用法。</p><h4 id="为类编写文档"><a href="#为类编写文档" class="headerlink" title="为类编写文档"></a>为类编写文档</h4><p>每个类都应该有类级别的docstring，这种文档的写法，与模块级别的docstring差不多。它的第一段，也需要用一句话来概述整个类的用途。后面的各段，可以详细讲解本类中的每一种操作。</p><p>类中比较重要的public属性与方法，同样应该在类级别的docstring里面加以强调。另外还需要说明，如果想编写子类，子类应该怎样与受保护的属性以及超类中的方法相交互。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>:</span></span><br><span class="line">  <span class="string">"""Represents a player of the game.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Subclasses may override the 'tick' method to provide custom animations for the player's movement depending on their power level, etc.</span></span><br><span class="line"><span class="string">  Public attributes:</span></span><br><span class="line"><span class="string">  - power: Unused power-ups(float between 0 and 1).</span></span><br><span class="line"><span class="string">  - coins: Coins found during the level(integer).</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><h4 id="为函数编写文档"><a href="#为函数编写文档" class="headerlink" title="为函数编写文档"></a>为函数编写文档</h4><p>每个public函数与方法都应该有docstring。它的写法与模块和类的相同，第一段也是一个句子，描述这个函数是做什么的。接下来的那段应该描述函数的行为。然后，可以各用一段来描述函数的参数与返回值。另外，如果调用者在使用这个函数接口的时候，需要处理该函数所抛出的一些异常，那么这些异常也要解释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word, dictionary)</span>:</span></span><br><span class="line">  <span class="string">"""Find all anagrams for a word.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  This function only runs as fast as the test for membership in the 'dictionary' container.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  words: String of the target word.</span></span><br><span class="line"><span class="string">  dictionary: collections.abc.Container with all strings that are known to be actual words.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  List of anagrams that were found. Empty if</span></span><br><span class="line"><span class="string">  none were found.</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>编写docstring的时候，需要注意下面几种特殊的情况：</p><ul><li>如果函数没有参数，而且返回的是个比较简单的值，那么就不用按照上面讲的那种格式分段书写了。直接用一句话来描述整个函数可能会更好。</li><li>如果函数没有返回值，那么最好是把描述返回值的那段完全省去，而不要专门写出返回None。</li><li>如果函数所抛出的异常也是接口的一部分，那么应该在docstring里面详细解释每一种异常的含义，并说明函数在什么场合会抛出这样的异常。</li><li>如果函数在正常使用的过程中，不会抛出异常，那么无须专门指出这一点。</li><li>如果函数可以接受数量可变的位置参数或关键字参数，那么应该在解释参数的那一部分用<code>*args</code>与<code>**kwargs</code>来说明这两种参数的用途。</li><li>如果参数有默认值，那么文档里应该提到这些默认值。</li><li>如果函数是个生成器，那么应该在docstring里面写明这个生成器在迭代过程中会产生什么样的值。</li><li>如果函数是异步协程，那么应该在docstring里面解释这个协程执行到何时会暂停。</li></ul><h4 id="用类型注解来简化docstring"><a href="#用类型注解来简化docstring" class="headerlink" title="用类型注解来简化docstring"></a>用类型注解来简化docstring</h4><p>Python现在已经支持类型注解了，这种注解有许多用途，其中一项就是简化docstring，因为原本写在docstring里面的某些含义，现在可以直接通过类型注解体现出来。下面，我们给find_anagrams函数的签名加上类型注解，以指出参数与返回值的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Container, List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word: str,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dictionary: Container[str])</span> -&gt; List[str]:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>有了这样的注解，我们就不用专门在docstring里面说明word参数是字符串了，因为现在的word参数后面有个冒号，冒号右侧标出了它的类型，即str。dictionary参数也一样，它的类型现在明确地标注成了collections.abc.Container。另外，返回值同样不用专门在docstring里面解释，因为声明函数时，已经在-&gt;符号右侧明确说明该函数会返回一份列表。这也意味着即便找不到与word参数的组成字母相同但排列顺序不同的词（或者说，找不到word参数的同字母异序词（anagram）），函数也依然要返回列表，当然这种情况下返回的列表是一份空白的列表，所以不用在docstring里面专门说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span><span class="params">(word: str,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dictionary: Container[str])</span> -&gt; List[str]:</span></span><br><span class="line">  <span class="string">"""Find all anagrams for word.</span></span><br><span class="line"><span class="string">  This function only runs as fast as the test for</span></span><br><span class="line"><span class="string">  membership in the 'dictionary' container.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  word: Target word.</span></span><br><span class="line"><span class="string">  dictionary: All known actual words.</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  Anagrams that were found.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>类型注解与docstring之间的这种重复现象，也会出现在实例字段、类属性与方法中。这样的类型信息最好是只写在一个地方，而不要同时写在类型注解与docstring中，因为在修改实现代码时，可能会忘记更新其中的某一处。</p><h3 id="第85条、用包来安排模块，以提供稳固的API"><a href="#第85条、用包来安排模块，以提供稳固的API" class="headerlink" title="第85条、用包来安排模块，以提供稳固的API"></a>第85条、用包来安排模块，以提供稳固的API</h3><p>项目代码变多之后，我们自然需要重新调整它的结构。可能要把大函数拆成许多个小的函数，或者通过辅助类改写某个数据结构，还有可能要把各项功能分散到多个相互依赖的模块里面。</p><p>到了一定阶段，你就会发现模块也变得多了起来，所以还得再构建一层机制以便于管理。在Python中，这可以通过包（package）来实现，包本身也是一种模块，只不过它里面还含有其他模块。</p><p>大多数情况下，把名为<strong>init</strong>.py的空白文件放在某个目录中，即可令该目录成为一个包。一旦有了<strong>init</strong>.py文件，我们就可以使用相对于该目录的路径引入包中的其他py文件了。例如，现在目录结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.py</span><br><span class="line">mypackage/__init__.py</span><br><span class="line">mypackage/models.py</span><br><span class="line">mypackage/utils.py</span><br></pre></td></tr></table></figure><p>如果想在main.py里面引入utils模块，那么可以把包名（也就是mypackage）写在from后面，并把其中的模块名写在import后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> utils</span><br></pre></td></tr></table></figure><p>如果有些包本身位于更大的包之中，那么就把从大包到这个包之间的各层都用圆点连起来。例如，要引入bar包中的某个模块，而bar包又位于mypackage包的foo目录之下，那么就写为<code>from mypackage.foo.bar import ...</code>。包在Python程序里主要有两种用途。</p><h4 id="用包划分名称空间"><a href="#用包划分名称空间" class="headerlink" title="用包划分名称空间"></a>用包划分名称空间</h4><p>包的一个用途是帮助把模块安排到不同的名称空间（namespace）里面，这样的话，即便两个模块所在的文件同名，也依然能够加以区分，因为它们所在的名称空间不同。例如，下面这个程序要从两个模块里面分别引入一个属性（本例实际引入一个函数），虽然这两个模块所在的文件都叫utils.py，但我们还是可以通过模块所属的包来区分它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> log_base2_bucket</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> stringify</span><br><span class="line"></span><br><span class="line">bucket = stringify(log_base2_bucket(<span class="number">33</span>))</span><br></pre></td></tr></table></figure><p>这种写法有个问题，如果两个包里有同名的模块，或者两个模块里有同名的函数或类，那么后引入的那个会把先引入的覆盖掉。例如，假设analysis.utils与frontend.utils模块里都有函数叫作inspect，那么就没办法通过刚才那种写法来同时使用这两个函数了，因为第二条import语句会把第一条所引入的那个inspect覆盖掉，导致当前范围内只存在一个inspect。</p><p>解决办法是给import语句加上as子句，这样就能把两个inspect函数分别用不同的名称引入到当前的范围里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> analysis_inspect</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> frontend_inspect</span><br></pre></td></tr></table></figure><p>as子句不仅可以给函数起别名，而且能把整个模块都换个名称，这让我们可以清晰地区分各种命名空间里面的同名实体。</p><p>另外一种办法是从能够区分它们的那一层开始书写访问名称。例如，可以把<code>from... import ...</code>形式的引入语句改成<code>import ...</code>形式，并且用analysis.utils.inspect与frontend. utils.inspect来区分这两个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> analysis.utils</span><br><span class="line"><span class="keyword">import</span> frontend.utils</span><br></pre></td></tr></table></figure><p>这种写法完全不需要使用as子句，而且由于它采用的名字比较全，初次读到这段代码的读者也可以清楚地了解到这两个inspect函数分别是在哪个包的哪个模块里面定义的。</p><h4 id="通过包来构建稳固的API"><a href="#通过包来构建稳固的API" class="headerlink" title="通过包来构建稳固的API"></a>通过包来构建稳固的API</h4><p>包的第二个用途是构建严谨而稳固的API，以便给外部的开发者使用。</p><p>如果这套API要提供给很多人使用，例如要做成开源的软件包，那么你可能想把它的功能稳定下来，以免新旧版本之间差得太大。为了做到这一点，必须隐藏软件包内部的代码结构，不要让外部的开发者依赖这套结构，只有这样，你才能重构并改善这些内部模块，而不必担心自己所做的修改会影响外部用户已经写好的那些代码。</p><p>Python允许我们通过<strong>all</strong>这个特殊的属性，决定模块或包里面有哪些内容应该当作API公布给外界。<strong>all</strong>的值是一份列表，用来描述可作为public API导出的所有内容名称。如果执行from foo import *这样的语句，那么只有<strong>all</strong>所列出名称的属性才会引入进来。若是foo里面没有<strong>all</strong>，那么就只会引入public属性。</p><p>谨慎地使用import<em>形式的引入语句。from x import y这种形式的引入语句，是很清晰的，因为它明确指出了y来自x包或x模块。引入语句还有一种写法，就是带有通配符的from foo import </em>形式，这种引入语句也很有用，尤其是在交互式的Python界面之中。然而大家必须注意，这样写会造成两方面的困难：</p><ul><li>用from … import <em>的形式引入，会让初次读到这段代码的读者弄不清某些名称究竟来自哪里。如果模块里有许多条这样的import </em>语句，那我们可能必须把受引用的模块全都查找一遍，才能确定某个名字到底是从哪个模块引入的。</li><li>import *形式的引入语句，会把已经引入本模块的同名实体覆盖掉，从而导致奇怪的bug，因为同一个名称，在执行这条语句之前，与执行这条语句之后，可能指向两个不同的地方。</li></ul><p>最稳妥的做法是不要采用import *的形式引入，而是通过from x import y明确指出名称y来自模块x。</p><p>如果不想让外界看到某些内容，那么可以在包目录中的<strong>init</strong>.py文件里面故意不引入这些内容，或者给这些只供本包内部使用的内容名称前面添加下划线。</p><p>假如这个包只在某个团队或某个项目内部使用，那恐怕就没必要专门通过<strong>all</strong>来指定外界能够访问到的API了。</p><h3 id="第86条、考虑用模块级别的代码配置不同的部署环境"><a href="#第86条、考虑用模块级别的代码配置不同的部署环境" class="headerlink" title="第86条、考虑用模块级别的代码配置不同的部署环境"></a>第86条、考虑用模块级别的代码配置不同的部署环境</h3><p>部署环境指的是程序运行在什么样的配置之下。每个程序至少要有一套部署环境，也就是生产环境（production environment）。我们之所以写程序，就是想让它能够在生产环境里面正常运行并产生预期的结果。</p><p>另外，我们可能还需要构建一套环境，可以方便地编写或修改程序代码，这套环境叫作开发环境（development environment），它的配置方式可能与生产环境有很大区别。例如，我们的程序可能是在单片机中开发的，但是却打算放在巨型的超级计算机上面运行。</p><p>venv这样的工具可以确保所有的环境里面安装的都是同一套Python软件包（参见第83条）。但是问题在于，软件在生产环境中运行的时候，通常需要依赖许多外部条件，而那些条件不太容易在开发环境里面重现。</p><p>要想解决这个问题，最好的办法是让程序在启动时，能够根据当前环境决定其中某些资源应该如何配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TESTING = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> db_connection</span><br><span class="line"></span><br><span class="line">db = db_connection.Database()</span><br></pre></td></tr></table></figure><p>这两份文件只有一个地方不同，也就是TESTING常量的取值。程序中的其他模块可以引入<strong>main</strong>模块，并根据TESTING的值决定如何配置自己的某些属性。</p><p>如果环境配置起来特别复杂，那就不要使用TESTING这样单纯的Python常量，而是可以考虑构建专门的配置文件，并通过Python内置的configparser模块等解析工具来处理这种文件，把它们与程序代码分开维护。在与运维团队合作的时候，这一点尤其重要。</p><p>模块级别的代码不仅可以模拟外部资源，而且还有其他用途。</p><p>我们还可以通过os.environ查询环境变量，从而决定模块中的相关内容应该如何定义。</p><h3 id="第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"><a href="#第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常" class="headerlink" title="第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"></a>第87条、为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h3><p>给模块定义API时，要定义的不仅是其中的函数与类，而且还必须注意这些函数会不会抛出异常，因为这些异常实际上也接口的一部分。</p><p>Python语言及标准库本身有自己的异常体系，所以在开发程序的时候，开发者喜欢沿用这些内置的异常类型来报告其中的错误，而不想定义新的类型。</p><p>给模块定义根异常，可以让使用这个模块的API用户将他们自己的代码与这个模块所提供的API隔开，以便分别处理其中的错误。</p><p>API用户在处理完API所属模块有可能抛出的具体异常后，可以写一个针对模块根异常的except块，如果程序进入这个块，那就说明他使用API的方式可能有问题，例如可能忘记处理某种本来应该处理的具体异常。</p><p>API用户还可以再写一个except块以捕获整个Python体系之中的根异常，如果程序进入了那个块，那说明所调用的API可能实现得有问题。在模块的根异常下，可以设立几个门类，让具体的异常不要直接继承总的根异常，而是继承各自门类中那个分根异常，这样的话，使用这个模块的开发者，就可以只关注这几个门类，即便你修改了某个门类之下的具体异常，也不会影响到他们已经写好的那些代码。</p><h3 id="第88条、用适当的方式打破循环依赖关系"><a href="#第88条、用适当的方式打破循环依赖关系" class="headerlink" title="第88条、用适当的方式打破循环依赖关系"></a>第88条、用适当的方式打破循环依赖关系</h3><p>在引入模块的时候，Python系统会按照深度优先的顺序，对模块执行以下五步：</p><ul><li>1）在sys.path里面寻找模块的位置。</li><li>2）把模块的代码加载进来，并确认这些代码能够编译。</li><li>3）创建相应的空白模块对象表示该模块。</li><li>4）把这个模块插入sys.modules字典。</li><li>5）运行模块对象之中的代码定义该模块的内容。</li></ul><p>循环依赖之所以会出错，原因在于，执行完第4步之后，这个模块已经位于sys.modules之中了，然而它的内容这个时候可能还没有得到定义，要等到执行完第5步，才能齐备。可是，Python系统在执行import语句的时候，如果发现要引入的模块已经出现在了sys.modules里面（也就是说，那个模块已经执行完了前4步），那么就会继续执行import的下一条语句，而不会顾及模块之中的内容是否得到了定义。</p><p>要解决这种问题，最好的办法是重构代码，把prefs数据结构放在依赖体系的最底层，把它单独放在一个工具模块里面，app与dialog模块就可以分别引入这个工具模块，而不用像原来那样，彼此依赖对方。予以划分，有时必须重构大量的代码，才能解开两个模块之间的相互依赖关系，让它们都去依赖第三个模块。</p><p>除了这种解法之外，还有三个办法，也能够解除循环依赖关系。</p><ul><li>第一个办法是，调整import语句的位置。调整import语句的位置，可能会让代码变得容易出错，因为有时只要稍微改动这条import语句的位置，整个模块就没办法使用了。</li><li>把模块划分成引入-配置-运行这样三个环节。循环引入问题的第二个解决办法是，尽量缩减引入时所要执行的操作。我们可以让模块只把函数、类与常量定义出来，而不真的去执行操作，这样的话，Python程序在引入本模块的时候，就不会由于操作其他模块而出错了。我们可以把本模块里面，需要用到其他模块的那种操作放在configure函数中，等到本模块彻底引入完毕后，再去调用。configure函数会访问其他模块中的相关属性，以便将本模块的状态配置好。这个函数是在该模块与它所要使用的那个模块都已经彻底引入后才调用的（也就是说，这两个模块都把各自的第5步执行完了），因此，其中涉及的所有属性全都定义过了。</li><li>动态引入。第三个办法比前两个都简单，也就是把import语句从模块级别下移到函数或方法里面，这样就可以解除循环依赖关系了。这种import语句并不会在程序启动并初始化本模块时执行，而是等到相关函数真正运行的时候才得以触发，因此又叫作动态引入（dynamic import）。</li></ul><p>当然了，一般来说，还是应该尽量避免动态引入，因为import语句毕竟是有开销的，如果它出现在需要频繁执行的循环体里面，那么这种开销会更大。另外，由于动态引入会推迟代码的执行时机，有可能让你的程序在启动了很久之后，突然因为在动态引入其他模块的过程中发生SyntaxError等错误而崩溃（如何避免此类问题）。动态引入虽然有这些缺点，但总比那种大幅度修改整个程序结构的办法好。</p><h3 id="第89条、重构时考虑通过warnings提醒开发者API已经发生变化"><a href="#第89条、重构时考虑通过warnings提醒开发者API已经发生变化" class="headerlink" title="第89条、重构时考虑通过warnings提醒开发者API已经发生变化"></a>第89条、重构时考虑通过warnings提醒开发者API已经发生变化</h3><p>我们经常需要更新API，以实现早前没有预料到的新需求。如果API很小，而且与上游及下游之间的依赖关系也不复杂，那么修改起来就比较简单。在这种情况下，只需要某位开发者把API本身与调用这些API的代码都改好，一起提交到代码库即可。</p><p>代码库变大之后，调用这个API的地方也会变多，而且可能来自好几个项目，所以在修改API的时候，不太容易保证那些地方也能够同步更新。我们必须想办法通知写那些代码的合作者这个API的用法已经变了，让他们尽快重构代码以适配新版的API。</p><p>warnings模块让我们以编程的手段提醒其他开发者注意：代码所依赖的底层库已经发生变化，请尽快做出相应修改。warnings模块发出的是警告，而不是那种带有Error字样的异常（exception），异常主要针对计算机而言，目标是让程序能够自动处理相关的错误，而警告则是写给开发者的，目标是与他们沟通，告诉对方应该如何正确地使用这个API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning.warn(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure><p>warnings.warn函数提供了一个名为stacklevel的参数，让我们可以根据栈的深度指出真正触发这条警告的那个位置，而不是调用warnings.warn函数的字面位置。</p><p>负责这段代码的开发者，如果已经意识到自己应该按照新的方式来使用你所提供的API，那么他就可以通过warnings模块的simplefilter与filterwarnings函数暂时忽略警告（详细的用法，参见<a href="https://docs.python.org/3/library/warnings）。" target="_blank" rel="noopener">https://docs.python.org/3/library/warnings）。</a></p><p>程序部署到生产环境之后，就没有必要让警告变成错误了，因为那样可能导致程序在关键时刻崩溃。比较好的办法是，通过Python内置的logging模块将警告信息重新定向到日志系统。</p><p>如果你设计的API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</p><h3 id="第90条、考虑通过typing做静态分析，以消除bug"><a href="#第90条、考虑通过typing做静态分析，以消除bug" class="headerlink" title="第90条、考虑通过typing做静态分析，以消除bug"></a>第90条、考虑通过typing做静态分析，以消除bug</h3><p>只有文档可能还不够，有时我们还是会把API用错，导致程序出现bug。所以，最好能有一套机制来验证调用者使用API的方式是否正确，如果我们把自己的API发布出去，那么这套机制还能帮助其他开发者检查他们的代码有没有恰当地使用这套API。许多编程语言通过编译期的类型检查来实现这种验证，这确实能够消除某些bug。</p><p>Python以前主要关注的是动态特性，所以没有提供编译期的类型安全机制。但是最近，Python开始引入一套特殊的写法，让我们可以通过内置的typing模块给变量、类中的字段、函数及方法添加类型信息。这些类型提示（type hint）信息可以实现渐进的类型判定机制（gradual typing），让我们在开发项目的过程中，把能够在编译期明确指定类型的地方逐渐确定下来。</p><p>给Python程序的代码添加类型信息之后，我们就可以运行静态分析（staticanalysis）工具，分析这些代码里面是否存在极有可能出现bug的地方。Python内置的typing模块本身并不实现类型检查功能，它只是一套可以公开使用的代码库，其中定义了相关的类型（也包括泛型类型），我们可以用这些类型来注解 Python代码，并利用其他工具根据这些类型判断受注解的代码有没有正确地得到使用。</p><p>Python解释器有许多种不同的实现方案，例如CPython、PyPy等，与之类似，与typing模块相搭配的Python静态分析工具，也有很多方案。笔者编写本书的时候，比较流行的是mypy（<a href="https://github.com/python/mypy）、pytype（https://github.com/google/pytype）、pyright（https://github.com/microsoft/pyright）与pyre（https://pyre-check.org）。" target="_blank" rel="noopener">https://github.com/python/mypy）、pytype（https://github.com/google/pytype）、pyright（https://github.com/microsoft/pyright）与pyre（https://pyre-check.org）。</a></p><p>如使用mypy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">substract</span><span class="params">(a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">return</span> a - b</span><br></pre></td></tr></table></figure><p>Python的动态机制有个好处，就是可以实现泛型，进而把需要操作的数据当成duck type使用。也就是说，只要用户给出支持这种操作的数据即可，不用管这份数据究竟是什么类型，这样我们就能够让函数接受各种各样的数据，而不用针对每一种数据都专门编写对应的版本，这可以避免重复代码并简化测试工作。</p><p>我们可以利用typing模块给函数所涉及的泛型做注解，从而通过静态手段把程序运行时可能发生的错误提前探查出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_default</span><span class="params">(value: Optional[int]m</span></span></span><br><span class="line"><span class="function"><span class="params">                  default: int)</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>typing模块还提供了许多选项，可以给代码做注解，详情参见<a href="https://docs.python.org/3.8/library/typing。然而特别需要注意的是，异常并不包括在内。Python与Java不同，Java里面有一种异常叫作受检异常（checkedexception），如果API宣称自己可能抛出这种异常，那么使用API的开发者必须明确做出应对。Python在这一方面更像C#，它们都不把异常当作接口定义中的一部分，因此，如果想确保自己的API能够正确地抛出异常，或确保自己在使用别人的API时能够正确地捕获异常，那么必须编写相关的测试。" target="_blank" rel="noopener">https://docs.python.org/3.8/library/typing。然而特别需要注意的是，异常并不包括在内。Python与Java不同，Java里面有一种异常叫作受检异常（checkedexception），如果API宣称自己可能抛出这种异常，那么使用API的开发者必须明确做出应对。Python在这一方面更像C#，它们都不把异常当作接口定义中的一部分，因此，如果想确保自己的API能够正确地抛出异常，或确保自己在使用别人的API时能够正确地捕获异常，那么必须编写相关的测试。</a></p><p>使用typing模块的过程中，经常会碰到这样一个问题，那就是我们在编写类型注解的时候，需要用到当前还没有定义出来的类型，这叫作提前引用（forwardreference）。</p><p>还有一种更好的办法是，通过<code>from __future__ import annotations</code>来引入类型注解功能，这种办法是从Python 3.7版本开始支持的，到了Python 4，将会成为默认的方式。这样写，会让Python系统在运行程序的时候，完全忽略类型注解里面提到的值，于是就解决了提前引用的问题，而且程序在启动时的性能也会提升。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value: SecondClass)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    </span><br><span class="line">second = SecondClass(<span class="number">5</span>)</span><br><span class="line">first = FirstClass(second)</span><br></pre></td></tr></table></figure><p>我们已经了解了类型提示信息的用法及其潜在好处，现在必须提醒大家注意，怎样合理地使用这些注解。下面是几条原则：</p><ul><li>如果刚开始写代码的时候，就想着如何添加类型注解，那可能会拖慢编程速度。所以我们通常应该先把代码本身写出来，然后编写测试，最后才考虑在必要的地方添加类型信息。类型提示信息最能发挥作用的地方，是在项目与项目衔接处。例如，如果有很多个项目都要使用你的API，那么这种API就很有必要做类型注解，因为这些信息可以跟集成测试（参见第77条）与警告互补，以确保API的调用者不会发生误用，并督促调用者在你更新API之后，及时修改他们的代码中与新版API不符的地方。</li><li>如果有些代码比较复杂，或者特别容易出错，那么即便不属于API，也仍然值得添加类型提示信息。但是要注意，没必要给所有的代码都添上类型注解，因为到了一定程度之后，再添加这种信息，就不会给项目带来太大的好处了。</li><li>如果有可能的话，应该把静态分析这一环节纳入自动构建流程与测试系统中，以确保提交上去的每份代码都会经受相关的检查。另外，检查类型信息所用的配置方案，应该放在代码库里面维护，以保证其他的合作者使用的也是这套规则。</li><li>每添加一批类型注解，就应该把静态分析工具运行一遍，这样可以及时发现问题并加以解决。假如把整个项目全都注解完之后，再实施类型检查，那么类型分析工具就有可能打印出极多的错误信息，让你不知道应该先处理哪一条才好，有时甚至会让你想要放弃类型注解。</li></ul><p>最后必须注意，还有许多场合是不需要写类型注解的，比如小型程序、临时代码、遗留项目以及原型等。没必要花时间给这些代码添加类型注解，因为这样做好处很少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-75-～-90-条（测试与调试、协作开发）读书笔记&quot;&gt;&lt;a href=&quot;#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="http://blog.michealwayne.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 52 ～ 74 条读书笔记</title>
    <link href="http://blog.michealwayne.cn/2024/05/25/python/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E4%BB%A3%E7%A0%81%E7%9A%8490%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B-52%E8%87%B374/"/>
    <id>http://blog.michealwayne.cn/2024/05/25/python/【笔记】《编写高质量Python代码的90个有效方法》-52至74/</id>
    <published>2024-05-25T06:13:54.000Z</published>
    <updated>2024-05-25T08:59:10.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-52-～-74-条（并发、稳定性）读书笔记"><a href="#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-52-～-74-条（并发、稳定性）读书笔记" class="headerlink" title="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 52 ～ 74 条（并发、稳定性）读书笔记"></a>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 52 ～ 74 条（并发、稳定性）读书笔记</h1><p>（书基于 Python 3.7+ 语法规范）</p><p>知识点概括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">subprocess模块</span><br><span class="line">threading模块</span><br><span class="line">Queue类</span><br><span class="line">fan-in/fan-out模式</span><br><span class="line">ThreadPoolExecutor类</span><br><span class="line">协程（coroutine）</span><br><span class="line">asyncio库</span><br><span class="line">multiprocessing模块</span><br><span class="line">contextlib和with语句</span><br><span class="line">datetime模块</span><br><span class="line">pickle模块</span><br><span class="line">copyreg模块</span><br><span class="line">Decimal类</span><br><span class="line">profile模块</span><br><span class="line">timeit模块</span><br><span class="line">bisect模块</span><br><span class="line">heapq模块</span><br><span class="line">memoryview类型/bytearray类型</span><br></pre></td></tr></table></figure><h2 id="7-并发与并行"><a href="#7-并发与并行" class="headerlink" title="7.并发与并行"></a>7.并发与并行</h2><p>并发（concurrency）指计算机似乎能在同一时刻做许多件不同的事情。</p><p>并行（parallelism）与并发的区别在于，它强调计算机确实能够在同一时刻做许多件不同的事情。</p><p>并行与并发之间的区别，关键在于能不能提速（speedup）。如果程序把总任务量分给两条独立的执行路径去同时处理，而且这样做确实能让总时间下降到原来的一半，那么这就是并行，此时的总速度是原来的两倍。反过来说，假如无法实现加速，那即便程序里有一千条独立的执行路径，也只能叫作并发，因为这些路径虽然看起来是在同时推进，但实际上却没有产生相应的提速效果。</p><p>Python让我们很容易就能写出各种风格的并发程序。在并发量较小的场合可以使用线程（thread），如果要运行大量的并发函数，那么可以使用协程（coroutine）。并行任务，可以通过系统调用、子进程与C语言扩展（C extension）来实现，但要写出真正能够并行的Python代码，其实是很困难的。</p><h3 id="第52条、用subprocess管理子进程"><a href="#第52条、用subprocess管理子进程" class="headerlink" title="第52条、用subprocess管理子进程"></a>第52条、用subprocess管理子进程</h3><p>Python有相当成熟的函数库可以运行并管理子进程，这让我们能够通过Python语言把其他一些工具（例如命令行工具）很好地拼接起来。Shell脚本经常容易越写越复杂，所以我们有时干脆就考虑改用Python来实现，这样更容易理解，也更容易维护。</p><p>由Python所启动的子进程可以平行地运行，这让我们能够充分利用计算机的每一个CPU核心，来尽量提升程序的处理效率。</p><p>Python里面有许多方式都可以运行子进程（例如os.popen函数以及os.exec*系列的函数），其中最好的办法是通过内置的subprocess模块来管理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run(</span><br><span class="line">  [<span class="string">'echo'</span>, <span class="string">'Hello form the child'</span>],</span><br><span class="line">  capture_output=<span class="literal">True</span>,</span><br><span class="line">  encoding=<span class="string">'utf-8'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result.check_returncode()</span><br><span class="line">print(result.stdout)</span><br></pre></td></tr></table></figure><p>通过run函数启动一条进程，然后确认该进程已经正常终止，最后打印它的输出值。</p><p>（这一条里面的范例代码需要用到操作系统之中的echo、sleep与openssl命令，所以系统里面应该提前准备好这些命令。）</p><p>子进程可以独立于父进程而运行，这里的父进程指Python解释器所在的那条进程。假如刚才那条子进程不是通过run函数启动，而是由Popen类启动的，那么我们就可以在它启动之后，让Python程序去做别的任务，每做一段时间就来查询一次子进程的状态以决定要不要继续执行任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">  print(<span class="string">'Working...'</span>)</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br></pre></td></tr></table></figure><p>把子进程从父进程中剥离，可以让程序平行地运行多条子进程。例如，我们可以像下面这样，先把需要运行的这些子进程用Popen启动起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">sleep_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">  proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line">  sleep_procs.append(proc)</span><br></pre></td></tr></table></figure><p>然后，在主进程里调用每条子进程的communicate方法，等待这条子进程把它的I/O工作处理完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> sleep_procs:</span><br><span class="line">  proc.communicate()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">delta = end - start</span><br><span class="line">print(F<span class="string">'Finished in &#123;delta: .3&#125; seconds'</span>)</span><br></pre></td></tr></table></figure><p>从统计结果可以看出，这10条子进程确实表现出了平行的效果。</p><p>我们还可以在Python程序里面把数据通过管道发送给子进程所运行的外部命令，然后将那条命令的输出结果获取到Python程序之中。而且，在执行外部命令的这个环节中，可以平行地运行多条命令。例如，要用oepnssl这样的命令行工具来加密数据。首先以适当的命令行参数构建一批子进程，并配置好相应的I/O管道，这在Python里很容易就能做到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_encrypt</span><span class="params">(data)</span>:</span></span><br><span class="line">  env = os.environ.copy()</span><br><span class="line">env[<span class="string">'password'</span>] = <span class="string">'zfsgjjj'</span></span><br><span class="line">proc = subprocess.Popen(</span><br><span class="line">[<span class="string">'openssl'</span>, <span class="string">'enc'</span>, <span class="string">'-des3'</span>, <span class="string">'-pass'</span>, <span class="string">'env:password'</span>],</span><br><span class="line">  env=env,</span><br><span class="line">  stdin=subprocess.PIPE,</span><br><span class="line">  stdout=subprocess.PIPE</span><br><span class="line">)</span><br><span class="line">proc.stdin.write(data)</span><br><span class="line">proc.stdin.flush()</span><br><span class="line"><span class="keyword">return</span> proc</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">  data = os.urandom(<span class="number">10</span>)</span><br><span class="line">  proc = run_encrypt(data)</span><br><span class="line">  procs.append(proc)</span><br></pre></td></tr></table></figure><p>这些子进程能够平行地运行，并各自处理它所接到的那份数据。现在逐个等待每一条子进程完工，然后获取并打印这条子进程的加密结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> procs:</span><br><span class="line">  out, _ = proc.communicate()</span><br><span class="line">  print(out[<span class="number">-10</span>:])</span><br></pre></td></tr></table></figure><p>这些平行运行的子进程还可以分别与另一套平行的子进程对接，形成许多条平行的管道（pipe）。这种管道与UNIX管道类似，能够把一条子进程的输出端同另一条子进程的输入端连接起来。</p><p>下面，我们写这样一个函数，让它开启一条子进程来运行openssl命令，这条命令会根据输入端所发来的数据在输出端生成Whirlpool哈希。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_hash</span><span class="params">(input_stdin)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> subprocess.Popen(</span><br><span class="line">  [<span class="string">'openssl'</span>, <span class="string">'dgst'</span>, <span class="string">'-whirlpool'</span>, <span class="string">'-binary'</span>],</span><br><span class="line">    stdin=input_stdin,</span><br><span class="line">    stdout=subprocess.PIPE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>调用communicate方法时可以指定timeout参数，让我们有机会把陷入死锁或已经卡住的子进程关掉。</p><h3 id="第53条、可以用线程执行阻塞式I-O，但不要用它做并行计算"><a href="#第53条、可以用线程执行阻塞式I-O，但不要用它做并行计算" class="headerlink" title="第53条、可以用线程执行阻塞式I/O，但不要用它做并行计算"></a>第53条、可以用线程执行阻塞式I/O，但不要用它做并行计算</h3><p>Python语言的标准实现叫作CPython，它分两步来运行Python程序。首先解析源代码文本，并将其编译成字节码（bytecode）。字节码是一种底层代码，可以把程序表示成8位的指令（从Python 3.6开始，这种底层代码实际上已经变成16位了，所以应该叫作wordcode才对，但基本原理依然相同）。然后，CPython采用基于栈的解释器来运行字节码。这种字节码解释器在执行Python程序的过程中，必须确保相关的状态不受干扰，所以CPython会用一种叫作全局解释器锁（global interpreter lock，GIL）的机制来保证这一点。</p><p>GIL实际上就是一种互斥锁（mutual-exclusion lock，mutex），用来防止CPython的状态在抢占式的多线程环境（preemptive multithreading）之中受到干扰，因为在这种环境下，一条线程有可能突然打断另一条线程抢占程序的控制权。如果这种抢占行为来得不是时候，那么解释器的状态（例如为垃圾回收工作而设立的引用计数等）就会遭到破坏。所以，CPython要通过GIL阻止这样的动作，以确保它自身以及它的那些C扩展模块能够正确地执行每一条字节码指令。</p><p>但是，GIL会产生一个很不好的影响。在C++与Java这样的语言里面，如果程序之中有多个线程能够分头执行任务，那么就可以把CPU的各个核心充分地利用起来。尽管Python也支持多线程，但这些线程受GIL约束，所以每次或许只能有一条线程向前推进，而无法实现多头并进。所以，想通过多线程做并行计算或是给程序提速的开发者，恐怕要失望了。</p><p>多线程的程序在标准的CPython解释器之中会受GIL牵制（例如CPython要通过GIL防止这些线程争抢全局锁，而且要花一些时间来协调）。</p><p>若要CPython把多个核心充分利用起来，还是有一些办法的，但那些办法都不采用标准的Thread类，而且实现起来也需要大量的精力。既然有这么多限制，那Python还支持多线程干什么？这其实有两个原因。</p><p>首先，这种机制让我们很容易就能实现出一种效果，也就是令人感觉程序似乎能在同一时间做许多件事。这样的效果采用手工方式很难编写而通过线程来实现，则可以让Python自动替我们把这些问题处理好，让多项任务能够并发地执行。由于GIL机制，虽然每次还是只能有一个线程向前执行，但CPython会确保这些Python线程之间能够公平地轮换执行。</p><p>其次，我们可以通过Python的多线程机制处理阻塞式的I/O任务，因为线程在执行某些系统调用的过程中会发生阻塞，假如只支持一条线程，那么整个程序就会卡在这里不动。Python程序需要通过系统调用与外部环境交互，其中有一些调用属于阻塞式的I/O操作，例如读取文件、写入文件、联网以及与显示器等设备交互。多线程机制可以让程序中的其他线程继续执行各自的工作，只有发起调用请求的那条线程才需要卡在那里等待操作系统给出结果。</p><p>GIL只不过是让Python内部的代码无法平行推进而已，至于系统调用，则不会受到影响，因为Python线程在即将执行系统调用时，会释放GIL，待完成调用之后，才会重新获取它。</p><p>除了线程，还有很多办法也能处理阻塞式的I/O（例如采用内置的asyncio模块等）。那些办法都很好，但你可能得花时间去重构代码适应它们所要求的执行模式。与那些办法相比，用多线程处理阻塞式I/O是最简单的，而且只需要稍微调整代码就行。</p><h3 id="第54条、利用Lock防止多个线程争用同一份数据"><a href="#第54条、利用Lock防止多个线程争用同一份数据" class="headerlink" title="第54条、利用Lock防止多个线程争用同一份数据"></a>第54条、利用Lock防止多个线程争用同一份数据</h3><p>了解到全局解释器锁（GIL）的效果之后，许多Python新手可能觉得没必要继续在代码里使用互斥锁（mutual-exclusion lock，mutex）了。既然GIL让Python线程没办法平行地运行在多个CPU核心上，那是不是就意味着它同时还会自动保护程序里面的数据结构，让我们不需要再加锁了？</p><p>其实并非如此。GIL起不到这样的保护作用。虽说同一时刻只能有一条Python线程在运行，但这条线程所操纵的数据结构还是有可能遭到破坏，因为它在执行完当前这条字节码指令之后，可能会被Python系统切换走，等它稍后切换回来继续执行下一条字节码指令时，当前的数据或许已经与实际值脱节了，因为中途切换进来的其他线程可能更新过这个值。所以，多个线程同时访问同一个对象是很危险的。<strong>每条线程在操作这份数据时，都有可能遭到其他线程打扰，因此数据之中的固定关系或许已经被别的线程破坏了，这会令程序陷入混乱状态。</strong></p><p>例如，要编写一个程序，让它平行地采集数据。如果要采集传感器网络中的每个传感器所给出的亮度，那么就需要用到这种程序。我们首先需要定义下面这样一个新类，用来记录采集到的样本总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">    self.count += offset</span><br></pre></td></tr></table></figure><p>然后，假设获取传感器读数的操作是一种阻塞式的I/O操作，这样的话，我们就需要针对每个传感器都开启一条工作线程专门读取它所负责的这个传感器。每采集到一份样本，线程就会给表示样本总数的那个量加1，直到采集完应采集样本为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    counter.increment(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>现在，给每个传感器建立各自的工作线程，让这些线程平行地采样，最后等待所有线程完成各自采样工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = Counter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  thread = Thread(target=worker,args=(i, how_many, counter))</span><br><span class="line">  threads.append(thread)</span><br><span class="line">  thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">  thread.join()</span><br><span class="line">  </span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>这个程序似乎相当简单，所以运行结果应该是500000才对。但实际上却差得很远，这是为什么?其实，Python解释器需要保证这些线程可以公平地获得执行机会，或者说，保证每条线程所分配到的执行时间大致相等。为了实现这种效果，它会及时暂停某条线程，并且把另一条线程切换过来执行。然而问题是，我们并不清楚它具体会在什么时候暂停线程，万一这条线程正在执行的是一项本来不应该中断的原子操作（atomic operation），那会如何呢？上面的例子遇到的正是这种情况。Counter对象的increment方法看上去很简单，工作线程在调用这个方法时，相当于是在执行下面这样一条语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter.count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然而，在对象的属性上面执行+=操作，实际上需要分成三个小的步骤。也就是说，Python系统会这样看待这次操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result = value + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result)</span><br></pre></td></tr></table></figure><p>这三个步骤本来应该一次执行完才对，但是Python系统有可能在任意两步之间，把当前这条线程切换走，这就导致这条线程在切换回来后，看到的是个已经过时的value值，它把这个过时的值通过setattr赋给Counter对象的count属性，从而使统计出来的样本总数偏小。</p><p>线程A在执行了第一步之后，还没来得及执行第二步，就被线程B打断了。等到线程B把它的三个步骤执行完毕后，线程A才重新获得执行机会。这时，它并不知道count已经被线程B更新过了，它仍然以为自己在第一步里读取到的那个value_a是正确的，于是线程A就给value_a加1并将结果（也就是result_a）赋给count属性。这实际上把线程B刚刚执行的那一次递增操作覆盖掉了。上面的传感器采样总数之所以出错，也正是这个原因所致。</p><p>除了这个例子，其他形式的数据结构也会遇到类似问题。<strong>为了避免数据争用，Python在内置的threading模块里提供了一套健壮的工具。其中最简单也最有用的是一个叫作Lock的类，它相当于互斥锁（mutex）。</strong></p><p>通过这样的锁，我们可以确保多条线程有秩序地访问Counter类的count属性，使得该属性不会遭到破坏，因为线程必须先获取到这把锁，然后才能操纵count，而每次最多只能有一条线程获得该锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.lock = Lock()</span><br><span class="line">    self.count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.lock:</span><br><span class="line">      self.count += offset</span><br></pre></td></tr></table></figure><p>现在，就可以确保这些工作线程能够正确地递增count属性了。只不过这次的Counter对象要改用刚才写的LockingCounter类来制作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">counter = LockingCounter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  thread Thread(target=worker, args=(i, how_many, counter))</span><br><span class="line">  threads.append(thread)</span><br><span class="line">  thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">  thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>这样的结果才正是我们想要看到的。这说明Lock确实能够解决数据争用问题。</p><h3 id="第55条、用Queue来协调各线程之间的工作进度"><a href="#第55条、用Queue来协调各线程之间的工作进度" class="headerlink" title="第55条、用Queue来协调各线程之间的工作进度"></a>第55条、用Queue来协调各线程之间的工作进度</h3><p>Python程序如果要同时执行多项任务，而这些任务又分别针对同一种产品的不同环节，那么就有可能得在它们之间进行协调。比较有用的一种协调方式是把函数拼接成管道。</p><p>这样的管道与生产线比较像。它可以按先后顺序划分成几个阶段，每个阶段都由相应的函数负责。程序会把未经加工的原料放在生产线（也就是管道）的起点，而那些函数，则分别关注着自己所负责的这一段，只要有产品来到当前环节，它就对这件产品做出相应的加工处理。如果所有函数都不会再收到有待加工的产品，那么整条生产线就可以关停。这套方案，很适合应对与阻塞式I/O或子进程有关的需求，因为我们很容易就能在Python程序里，平行地开启多个线程来分别负责生产线中的某个环节。</p><p>例如，要构建这样一套系统，让它持续从数码相机里获取照片，然后调整照片尺寸，最后把调整好的照片添加到网络相册之中。</p><p>假如这三个环节所对应的download、resize与upload函数，现在都已经写好了，那么应该如何拼接成一条管道呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure><p>首先，必须想办法表示每个环节所要加工的产品，并让加工好的产品能够为下一个环节所获取。这可以用线程安全的生产-消费队列（producer-consumer queue，也叫生产者-消费队列）来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.items = deque()</span><br><span class="line">    self.lock = Lock()</span><br></pre></td></tr></table></figure><p>首先定义put方法，让生产者（也就是数码相机）可以通过这个方法把新图像添加到deque的尾部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> self.lock:</span><br><span class="line">    self.items.append(item)</span><br></pre></td></tr></table></figure><p>然后定义下面这个方法。第一阶段的消费者，也就是需要下载照片的那个函数，可以通过这个方法从deque的前端（即左侧）获取元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> self.lock:</span><br><span class="line">    <span class="keyword">return</span> self.items.popleft()</span><br></pre></td></tr></table></figure><p>我们把管道的每个阶段都表示成一条Python线程，它会从刚才那样的队列中取出有待处理的产品，并交给对应的函数去处理，接着再把处理结果放到下一个队列之中。另外，我们再添加两个字段，分别记录这条线程向上游队列查询产品的次数以及完成加工的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">    super().__init__()</span><br><span class="line">    self.func = func</span><br><span class="line">    self.in_queue = in_queue</span><br><span class="line">    self.out_queue = out_queue</span><br><span class="line">    self.polled_count = <span class="number">0</span></span><br><span class="line">    self.work_done = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面我们试着通过捕捉IndexError来处理这种上游发生延迟的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    self.polled_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      item = self.in_queue.get()</span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">      time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      result = self.func(item)</span><br><span class="line">      self.out_queue.put(result)</span><br><span class="line">      self.work_done += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在，创建四个队列，并在它们之间安排三条工作线程，让每条线程都从上游队列里面获取元素，并把加工过的元素放到下游队列之中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">download_queue = MyQueue()</span><br><span class="line">resize_queue = MyQueue()</span><br><span class="line">upload_queue = MyQueue()</span><br><span class="line">done_queue = MyQueue()</span><br><span class="line">threads = [</span><br><span class="line">  Worker(download, download_queue, resize_queue),</span><br><span class="line">  Worker(resize, resize_queue, upload_queue),</span><br><span class="line">  Worker(upload, upload_queue, done_queue)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这种实现方式的问题远不止这一个，还有另外三个问题也必须重视。第一，为了判断全部产品是否加工完毕，必须像Worker线程里的run方法那样，反复查询最后那个队列，以确认里面的元素个数是否已经变得与刚开始的原料总数相同。第二，目前这种方案会使run方法陷入无限循环，我们没办法明确通知线程何时应该退出。第三，如果下游环节的处理速度过慢，那么程序随时都有可能崩溃，这是最严重的问题。例如，如果第一个环节处理得很快，而第二个环节处理得比较慢，那么连接这两个环节的那个队列就会迅速膨胀，因为它里面堆积了大量的产品等着第二个环节来加工，可是第二个环节又跟不上节奏。时间久了，数据会越积越多，导致程序因为耗尽内存而崩溃。</p><p>总之，这种需求不适合用管道来实现，因为很难构建出良好的生产-消费队列。</p><p>改用Queue来实现：内置的queue模块里有个Queue类</p><p>改用Queue之后，就不用再频繁查询是否有新产品要加工了，因为它的get方法会一直阻塞在那里，直至有新数据返回为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">my_queue = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">  my_queue.get()</span><br><span class="line">  print(<span class="string">'Consumer done'</span>)</span><br><span class="line">  </span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>即便这个线程先启动，也没有关系，因为只有当生产线程通过Queue实例的put方法给队列里面填入新数据之后，刚才那个get方法才有数据可以返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br></pre></td></tr></table></figure><p>为了解决因下游环节速度过慢而造成的管道拥堵问题，我们可以限定Queue最多只能堆积多少个元素。如果通过put方法给已经填满的队列添加新元素，那么这个方法就会阻塞，直到队列里有空位为止。下面我们创建最多只能保存一个元素的队列，并且定义这样一条消费线程，让它先等待一段时间，然后再从队列中获取元素，这样就促使生产线程没办法立刻给队列中添加新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_queue = Queue(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">  time.sleep(<span class="number">0.1</span>)</span><br><span class="line">  my_queue.get()</span><br><span class="line">  print(<span class="string">'Consumer got 1'</span>)</span><br><span class="line">  my_queue.get()</span><br><span class="line">  print(<span class="string">'Consumer got 2'</span>)</span><br><span class="line">  print(<span class="string">'Consumer done'</span>)</span><br><span class="line">  </span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>编写time.sleep(0.1)这条语句，是想故意让消费线程慢下来，以免生产线程在第二次调用put方法时，它第一次放进去的那个元素还没来得及被消费线程提取走。Queue的容量为1，所以生产线程会阻塞在第二个put方法这里，它必须等消费线程通过get方法把队列中的那个元素取走，才能继续往里面添加新元素。</p><p>管道非常适合用来安排多阶段的任务，让我们能够把每一阶段都交给各自的线程去执行，这尤其适合用在I/O密集型的程序里面。</p><p>构造这种并发的管道时，有很多问题需要注意，例如怎样防止线程频繁地查询队列状态，怎样通知线程尽快结束操作，以及怎样防止管道出现拥堵等。</p><p>我们可以利用Queue类所具有的功能来构造健壮的管道系统，因为这个类提供了阻塞式的入队（put）与出队（get）操作，而且可以限定缓冲区的大小，还能够通过task_done与join来确保所有元素都已处理完毕。</p><h3 id="第56条、学会判断什么场合必须做并发"><a href="#第56条、学会判断什么场合必须做并发" class="headerlink" title="第56条、学会判断什么场合必须做并发"></a>第56条、学会判断什么场合必须做并发</h3><p>程序范围变大、需求变复杂之后，经常要用多条路径平行地处理任务。</p><p>fan-out与fan-in是最常见的两种并发协调（concurrency coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。</p><p>Python提供了很多种实现fan-out与fan-in的方案。</p><h3 id="第57条、不要在每次fan-out时都新建一批Thread实例"><a href="#第57条、不要在每次fan-out时都新建一批Thread实例" class="headerlink" title="第57条、不要在每次fan-out时都新建一批Thread实例"></a>第57条、不要在每次fan-out时都新建一批Thread实例</h3><p>想在Python里平行地做I/O，首先要考虑的工具当然是线程。但如果真用线程来表示fan-out模式中的执行路径，你就会发现，这样其实有很多问题。</p><p>每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</p><p>线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</p><h3 id="第58条、学会正确地重构代码，以便用Queue做并发"><a href="#第58条、学会正确地重构代码，以便用Queue做并发" class="headerlink" title="第58条、学会正确地重构代码，以便用Queue做并发"></a>第58条、学会正确地重构代码，以便用Queue做并发</h3><p>每次都手工创建一批线程并平行地执行I/O任务是有很多缺点的。另一种方案，也就是用内置的queue模块里的Queue类实现多线程管道</p><p>这种方案的总思路是：在推进生命游戏时，不像原来那样，每推进一代，就新建一批线程来推进相应的单元格，而是可以提前创建数量固定的一组工作线程，令这组线程平行地处理当前这批I/O任务，并在处理完之后，继续等待下一批任务，这样就不会消耗那么多资源了，程序也不会再因为频繁新建线程而耽误那么多时间。</p><p>把队列（Queue）与一定数量的工作线程搭配起来，可以高效地实现fan-out（分派）与fan-in（归集）。</p><p>为了改用队列方案来处理I/O，我们重构了许多代码，如果管道要分成好几个环节，那么要修改的地方会更多。</p><p>利用队列并行地处理I/O任务，其处理I/O任务量有限，我们可以考虑用Python内置的某些功能与模块打造更好的方案。</p><h3 id="第59条、如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现"><a href="#第59条、如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现" class="headerlink" title="第59条、如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现"></a>第59条、如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</h3><p>Python有个内置模块叫作concurrent.futures，它提供了ThreadPoolExecutor类。这个类结合了线程（Thread）方案与队列（Queue）方案的优势，可以用来平行地处理生命游戏里的那种I/O操作。</p><p>利用ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I/O操作，这种方案省去了每次fan-out（分派）任务时启动线程的那些开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game_logic</span><span class="params">(state, neighbors)</span>:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">raise</span> OSError(<span class="string">'Problem with I/O'</span>)</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> pool:</span><br><span class="line">  task = pool.submit(game_logic, ALIVE, <span class="number">3</span>)</span><br><span class="line">  task.result()</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor方案仍然有个很大的缺点，就是I/O并行能力不高，即便把max_workers设成100，也无法高效地应对那种有一万多个单元格，且每个单元格都要同时做I/O的情况。如果你面对的需求，没办法用异步方案解决，而是必须执行完才能往后走（例如文件I/O），那么ThreadPoolExecutor是个不错的选择。然而在许多情况下，其实还有并行能力更强的办法可以考虑。</p><h3 id="第60条、用协程实现高并发的I-O"><a href="#第60条、用协程实现高并发的I-O" class="headerlink" title="第60条、用协程实现高并发的I/O"></a>第60条、用协程实现高并发的I/O</h3><p>如果同时需要执行的I/O任务有成千上万个，那么之前这些方案的效率就不太理想了。</p><p>像这种在并发方面要求比较高的I/O需求，可以用Python的协程（coroutine）来解决。协程能够制造出一种效果，让我们觉得Python程序好像真的可以同时执行大量任务。这种效果需要使用async与await关键字来实现，它的基本原理与生成器（generator）类似，也就是不立刻给出所有的结果，而是等需要用到的时候再一项一项地获取。</p><p>启动协程是有代价的，就是必须做一次函数调用。协程激活之后，只占用不到1KB内存，所以只要内存足够，协程稍微多一些也没关系。与线程类似，协程所要执行的任务也是用一个函数来表示的，在执行这个函数的过程中，协程可以从执行环境里面获取输入值，并把输出结果放到这个执行环境之中。协程与线程的区别在于，它不会把这个函数从头到尾执行完，而是每遇到一个await表达式，就暂停一次，下次继续执行的时候，它会先等待await所针对的那项awaitable操作有了结果（那项操作是用async函数表示的），然后再推进到下一个await表达式那里（这跟生成器函数的运作方式有点像，那种函数也是一遇到yield就暂停）。</p><p>Python系统可以让数量极多的async函数各自向前推进，看起来像很多条Python线程那样，能够并发地运行。然而，这些协程并不会像线程那样占用大量内存，启动和切换的开销也比较小，而且不需要用复杂的代码来实现加锁或同步。这种强大的机制是通过事件循环（event loop）打造的，只要把相关的函数写对，这种循环就可以穿插着执行许多个这样的函数，并且执行得相当快，从而高效地完成并发式的I/O任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ALIVE = <span class="string">'*'</span></span><br><span class="line">EMPTY = <span class="string">'-'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_neighbors</span><span class="params">(y, x, get)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">game_logic</span><span class="params">(state, neighbors)</span>:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  data = <span class="keyword">await</span> my_socket.read(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>加上async，表示该函数是一个协程，这样我们就可以在函数里面用await做I/O了。</p><p>协程是采用async关键字所定义的函数。如果你想执行这个协程，但并不要求立刻就获得执行结果，而是稍后再来获取，那么可以通过await关键字表达这个意思。协程能够制造出这样一种效果，让人以为程序里有成千上万个函数都在同一时刻高效地运行着。协程可以用fan-out（分派）与fan-in（归集）模式实现并行的I/O操作，而且能够克服用线程做I/O时的缺陷。</p><p>协程的优点是，能够把那些与外部环境交互的代码（例如I/O调用）与那些实现自身需求的代码（例如事件循环）解耦。这让我们可以把重点放在实现需求所用的逻辑上面，而不用专门花时间去写一些代码来确保这些需求能够并发地执行。</p><h3 id="第61条、学会用asyncio改写那些通过线程实现的I-O"><a href="#第61条、学会用asyncio改写那些通过线程实现的I-O" class="headerlink" title="第61条、学会用asyncio改写那些通过线程实现的I/O"></a>第61条、学会用asyncio改写那些通过线程实现的I/O</h3><p>Python已经将异步执行功能很好地集成到语言里面了，所以我们很容易就能把采用线程实现的阻塞式I/O操作转化为采用协程实现的异步I/O操作。</p><p>asyncio库的文档（<a href="https://docs.python.org/3/library/asyncio.html）" target="_blank" rel="noopener">https://docs.python.org/3/library/asyncio.html）</a></p><p>Python提供了异步版本的for循环、with语句、生成器与推导机制，而且还有很多辅助的库函数，让我们能够顺利地迁移到协程方案。我们很容易就能利用内置的asyncio模块来改写代码，让程序不要再通过线程执行阻塞式的I/O，而是改用协程来执行异步I/O。</p><h3 id="第62条、结合线程与协程，将代码顺利迁移到asyncio"><a href="#第62条、结合线程与协程，将代码顺利迁移到asyncio" class="headerlink" title="第62条、结合线程与协程，将代码顺利迁移到asyncio"></a>第62条、结合线程与协程，将代码顺利迁移到asyncio</h3><p>如果项目比较大，那通常需要一点一点地迁移，也就是要边改边测，确保迁移过去的这一部分代码的效果跟原来相同。</p><p>为了能够分步骤地迁移，必须让采用线程做阻塞式I/O的那些代码能够与采用协程做异步I/O的代码相互兼容。具体来说，这要求我们既能够在线程里面执行协程，又能够在协程里面启动线程并等待运行结果。好在asyncio模块已经内置了相关的机制，让线程与协程可以顺利地操作对方。</p><p>asyncio模块的事件循环提供了一个返回awaitable对象的run_in_executor方法，它能够使协程把同步函数放在线程池执行器（ThreadPoolExecutor）里面执行，让我们可以顺利地将采用线程方案所实现的项目，从上至下地迁移到asyncio方案。</p><p>asyncio模块的事件循环还提供了一个可以在同步代码里面调用的run_until_complete方法，用来运行协程并等待其结束。它的功能跟asyncio.run_coroutine_threadsafe类似，只是后者面对的是跨线程的场合，而前者是为同一个线程设计的。这些都有助于将采用线程方案所实现的项目从下至上地迁移到asyncio方案。</p><p>只要输入文件的句柄处于开启状态，相应的工作线程就不会退出。反过来说，这条线程要是退出了，那就意味着有人把那份文件的句柄关了。于是，只需要等待所有的线程都完工，就可以确定这些文件的句柄已经全部关闭。</p><p>我们在判断是否需要移植时，应该考虑到，这样做会不会让代码变得难懂，会不会降低程序的效率。有的时候，所有代码都应该迁移到asyncio，但另一些场合则没必要这么做。</p><p>上面讲的是从上往下迁移，我们现在反过来，看看如何从下往上迁移。这也可以分成四步，但方向相反。原来是从顶层函数入手，沿着调用栈向下走，现在是从末端函数（也就是叶节点）入手，沿着调用栈向上走，一直走到整个调用体系的顶层，也就是入口点所在的那一层。具体步骤为：</p><ul><li>1）为要移植的每个末端函数（leaf function）都创建一个对应的异步协程版本。</li><li>2）修改现有的同步版本函数，把它原来执行的那些实际操作全都拿掉，让它只通过事件循环去调用刚写的那个异步版本函数。</li><li>3）沿着调用栈向上移动一层，针对这一层里的相关函数制作对应的异步版本，并让那些异步版本函数去调用第1步里创建的相应协程。</li><li>4）把第2步里纯粹为了封装协程而设的同步版本删掉，因为上一层现在调用的是下一层里的异步版本函数，这些同步版本现在已经用不到了。</li></ul><h3 id="第63条、让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力"><a href="#第63条、让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力" class="headerlink" title="第63条、让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力"></a>第63条、让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力</h3><p>把系统调用（包括阻塞式的I/O以及启动线程等操作）放在协程里面执行，会降低程序的响应能力，增加延迟感。</p><p>调用asyncio.run函数时，把debug参数设为True，可以帮助我们发现这种问题。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">slow_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">  time.sleep(<span class="number">0.5</span>)</span><br><span class="line">  </span><br><span class="line">asyncio.run(slow_coroutine(), debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="第64条、考虑用concurrent-futures实现真正的并行计算"><a href="#第64条、考虑用concurrent-futures实现真正的并行计算" class="headerlink" title="第64条、考虑用concurrent.futures实现真正的并行计算"></a>第64条、考虑用concurrent.futures实现真正的并行计算</h3><p>有些Python程序写到一定阶段，性能就再也上不去了。即便优化了代码，程序的执行速度可能还是达不到要求。考虑到现在的计算机所装配的CPU核心数量越来越多，所以我们很自然地就想到用并行方式来解决这个问题。那么接下来就必须思考，如何将代码所要执行的计算任务划分成多个独立的部分并在各自的核心上面平行地运行。</p><p>Python的全局解释器锁（global interpreter lock，GIL）导致我们没办法用线程来实现真正的并行，所以先把这种方案排除掉。另一种常见的方案，是把那些对性能要求比较高的（performance-critical）代码用C语言重写成扩展模块。C语言比Python更接近底层硬件，因此运行速度要比Python快，这样的话，有些任务可能根本就不需要做并行，而是单单用C语言重写一遍就好。另外，C扩展还可以启动原生线程（native thread），这种线程不受Python解释器制约，也不必考虑GIL的问题，它们能够平行地运行，从而发挥出多核CPU的优势。Python里面针对C扩展而设计的那些API，有详细的文档可以参考，所以这是个很好的备选方案。大家在开发扩展模块的时候，还可以借助SWIG（<a href="https://github.com/swig/swig）与CLIF（https://github.com/google/clif）等工具。" target="_blank" rel="noopener">https://github.com/swig/swig）与CLIF（https://github.com/google/clif）等工具。</a></p><p>然而，用C语言重写Python代码，代价是比较高的。因为有些代码在Python之中很简洁，但是改写成C代码之后，就变得特别难懂、特别复杂了。在移植过程中，我们还必须做大量的测试，以确保移植过去的那些代码跟原来的Python代码效果相同，并且不会引入bug。有的时候，这些工作确实很有意义，所以Python行业里面出现了大量的C扩展模块，用来迅速执行各种任务，例如文本解析、图像合成、矩阵运算等。另外还有Cython（<a href="https://cython.org/）与Numba（https://numba.pydata.org/）这样的开源工具帮我们顺利地向C语言移植。" target="_blank" rel="noopener">https://cython.org/）与Numba（https://numba.pydata.org/）这样的开源工具帮我们顺利地向C语言移植。</a></p><p>问题是，在大多数情况下，我们不能只把整个程序里的一小段代码移植到C语言，因为程序的性能之所以缓慢，通常是由多个因素造成的，而不是说只要消除了其中某一个主要因素，整个程序的性能就会大幅提升。要想把C语言在底层硬件与线程方面的优势发挥出来，必须把程序里的许多代码都迁移过去，这会让测试量激增，而且容易引入新的bug。所以，还是得想想有没有什么好办法，能够在Python语言自身的范围内，解决这种复杂的并行计算问题。</p><p>Python内置的multiprocessing模块提供了多进程机制，这种机制很容易通过内置的concurrent.futures模块来使用，这可能就是我们要找的理想方案（相关范例参见第59条）。这种方案可以启动许多条子进程（child process），这些进程是独立于主解释器的，它们有各自的解释器与相应的全局解释器锁，因此这些子进程可以平行地运行在CPU的各个核心上面。每条子进程都能够充分利用它所在的这个核心来执行运算。这些子进程都有指向主进程的链接，用来接收所要执行的计算任务并返回结果。</p><p>如计算最大公约数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(pair)</span>:</span></span><br><span class="line">  a, b = pair</span><br><span class="line">  low = min(a, b)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> a % <span class="number">1</span> == <span class="number">0</span> <span class="keyword">and</span> b % i == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">'Not reachable'</span></span><br></pre></td></tr></table></figure><p>如果把有待求解最大公约数的那些元组按照先后顺序交给这个函数去执行，那么程序花费的总时间就会随着元组的数量呈正比例上升，因为我们根本就没有做平行计算。</p><p>直接把这种代码分给多条Python线程去执行，是不会让程序提速的，因为它们全都受制于同一个Python全局解释器锁（GIL），无法真正平行地运行在各自的CPU核心上面。</p><p>使用concurrent.futures模块里面的ThreadPoolExecutor类，并允许它最多可以启用两条工作线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUMBERS = [</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  start = time.time()</span><br><span class="line">  pool = ThreadPoolExecutor(max_workers = <span class="number">2</span>)</span><br><span class="line">  results = list(pool.map(my_module.gcd, NUMBERs))</span><br><span class="line">  end = time.time()</span><br><span class="line">  delta = end - start</span><br><span class="line">  print(<span class="string">f'Took <span class="subst">&#123;delta:<span class="number">.3</span>f&#125;</span> seconds'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>由于要启动线程池并和它通信，这种写法比单线程版本还慢。</p><p>但是请注意，只需要变动一行代码就能让程序出现奇效，也就是把ThreadPoolExecutor改成concurrent.futures模块里的ProcessPoolExecutor。这样一改，程序立刻就快了起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUMBERS = [</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  start = time.time()</span><br><span class="line">  pool = ThreadPoolExecutor(max_workers = <span class="number">2</span>)</span><br><span class="line">  results = list(pool.map(my_module.gcd, NUMBERs))</span><br><span class="line">  end = time.time()</span><br><span class="line">  delta = end - start</span><br><span class="line">  print(<span class="string">f'Took <span class="subst">&#123;delta:<span class="number">.3</span>f&#125;</span> seconds'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>这是为什么呢？因为ProcessPool-Executor类会执行下面这一系列的步骤（当然，这实际上是由multiprocessing模块里的底层机制所推动的）。</p><ul><li>1）从包含输入数据的NUMBERS列表里把每个元素取出来，以便交给map。</li><li>2）用pickle模块对每个元素做序列化处理，把它转成二进制形式（参见第68条）。</li><li>3）将序列化之后的数据，从主解释器所在的进程经由本地socket复制到子解释器所在的进程。</li><li>4）在子进程里面，用pickle模块对数据做反序列化处理，把它还原成Python对象。</li><li>5）引入包含gcd函数的那个Python模块。</li><li>6）把刚才还原出来的那个对象交给gcd函数去处理，此时，其他子进程也可以把它们各自的那份数据交给它们各自的gcd函数执行。</li><li>7）对执行结果做序列化处理，把它转化成二进制形式。</li><li>8）将二进制数据通过socket复制到上级进程。</li><li>9）在上级进程里面对二进制数据做反序列化处理，把它还原成Python对象。</li><li>10）把每条子进程所给出的结果都还原好，最后合并到一个list里面返回。</li></ul><p>从开发者这边来看，这个过程似乎很简单，但实际上，multiprocessing模块与Proce-ssPoolExecutor类要做大量的工作才能实现出这样的并行效果。同样的效果，假如改用其他语言来做，那基本上只需要用一把锁或一项原子操作就能很好地协调多个线程，从而实现并行。但这在Python里面不行，所以我们才考虑通过ProcessPoolExecutor来实现。然而这样做的开销很大，因为它必须在上级进程与子进程之间做全套的序列化与反序列化处理。</p><p>这个方案对那种孤立的而且数据利用度较高的任务来说，比较合适。所谓孤立（isolated），这里指每一部分任务都不需要跟程序里的其他部分共用状态信息。所谓数据利用度较高（high-leverage），这里指任务所使用的原始材料以及最终所给出的结果数据量都很小，因此上级进程与子进程之间只需要互传很少的信息就行，然而在把原始材料加工成最终产品的过程中，却需要做大量运算。刚才那个求最大公约数的任务就属于这样的例子，当然还有很多涉及其他数学算法的任务，也是如此。</p><p>如果你面对的计算任务不具备刚才那两项特征，那么使用ProcessPoolExecutor所引发的开销可能就会盖过因为并行而带来的好处。在这种情况下，我们可以考虑直接使用multiprocessing所提供的一些其他高级功能，例如共享内存（shared memory）、跨进程的锁（cross-process lock）、队列（queue）以及代理（proxy）等。但是，这些功能都相当复杂，即便两个Python线程之间所要共享的进程只有一条，也是要花很大工夫才能在内存空间里面将这些工具安排到位。假如需要共享的进程有很多条，而且还涉及socket，那么这种代码理解起来会更加困难。</p><p>只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。不要刚一上来，就立刻使用跟multiprocessing这个内置模块有关的机制，而是可以先试着用ThreadPoolExecutor来运行这种孤立且数据利用度较高的任务。把这套方案实现出来之后，再考虑向ProcessPoolExecutor方案迁移。如果ProcessPoolExecutor方案也无法满足要求，而且其他办法也全都试遍了，那么最后可以考虑直接使用multiprocessing模块里的高级功能来编写代码。</p><hr><h2 id="8-稳定与性能"><a href="#8-稳定与性能" class="headerlink" title="8.稳定与性能"></a>8.稳定与性能</h2><p>写了一个有用的Python程序之后，接下来就该考虑怎样让代码变得健壮（robust）起来，只有这样，才能将这个程序变为正式的产品（productionize）。把程序的功能写对，当然是很重要的，然而我们还得考虑怎样让程序在面对意外情况时，依然能够可靠地运作。Python有很多内置的特性与模块，可以帮我们加固程序代码，让它应付各种各样的状况。</p><p>说到健壮，其中一项指标在于能不能高效地应对大规模的数据。我们经常发现自己写的Python程序在处理少量数据时没有问题，但数据量一多，速度就下降，这可能是因为自己的算法过于复杂，或者计算的时候还有其他一些开销。不过没关系，Python提供了很多算法和数据结构，可以让我们轻松地写出高性能的程序。</p><h3 id="第65条、合理利用try-except-else-finally结构中的每个代码块"><a href="#第65条、合理利用try-except-else-finally结构中的每个代码块" class="headerlink" title="第65条、合理利用try/except/else/finally结构中的每个代码块"></a>第65条、合理利用try/except/else/finally结构中的每个代码块</h3><p>在Python代码中处理异常，需要考虑四个情况，这正好对应try/except/else/finally这个结构中的四个代码块。这种复合语句的每块代码都有各自的用途，你可以全写，也可以只写其中几个</p><h4 id="try-finally形式"><a href="#try-finally形式" class="headerlink" title="try/finally形式"></a>try/finally形式</h4><p>如果我们想确保，无论某段代码有没有出现异常，与它配套的清理代码都必须得到执行，同时还想在出现异常的时候，把这个异常向上传播，那么可以将这两段代码分别放在try/finally结构的两个代码块里面。最常见的例子是确保文件句柄能够关闭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_finally_example</span><span class="params">(filename)</span>:</span></span><br><span class="line">  print(<span class="string">'* Opening file'</span>)</span><br><span class="line">  handle = open(filename, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'* Reading data'</span>)</span><br><span class="line">    <span class="keyword">return</span> handle.read()</span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'* Calling close()'</span>)</span><br><span class="line">    handle.close()</span><br></pre></td></tr></table></figure><p>如果read方法抛出异常，那么这个异常肯定会向上传播给调用try_finally_example函数的那段代码，然而在传播之前，系统会记得运行finally块中的代码，使文件句柄（handle）能够关闭（close）。</p><h4 id="try-except-else形式"><a href="#try-except-else形式" class="headerlink" title="try/except/else形式"></a>try/except/else形式</h4><p>如果你想在某段代码发生特定类型的异常时，把这种异常向上传播，同时又要在代码没有发生异常的情况下，执行另一段代码，那么可以使用try/except/else结构表达这个意思。如果try块代码没有发生异常，那么else块就会运行。try里面应该尽量少写一些代码，这样阅读起来比较清晰，而且即便出现异常，我们也能很快找到它是由哪一行代码引发的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_json_key</span><span class="params">(data, key)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'* Loading JSON data'</span>)</span><br><span class="line">    result_dict = json.loads(data)</span><br><span class="line">  <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'* Handling ValueError'</span>)</span><br><span class="line">    <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> e</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'* Looking up key'</span>)</span><br><span class="line">    <span class="keyword">return</span> result_dict[key]</span><br></pre></td></tr></table></figure><h4 id="完整的try-except-else-finally形式"><a href="#完整的try-except-else-finally形式" class="headerlink" title="完整的try/except/else/finally形式"></a>完整的try/except/else/finally形式</h4><p>如果这四个代码块的功能全都要用到，那么可以编写完整的try/except/else/finally结构。</p><h3 id="第66条、考虑用contextlib和with语句来改写可复用的try-finally代码"><a href="#第66条、考虑用contextlib和with语句来改写可复用的try-finally代码" class="headerlink" title="第66条、考虑用contextlib和with语句来改写可复用的try/finally代码"></a>第66条、考虑用contextlib和with语句来改写可复用的try/finally代码</h3><p>Python里的with语句可以用来强调某段代码需要在特殊情境之中执行。例如，如果必须先持有互斥锁，然后才能运行某段代码，那么就可以用with语句来表达这个意思（此时，所谓在特殊情境之中执行，指的就是在持有互斥锁的情况下执行）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure><p>这样写，其实跟相应的try/finally结构是一个意思，这是因为Lock类做了专门的设计，它结合with结构使用，表达的也是这个意思。</p><p>跟try/finally结构相比，with语句的好处在于，写起来比较方便，我们不用在每次执行这段代码前，都通过lock.acquire()加锁，而且也不用总是提醒自己要在finally块里通过lock.release()解锁。</p><p>如果想让其他的对象跟函数，也能像Lock这样用在with语句里面，那么可以通过内置的contextlib模块来实现。这个模块提供了contextmanager修饰器，它可以使没有经过特别处理的普通函数也能受到with语句支持。这要比标准做法简单得多，因为那种做法必须定义新类并实现名为<strong>enter</strong>与<strong>exit</strong>的特殊方法。</p><p>例如，有些情况下，我们想在执行某个函数的时候，看到更为详细的调试信息。下面这个函数会打印出两种级别的日志信息，一种是DEBUG级别，一种是ERROR级别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">()</span>:</span></span><br><span class="line">  logging.debug(<span class="string">'Some debug data'</span>)</span><br><span class="line">  logging.error(<span class="string">'Error log here'</span>)</span><br><span class="line">  logging.debug(<span class="string">'More debug data'</span>)</span><br></pre></td></tr></table></figure><p>这个程序默认的日志级别（log level）是WARNING，所以，它只会把级别大于或等于WARNING的消息打印到屏幕上。DEBUG的级别低于WARNING，因此这种级别的消息是看不到的。</p><p>要想临时改变日志级别，可以定义情境管理器（context manager）。用@contextmanager来修饰下面这个辅助函数，就能定义出这样一种管理器。这种管理器可以用在with语句里面，让日志记录器（Logger）在进入这个范围之后，临时改变自己的日志级别，这样的话，原来那些低级别的消息，现在就可以显示出来了，待with语句块执行完毕后，再恢复原有日志级别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">  logger = logging.getLogger()</span><br><span class="line">  old_level = logger.getEffectiveLevel()</span><br><span class="line">  logger.setLevel(level)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    logger.setLevel(old_level)</span><br></pre></td></tr></table></figure><p>系统开始执行with语句时，会先把@contextmanager所修饰的debug_logging辅助函数推进到yield表达式所在的地方，然后开始执行with结构的主体部分。如果执行with语句块（也就是主体部分）的过程中发生异常，那么这个异常会重新抛出到yield表达式所在的那一行里，从而为辅助函数中的try结构所捕获。</p><p>Python内置的contextlib模块提供了contextmanager修饰器，让我们可以很方便地修饰某个函数，从而制作出相对应的情境管理器，使得这个函数能够运用在with语句里面。情境管理器通过yield语句所产生的值，可以由with语句之中位于as右侧的那个变量所接收，这样的话，我们就可以通过该变量与当前情境相交互了。</p><h4 id="带目标的with语句"><a href="#带目标的with语句" class="headerlink" title="带目标的with语句"></a>带目标的with语句</h4><p>with语句还有一种写法，叫作<code>with...as...</code>，它可以把情境管理器所返回的对象赋给as右侧的局部变量，这样的话，with结构的主体部分代码就可以通过这个局部变量与情境管理器所针的那套情境交互了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'my_output.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">  handle.write(<span class="string">'This is some data'</span>)</span><br></pre></td></tr></table></figure><p>与手动打开并关闭文件句柄的写法相比，这种写法更符合Python的风格。这样写，可以保证程序在离开with结构的时候总是会把文件关掉，而且这种结构可以提醒我们把主体部分代码写得简短一些，也就是在打开文件句柄之后，尽快把自己要执行的操作给做完，这是个值得提倡的做法。</p><h3 id="第67条、用datetime模块处理本地时间，不要用time模块"><a href="#第67条、用datetime模块处理本地时间，不要用time模块" class="headerlink" title="第67条、用datetime模块处理本地时间，不要用time模块"></a>第67条、用datetime模块处理本地时间，不要用time模块</h3><p>协调世界时（Coordinated Universal Time，UTC）是标准的时间表示方法，它不依赖特定时区。有些计算机采用与UNIX时间原点（UNIX epoch）之间的秒数来表达时间，在这种场合，UTC用起来是很方便的，然而对于人类来说，UTC却不太直观，因为我们平常所说的时间，总是默认针对自己所在的地方而言的。例如我们习惯说“早上8点”，而不习惯说“比UTC的15点整早7个小时”。所以，在涉及时间的程序里，我们很有可能要在UTC与当地时区之间互相转换，这样才能给出用户容易理解的格式。</p><p>Python里面有两种办法可以转换时区，一种是老办法，也就是通过内置的time模块来做，这种办法很容易出错。还有一种是新办法，也就是通过内置的datetime模块来做，这种办法可以跟第三方的Python开发者所构造的pytz软件包搭配起来，形成很好的转换效果。</p><h4 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h4><p>内置time模块的localtime函数可以把UNIX时间戳（UNIX timestamp）转换为与宿主计算机的时区相符的本地时间（UNIX时间戳是个UTC时间，表示某时刻与UNIX时间原点之间的秒数；笔者这台计算机使用的时区为太平洋夏令时（Pacific Daylight Time，PDT），它比UTC慢7个小时）。转换之后的本地时间，可以用strftime函数调整成用户习惯的格式。</p><p>许多操作系统会通过相关的配置文件自动反映时区方面的变化，在这样的操作系统上，time模块是可以支持某些时区的。但另外一些操作系统（例如Windows）则不行，所以在那些操作系统上，不要想着用time去做转换。</p><p>time模块本质上仍然要依赖具体的平台而运作。它的行为取决于底层的C函数与宿主操作系统之间的协作方式，这导致该模块的功能在Python里面显得不太可靠。time模块没办法稳定地处理多个时区，所以不要用这个模块来编写这方面的代码。假如一定要用，那最多也就是在UTC时间和宿主计算机的当地时区之间用它来转换，涉及其他时区的转换操作，最好还是通过datetime模块来做。</p><h4 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h4><p>跟time模块一样，它也能把UTC时间转换成本地时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone</span><br><span class="line"></span><br><span class="line">now = datetime(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">33</span>)</span><br><span class="line">now_utc = now.replace(tzinfo=timezone.utc)</span><br><span class="line">now_loca = now_utc.astimezone()</span><br><span class="line">print(now_local)</span><br></pre></td></tr></table></figure><p>反过来也很容易。我们同样可以用datetime模块把本地时间转换成UTC格式的UNIX时间戳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time_str = <span class="string">'2024-05-25 12:11:33'</span></span><br><span class="line">now = datetime.strptime(time_str, time_format)</span><br><span class="line">time_tuple = now.timetuple()</span><br><span class="line">utc_now = time.mktime(time_tuple)</span><br><span class="line">print(utc_now)</span><br></pre></td></tr></table></figure><p>跟time模块不同，datetime模块里面有相应的机制，可以把一个时区的本地时间可靠地转化成另一个时区的本地时间。但问题是，datetime的这套时区操纵机制必须通过tzinfo类与相关的方法来运作，而系统在安装Python的时候，并不会默认安装UTC之外的时区定义信息。</p><p>好在其他Python开发者提供了pytz模块，能够把这些缺失的时区定义信息给补上，这个模块可以从Python Package Index下载。pytz包含一整套数据库，你可能会用到的每个时区它应该都有。</p><p>为了顺利使用pytz模块，应该先把本地时间转换成UTC时间，然后在这样的时间值上通过datetime所提供的各种方法执行自己想要的操作（例如通过下面提到的astimezone方法来调整时区属性），最后把操作好的时间转回当地时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">arrival_nyc = <span class="string">'2024-05-25 12:11:33'</span></span><br><span class="line">nyc_dt_naive = datetime.strptime(arrival_nyc, time_format)</span><br><span class="line">eastern = pytz.timezone(<span class="string">'US/Eastern'</span>)</span><br><span class="line">nyc_dt = eastern.localize(nyc_dt_naive)</span><br><span class="line">utc_dt = pytz.utc.normalize(nyc_dt.astimezone(pytz.utc))</span><br></pre></td></tr></table></figure><p>把datetime与pytz搭配起来使用，可以确保程序在各种环境下，都能够给出一致的转换结果，而不依赖于具体的操作系统与宿主计算机。</p><h3 id="第68条、用copyreg实现可靠的pickle操作"><a href="#第68条、用copyreg实现可靠的pickle操作" class="headerlink" title="第68条、用copyreg实现可靠的pickle操作"></a>第68条、用copyreg实现可靠的pickle操作</h3><p>Python内置的pickle模块可以将对象序列化成字节流，也可以把字节流反序列化（还原）成对象。经过pickle处理的字节流，只应该在彼此信任的双方之间传输，而不应该随意传给别人，或者随意接受别人发来的这种数据，因为pickle的本意只是提供一种数据传输手段，让你在自己可以控制的程序之间传递二进制形式的Python对象。</p><blockquote><p>pickle模块所使用的这种序列化格式本身就没有考虑过安全问题。这种格式会把原有的Python对象记录下来，让系统可以在稍后予以重建。这意味着，假如记录的这个对象本身含有恶意行为，那么通过反序列化还原出来之后，就有可能破坏整个程序。</p></blockquote><p>跟pickle不同，json模块考虑到了安全问题。序列化之后的JSON数据表示的只不过是一套对象体系而已，把这样的数据反序列化不会给程序带来风险。如果要在彼此不信任的两个人或两个程序之间传递数据，那么应该使用JSON这样的格式。</p><p>pickle模块主要用途仅仅是让我们能够把对象轻松地序列化成二进制数据。如果想直接使用这个模块来实现比这更为复杂的需求，那么可能就会看到奇怪的结果。解决这样的问题，也非常简单，即可以用内置的copyreg模块解决。这个模块允许我们向系统注册相关的函数，把Python对象的序列化与反序列化操作交给那些函数去处理，这样的话，pickle模块就运作得更加稳定了。</p><h3 id="第69条、在需要准确计算的场合，用decimal表示相应的数值"><a href="#第69条、在需要准确计算的场合，用decimal表示相应的数值" class="headerlink" title="第69条、在需要准确计算的场合，用decimal表示相应的数值"></a>第69条、在需要准确计算的场合，用decimal表示相应的数值</h3><p>Python语言很擅长操纵各种数值。它的整数类型实际上可以表示任意尺寸的整型数据，它的双精度浮点数类型遵循IEEE 754规范。另外，Python还提供了标准的复数类型，用来表示虚数。尽管有这么多类型，但还是没办法把每种情况都覆盖到。</p><p>例如，我们要给国际长途电话计费。通话时间用分和秒来表示，这项数据是已知的（例如3分42秒）。通话费率也是固定的，例如从美国打给南极洲的电话，每分钟1.45美元。现在要计算这次通话的具体费用。有人可能觉得应该用浮点数来计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rate = <span class="number">1.45</span></span><br><span class="line">seconds = <span class="number">3</span>*<span class="number">60</span> + <span class="number">42</span></span><br><span class="line">cost = rate * seconds/ <span class="number">60</span>  <span class="comment"># 5.364999...</span></span><br></pre></td></tr></table></figure><p>这个答案比正确答案（5.365）少了0.000000000000001，这是因为浮点数必须表示成IEEE 754格式，所以采用浮点数算出的结果可能跟实际结果稍有偏差。</p><p>这样的计算应该用Python内置的decimal模块所提供的Decimal类来做。这个类默认支持28位小数，如果有必要，还可以调得更高。改用这个类之后，就不会出现由于IEEE 754浮点数而造成的偏差了。另外，这种数值所支持的舍入方式，也比浮点数丰富可控。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">rate = Decimal(<span class="string">'1.45'</span>)</span><br><span class="line">seconds = Decimal(<span class="number">3</span>*<span class="number">60</span> + <span class="number">42</span>)</span><br><span class="line">cost = rate * seconds / Decimal(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>Decimal的初始值可以用两种办法来指定。第一种，是把含有数值的str字符串传给Decimal的构造函数，这样做不会让字符串里面的数值由于Python本身的浮点数机制而出现偏差。第二种，是直接把float或int实例传给构造函数。通过下面这段代码，我们可以看到，这两种办法在某些小数上会产生不同的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Decimal(<span class="string">'1.45'</span>)  <span class="comment"># 1.45</span></span><br><span class="line">Decimal(<span class="number">1.45</span>) <span class="comment"># 1.449999999...</span></span><br></pre></td></tr></table></figure><p>所以，如果你想要的是准确答案，那么应该使用str字符串来构造Decimal，这种decimal的精确度可能比你需要的更高，但无论如何，都比刚一开始就出现偏差要好。</p><p>Decimal类提供了quantize函数，可以根据指定的舍入方式把数值调整到某一位。</p><h3 id="第70条、先分析性能，然后再优化"><a href="#第70条、先分析性能，然后再优化" class="headerlink" title="第70条、先分析性能，然后再优化"></a>第70条、先分析性能，然后再优化</h3><p>Python的动态机制，让我们很难预判程序在运行时的性能。有些操作，看上去似乎比较慢，但实际执行起来却很快（例如操纵字符串，使用生成器等）；还有一些操作，看上去似乎比较快，但实际执行起来却很慢（例如访问属性，调用函数等）。让Python程序速度变慢的原因，有时很难观察出来。</p><p>所以，最好不要凭感觉去判断，而是应该先获得具体的测评数据，然后再决定怎么优化。Python内置了profiler模块，可以找到程序里面占总执行时间比例最高的一部分，这样的话，我们就可以专心优化这部分代码，而不用执着于对程序性能影响不大的那些地方（因为你把同样的精力投入到那些地方，产生的提速效果不会太好）。</p><p>Python内置了两种profiler，一种是由profile模块提供的纯Python版本，还有一种是由cProfile模块提供的C扩展版本。这个版本比纯Python版要好，因为它在执行测评的过程中，对受测程序的影响比较小，测评结果更加准确。相反，纯Python版本的开销比较大，会令测评结果有所偏差。</p><blockquote><p>分析Python程序的性能之前，一定要提醒自己注意，别把访问外部系统的那些代码，与核心代码混在一起测。例如，访问网络或磁盘资源的那些函数就有可能需要调用某些底层机制，而那些机制的运作速度比较慢，从而对程序的执行时间造成很大影响。另外，如果程序把这些访问速度较慢的资源缓存了起来，那么在开始分析性能之前，一定要先将缓存预热（也就是要把里面的内容提前配置好）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cProfile <span class="keyword">import</span> Profile</span><br><span class="line"></span><br><span class="line">profiler = Profile()</span><br><span class="line">profiler.runcall(test)</span><br></pre></td></tr></table></figure><p>运行完test函数后，用内置的pstats模块与里面的Stats类来统计结果。Stats对象提供了各种方法，通过这些方法我们可以只把自己关注的那部分测评信息打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pstats <span class="keyword">import</span> Stats</span><br><span class="line"></span><br><span class="line">stats = Stats(profiler)</span><br><span class="line">stats.strip_dirs()</span><br><span class="line">stats.sort_stats(<span class="string">'cumulative'</span>)</span><br><span class="line">stats.print_stats()</span><br></pre></td></tr></table></figure><p>print_stats方法输出了一张表格，其中每一行都表示一个函数的执行情况。这些样本，都是在profiler激活之后才开始采集的，或者说是在执行profiler.runcall(test)的过程中采集的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ncalls：函数在测评期间的调用次数。</span><br><span class="line">tottime：程序执行这个函数本身所花时间（不包括该函数调用其他函数所花时间）。</span><br><span class="line">tottime percall：程序每次执行这个函数所花的平均时间（不统计该函数调用其他函数所花时间）。这相当于tottime除以ncalls。</span><br><span class="line">cumtime：程序执行这个函数以及它所调用的其他函数所花时间。</span><br><span class="line">cumtime percall：程序每次执行这个函数以及它所调用的其他函数平均花费时间。这相当于cumtime除以ncalls。</span><br></pre></td></tr></table></figure><p>profiler的print_callers方法来打印统计结果，它可以显示出程序里面有哪几个函数调用了我们关心的这个函数。</p><p>可以通过Stats对象筛选出我们关心的那些分析结果，从而更为专注地思考如何优化程序性能。</p><h3 id="第71条、优先考虑用deque实现生产者-消费者队列"><a href="#第71条、优先考虑用deque实现生产者-消费者队列" class="headerlink" title="第71条、优先考虑用deque实现生产者-消费者队列"></a>第71条、优先考虑用deque实现生产者-消费者队列</h3><p>写程序的时候，经常要用到先进先出的（first-in, first-out，FIFO）队列，这种队列也叫作生产者-消费者队列（producer–consumer queue）或生产-消费队列。FIFO队列可以把某个函数给出的值收集起来，并交给另一个函数按序处理。一般来说，开发者会用Python内置的list类型来实现FIFO队列。</p><p>用list来实现这种生产-消费队列，在一定程度上是没问题的，但是当基数（cardinality，也就是列表中的元素数量）变多之后，list的性能就会下降，并且不是等比例地下降，而是更为严重。为了对采用列表所实现的FIFO队列做性能分析，我们通过内置的timeit模块执行一些micro-benchmark。这种micro-benchmark放在相应的benchmark函数里面执行，比如这里定义的list_append_benchmark函数测评的就是用list的append方法给队列中添加新元素时的性能（这正是刚才的生产函数所用的做法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">timeit.repeat(...)</span><br></pre></td></tr></table></figure><p>list类型可以用来实现FIFO队列，生产者可以通过append方法向队列添加元素。但这种方案有个问题，就是消费者在用pop(0)从队列中获取元素时，所花的时间会随着队列长度，呈平方式增长。</p><p>跟list不同，内置collections模块之中的deque类，无论是通过append添加元素，还是通过popleft获取元素，所花的时间都只跟队列长度呈线性关系，而非平方关系，这使得它非常适合于FIFT队列。</p><h3 id="第72条、考虑用bisect搜索已排序的序列"><a href="#第72条、考虑用bisect搜索已排序的序列" class="headerlink" title="第72条、考虑用bisect搜索已排序的序列"></a>第72条、考虑用bisect搜索已排序的序列</h3><p>我们经常要将大量数据载入内存，并把它们放到一份有序的列表之中以便搜索。例如，可能要把一本英语辞典加载进来以实现拼写检查，或者把一套财务交易数据加载进来以便审计。</p><p>不管程序要处理的是什么数据，在列表（list）里面通过index方法搜索某个值，所花的时间都跟列表长度成正比（或者说，随着列表长度呈线性增长）。</p><p>如果你不能确定这个值是否在列表里面，那么你要查的就应该是：列表中恰好等于目标值，或比目标值大但最接近目标值的那个元素所在的位置。要想找到这个位置，最简单的办法是对列表做线性扫描，把其中的元素逐个与目标值比较。</p><p>Python内置的bisect模块可以更好地搜索有序列表。其中的bisect_left函数，能够迅速地对任何一个有序的序列执行二分搜索。如果序列中有这个值，那么它返回的就是跟这个值相等的头一个元素所在的位置；如果没有，那么它返回的是插入位置，也就是说，把待查的值插到这个位置可以让序列继续保持有序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"></span><br><span class="line">index = bisect_left(data, <span class="number">91234</span>)</span><br><span class="line"><span class="keyword">assert</span> index == <span class="number">91234</span></span><br><span class="line">index = bisect_left(data, <span class="number">91234.56</span>)</span><br><span class="line"><span class="keyword">assert</span> index == <span class="number">91235</span></span><br></pre></td></tr></table></figure><p>bisect模块的二分搜索算法，在复杂度上面是对数级别的。这意味着，线性搜索算法（list.index方法）在包含20个元素的列表中查询目标值所花的时间，已经够这个算法搜索长度为一百万个元素的列表了（math.log2(10**6)大约是19.93）。它要比线性搜索快得多！</p><p>bisect最好的地方，是它不局限于list类型，而是可以用在任何一种行为类似序列的对象上面。bisect模块还提供了其他一些功能，可以实现更为高级的用法（在Python解释器界面输入help(bisect)，查看详细文档）。</p><h3 id="第73条、学会使用heapq制作优先级队列"><a href="#第73条、学会使用heapq制作优先级队列" class="headerlink" title="第73条、学会使用heapq制作优先级队列"></a>第73条、学会使用heapq制作优先级队列</h3><p>有的时候，我们想根据元素的重要程度来排序。在这种情况下，应该使用优先级队列（priority queue）。</p><p>模块名称里面的heap指的是堆，这是一种数据结构，可以维护列表中的元素，并且只需要对数级别的时间就可以添加新元素或移除其中最小的元素（这种算法的复杂程度，要低于线性算法，所以效率比线性算法高）。在这个图书馆程序里面，所谓最小的元素是指逾期时间最长的（或者说，应还日期距离现在最远的）那次出借记录。这个模块最好的地方，就是我们不用了解相关的算法如何实现，只需要调用它就行。</p><p>优先级队列让我们能够按照重要程度来处理元素，而不是必须按照先进先出的顺序处理。</p><p>如果直接用相关的列表操作来模拟优先级队列，那么程序的性能会随着队列长度的增大而大幅下降，因为这样做的复杂程度是平方级别，而不是线性级别。</p><p>通过Python内置的heapq模块所提供的函数，我们完全可以实现基于堆的优先级队列，从而高效地处理大量数据。</p><p>要使用heapq模块，我们必须让元素所在的类型支持自然排序，这可以通过对类套用<a href="mailto:`@functools.tota" target="_blank" rel="noopener">`@functools.tota</a>l_ordering`修饰器并定义<strong>lt</strong>方法来实现。</p><h3 id="第74条、考虑用memoryview与bytearray来实现无须拷贝的bytes操作"><a href="#第74条、考虑用memoryview与bytearray来实现无须拷贝的bytes操作" class="headerlink" title="第74条、考虑用memoryview与bytearray来实现无须拷贝的bytes操作"></a>第74条、考虑用memoryview与bytearray来实现无须拷贝的bytes操作</h3><p>针对CPU密集型的计算任务，要想用Python程序平行地处理，可能得多花一点功夫，但针对I/O密集型的任务，却很容易就能用各种方式写出吞吐量较大（也就是处理能力较强）的平行代码（参见第53条与第60条）。然而，由于这种代码写起来很简单，特别容易遭到误用，让人以为Python好像慢得连I/O密集型任务都处理不好。</p><p>Python内置的memoryview类型提供了一套无须执行拷贝的（也就是零拷贝的）操作接口，让我们可以对支持缓冲协议的Python对象制作切片，并通过这种切片高速地完成读取与写入。</p><p>Python内置的bytearray类型是一种与bytes相似但内容能够改变的类型，我们可以通过socket.recv_from这样的函数，以无需拷贝的方式（也就是零拷贝的方式）读取数据。我们可以用memoryview来封装bytearray，从而用收到的数据覆盖底层缓冲里面的任意区段，同时又无需执行拷贝操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-52-～-74-条（并发、稳定性）读书笔记&quot;&gt;&lt;a href=&quot;#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》—
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="http://blog.michealwayne.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 31 ～ 51 条读书笔记</title>
    <link href="http://blog.michealwayne.cn/2024/04/14/python/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E4%BB%A3%E7%A0%81%E7%9A%8490%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B-31%E8%87%B351/"/>
    <id>http://blog.michealwayne.cn/2024/04/14/python/【笔记】《编写高质量Python代码的90个有效方法》-31至51/</id>
    <published>2024-04-14T03:39:54.000Z</published>
    <updated>2024-04-16T10:54:01.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-31-～-51-条（函数、类）读书笔记"><a href="#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-31-～-51-条（函数、类）读书笔记" class="headerlink" title="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 31 ～ 51 条（函数、类）读书笔记"></a>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 31 ～ 51 条（函数、类）读书笔记</h1><p>（书基于 Python 3.7+ 语法规范）</p><p>知识点概括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iter函数</span><br><span class="line">生成器表达式、yield相关语法</span><br><span class="line">itertools模块</span><br><span class="line">闭包</span><br><span class="line">__call__</span><br><span class="line">@classmethod</span><br><span class="line">MRO</span><br><span class="line">mix-in类</span><br><span class="line">public/private属性</span><br><span class="line">@property</span><br><span class="line">类装饰器</span><br></pre></td></tr></table></figure><h3 id="第31条、谨慎地迭代函数所收到的参数"><a href="#第31条、谨慎地迭代函数所收到的参数" class="headerlink" title="第31条、谨慎地迭代函数所收到的参数"></a>第31条、谨慎地迭代函数所收到的参数</h3><p>函数和方法如果要把收到的参数遍历很多遍，那就必须特别小心。因为如果这些参数为迭代器，那么程序可能得不到预期的值，从而出现奇怪的效果。</p><p>为了应对大规模的数据，其中一个变通方案是让normalize函数接受另外一个函数（也就是下面的get_iter），使它每次要使用迭代器时，都去向那个函数索要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_func</span><span class="params">(get_iter)</span>:</span></span><br><span class="line">  total = sum(get_iter())</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> get_iter():</span><br><span class="line">    percent = <span class="number">100</span> * value / total</span><br><span class="line">    result.append(percent)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">normalize_func(<span class="keyword">lambda</span>: read_visits(path))</span><br></pre></td></tr></table></figure><p>使用normalize_func函数时，需要传入一条lambda表达式，让这个表达式去调用read_visits生成器函数。这样normalize_func每次向get_iter索要迭代器时，程序都会给出一个新的迭代器。</p><p>这样做虽然可行，但传入这么一个lambda表达式显得有点儿生硬。要想用更好的办法解决这个问题，可以新建一种容器类，让它实现迭代器协议（iterator protocol）。</p><p><strong>Python的for循环及相关的表达式，正是按照迭代器协议来遍历容器内容的。</strong>Python执行for x in foo这样的语句时，实际上会调用iter(foo)，也就是把foo传给内置的iter函数。这个函数会触发名为foo.<strong>iter</strong>的特殊方法，该方法必须返回迭代器对象（这个迭代器对象本身要实现<strong>next</strong>特殊方法）。最后，Python会用迭代器对象反复调用内置的next函数，直到数据耗尽为止（如果抛出StopIteration异常，就表示数据已经迭代完了）。</p><p>下面定义这样一种可迭代的容器类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadVisits</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_path)</span>:</span></span><br><span class="line">    self.data_path = data_path</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(self.data_path) <span class="keyword">as</span> f:</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">yield</span> int(line)</span><br><span class="line">        </span><br><span class="line">visits = ReadVisits(path)</span><br><span class="line">percentages = normalize(visits)</span><br></pre></td></tr></table></figure><p>我们只需要把新的容器传给最早的那个normalize函数运行即可，函数本身的代码不需要修改。</p><p>这样做为什么可行呢？因为normalize函数里面的sum会触发ReadVisits.<strong>iter</strong>，让系统分配一个新的迭代器对象给它。接下来，normalize通过for循环计算每项数据占总值的百分比时，又会触发<strong>iter</strong>，于是系统会分配另一个迭代器对象。这些迭代器各自推进，其中一个迭代器把数据耗尽，并不会影响其他迭代器。所以，在每一个迭代器上面遍历，都可以分别看到一套完整的数据。这种方案的唯一缺点，就是多次读取输入数据。</p><h3 id="第32条、考虑用生成器表达式改写数据量较大的列表推导"><a href="#第32条、考虑用生成器表达式改写数据量较大的列表推导" class="headerlink" title="第32条、考虑用生成器表达式改写数据量较大的列表推导"></a>第32条、考虑用生成器表达式改写数据量较大的列表推导</h3><p>列表推导可以根据输入序列中的每个元素创建一个包含派生元素的新列表。如果输入的数据量比较小，那么这样做没问题，但如果数据量很大，那么程序就有可能因为内存耗尽而崩溃。</p><p>要想处理大规模的数据，可以使用<strong>生成器表达式（generator expression）</strong>来做，它扩展了列表推导式与生成器机制。程序在对生成器表达式求值时，并不会让它把包含输出结果的那个序列立刻构建出来，而是会把它当成一个迭代器，该迭代器每次可以根据表达式中的逻辑给出一项结果。</p><p>生成器表达式的写法，与列表推导式语法类似，但它是写在一对圆括号内，而不是方括号里面。下面这种写法的效果与刚才一样，但是程序并不会立刻给出全部结果，而是先将生成器表达式表示成一个迭代器返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(<span class="string">'my_file.txt'</span>))</span><br><span class="line"></span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br></pre></td></tr></table></figure><p>返回的迭代器每次可以推进一步，这时它会根据生成表达式的逻辑计算出下一项输出结果（这项结果可以通过内置的next函数取得）。需要多少项结果，就把迭代器推进多少次，这种采用生成器表达式来实现的写法不会消耗太多内存。</p><p>生成器表达式还有个强大的特性，就是可以组合起来。例如，可以用刚才那条生成器表达式所形成的it迭代器作为输入，编写一条新的生成器表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roots = ((x, x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br></pre></td></tr></table></figure><p>这条表达式所形成的roots迭代器每次推进时，会引发连锁反应：它也推进内部迭代器it以判断当前是否还能在it上面继续迭代，如果可以，就把it所返回的值代入(x, x**0.5)里面求出结果。这种写法使用的内存同样不会太多。</p><p>多个生成器嵌套而成的代码，执行起来还是相当快的。所以，如果要对数据量很大的输入流做一系列处理，那么生成器表达式应该是个很好的选择。唯一需要注意的是，生成器表达式返回的迭代器是有状态的，跑完一整轮之后，就不能继续使用了。</p><h3 id="第33条、通过yield-from把多个生成器连起来用"><a href="#第33条、通过yield-from把多个生成器连起来用" class="headerlink" title="第33条、通过yield from把多个生成器连起来用"></a>第33条、通过yield from把多个生成器连起来用</h3><p>这种形式，会先从嵌套进去的小生成器里面取值，如果该生成器已经用完，那么程序的控制流程就会回到yield from所在的这个函数之中，然后它有可能进入下一套yield from逻辑。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate_composed</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> pause(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">run(animate_composed)</span><br></pre></td></tr></table></figure><p>Python解释器看到yield from形式的表达式后，会自己想办法实现与带有普通yield语句的for循环相同的效果，而且这种实现方式要更快。</p><p>yield from的性能要胜过那种在for循环里手工编写yield表达式的方案。</p><h3 id="第34条、不要用send给生成器注入数据"><a href="#第34条、不要用send给生成器注入数据" class="headerlink" title="第34条、不要用send给生成器注入数据"></a>第34条、不要用send给生成器注入数据</h3><p>yield表达式通道是单向的，也就是说，无法让生成器在其一端接收数据流，同时在另一端给出计算结果。假如能实现双向通信，那么生成器的适用面会更广。</p><p>Python的生成器支持send方法，这可以让生成器变为双向通道。send方法可以把参数发给生成器，让它成为上一条yield表达式的求值结果，并将生成器推进到下一条yield表达式，然后把yield右边的值返回给send方法的调用者。然而在一般情况下，我们还是会通过内置的next函数来推进生成器，按照这种写法，上一条yield表达式的求值结果总是None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">  received = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  print(<span class="string">f'received = <span class="subst">&#123;received&#125;</span>'</span>)</span><br><span class="line"> </span><br><span class="line">it = iter(my_generator())</span><br><span class="line">output = next(it)</span><br><span class="line">print(<span class="string">f'output = <span class="subst">&#123;output&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  next(it)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果不通过for循环或内置的next函数推进生成器，而是改用send方法，那么调用方法时传入的参数就会成为上一条yield表达式的值，生成器拿到这个值后，会继续运行到下一条yield表达式那里。可是，刚开始推进生成器的时候，它是从头执行的，而不是从某一条yield表达式那里继续的，所以，首次调用send方法时，只能传None，要是传入其他值，程序运行时就会抛出异常。</p><p>最简单的一种写法，是把迭代器传给wave函数，让wave每次用到振幅的时候，通过Python内置的next函数推进这个迭代器并返回一个输入振幅。于是，这就促使多个生成器之间，产生连环反应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wave_cascading</span><span class="params">(amplitude_it, steps)</span>:</span></span><br><span class="line">  step_size = <span class="number">2</span> * math.pi / steps</span><br><span class="line">  <span class="keyword">for</span> steps <span class="keyword">in</span> range(steps):</span><br><span class="line">    radians = step * step_size</span><br><span class="line">    fraction = math.sin(radians)</span><br><span class="line">    amplitude = next(amplitude_it)</span><br><span class="line">    output = amlitude * fraction</span><br><span class="line">    <span class="keyword">yield</span> output</span><br></pre></td></tr></table></figure><p>这样，只需要把同一个迭代器分别传给这几条yield from语句里的wave_cascading就行。</p><p>这种写法最大的优点在于，迭代器可以来自任何地方，而且完全可以是动态的（例如可以用生成器函数来实现迭代器）。此方案只有一个缺陷，就是必须假设负责输入的生成器绝对能保证线程安全，但有时其实保证不了这一点。如果代码要跨越线程边界，那么用async函数实现可能更好。</p><p>通过迭代器向组合起来的生成器输入数据，要比采用send方法的那种方案好，所以尽量避免使用send方法。</p><h3 id="第35条、不要通过throw变换生成器的状态"><a href="#第35条、不要通过throw变换生成器的状态" class="headerlink" title="第35条、不要通过throw变换生成器的状态"></a>第35条、不要通过throw变换生成器的状态</h3><p>生成器还有一项高级功能，就是可以把调用者通过throw方法传来的Exception实例重新抛出。这个throw方法用起来很简单：如果调用了这个方法，那么生成器下次推进时，就不会像平常那样，直接走到下一条yield表达式那里，而是会把通过throw方法传入的异常重新抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">it = my_generator()</span><br><span class="line">next(it);</span><br><span class="line">it.throw(MyError(<span class="string">'test Error'</span>))</span><br></pre></td></tr></table></figure><p>生成器函数可以用标准的try/except复合语句把yield表达式包裹起来，如果函数上次执行到了这条表达式这里，而这次即将继续执行时，又发现外界通过throw方法给自己注入了异常，那么这个异常就会被try结构捕获下来，如果捕获之后不继续抛异常，那么生成器函数会推进到下一条yield表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">except</span> MyError:</span><br><span class="line">    print(<span class="string">'Got MyError!'</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这项机制会在生成器与调用者之间形成双向通信通道，这项机制会在生成器与调用者之间形成双向通信通道，这在某些情况下是有用的。例如，要编写一个偶尔可以重置的计时器程序。如定义下面的Reset异常与timer生成器方法，让调用者可以在timer给出的迭代器上通过throw方法注入Reset异常，令计时器重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reset</span><span class="params">(Exception)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(period)</span>:</span></span><br><span class="line">  current = period</span><br><span class="line">  <span class="keyword">while</span> current:</span><br><span class="line">    current -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">yield</span> current</span><br><span class="line">    <span class="keyword">except</span> Reset:</span><br><span class="line">      current = period</span><br></pre></td></tr></table></figure><p>按照这种写法，如果timer正准备从yield表达式往下推进时，发现有人注入了Reset异常，那么它就会把这个异常捕获下来，并进入except分支，在这里它会把表示倒计时的current变量重新调整成最初的period值。</p><p>这个计时器可以与外界某个按秒轮询的输入机制对接起来。为此，定义一个run函数以驱动timer生成器所给出的那个it迭代器，并根据外界的情况做处理，如果外界要求重置，那就通过it迭代器的throw方法给计时器注入Reset变量，如果外界没有这样要求，那就调用announce函数打印生成器所给的倒计时值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_for_reset</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># Poll for external event</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">announce</span><span class="params">(remaining)</span>:</span></span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;remaining&#125;</span> ticks remaining'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  it = timer(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">if</span> check_for_reset():</span><br><span class="line">        current = it.throw(Reset())</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        current = next(it)</span><br><span class="line">     <span class="keyword">except</span> StopIteration:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">      announce(current)</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>这样写没错，但是有点儿难懂，因为用了许多层嵌套结构。</p><p>有个简单的办法，能够改写这段代码，那就是用可迭代的容器对象定义一个有状态的闭包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, period)</span>:</span></span><br><span class="line">    self.current = period</span><br><span class="line">    self.period = period</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.current = self.period</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current:</span><br><span class="line">      self.current -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">yield</span> self.current</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  timer = Timer(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">for</span> current <span class="keyword">in</span> timer:</span><br><span class="line">    <span class="keyword">if</span> check_for_reset():</span><br><span class="line">      timer.reset()</span><br><span class="line">    announce(current)</span><br><span class="line">    </span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>这样写所输出的结果与前面一样，但是这种实现方案理解起来要容易得多</p><p>凡是想用生成器与异常来实现的功能，通常都可以改用异步机制去做。</p><p>如果确实遇到了这里讲到的这种需求，那么应该通过可迭代的类来实现生成器，而不要用throw方法注入异常。</p><h3 id="第36条、考虑用itertools拼装迭代器与生成器"><a href="#第36条、考虑用itertools拼装迭代器与生成器" class="headerlink" title="第36条、考虑用itertools拼装迭代器与生成器"></a>第36条、考虑用itertools拼装迭代器与生成器</h3><p>Python内置的itertools模块里有很多函数，可以用来安排迭代器之间的交互关系。</p><p>如果要实现比较难写的迭代逻辑，那么应该先查看itertools的文档（在Python解释器界面输入<code>help(itertools)</code>）。</p><h4 id="连接多个迭代器"><a href="#连接多个迭代器" class="headerlink" title="连接多个迭代器"></a>连接多个迭代器</h4><p>内置的itertools模块有一些函数可以把多个迭代器连成一个使用。</p><ul><li><code>chain</code>可以把多个迭代器从头到尾连成一个迭代器。</li><li><code>repeat</code>可以制作这样一个迭代器，它会不停地输出某个值。调用repeat时，也可以通过第二个参数指定迭代器最多能输出几次。</li><li><code>cycle</code>可以制作这样一个迭代器，它会循环地输出某段内容之中的各项元素</li><li><code>tee</code>可以让一个迭代器分裂成多个平行的迭代器，具体个数由第二个参数指定。如果这些迭代器推进的速度不一致，那么程序可能要用大量内存做缓冲，以存放进度落后的迭代器将来会用到的元素。</li><li><code>zip_longest</code>与Python内置的zip函数类似，但区别在于，如果源迭代器的长度不同，那么它会用fillvalue参数的值来填补提前耗尽的那些迭代器所留下的空缺。</li></ul><h4 id="过滤源迭代器中的元素"><a href="#过滤源迭代器中的元素" class="headerlink" title="过滤源迭代器中的元素"></a>过滤源迭代器中的元素</h4><p>Python内置的itertools模块里有一些函数可以过滤源迭代器中的元素。</p><ul><li><code>islice</code>可以在不拷贝数据的前提下，按照下标切割源迭代器。可以只给出切割的终点，也可以同时给出起点与终点，还可以指定步进值。</li><li><code>takewhile</code>会一直从源迭代器里获取元素，直到某元素让测试函数返回False为止。</li><li><code>dropwhile</code>与<code>takewhile</code>相反，dropwhile会一直跳过源序列里的元素，直到某元素让测试函数返回True为止，然后它会从这个地方开始逐个取值。</li><li><code>filterfalse</code>和内置的filter函数相反，它会逐个输出源迭代器里使得测试函数返回False的那些元素。</li></ul><h4 id="用源迭代器中的元素合成新元素"><a href="#用源迭代器中的元素合成新元素" class="headerlink" title="用源迭代器中的元素合成新元素"></a>用源迭代器中的元素合成新元素</h4><p>Python内置的itertools模块里，有一些函数可以根据源迭代器中的元素合成新的元素。</p><ul><li><code>accumulate</code>会从源迭代器里取出一个元素，并把已经累计的结果与这个元素一起传给表示累加逻辑的函数，然后输出那个函数的计算结果，并把结果当成新的累计值。</li><li><code>product</code>会从一个或多个源迭代器里获取元素，并计算笛卡尔积（Cartesian product），它可以取代那种多层嵌套的列表推导代码</li><li><code>permutations</code>会考虑源迭代器所能给出的全部元素，并逐个输出由其中N个元素形成的每种有序排列（permutation）方式，元素相同但顺序不同，算作两种排列。</li><li><code>combinations</code>会考虑源迭代器所能给出的全部元素，并逐个输出由其中N个元素形成的每种无序组合（combination）方式，元素相同但顺序不同，算作同一种组合。</li><li><code>combinations_with_replacement</code>与<code>combinations</code>类似，但它允许同一个元素在组合里多次出现。</li></ul><hr><h2 id="5-类与接口"><a href="#5-类与接口" class="headerlink" title="5.类与接口"></a>5.类与接口</h2><h3 id="第37条、用组合起来的类来实现多层结构，不要用嵌套的内置类型"><a href="#第37条、用组合起来的类来实现多层结构，不要用嵌套的内置类型" class="headerlink" title="第37条、用组合起来的类来实现多层结构，不要用嵌套的内置类型"></a>第37条、用组合起来的类来实现多层结构，不要用嵌套的内置类型</h3><p>Python内置的字典类型，很适合维护对象在生命期内的动态内部状态。所谓动态的（dynamic），是指我们无法获知那套状态会用到哪些标识符。</p><p>例如，如果要用成绩册（Gradebook）记录学生的分数，而我们又没办法提前确定这些学生的名字，那么受到记录的每位学生与各自的分数，对于Gradebook对象来说，就属于动态的内部状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleGradebook</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._grades = &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self._grades[name] = []</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">report_grade</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">    self._grades[name].append(score)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    grades = self._grades[name]</span><br><span class="line">    <span class="keyword">return</span> sum(grades) / len(grades)</span><br></pre></td></tr></table></figure><p>字典与相关的内置类型用起来很方便，但同时也容易遭到滥用导致代码出问题。例如，我们现在要扩展这个SimpleGradebook类的功能，让它按照科目保存成绩，而不是把所有科目的成绩存在一起。通过修改_grades字典的用法，使它必须把键（也就是学生的名字）与另一个小字典相对应，而不是像刚才那样，直接与列表对应起来。那份小字典以各科的名称作键与一份列表对应起来，以保存学生在这一科的全部考试成绩。这次笔者用defaultdict来实现这个小字典，这样可以方便地处理科目名称还不存在的那些情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BySubjectGradebook</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._grades = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self._grades[name] = defaultdict(list)</span><br></pre></td></tr></table></figure><p>如果遇到的是类似这种比较复杂的需求，那么不要再嵌套字典、元组、集合、列表等内置的类型了，而是应该编写一批新类并让这些类形成一套体系。</p><h4 id="把多层嵌套的内置类型重构为类体系"><a href="#把多层嵌套的内置类型重构为类体系" class="headerlink" title="把多层嵌套的内置类型重构为类体系"></a>把多层嵌套的内置类型重构为类体系</h4><blockquote><p>namedtuple的局限：namedtuple类无法指定默认的参数值[1]。如果数据的可选属性比较多，那么采用这种类来表示，会很不方便。在属性较多的情况下，应该改用内置的dataclasses模块实现。namedtuple实例的属性值仍然可以通过数字下标与迭代来访问，所以可能还是会有人（尤其是那些通过你发布的API来编程的人）会采用这种方式访问这些属性，这样的话，将来就不太容易把它转成普通的类了。如果无法完全控制这些namedtuple实例的用法，那么最好还是明确定义一个新的类。</p></blockquote><p>有了叫作Grade的具名元组，我们就可以写出表示科目的Subject类，让它容纳许多个这样的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._grades = []</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">report_grade</span><span class="params">(self, score, weight)</span>:</span></span><br><span class="line">    self._grades.append(Grade(score, weight))</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">    total, total_weight = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> grade <span class="keyword">in</span> self._grades:</span><br><span class="line">      total += grade.score * grade.weight</span><br><span class="line">      total_weight += grade.weight</span><br><span class="line">    <span class="keyword">return</span> total / total_weight</span><br></pre></td></tr></table></figure><p>然后，就可以写一个表示学生的Student类，用它来记录某位学生各科目（Subject）的考试成绩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._subjects = defaultdict(Subject)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_subject</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._subjects[name]</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">    total, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> self._subjects.values():</span><br><span class="line">      total += subject.average_grade()</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total / count</span><br></pre></td></tr></table></figure><p>最后，写这样一个表示成绩册的Gradebook容器类，把每位学生的名字与表示这位学生的Student对象关联起来，如果成绩册里还没有记录过这位学生，那么在调用get_student方法时，Gradebook就会构造一个默认的Student对象给调用者使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gradebook</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._students = defaultdict(Student)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._students[name]</span><br></pre></td></tr></table></figure><p>虽然比原来那种写法长了一倍，但理解起来却要容易得多。而且用这些类写出来的调用代码，也比原来更清晰、更便于扩展。</p><p>不要在字典里嵌套字典、长元组，以及用其他内置类型构造的复杂结构。</p><h3 id="第38条、让简单的接口接受函数，而不是类的实例"><a href="#第38条、让简单的接口接受函数，而不是类的实例" class="headerlink" title="第38条、让简单的接口接受函数，而不是类的实例"></a>第38条、让简单的接口接受函数，而不是类的实例</h3><p>Python有许多内置的API，都允许我们传入某个函数来定制它的行为。这种函数可以叫作挂钩（hook），API在执行过程中，会回调（call back）这些挂钩函数。</p><p>例如，list类型的sort方法就带有可选的key参数，如果明确指定了这个参数，那么它就会按照你提供的挂钩函数来决定列表中每个元素的先后顺序。下面的代码把内置的len函数当成挂钩传给key参数，让sort方法根据长度排列这些名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Scorates'</span>, <span class="string">'Archimedes'</span>, <span class="string">'Plato'</span>, <span class="string">'Aristotle'</span>]</span><br><span class="line">names.sort(key=len)</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><p>在其他编程语言中，挂钩可能会用抽象类（abstract class）来定义。但在Python中，许多挂钩都是无状态的函数（stateless function），带有明确的参数与返回值。挂钩用函数来描述，要比定义成类更简单。用作挂钩的函数与别的函数一样，都是Python里的头等（first-class）对象，也就是说，这些函数与方法可以像Python中其他值那样传递与引用。</p><p>例如，我们要定制defaultdict类的行为。这种defaultdict数据结构允许调用者提供一个函数，用来在键名缺失的情况下，创建与这个键相对应的值。只要字典发现调用者想要访问的键不存在，就会触发这个函数，以返回应该与键相关联的默认值。下面定义一个log_missing函数作为键名缺失时的挂钩，该函数总是会把这种键的默认值设为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_missing</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'Key added'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面这段代码通过定制的defaultdict字典，把increments列表里面描述的增量添加到current这个普通字典所提供的初始量上面，但字典里一开始没有’red’和’orange’这两个键，因此log_missing这个挂钩函数会触发两次，每次它都会打印’Key added’信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">current = &#123;<span class="string">'green'</span>: <span class="number">12</span>, <span class="string">'blue'</span>: <span class="number">3</span>&#125;</span><br><span class="line">increments = [</span><br><span class="line">  (<span class="string">'red'</span>, <span class="number">5</span>),</span><br><span class="line">  (<span class="string">'blue'</span>, <span class="number">17</span>),</span><br><span class="line">  (<span class="string">'orange'</span>, <span class="number">9</span>)</span><br><span class="line">]</span><br><span class="line">result = defaultdict(log_missing, current)</span><br><span class="line">print(<span class="string">'Before:'</span>, dict(result))</span><br><span class="line"><span class="keyword">for</span> key, amount <span class="keyword">in</span> increments:</span><br><span class="line">  result[key] += amount</span><br><span class="line">print(<span class="string">'After: '</span>, dict(result))</span><br></pre></td></tr></table></figure><p>通过log_missing这样的挂钩函数，我们很容易构建出便于测试的API，这种API可以把挂钩所实现的附加效果（side effect）与数据本身所应具备的确定行为分开。</p><p>例如，假设我们要在传给defaultdict的挂钩里面，统计它总共遇到了多少次键名缺失的情况。要实现这项功能，其中一个办法是采用有状态的闭包（stateful closure，参见第21条）。下面就定义一个辅助函数，把missing闭包当作挂钩传给defaultdict字典，以便为缺失的键提供默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_with_report</span><span class="params">(current, increment)</span>:</span></span><br><span class="line">  added_count = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">missing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> added_count <span class="comment"># Stateful closure</span></span><br><span class="line">    added_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  result = defaultdict(missing, current)</span><br><span class="line">  <span class="keyword">for</span> key, amount <span class="keyword">in</span> increments:</span><br><span class="line">    result[key] += amount</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> result, added_count</span><br></pre></td></tr></table></figure><p>统计键名缺失次数所用的added_count状态是由missing挂钩维护的，采用挂钩来运作的defaultdict字典并不需要关注这个细节。于是，这就体现了把简单函数传给接口的另一个好处，也就是方便稍后添加新的功能，因为我们可以把实现这项功能所用的状态隐藏在这个简单的闭包里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result, count = increment_with_report(current, increments)</span><br><span class="line"><span class="keyword">assert</span> count == <span class="number">2</span></span><br></pre></td></tr></table></figure><p>与无状态的闭包函数相比，用有状态的闭包作为挂钩写出来的代码会难懂一些。为了让代码更清晰，可以专门定义一个小类，把原本由闭包所维护的状态给封装起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountMissing</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.added = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">missing</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.added += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在其他编程语言中，可能需要修改defaultdict以便与CountMissing接口相适应。但在Python中，方法与函数都是头等的（first-class）对象，因此可以直接通过对象引用它所属的CountMissing类里的missing方法，并把这个方法传给defaultdict充当挂钩，让字典可以用这个挂钩制作默认值。</p><p>在Python中，这种通过对象实例而引用的方法，很容易就能满足函数的接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">counter = ConutMissing()</span><br><span class="line">result = defaultdict(counter.missing, current)</span><br><span class="line"><span class="keyword">for</span> key, amount <span class="keyword">in</span> increments:</span><br><span class="line">  result[key] += amount</span><br><span class="line"><span class="keyword">assert</span> counter.added == <span class="number">2</span></span><br></pre></td></tr></table></figure><p>把有状态的闭包所具备的行为，改用辅助类来实现，要比前面的increment_with_report函数更清晰。但如果单看这个类，可能没办法立刻了解它的意图。</p><p>为了让这个类的意义更加明确，可以给它定义名为<code>__call__</code>的特殊方法。这会让这个类的对象能够像函数那样得到调用。同时，也让内置的callable函数能够针对这种实例返回True值，用以表示这个实例与普通的函数或方法类似，都是可调用的。<strong>凡是能够像这样（在后面加一对括号来）执行的对象，都叫作callable。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterCountMissing</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.added = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.added += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = BetterCountMissing()</span><br><span class="line"><span class="keyword">assert</span> counter() == <span class="number">0</span></span><br><span class="line"><span class="keyword">assert</span> callable(counter)</span><br></pre></td></tr></table></figure><p>下面，就用这样的BetterCountMissing实例给defaultdict当挂钩，让它在字典里没有键名时，创建默认的键值，并把这种情况记入键名缺失的总次数里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">counter = BetterCountMissing()</span><br><span class="line">result = defaultdict(counter, current)</span><br><span class="line"><span class="keyword">for</span> key, amount <span class="keyword">in</span> increments:</span><br><span class="line">  result[key] += amount</span><br><span class="line"><span class="keyword">assert</span> counter.added == <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面这段代码要比CountMissing更清晰，因为它里面有<code>__call__</code>方法，这说明这个类的实例可像普通的函数那样使用（例如可以传给API当挂钩）。即便是初次看到这段代码，也能明白这个类的主要目标。因为你应该会注意到那个比较显眼的<code>__call__</code>方法。它强烈暗示着这个类可以像有状态的闭包那样使用。</p><p>总之，最大的优势在于，defaultdict仍然不需要关注<code>__call__</code>方法触发之后究竟会做什么。它只知道自己可以用这样一个挂钩，来给缺失的键制作默认值。Python很容易就能设计这种把挂钩函数当参数来用的接口，面对这种接口，调用者可以采用最适合自己的，把符合接口要求的东西传进去。</p><h3 id="第39条、通过-classmethod多态来构造同一体系中的各类对象"><a href="#第39条、通过-classmethod多态来构造同一体系中的各类对象" class="headerlink" title="第39条、通过@classmethod多态来构造同一体系中的各类对象"></a>第39条、通过@classmethod多态来构造同一体系中的各类对象</h3><p>在Python中，不仅对象支持多态，类也支持多态。</p><p>多态机制使同一体系中的多个类可以按照各自独有的方式来实现同一个方法，这意味着这些类都可以满足同一套接口，或者都可以当作某个抽象类来使用，同时，它们又能在这个前提下，实现各自的功能。</p><p>例如，要实现一套MapReduce（映射-归纳/映射-化简）流程，并且以一个通用的类来表示输入数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputData</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>然后，编写一个具体的InputData子类，例如，可以从磁盘文件中读取数据的PathInputData类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathInputData</span><span class="params">(InputData)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">    super().__init__()</span><br><span class="line">    self.path = path</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(self.path) <span class="keyword">as</span> f:</span><br><span class="line">      <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure><p>通用的InputData类以后可能会有很多个像PathInputData这样的子类，每个子类都会实现标准的read接口，并按照各自的方式把需要处理的数据读取进来。例如，有的InputData子类可从网上读取数据，有的InputData可读取压缩格式的数据并将其解压成普通数据，等等。</p><p>除了输入数据要通用，我们还想让处理MapReduce任务的工作节点（Worker）也能有一套通用的抽象接口，这样不同的Worker就可以通过这套标准的接口来消耗输入数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_data)</span>:</span></span><br><span class="line">    self.input_data = input_data</span><br><span class="line">    self.result = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>定义一种具体的Worker子类，使它按照特定的方式实现MapReduce。也就是统计每份数据里的换行符个数，然后把所有的统计值汇总起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineCountWorker</span><span class="params">(Worker)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(self)</span>:</span></span><br><span class="line">    data = self.input_data.read()</span><br><span class="line">    self.result = data.count(<span class="string">'\n'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    self.result += other.result</span><br></pre></td></tr></table></figure><p>这样实现似乎不错，但接下来会碰到一个大难题，也就是如何把这些组件拼接起来。输入数据与工作节点都有各自的类体系，而且这两套体系也抽象出了合理的接口，然而，它们都必须落实到具体的对象上面，只有构造出了具体对象，才能写出有用的程序。</p><p>在其他编程语言中，可以利用<strong>构造函数多态（constructor polymorphism）</strong>来解决，也就是子类不仅要具备与超类一致的构造函数，而且还必须各自提供一个特殊的构造函数以实现和自身有关的构造逻辑。这样，刚才那些辅助方法在编排MapReduce流程时，就可以按照超类的形式统一地构造这些对象，并使其根据所属的子类分别去触发相关的特殊构造函数（类似工厂模式）。但是我们在Python里不能这样做，因为Python的类只能有一个构造方法（即<code>__init__</code>方法），没办法要求所有的InputData子类都采用同一种写法来定义<code>__init__</code>（因为它们必须用各自不同的数据来完成构造）。</p><p>我们现在运用方法多态来实现MapReduce流程所用到的这些类。首先改写InputData类，把generate_inputs方法放到该类里面并声明成通用的<code>@classmethod</code>，这样它的所有子类都可以通过同一个接口来新建具体的InputData实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericInputData</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span><span class="params">(cls, config)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>新的generate_inputs方法带有一个叫作config的字典参数，调用者可以把一系列配置信息放到字典里中，让具体的GenericInputData子类去解读。例如PathInputData这个子类就会通过’data_dir’键从字典里寻找含有输入文件的那个目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathInputData</span><span class="params">(GenericInputData)</span>:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span><span class="params">(cls, config)</span>:</span></span><br><span class="line">    data_dir = config[<span class="string">'data_dir'</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(data_dir):</span><br><span class="line">      <span class="keyword">yield</span> cls(os.path.join(data_dir, name))</span><br></pre></td></tr></table></figure><p>然后，可以用类似的思路改写前面的Worker类。把名叫create_workers的辅助方法移到这个类里面并且也声明成<code>@classmethod</code>。新方法的input_class参数将会是GenericInputData的某个子类，我们要通过这个参数触发那个子类的generate_inputs方法，以创建出Worker所需的输入信息。有了输入信息之后，通过cls(input_data)这个通用的形式来调用构造函数，这样创建的实例，其类型是cls所表示的具体GenericWorker子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericWorker</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_data)</span>:</span></span><br><span class="line">    self.input_data = input_data</span><br><span class="line">    self.result = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_workers</span><span class="params">(cls, input_class, config)</span>:</span></span><br><span class="line">    workers = []</span><br><span class="line">    <span class="keyword">for</span> input_data <span class="keyword">in</span> input_class.generate_inputs(config):</span><br><span class="line">      workers.append(cls(input_data))</span><br><span class="line">    <span class="keyword">return</span> workers</span><br></pre></td></tr></table></figure><p>上面的代码创建输入信息时，用的是input_class.generate_inputs这样的写法，这么写正是为了触发类多态机制，以便将generate_inputs派发到input_class所表示的那个实际子类上面。另外还要注意，在构造GenericWorker的子类对象时，用的是cls(…)这样的通用写法，而没有直接调用<code>__init__</code>方法。</p><p>接下来要修改具体的Worker类，这其实很简单，只需要把超类的名称改为GenericWorker就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineCountWorker</span><span class="params">(GerericWorker)</span>:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>最后，重新编写mapreduce函数，让它通过worker_class.create_workers来创建工作节点，这样它就变得通用了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapreduce</span><span class="params">(worker_class, input_class, config)</span>:</span></span><br><span class="line">  workers = worker_class.create_workers(input_class, config)</span><br><span class="line">  <span class="keyword">return</span> execute(workers)</span><br></pre></td></tr></table></figure><p>把原来那套实现方案所处理的随机文件，再采用这套新的工作节点来处理，可以产生相同的结果。区别只在于，这次调用mapreduce时，必须多传几个参数，因为它现在是个通用的函数，必须把实际的输入数据与实际的工作节点告诉它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config = &#123;<span class="string">'data_dir'</span>: tmpdir&#125;</span><br><span class="line">result = mapreduce(LineCountWorker, PathInputData, config)</span><br></pre></td></tr></table></figure><p>这套方案让我们能够随意编写其他的GenericInputData与GenericWorker子类，而不用再花时间去调整它们之间的拼接代码（glue code）。</p><h3 id="第40条、通过super初始化超类"><a href="#第40条、通过super初始化超类" class="headerlink" title="第40条、通过super初始化超类"></a>第40条、通过super初始化超类</h3><p>以前有种简单的写法，能在子类里面执行超类的初始化逻辑，那就是直接在超类名称上调用<code>__init__</code>方法并把子类实例传进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    MyBaseClass.__init__(self, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这个办法能够应对比较简单的类体系，但是在其他的情况下容易出现问题。</p><p>假如某个类继承了多个超类，那么直接调用超类的<code>__init__</code>方法会让代码产生误会。</p><p>直接调用<code>__init__</code>方法所产生的第一个问题在于，超类的构造逻辑不一定会按照它们在子类class语句中的声明顺序执行。例如，在MyBaseClass之外再定义两个类，让它们也分别去操纵本实例的value字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesTwo</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.value *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusFive</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.value += <span class="number">5</span></span><br></pre></td></tr></table></figure><p>下面这个子类继承了刚才那三个类，而且它在class语句里指定的超类顺序与它执行那些超类的<strong>init</strong>时所用的顺序一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneWay</span><span class="params">(MyBaseClass, TimesTwo, PlusFive)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    MyBaseClass.__init__(self, value)</span><br><span class="line">    TimesTwo.__init__(self)</span><br><span class="line">    PlusFive.__init(self)</span><br></pre></td></tr></table></figure><p>这样写，程序会按正常顺序初始化那几个超类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = OneWay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>但如果子类在class语句里指定的超类顺序，与它执行那些超类的<code>__init__</code>时的顺序不同，那么运行结果就会让人困惑（例如这次先声明它继承PlusFive类，然后才声明它继承TimesTwo类，但执行<code>__init__</code>的顺序却刚好相反）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWay</span><span class="params">(MyBaseClass, PlusFive, TimesTwo)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    MyBaseClass.__init__(self, value)</span><br><span class="line">    TimesTwo.__init__(self)</span><br><span class="line">    PlusFive.__init__(self)</span><br></pre></td></tr></table></figure><p>该子类调整了两个超类的声明顺序，但没有相应调整构造逻辑的执行顺序，因此它还是会跟前面那个子类一样，先初始化TimesTwo，然后初始化PlusFive。这样写，就让初次看到这段代码的人很难理解程序的运行结果，他们以为程序先加5，再乘2，这样算出来是20；但实际上，程序依照的是<code>__init__</code>的调用顺序，而不是class语句中的声明顺序，这是个很难察觉的问题。</p><p>直接调用<code>__init__</code>所产生的第二个问题在于，无法正确处理菱形继承（diamond inheritance）。这种继承指的是子类通过类体系里两条不同路径的类继承了同一个超类。如果采用刚才那种常见的写法来调用超类的<code>__init__</code>，那么会让超类的初始化逻辑重复执行，从而引发混乱。例如，下面先从MyBaseClass派生出两个子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesSeven</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    MyBaseClass.__init__(self, value)</span><br><span class="line">    self.value *= <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusNine</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    MyBaseClass.__init(self, value)</span><br><span class="line">    self.value += <span class="number">9</span></span><br></pre></td></tr></table></figure><p>然后，定义最终的子类，让它分别继承刚才那两个类，这样MyBaseClass就会出现在菱形体系的顶端。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWay</span><span class="params">(TimesSeven, PlusNine)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    TimeSeven.__init__(self, value)</span><br><span class="line">    PlusNine.__init(self, value)</span><br><span class="line">    </span><br><span class="line">foo = ThisWay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>当ThisWay调用第二个超类的<code>__init__</code>时，那个方法会再度触发MyBaseClass的<strong>init</strong>，导致self.value重新变成5。所以，最后的结果是5 + 9 = 14，而不是(5 * 7) + 9= 44，因为早前由<code>TimesSeven.__init__</code>所做的初始化效果已经被第二次执行的<code>MyBaseClass.__init__</code>覆盖了。这是个违背直觉的结果，如果情况更为复杂，那么调试起来会特别困难。</p><p>为了解决这些问题，<strong>Python内置了super函数并且规定了标准的方法解析顺序（method resolution order，MRO）。super能够确保菱形继承体系中的共同超类只初始化一次。MRO可以确定超类之间的初始化顺序，它遵循C3线性化（C3 linearization）算法。</strong></p><p>改用<code>super()</code>来调用超类的初始化逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeSevenCorrect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super().__init__(value)</span><br><span class="line">    self.value *= <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusNineCorrect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super().__init__(value)</span><br><span class="line">    self.value += <span class="number">9</span></span><br></pre></td></tr></table></figure><p>位于菱形结构顶端的MyBaseClass，会率先初始化，而且只会初始化一次。接下来，程序会参照菱形底端那个子类在class语句里声明超类时的顺序，来执行菱形结构中部的那两个超类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesSevenCorrect, PlusNineCorrect)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super().__init__(value)</span><br><span class="line">    </span><br><span class="line">foo = GoodWay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这个执行顺序，似乎与看上去的相反。既然GoodWay在指定超类时，先写的是TimesSevenCorrect，那就应该先执行<code>TimesSevenCorrect.__init</code>__才对，这样结果应该是(5* 7) + 9 = 44。但实际上并非如此。这两个超类之间的初始化顺序，要由子类的MRO确定，它可以通过mro方法来查询。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mro_str = <span class="string">'\n'</span>.join(repr(cls) <span class="keyword">for</span> cls <span class="keyword">in</span> GoodWay.mro())</span><br></pre></td></tr></table></figure><p>调用GoodWay(5)时，会先触发<code>TimesSevenCorrect.__init__</code>，进而触发<code>PlusNine-Correct.__init__</code>，而这又会触发<code>MyBaseClass.__init__</code>。程序到达菱形结构的顶端后，开始执行MyBaseClass的初始化逻辑，然后按照与刚才相反的顺序，依次执行PlusNineCorrect、TimesSevenCorrect与GoodWay的初始化逻辑。所以，程序首先会在<code>MyBaseClass.__init__</code>中，把value设为5，然后在PlusNineCorrect.<strong>init</strong>里面给它加9，这样就成了14，接着又会在TimesSevenCorrect.<strong>init</strong>里面将它乘7，于是等于98。</p><p>除了可以应对菱形继承结构，通过<code>super()</code>调用<code>__init__</code>，与在子类内通过类名直接调用<code>__init__</code>相比，可使代码更容易维护。现在不用从子类里面指名调用<code>MyBaseClass.__init__</code>方法了，因此可以把MyBaseClass改成其他名字，或者让TimesSevenCorrect与PlusNineCorrect从另外一个超类里面继承，这些改动都无须调整super这一部分的代码。假如像原来那样写，那就必须手工修改<code>__init__</code>方法前面的类名。</p><p>super函数也可以用双参数的形式调用。第一个参数表示从这个类型开始（不含该类型本身）按照方法解析顺序（MRO）向上搜索，而解析顺序则要由第二个参数所在类型的<code>__mro__</code>决定。例如，按照下面这种写法，如果在super所返回的内容上调用<strong>init</strong>方法，那么程序会从ExplicitTrisect类型开始（不含该类型本身）按照MRO向上搜索，直至找到这样的<code>__init__</code>方法为止，而解析顺序是由第二个参数（self）所属的类型（ExplicitTrisect）决定的，所以解析顺序是ExplicitTrisect -&gt; MyBaseClass -&gt; object。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExplicitTrisect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super(ExplicitTrisect, self).__init__(value)</span><br><span class="line">    self.value /= <span class="number">3</span></span><br></pre></td></tr></table></figure><p>一般来说，在类的<code>__init__</code>方法里面通过super初始化实例时，不需要采用双参数的形式，而是可以直接采用不带参数的写法调用super，这样Python编译器会自动将<code>__class__</code>和self当成参数传递进去。所以，下面这两种写法跟刚才那种写法是同一个意思。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticTrisect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super(__class__, self).__init__(value)</span><br><span class="line">    self.value /= <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplicitTrisect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    super().__init(value)</span><br><span class="line">    self.value /= <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">assert</span> ExplicitTrisect(<span class="number">9</span>).value == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> AutomaticTrisect(<span class="number">9</span>).value == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> ImplicitTrisect(<span class="number">9</span>).value == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>只有一种情况需要明确给super指定参数，这就是：我们想从子类里面访问超类对某项功能所做的实现方案，而那种方案可能已经被子类覆盖掉了（例如，在封装或复用功能时，就会遇到这样的情况）。</p><h3 id="第41条、考虑用mix-in类来表示可组合的功能"><a href="#第41条、考虑用mix-in类来表示可组合的功能" class="headerlink" title="第41条、考虑用mix-in类来表示可组合的功能"></a>第41条、考虑用mix-in类来表示可组合的功能</h3><p>Python是面向对象的编程语言，而且内置了相关的机制，使开发者能够正确处理多重继承。尽管如此，但还是应该尽量少用多重继承。</p><p>如果既要通过多重继承来方便地封装逻辑，又想避开可能出现的问题，那么就应该把有待继承的类写成mix-in类。这种类只提供一小套方法给子类去沿用，而不定义自己实例级别的属性，也不需要<code>__init__</code>构造函数。</p><p>在Python里很容易编写mix-in，因为无论对象是什么类型，我们都可以方便地检视（inspect）它当前的状态。这种动态检测机制，让我们只需要把通用的功能在mix-in实现一遍即可，将来也可以把这项功能应用到其他许多类里面。可以把这些mix-in类有层次地组合起来，从而用相当少的代码表达出丰富的功能。</p><p>例如，现在要实现这样一个功能，把内存中的Python对象表示成字典形式以便做序列化（serialization）处理。不妨将这项功能写为通用代码，以供其他类使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToDictMixin</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.traverse_dict(self.__dict__)</span><br></pre></td></tr></table></figure><p>具体的实现代码写得很直观，我们可以通过isinstance函数动态地检视值的类型，并利用hasattr函数判断值里面有没有叫作<code>__dict__</code>的字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_traverse_dict</span><span class="params">(self, instance_dict)</span>:</span></span><br><span class="line">  output = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> instance_dict.items():</span><br><span class="line">    output[key] = self._traverse(key, value)</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_traverse</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> isinstance(value, ToDictMixin):</span><br><span class="line">    <span class="keyword">return</span> value.to_dict()</span><br><span class="line">  <span class="keyword">elif</span> isinstance(value, dict):</span><br><span class="line">    <span class="keyword">return</span> self._traverse_dict(value)</span><br><span class="line">  <span class="keyword">elif</span> isinstance(value, list):</span><br><span class="line">    <span class="keyword">return</span> [self._traverse(key, i) <span class="keyword">for</span> i <span class="keyword">in</span> value]</span><br><span class="line">  <span class="keyword">elif</span> hasattr(value, <span class="string">'__dict__'</span>):</span><br><span class="line">    <span class="keyword">return</span> self._traverse_dict(value.__dict__)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>下面以二叉树为例，演示如何使表示二叉树的BinaryTree类具备刚才那个mix-in所提供的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">(ToDictMixin)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, left=None, right=None)</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    self.left = left</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><p>定义了这样的BinaryTree类后，很容易就能把二叉树里面那些相互关联的Python对象转换成字典的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree = BinaryTree(<span class="number">10</span>, left=BinaryTree(<span class="number">7</span>, right=BinaryTree(<span class="number">9</span>)), right=BinaryTree(<span class="number">13</span>, left=BinaryTree(<span class="number">11</span>)))</span><br><span class="line"></span><br><span class="line">tree.to_dict()</span><br></pre></td></tr></table></figure><p>mix-in最妙的地方在于，子类既可以沿用它所提供的功能，又可以对其中一些地方做自己的处理。</p><p>例如，我们从普通的二叉树（BinaryTree）派生了一个子类，让这种特殊的BinaryTreeWithParent二叉树能够把指向上级节点的引用保留下来。但问题是，这种二叉树的to_dict方法是从ToDictMixin继承来的，它所触发的_traverse方法，在面对循环引用时，会无休止地递归下去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeWithParent</span><span class="params">(BinaryTree)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, left=None, right=None, parent=None)</span>:</span></span><br><span class="line">    super().__init__(value, left=left, right=right)</span><br><span class="line">    self.parent = parent</span><br></pre></td></tr></table></figure><p>为了避免无限循环，我们可以覆盖BinaryTreeWithParent._traverse方法，让它对指向上级节点的引用做专门处理，而对于其他的值，则继续沿用从mix-in继承的_traverse逻辑。下面这段代码，首先判断当前值是不是指向上级节点的引用。如果是，就直接返回上级节点的value值；如果不是，那就通过内置的super函数沿用由mix-in超类所给出默认实现方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_traverse</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> (isinstance(value, BinaryTreeWithParent) <span class="keyword">and</span> key == <span class="string">'parent'</span>):</span><br><span class="line">    <span class="keyword">return</span> value.value</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> super()._traverse(key, value)</span><br></pre></td></tr></table></figure><p>现在调用BinaryTreeWithParent.to_dict就没有问题了，因为它所触发的是BinaryTreeWithParent自己的_traverse方法，该方法不会再递归地处理循环引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root = BinaryTreeWithParent(<span class="number">10</span>)</span><br><span class="line">root.left = BinaryTreeWithParent(<span class="number">7</span>, parent=root)</span><br><span class="line">root.left.right = BinaryTreeWithParent(<span class="number">9</span>, parent=root.left)</span><br></pre></td></tr></table></figure><p>只要BinaryTreeWithParent._traverse没问题，带有BinaryTreeWithParent属性的其他类就可以直接继承ToDictMixin，这样的话，程序在把这种对象转化成字典时，会自动对其中的BinaryTreeWithParent属性做出正确处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedSubTree</span><span class="params">(ToDictMixin)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, tree_with_parent)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.tree_with_parent = tree_with_parent</span><br><span class="line">    </span><br><span class="line">my_tree = NamedSubTree(<span class="string">'foobar'</span>, root.left.right)</span><br><span class="line">my_tree.to_dict()</span><br></pre></td></tr></table></figure><p>多个mix-in可以组合起来用。例如，我们要再写一个mix-in，让所有的类都可以通过继承它来实现JSON序列化功能。在编写这个mix-in时，假设继承了它的那个类肯定有自己的to_dict方法（这个方法有可能是从另一个mix-in（如ToDictMixin）继承的）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonMixin</span>:</span></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">from_json</span><span class="params">(cls, data)</span>:</span></span><br><span class="line">    kwargs = json.loads(data)</span><br><span class="line">    <span class="keyword">return</span> cls(**kwargs)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(self.to_dict())</span><br></pre></td></tr></table></figure><p>请注意，JsonMixin既定义了实例方法，也定义了类方法。于是，继承了这个mix-in的其他类也会拥有这两种行为。在本例中，继承JsonMixin的类只需要提供to_dict方法以及能够接受关键字参数的<code>__init__</code>方法即可。</p><p>有了这样两个mix-in，我们很容易就能创建一套含有工具类的体系，让其中的各种类型都可以把对象序列化成JSON格式并且能够根据JSON格式的数据创建这样的对象。而这只需要开发者按照固定的样式多写一点点代码即可。例如，可以用这样一套由数据类所构成的体系表示数据中心的各种设备与它们之间的结构关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatacenterRack</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, switch=None, machines=None)</span>:</span></span><br><span class="line">    self.switch - Switch(**switch)</span><br><span class="line">    self.machines = [Machine(**kwargs) <span class="keyword">for</span> kwargs <span class="keyword">in</span> machines]</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ports=None, speed=None)</span>:</span></span><br><span class="line">    self.ports = ports</span><br><span class="line">    self.speed = speed</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Machine</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cores=None, ram=None, dist=None)</span>:</span></span><br><span class="line">    self.cores = cores</span><br><span class="line">    self.ram = ram</span><br><span class="line">    self.disk = disk</span><br></pre></td></tr></table></figure><p>这样写之后，我们很容易就能根据JSON格式的信息把这些对象还原出来，另外，也可以把它们再序列化成JSON格式。下面我们就先把serialized变量所指的一段JSON信息反序列化（也就是还原）成DatacenterRack对象，然后再把这个对象序列化成JSON信息并保存到roundtrip变量，最后通过json.loads方法验证这两个变量中的信息是否等效。</p><p>对于JsonMixin这样的mix-in来说，即便直接继承它的那个类还通过类体系中的其他更高层类型间接地继承了它，程序也依然能够正常运行，因为Python可以把相关的方法正确地派发给JsonMixin类。</p><h3 id="第42条、优先考虑用public属性表示应受保护的数据，不要用private属性表示"><a href="#第42条、优先考虑用public属性表示应受保护的数据，不要用private属性表示" class="headerlink" title="第42条、优先考虑用public属性表示应受保护的数据，不要用private属性表示"></a>第42条、优先考虑用public属性表示应受保护的数据，不要用private属性表示</h3><p> Python类的属性只有两种访问级别，也就是public与private。</p><p>public属性能够公开访问，只需要在对象后面加上圆点操作符（dot operator），并写出属性的名称即可。</p><p>如果属性名以两个下划线开头，那么即为private字段。属性所在的类可以通过实例方法访问该属性。</p><p>但如果在类的外面直接通过对象访问private字段，那么程序就会抛出异常。</p><p>类方法（@classmethod）可以访问本类的private属性，因为这种方法也是在这个类（class）的范围里面声明的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherObject</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.__private_field = <span class="number">71</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_private_field_of_instance</span><span class="params">(cls, instance)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> instance.__private_field</span><br><span class="line">  </span><br><span class="line">bar = MyOtherObject()</span><br><span class="line"><span class="keyword">assert</span> MyOtherObject.get_private_field_of_instance(bar) == <span class="number">71</span></span><br></pre></td></tr></table></figure><p>private字段只给这个类自己使用，子类不能访问超类的private字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParentObject</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.__private_field = <span class="number">71</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildObject</span><span class="params">(MyParentObject)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_private_field</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__private_field</span><br><span class="line">  </span><br><span class="line">baz = MyChildObject()</span><br><span class="line">baz.get_private_field()</span><br></pre></td></tr></table></figure><p>这种防止其他类访问private属性的功能，其实仅仅是通过变换属性名称而实现的。当Python编译器看到MyChildObject.get_private_field这样的方法想要访问<code>__private_field</code>属性时，它会把下划线和类名加在这个属性名称的前面，所以代码实际上访问的是<code>_MyChildObject__private_field</code>。在上面的例子中，<code>__private_field</code>是在MyParentObject的<code>__init__</code>里面定义的，所以，它变换之后的真实名称是<code>_MyParentObject__private_field</code>。子类不能通过<code>__private_field</code>来访问这个属性，因为这样写实际上是在访问不存的<code>_MyChildObject__private_field</code>，而不是<code>_MyParentObject__private_field</code>。</p><p>了解名称变换规则后，我们就可以从任何一个类里面访问private属性。无论是子类还是外部的类，都可以不经许可就访问到这些属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> baz._MyParentObject__private_field == <span class="number">71</span></span><br></pre></td></tr></table></figure><p>查看该对象的属性字典，就会发现private属性的名称其实是以变换后的名称存储的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(baz.__dict__)</span><br></pre></td></tr></table></figure><p>为什么Python不从语法上严格禁止其他类访问private属性呢？这可以用一句常见的Python格言来回答：我们都是成年人了（We are all consenting adults here）。意思是说，我们用不着让编程语言把自己给拦住。你可以按照自己的想法扩展某个类的功能，同时也必须考虑到这样做的风险，并为此负责。Python开发者相信，虽然开放访问权限可能导致别人不按默认方式扩展这个类，但总比封闭起来要好。</p><p>另外，Python里面还有一些挂钩函数可以访问到这种属性，我们可以通过这些机制按需操纵对象的内部数据。既然这样，那即便Python阻止我们通过圆点加名称的办法访问private属性，我们也还是有其他办法能访问到，那么Python阻止private属性访问又有何意义？</p><p><strong>为了减少在不知情情况下访问内部数据而造成的损伤，Python开发者会按照风格指南里面建议的方式来给字段命名</strong>。以单下划线开头的字段（例如_protected_field），习惯上叫作受保护的（protected）字段，表示这个类以外的用户在使用这种字段时必须慎重。</p><p>尽管如此，有许多Python新手还是喜欢把内部的API设计成private字段，想通过这种写法防止子类或外部类访问这些字段。</p><p>如果把属性设为private，那么子类在覆盖或扩充这个类的时候，就必须采用变换之后的名称来访问那个属性，这会让代码变得很容易出错。例如，在写这样一个子类时，就不得不去访问超类中的private字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    self.__value = value</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(self.__value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegerSubClass</span><span class="params">(MyStringClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(self._MyStringClass__value)</span><br><span class="line">foo = MyIntegerSubClass(<span class="string">'5'</span>)</span><br><span class="line"><span class="keyword">assert</span> foo.get_value() == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这样写的问题是，如果类体系发生变动，那么引用private属性的那些代码就失效了。例如，MyIntegerSubclass类的直接超类（也就是MyStringClass）本身现在也继承自一个类（叫作MyBaseClass），而且它把早前的__value属性移到了那个类里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    self.__value = value</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(super().get_value())</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegerSubclass</span><span class="params">(MyStringClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(self._MyStringClass__value)</span><br></pre></td></tr></table></figure><p>现在的<code>__value</code>属性，是在MyBaseClass里面设置的，而不是在MyStringClass里面，所以MyIntegerSubclass没办法再通过self._MyStringClass__value访问这个属性。</p><p>一般来说，这种属性应该设置成protected字段，这样虽然有可能导致子类误用，但还是要比直接设为private好。我们可以在每个protected字段的文档里面详细解释，告诉用户这是属于可以由子类来操作的内部API，还是属于完全不应该触碰的数据。这样的文档，既可以给别人提供建议，也可以指导自己安全地扩充代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="comment"># This stores the user-supplied value for the object</span></span><br><span class="line">    <span class="comment"># It should be coercible to a string.Once assigned in</span></span><br><span class="line">    <span class="comment"># the object it shoule be treated as immutable.</span></span><br><span class="line">    self._value = value</span><br></pre></td></tr></table></figure><p>只有一种情况是可以考虑用private属性解决的，就是子类属性有可能与超类重名的情况。如果子类定义属性时使用的名称，恰巧与超类相同，那就会出现这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiClass</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._value = <span class="number">5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(ApiClass)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super().__init__()</span><br><span class="line">    self._value = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>如果超类属于开放给外界使用的API，那么你就没办法预料哪些子类会继承它，也不知道那些子类会添加什么属性，此时很有可能出现这个问题，而且你无法通过重构代码来解决。属性名越常见（如本例中的value），越容易发生冲突。为了减少冲突，我们可以把超类的属性设计成private属性，使子类的属性名不太可能与超类重复。</p><h3 id="第43条、自定义的容器类型应该从collections-abc继承"><a href="#第43条、自定义的容器类型应该从collections-abc继承" class="headerlink" title="第43条、自定义的容器类型应该从collections.abc继承"></a>第43条、自定义的容器类型应该从collections.abc继承</h3><p>编写Python程序时，要花很多精力来定义类，以存放数据并描述这种对象与其他对象之间的关系。每个Python类其实都是某种容器，可以把属性与功能封装进来。除了自定义的类之外，Python本身还提供了一些内置的容器类型，例如列表（list）、元组（tuple）、集合（set）、字典（dict）等，也可以用来管理数据。</p><p>如果要定义的是那种用法比较简单的类，那么我们自然就会想到直接从Python内置的容器类型里面继承，例如通过继承list类型实现某种序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrequencyList</span><span class="params">(list)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, members)</span>:</span></span><br><span class="line">    super().__init__(members)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">frequency</span><span class="params">(self)</span>:</span></span><br><span class="line">    counts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self:</span><br><span class="line">      counts[item] = counts.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure><p>继承list类，可以自动获得标准的Python列表所具备的各项功能。这样的话，其他开发者就可以像使用普通列表那样使用FrequencyList了。此外，我们还可以定义其他一些方法，来提供想要实现的各种行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo = FrequencyList([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>])</span><br><span class="line">foo.pop()</span><br><span class="line">repr(foo)</span><br><span class="line">foo.frequency()</span><br></pre></td></tr></table></figure><p>有的时候，某个对象所属的类本身虽然不是list的子类，但我们还是想让它能像list那样，可以通过下标来访问。例如，下面这个表示二叉树节点的BinaryNode类就不是list的子类，但我们想让它能够像序列（list或tuple等）那样，通过下标来访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, left=None, right=None)</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line">    self.left = left</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><p>让这个类可以像序列一样访问需要实现一些名称特殊的实例方法。当通过下标访问序列中的元素时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bar[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>Python会把访问操作解读为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.__getitem__(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>所以，为了让BinaryNode类能像序列那样使用，我们可以定义<code>__getitem__</code>方法（一般叫作dunder getitem，其中的dunder为double underscore（双下划线）的简称）。这个方法可以按照深度优先的方式遍历BinaryNode对象所表示的二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexableNode</span><span class="params">(BinaryNode)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_traverse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">from</span> self.left._traverse()</span><br><span class="line">    <span class="keyword">yield</span> self</span><br><span class="line">    <span class="keyword">if</span> self.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">from</span> self.right_traverse()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(self._traverse()):</span><br><span class="line">      <span class="keyword">if</span> i == index:</span><br><span class="line">        <span class="keyword">return</span> item.value</span><br><span class="line">    <span class="keyword">raise</span> IndexError(<span class="string">f'Index <span class="subst">&#123;index&#125;</span> is out of range'</span>)</span><br></pre></td></tr></table></figure><p>我们可以像使用BinaryNode那样，用这种定制过的IndexableNode对象来构造二叉树。</p><p>但问题是，除了下标索引，list实例还支持其他一些功能，所以只实现<code>__getitem__</code>这样一个特殊方法是不够的。例如，我们现在还是没办法像查询list长度那样查询这种二叉树的长度（元素总数）。</p><p>要想让定制的二叉树支持内置的len函数，必须再实现一个特殊方法，也就是<code>__len__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceNode</span><span class="params">(IndexableNode)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> count, _ <span class="keyword">in</span> enumerate(self._travrse(), <span class="number">1</span>):</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">tree = SequenceNode(</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">  left=SequenceNode(<span class="number">5</span>, left=SequenceNode(<span class="number">2</span>), right=SequenceNode(<span class="number">6</span>, right=SequenceNode(<span class="number">7</span>))),</span><br><span class="line">  right= SequenceNode(<span class="number">15</span>, left=SequenceNode(<span class="number">11</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实现完这样两个方法之后，我们仍然没办法让这种二叉树具备列表所应支持的全套功能。因为，有些Python开发者可能还想在二叉树上面调用count与index等方法，他们觉得，既然list或tuple这样的序列支持这些方法，那二叉树也应该支持才对。这样看来，要定制一个与标准容器兼容的类，似乎比想象中麻烦。</p><p>Python内置的collections.abc模块定义了一系列抽象基类（abstract base class），把每种容器类型应该提供的所有常用方法都写了出来。我们只需要从这样的抽象基类里面继承就好。同时，如果忘了实现某些必备的方法，那么程序会报错，提醒我们这些方法必须实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sequence</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadType</span><span class="params">(Sequence)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo = BadType()</span><br></pre></td></tr></table></figure><p>如果这些必备的方法都已经实现好了，那我们就可以从collections.abc模块的抽象基类里面继承了。例如，下面这个BetterNode二叉树类就是正确的，因为它已经通过继承前面的SequenceNode类实现了序列容器所应支持的全部必备方法，至于其他一些方法（例如index与count）则会由Sequence这个抽象基类自动帮我们实现（它在实现的时候，会借助BetterNode从SequenceNode继承的那些必备方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterNode</span><span class="params">(SequenceNode, Sequence)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">tree = BetterNode(</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">  left=BetterNode(<span class="number">5</span>, left=BetterNode(<span class="number">2</span>), right=BetterNode(<span class="number">6</span>, right=BetterNode(<span class="number">7</span>))),</span><br><span class="line">  right= BetterNode(<span class="number">15</span>, left=BetterNode(<span class="number">11</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于定制集合或可变映射等复杂的容器类型来说，继承collections.abc模块里的Set或MutableMapping等抽象基类所带来的好处会更加明显。假如自己从头开始实现，那必须编写大量的特殊方法才能让这些容器类的对象也能像标准的Python容器那样使用。collections.abc模块要求子类必须实现某些特殊方法，另外，<strong>Python在比较或排列对象时，还会用到其他一些特殊方法，无论定制的是不是容器类，有时为了支持某些功能，你都必须定义相关的特殊方法才行。</strong></p><hr><h2 id="6-元类与属性"><a href="#6-元类与属性" class="headerlink" title="6.元类与属性"></a>6.元类与属性</h2><p>元类（metaclass）是一种在类之上、超乎于类的概念。元类能够拦截Python的class语句，让系统每次定义类的时候，都能实现某些特殊的行为。</p><h3 id="第44条、用纯属性与修饰器取代旧式的setter与getter方法"><a href="#第44条、用纯属性与修饰器取代旧式的setter与getter方法" class="headerlink" title="第44条、用纯属性与修饰器取代旧式的setter与getter方法"></a>第44条、用纯属性与修饰器取代旧式的setter与getter方法</h3><p>从其他编程语言转入Python的开发者，可能想在类里面明确地实现getter与setter方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    self._ohms = ohms</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._ohms</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    self._ohms = ohms</span><br></pre></td></tr></table></figure><p>虽然这些setter与getter用起来很简单，但这并不符合Python的风格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r0 = OldResistor(<span class="number">50e3</span>)</span><br><span class="line">r0.get_ohms() <span class="comment"># 50000.0</span></span><br><span class="line">r0.set_ohms(<span class="number">10e3</span>)</span><br><span class="line">ro.get_ohms() <span class="comment"># 10000.0</span></span><br></pre></td></tr></table></figure><p>例如，想让属性值变大或者变小，采用这些方法来写会特别麻烦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r0.set_ohms(r0.get_ohms() - <span class="number">4e3</span>)</span><br><span class="line"><span class="keyword">assert</span> r0.get_ohms() == <span class="number">6e3</span></span><br></pre></td></tr></table></figure><p>这种工具方法确实有助于将类的接口定义得更加清晰，并方便开发者封装功能、验证用法、划定界限。这些都是在设计类时应该考虑的目标，实现这些目标可以确保我们在完善这个类的过程中不影响已经写好的调用代码。可是，在Python中实现这些目标时，没必要明确定义setter与getter方法。而是应该从最简单的public属性开始写起，例如像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resistor</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    self.ohms = ohms</span><br><span class="line">    self.voltage = <span class="number">0</span></span><br><span class="line">    self.current = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">r1 = Resistor(<span class="number">50e3</span>)</span><br><span class="line">r1.ohms = <span class="number">10e3</span></span><br></pre></td></tr></table></figure><p>按照这种写法，很容易就能实现原地增减属性值。</p><p>将来如果想在设置属性时，实现特别的功能，那么可以先通过<code>@property</code>修饰器来封装获取属性的那个方法，并在封装出来的修饰器上面通过setter属性来封装设置属性的那个方法。下面这个新类继承自刚才的Resistor类，它允许我们通过设置voltage（电压）属性来改变current（电流）。为了正确实现这项功能，必须保证设置属性与获x取属性所用的那两个方法都跟属性同名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltageResistance</span><span class="params">(Resistor)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    super().__init__(ohms)</span><br><span class="line">    self._voltage = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">voltage</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._voltage</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @voltage setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">voltage</span><span class="params">(self, voltage)</span>:</span></span><br><span class="line">    self._voltage = voltage</span><br><span class="line">    self.current = self._voltage / self.ohms</span><br></pre></td></tr></table></figure><p>按照这种写法，给voltage属性赋值会触发同名的setter方法，该方法会根据新的voltage计算本对象的current属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r2 = VoltageResistance(<span class="number">1e3</span>)</span><br><span class="line">r2.voltage = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>为属性指定setter方法还可以用来检查调用方所传入的值在类型与范围上是否符合要求。例如，下面这个Resistor子类可以确保用户设置的电阻值总是大于0的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedResistance</span><span class="params">(Resistor)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    super().__init__(ohms)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._ohms</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @ohms.setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ohms &lt;= <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">f'ohms must be &gt; 0; got <span class="subst">&#123;ohms&#125;</span>'</span>)</span><br><span class="line">    self._ohms = ohms</span><br></pre></td></tr></table></figure><p>给这个类的属性设置无效电阻值，程序会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r3 = BoundedResistance(<span class="number">1e3</span>)</span><br><span class="line">r3.ohms = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果构造时所用的值无效，那么同样会触发异常。</p><p>之所以会出现这种效果，是因为子类的构造器（BoundedResistance.<strong>init</strong>）会调用超类的构造器（Resistor.<strong>init</strong>），而超类的构造器会把self.ohms设置成-5。于是，就会触发BoundedResistance里面的<a href="mailto:`@ohms.setter" target="_blank" rel="noopener">`@ohms.setter</a><code>方法，该方法立刻发现属性值无效，所以程序在对象还没有构造完之前，就会抛出异常。我们还可以利用</code>@property`阻止用户修改超类中的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedResistance</span><span class="params">(Resistor)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    super().__init__(ohms)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._ohms</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @ohms.setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(self, <span class="string">'_ohms'</span>):</span><br><span class="line">      <span class="keyword">raise</span> AttributeError(<span class="string">'Ohms is immutable'</span>)</span><br><span class="line">    self._ohms = ohms</span><br></pre></td></tr></table></figure><p>构造好对象之后，如果试图给属性赋值，那么程序就会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r4 = FixedResistance(<span class="number">1e3</span>)</span><br><span class="line">r4.ohms = <span class="number">2e3</span></span><br></pre></td></tr></table></figure><p>用@property实现setter与getter时，还应该注意不要让对象产生反常的行为。例如，不要在某属性的getter方法里面设置其他属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysteriousResistor</span><span class="params">(Resistor)</span>:</span></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.voltage = self._ohms * self.current</span><br><span class="line">    <span class="keyword">return</span> self._ohms</span><br><span class="line"><span class="meta">  @ohms.setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">    self._ohms = ohms</span><br></pre></td></tr></table></figure><p>假如在获取属性的getter方法里面修改了其他属性的值，那么用户查询这个属性时，就会觉得相当奇怪，他可能不理解为什么另外一个属性会在我查询这个属性时发生变化。</p><p>最好的办法是，只在@property.setter方法里面修改状态，而且只应该修改对象之中与当前属性有关的状态。同时还得注意不要产生让调用者感到意外的其他一些副作用，例如，不要动态地引入模块，不要运行速度较慢的辅助函数，不要做I/O，不要执行开销较大的数据库查询操作等。类的属性用起来应该跟其他的Python对象一样方便而快捷。如果确实要执行比较复杂或比较缓慢的操作，那么应该用普通的方法来做，而不应该把这些操作放在获取及设置属性的这两个方法里面。</p><p>@property最大的缺点是，通过它而编写的属性获取及属性设置方法只能由子类共享。与此无关的类不能共用这份逻辑。但是没关系，Python还支持描述符，我们可以利用这种机制把早前编写的属性获取与属性设置逻辑复用到其他许多地方。</p><h3 id="第45条、考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码"><a href="#第45条、考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码" class="headerlink" title="第45条、考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码"></a>第45条、考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</h3><p>@property还有一种更为高级的用法，其实也很常见，这就是把简单的数值属性迁移成那种实时计算的属性。这个用法的意义特别大，因为它可以确保，按照旧写法来访问属性的那些代码依然有效，而且会自动按照新逻辑执行，也不需要重写原来那些访问代码（这一点相当关键，因为那些代码未必都在你控制之下）。@property可以说是一种重要的缓冲机制，使开发者能够逐渐改善接口而不影响已经写好的代码。</p><p>可以利用@property给已有的实例属性增加新的功能。可以利用@property逐渐改善数据模型而不影响已经写好的代码。</p><p>@property可以帮助解决实际工作中的许多问题，但不应该遭到滥用。如果你发现自己总是在扩充@property方法，那可能说明这个类确实应该重构了。在这种情况下，就不要再沿着糟糕的方案继续往下写了。</p><h3 id="第46条、用描述符来改写需要复用的-property方法"><a href="#第46条、用描述符来改写需要复用的-property方法" class="headerlink" title="第46条、用描述符来改写需要复用的@property方法"></a>第46条、用描述符来改写需要复用的@property方法</h3><p>Python内置的@property机制的最大的缺点就是不方便复用。我们不能把它修饰的方法所使用的逻辑，套用在同一个类的其他属性上面，也不能在无关的类里面复用。</p><p>例如，我们要编写一个类来记录学生的家庭作业成绩，而且要确保设置的成绩位于0到100之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Homework</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._grade = <span class="number">0</span></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._grade</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @grade.setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">    self._grade = value</span><br></pre></td></tr></table></figure><p>受@property修饰的属性用起来很简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">galileo = Homework()</span><br><span class="line">galileo.grade = <span class="number">95</span></span><br></pre></td></tr></table></figure><p>假设，我们还需要写一个类记录学生的考试成绩，而且要把每科的成绩分别记录下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._writing_grade = <span class="number">0</span></span><br><span class="line">    self._math_grade = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br></pre></td></tr></table></figure><p>这样写很费事，因为每科的成绩都需要一套@property方法，而且其中设置属性值的那个方法还必须调用_check_grade验证新值是否位于合理的范围内。</p><p>在Python里，这样的功能最好通过描述符（descriptor）实现。描述符协议（descriptor protocol）规定了程序应该如何处理属性访问操作。充当描述符的那个类能够实现<code>__get__</code>与<code>__set__</code>方法，这样其他类就可以共用这个描述符所实现的逻辑而无须把这套逻辑分别重写一遍。</p><p>下面重新定义Exam类，这次我们采用类级别的属性来实现每科成绩的访问功能，这些属性指向下面这个Grade类的实例，而这个Grade类则实现刚才提到的描述符协议。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">clas Exam:</span><br><span class="line">  <span class="comment"># Class attributes</span></span><br><span class="line">  math_grade = Grade()</span><br><span class="line">  writing_grade = Grade()</span><br><span class="line">  science_grade = Grade()</span><br></pre></td></tr></table></figure><p>当程序访问Exam实例的某个属性时，Python如何将访问操作派发到Exam类的描述符属性上面。例如，如果要给Exam实例的writing_grade属性赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exam = Exam()</span><br><span class="line">exam.writing_grade = <span class="number">40</span></span><br></pre></td></tr></table></figure><p>那么Python会把这次赋值操作转译为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exam.__dict__[<span class="string">'writing_grade'</span>].__set__(exam, <span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>获取这个属性时也一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exam.__dict__[<span class="string">'writing_grade'</span>].__get__(exam)  <span class="comment"># exam.writing_grade</span></span><br></pre></td></tr></table></figure><p>这样的转译效果是由object的<code>__getattribute__</code>方法促成的。</p><p>简单地说，就是当Exam实例里面没有名为writing_grade的属性时，Python会转而在类的层面查找，查询Exam类里面有没有这样一个属性。如果有，而且还是个实现了<code>__get__</code>与<code>__set__</code>方法的对象，那么系统就认定你想通过描述符协议定义这个属性的访问行为。</p><p>知道了这条规则之后，我们来尝试把Homework类早前用@property实现的成绩验证逻辑搬到Grade描述符里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._value = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">    self._value = value</span><br></pre></td></tr></table></figure><p>这样写其实不对，而且会让程序出现混乱。但在同一个Exam实例上面访问不同的属性是没有问题的。</p><p>出现这种问题的原因在于，这些Exam实例之中的writing_grade属性实际上是在共享同一个Grade实例。在整个程序的运行过程中，这个Grade只会于定义Exam类时构造一次，而不是每创建一个Exam实例都有一个新的Grade来与writing_grade属性相搭配。为解决此问题，我们必须把每个Exam实例在这个属性上面的取值都记录下来。可以通过字典实现每个实例的状态保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._values = &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">return</span> self._values.get(instance, <span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">    self._values[instance] = value</span><br></pre></td></tr></table></figure><p>这种实现方案很简单，而且能得到正确结果，但仍然有一个缺陷，就是会泄漏内存。在程序运行过程中，传给<code>__set__</code>方法的那些Exam实例全都会被Grade之中的_values字典所引用。于是，指向那些实例的引用数量就永远不会降到0，这导致垃圾回收器没办法把那些实例清理掉。</p><p>为了解决这个问题，我们可以求助于Python内置的weakref模块。该模块里有一种特殊的字典，名为WeakKeyDictionary，它可以取代刚才实现_values时所用的普通字典。这个字典的特殊之处在于：如果运行时系统发现，指向Exam实例的引用只剩一个，而这个引用又是由WeakKeyDictionary的键所发起的，那么系统会将该引用从这个特殊的字典里删掉，于是指向那个Exam实例的引用数量就会降为0。总之，改用这种字典来实现_values会让Python系统自动把内存泄漏问题处理好，如果所有的Exam实例都不再使用了，那么_values字典肯定是空的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> WeakKeyDictionary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._values = WeakKeyDictionary()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>不要太纠结于<code>__getattribute__</code>是怎么通过描述符协议来获取并设置属性的。</p><h3 id="第47条、针对惰性属性使用-getattr-、-getattribute-及-setattr"><a href="#第47条、针对惰性属性使用-getattr-、-getattribute-及-setattr" class="headerlink" title="第47条、针对惰性属性使用__getattr__、__getattribute__及__setattr__"></a>第47条、针对惰性属性使用<code>__getattr__</code>、<code>__getattribute__</code>及<code>__setattr__</code></h3><p>Python的object提供了一套挂钩，使开发者很容易就能写出通用的代码，将不同的系统粘合到一起。</p><p>如果类中定义了<code>__getattr__</code>，那么每当访问该类对象的属性，而且实例字典里又找不到这个属性时，系统就会触发<code>__getattr__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyRecord</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.exists = <span class="number">5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    value = <span class="string">f'Value for <span class="subst">&#123;name&#125;</span>'</span></span><br><span class="line">    setattr(self, name, value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>我们试着访问foo属性。data实例中并没有这样一个属性，因此Python会触发上面定义的<code>__getattr__</code>方法，而该方法又会通过setattr修改本实例的<strong>dict</strong>字典。</p><p>我们通过子类给LazyRecord增加日志功能，用来观察程序在什么样的情况下才会调用<code>__getattr__</code>方法。我们先写入第一条日志，然后通过super()调用超类所实现的<code>__getattr__</code>方法，并把那个方法返回的结果记录到第二条日志里面。假如不加super()，那么程序就会无限递归，因为那样调用的是本类所写的<code>__getattr__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingLazyRecord</span><span class="params">(LazyRecord)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    print(<span class="string">f'called __getattr__(<span class="subst">&#123;name!r&#125;</span>)'</span>)</span><br><span class="line">    result = super().__getattr__(name)</span><br><span class="line">    print(<span class="string">f'Returning <span class="subst">&#123;result!r&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>exists属性本来就在实例字典里，所以访问data.exists时不会触发<code>__getattr__</code>。接下来，开始访问data.foo。foo属性不在实例字典中，因此系统会触发<code>__getattr__</code>方法，这个方法会通过setattr把foo属性添加到实例字典。然后，我们第二次访问data.foo，这次data实例的<code>__dict__</code>字典已经包含这个属性，所以不会触发<code>__getattr__</code>。</p><p>如果要实现惰性的（lazy，也指按需的）数据访问机制，而这份数据又没有schema，那么通过<code>__getattr__</code>来做就相当合适。它只需要把属性加载一次即可，以后再访问这个属性时，系统会直接从实例字典中获取。</p><p>假设我们现在还需要验证数据库系统的事务状态。也就是说，用户每次访问某属性时，我们都要确保数据库里面的那条记录依然有效，而且相应的事务也处在开启状态。这个需求没办法通过<code>__getattr__</code>实现，因为一旦对象的实例字典里包含了这个属性，那么程序就会直接从字典获取，而不会再触发<code>__getattr__</code>。</p><p>为了应对这种比较高级的用法，Python的object还提供了另一个挂钩，叫作<code>__getattribute__</code>。只要访问对象中的属性，就会触发这个特殊方法，即便这项属性已经在<code>__dict__</code>字典里，系统也还是会执行<code>__getattribute__</code>方法。于是，我们可以在这个方法里面检测全局的事务状态，这样就能对每一次属性访问操作都进行验证了。同时，我们必须注意这种写法开销很大，而且会降低程序的效率，但有的时候确实值得这么做。下面就定义ValidatingRecord类，让它实现<code>__getattribute__</code>方法，并在系统每次调用这个方法时，打印相关的日志消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatingRecord</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.exists = <span class="number">5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    print(<span class="string">f'* Called __getattribute__(<span class="subst">&#123;name!r&#125;</span>)'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      value = super().__getattribute__(name)</span><br><span class="line">      print(<span class="string">f'* Found <span class="subst">&#123;name!r&#125;</span>, returning <span class="subst">&#123;value!r&#125;</span>'</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">      value = <span class="string">f'Value for <span class="subst">&#123;name&#125;</span>'</span></span><br><span class="line">      print(<span class="string">f'* Setting <span class="subst">&#123;name!r&#125;</span> to <span class="subst">&#123;value!r&#125;</span>'</span>)</span><br><span class="line">      setattr(self, name, value)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"> data = ValidatingRecord()</span><br></pre></td></tr></table></figure><p>如果要访问的属性根本就不应该存在，那么可以在<code>__getattr__</code>方法里面拦截。无论是<code>__getattr__</code>还是<code>__getattribute__</code>，都应该抛出标准的AttributeError来表示属性不存在或不适合存在的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingPropertyRecord</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'bad_name'</span>:</span><br><span class="line">      <span class="keyword">raise</span> AttributeError(<span class="string">f'<span class="subst">&#123;name&#125;</span> is missing'</span>)</span><br><span class="line">      <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">data = MissingPropertyRecord()</span><br><span class="line">data.bad_name</span><br></pre></td></tr></table></figure><p>在编写通用的Python代码时，我们经常要依靠内置的hasattr函数判断属性是否存在，并且通过内置的getattr函数获取属性值。这些函数也会先在实例的<code>__dict__</code>字典里面查找，如果找不到，则会触发<code>__getattr__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = LoggingLazyRecord()</span><br><span class="line">data.__dict__</span><br><span class="line">hasattr(data, <span class="string">'foo'</span>)</span><br><span class="line">data.__dict__</span><br><span class="line">hasattr(data, <span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>在运行上面那段代码的过程中，<code>__getattr__</code>只触发了一次。假如data所属的类实现的不是<code>__getattr__</code>，而是<code>__getattribute__</code>方法，那么效果就不一样了，程序每次对实例做hasattr与getattr操作时，都会触发这个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = ValidatingRecord()</span><br><span class="line">print(hasattr(data, <span class="string">'foo'</span>))</span><br><span class="line">print(hasattr(data, <span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>假设程序给Python对象赋值时，我们不想立刻更新数据库，而是打算稍后再推送回去。这个功能可以通过<code>__setattr__</code>实现，而它也是object提供的挂钩，可以拦截所有的属性赋值操作。属性的获取操作分别通过<code>__getattr__</code>与<code>__getattribute__</code>挂钩拦截，但设置操作只需要这一个挂钩就行。只要给实例中的属性赋值（不论是直接赋值，还是通过内置的setattr函数赋值），系统就触发<code>__setattr__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingRecord</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    super().__setattr(name, value)</span><br></pre></td></tr></table></figure><p><code>__getattribute__</code>与<code>__setattr__</code>这样的方法有个问题，就是只要访问对象的属性，系统就会触发该方法。但有时候，我们其实并不希望出现这种效果。</p><p>为解决这个问题，我们可以改用<code>super().__getattribute__</code>方法获取_data属性，由于超类的<code>__getattribute__</code>是直接从实例的属性字典获取的，不会继续触发<code>__getattribute__</code>，这样就避开了递归。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictionaryRecord</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    self._data = data</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    print(<span class="string">f'* Called __getattribute__(<span class="subst">&#123;name!r&#125;</span>)'</span>)</span><br><span class="line">    data_dict = super().__getattribute__(<span class="string">'_data'</span>)</span><br><span class="line">    <span class="keyword">return</span> data_dict[name]</span><br><span class="line">  </span><br><span class="line">data = DictionaryRecord(&#123;<span class="string">'foo'</span>: <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>在<code>__setattr__</code>里面为这种对象实现属性修改逻辑时，也需要通过<code>super().__setattr__</code>来获取_data字典。</p><h3 id="第48条、用-init-subclass-验证子类写得是否正确"><a href="#第48条、用-init-subclass-验证子类写得是否正确" class="headerlink" title="第48条、用__init_subclass__验证子类写得是否正确"></a>第48条、用<code>__init_subclass__</code>验证子类写得是否正确</h3><p>元类最简单的一种用法是验证某个类定义得是否正确。如果要构建一套比较复杂的类体系，那我们可能得确保这套体系中的类采用的都是同一种风格，为此我们可能需要判断这些类有没有重写必要的方法，或者判断类属性之间的关系是否合理。元类提供了一种可靠的手段，只要根据这个元类来定义新类，就能用元类中的验证逻辑核查新类的代码写得是否正确。</p><p>一般来说，我们会在类的<code>__init__</code>方法里面检查新对象构造得是否正确。但有的时候，整个类的写法可能都是错的，而不单单是该类的某个对象构造得有问题，所以我们想尽早拦住这种错误。例如，当程序刚刚启动并把包含这个类的模块加载进来时，我们就想验证这个类写得对不对，此时便可利用元类来实现。</p><p>在讲解如何用自定义的元类验证子类之前，我们首先必须明白元类的标准用法。元类应该从type之中继承。在默认情况下，系统会把通过这个元类所定义的其他类发送给元类的<code>__new__</code>方法，让该方法知道那类个的class语句是怎么写的。下面就定义这样一个元类，如果用户通过这个元类来定义其他类，那么在那个类真正构造出来之前，我们可以先在<code>__new__</code>里面观察到它的写法并做出修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    print(<span class="string">f'* Running <span class="subst">&#123;meta&#125;</span>.__new__ for <span class="subst">&#123;name&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">'Bases:'</span>, bases)</span><br><span class="line">    print(class_dict)</span><br><span class="line">    <span class="keyword">return</span> type.__new__(meta, name, bases, class_dict)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line">  stuff = <span class="number">123</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubclass</span><span class="params">(MyClass)</span>:</span></span><br><span class="line">  other = <span class="number">567</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>元类可以获知那个类的名称（name）、那个类的所有超类（bases）以及class语句体中定义的所有类属性（class_dict）。因为每个类最终都要继承object，所以这个object名字不会体现在罗列超类名称的bases元组之中。</p><p>我们可以在元类的<code>__new__</code>方法里面添加一些代码，用来判断根据这个元类所定义的类的各项参数是否合理。例如，要用不同的类来表示边数不同的多边形（polygon）。如果把这些类都纳入同一套体系，那么可以定义这样一个元类，让该体系内的所有类都受它约束。我们在这个元类的<code>__new__</code>里面检查那些类的边数（sides）是否有效。注意，不要把检查逻辑运用到类体系的顶端，也就是基类Polygon上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatePolygon</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    <span class="comment"># Only validate subclasses of the Polygon class</span></span><br><span class="line">    <span class="keyword">if</span> bases:</span><br><span class="line">      <span class="keyword">if</span> class_dict[<span class="string">'sides'</span>] &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Polygons need 3+ sides'</span>)</span><br><span class="line">    <span class="keyword">return</span> type.__new__(meta, name, bases, class_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span><span class="params">(metaclass=ValidatePolygon)</span>:</span></span><br><span class="line">  sides = <span class="literal">None</span> <span class="comment"># Must be specified by subclasses</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interior_angles</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (cls.sides - <span class="number">2</span>) * <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(Polygon)</span>:</span></span><br><span class="line">  sides = <span class="number">3</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(Polygon)</span>:</span></span><br><span class="line">  sides = <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monagon</span><span class="params">(Polygon)</span>:</span></span><br><span class="line">  sides = <span class="number">9</span></span><br></pre></td></tr></table></figure><p>如果我们试着定义边数小于3的多边形子类，那么刚把那个子类的class语句体写完，元类就会通过<code>__new__</code>方法察觉到这个问题。这意味着，只要定义了无效的多边形子类，程序就无法正常启动，除非那个类是在动态引入的模块里面定义的。</p><p>这样一项基本的任务竟然要写这么多代码才能实现。好在Python 3.6引入了一种简化的写法，能够直接通过<code>__init_subclass__</code>这个特殊的类方法实现相同的功能，这样就不用专门定义元类了。下面我们改用这个机制来实现与刚才相同的验证逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterPolygon</span>:</span></span><br><span class="line">  sides = <span class="literal">None</span> <span class="comment"># Must be specified by subclasses</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    <span class="keyword">if</span> cls.sides &lt; <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Polygons need 3+ sides'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interior_angles</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (cls.sides - <span class="number">2</span>) * <span class="number">180</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hexagon</span><span class="params">(BetterPolygon)</span>:</span></span><br><span class="line">  sides = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>现在的代码简短多了，完全不需要定义ValidatePolygon这样一个元类。在<code>__init_subclass__</code>方法里面，我们可以直接通过cls实例来访问类级别的sides属性，而不用像原来那样，在存放类属性的class_dict里面查询’sides’键。现在的多边形子类应该继承刚写的BetterPolygon基类。如果子类定义的边数无效，那么程序会抛出同样的异常。</p><p>用标准的Python元类机制来实现验证还有个缺点，就是每个类只能定义一个元类。</p><p>要解决这个问题，我们可以创建一套元类体系，让不同层面上的元类分别完成各自的验证逻辑（也就是先在下层元类里面验证填充色，如果验证无误，那么再去上层元类里面验证边数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatePolygon</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    <span class="comment"># Only validate non-root classes</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> class_dict.get(<span class="string">'is_root'</span>):</span><br><span class="line">      <span class="keyword">if</span> class_dict[<span class="string">'sides'</span>] &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Polygons need 3+ sides'</span>)</span><br><span class="line">    <span class="keyword">return</span> type.__new__(meta, name, bases, class_dict)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span><span class="params">(metaclass=ValidatePolygon)</span>:</span></span><br><span class="line">  is_root = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>同时，这也要求我们必须设计一个支持填充色的多边形类（FilledPolygon），让它在多边形类（Polygon）的基础上增加填充色逻辑，而不能像刚才那样，把填充色与边数分别放在Filled与Polygon两个类中。现在，带有具体填充色与边数的多边形需要从这个FilledPolygon里面继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenPentagon</span><span class="params">(FilledPolygon)</span>:</span></span><br><span class="line">  color = <span class="string">'green'</span></span><br><span class="line">  sides = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>如果采用不受支持的填充色来定义FilledPolygon子类，那么ValidateFilledPolygon里面的验证逻辑就会查出这个问题。ValidateFilledPolygon元类继承自ValidatePolygon，因此边数的错误也可以检查出来。</p><p>但是按照现在这种写法，如果想把颜色的验证逻辑施加在多边形之外的另一套类体系中，那么必须按照刚才的样板重复编写许多代码才行，而没办法很方便地复用已有的代码。</p><p>这个问题，同样可以通过<code>__init_subclass__</code>这个特殊的类方法来解决。在多层的类体系中，只要通过内置的super()函数来调用<code>__init_subclass__</code>方法，系统就会按照适当的解析顺序触发超类或平级类的<code>__init_subclass__</code>方法，以保证那些类在各自的<code>__init_subclass__</code>里面所实现的验证逻辑也能够正确地执行（类似案例参见第40条）。这种写法可以正确应对多重继承。例如，下面这个Filled类就通过<code>__init_subclass__</code>来验证填充色，这样的话，子类可以同时继承该类以及刚才的BetterPolygon类，从而把这两个类所实现的验证逻辑组合起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filled</span>:</span></span><br><span class="line">  color = <span class="literal">None</span> <span class="comment"># Must be specified by subclasses</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    <span class="keyword">if</span> cls.color <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>):</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Fills need a valid color'</span>)</span><br></pre></td></tr></table></figure><p><code>__init_subclass__</code>还可以处理更为复杂的情况，例如菱形继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass_</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    print(<span class="string">f'Top for <span class="subst">&#123;cls&#125;</span>'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span><span class="params">(Top)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    print(<span class="string">f'Left for <span class="subst">&#123;cls&#125;</span>'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span><span class="params">(Top)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    print(<span class="string">f'Right for <span class="subst">&#123;cls&#125;</span>'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span><span class="params">(Left, Right)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    print(<span class="string">f'Bottom for <span class="subst">&#123;cls&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>可以看到，菱形体系底部的Bottom类通过Left与Right两条路径重复继承了体系顶端的Top类。然而，由于是通过super()触发<code>__init_subclass__</code>，系统在处理Bottom类的定义时，只会把Top类的<code>__init_subclass__</code>执行一遍。</p><h3 id="第49条、用-init-subclass-记录现有的子类"><a href="#第49条、用-init-subclass-记录现有的子类" class="headerlink" title="第49条、用__init_subclass__记录现有的子类"></a>第49条、用<code>__init_subclass__</code>记录现有的子类</h3><p>元类还有个常见的用途，是可以自动记录（或者说注册）程序之中的类型。利用这项功能，我们就能根据某个标识符反向查出它所对应的类。</p><p>让元类把子类的class定义拦截下来，然后自动调用register_class去注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    cls = type.__new__(meta, name, bases, class_dict)</span><br><span class="line">    register_class(cls)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisteredSerializable</span><span class="params">(BetterSenializable, metaclass=Meta)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>用户只要把RegisteredSerializable的子类定义完，就可以确信程序已经通过register_class将这个子类注册过了，所以它肯定支持反序列化。</p><p>还有一种办法比上面的实现方式更简单，那就是通过名为<code>__init_subclass__</code>的特殊类方法来实现。这是Python 3.6引入的新写法，我们只需要编很少的代码，就可以把自己的逻辑运用到子类上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterRegisteredSerializable</span><span class="params">(BetterSerializable)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span><span class="params">(cls)</span>:</span></span><br><span class="line">    super().__init_subclass__()</span><br><span class="line">    register_class(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector1D</span><span class="params">(BetterRegisteredSerializable)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, magnitude)</span>:</span></span><br><span class="line">    super().__init__(magnitude)</span><br><span class="line">    self.magnitude = magnitude</span><br></pre></td></tr></table></figure><p>在类体系正确无误的前提下，通过<code>__init_subclass__</code>（或元类）自动注册子类可以避免程序由于用户忘记注册而引发问题。这不仅适用于上述序列化与反序列化功能的实现，而且还可以用在数据库的对象关系映射（object-relational mapping，ORM）、可扩展的插件系统以及回调挂钩上面。</p><h3 id="第50条、用-set-name-给类属性加注解"><a href="#第50条、用-set-name-给类属性加注解" class="headerlink" title="第50条、用__set_name__给类属性加注解"></a>第50条、用<code>__set_name__</code>给类属性加注解</h3><p>元类还有一个更有用的功能，那就是可以在某个类真正投入使用之前，率先修改或注解这个类所定义的属性。这通常需要与描述符（descriptor）搭配使用，这样可以让我们更详细地了解这些属性在定义它们的那个类里是如何使用的。</p><p>例如，我们要定义一个新的类，来表示客户数据库中的每一行数据。这个类需要定义一些属性，与数据表中的各列相对应，每个属性都分别表示这行数据在这一列的取值。下面用描述符类来实现这些属性，把它们和数据表中同名的列联系起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.internal_name = <span class="string">'_'</span> + self.name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">return</span> getattr(instance, self.internal_name, <span class="string">''</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    setattr(instance, self.internal_name, value)</span><br></pre></td></tr></table></figure><p>Field描述符的name属性指的就是数据表中那一列的列名，所以，我们可以通过内置的setattr函数把每行数据在这个属性上面的取值保存到那行数据自己的状态字典里面去，只不过属性名应该稍加调整，我们给它前面加个下划线表示它是受到保护的属性。另外，我们通过getattr函数实现属性加载功能。这种写法，看上去似乎要比把每个实例在这项属性上面的取值都保存到weakref字典里面更简单（那种字典是weakref模块所提供的特殊字典，用以防止内存泄漏）。</p><p>下面定义Customer类，每个Customer都表示数据表中的一行数据，其中的四个属性分别对应于这行数据在那四列上面的取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">  <span class="comment"># Class attributes</span></span><br><span class="line">  first_name = Field(<span class="string">'first_name'</span>)</span><br><span class="line">  last_name = Field(<span class="string">'last_name'</span>)</span><br><span class="line">  prefix = Field(<span class="string">'prefix'</span>)</span><br><span class="line">  suffix = Field(<span class="string">'suffix'</span>)</span><br></pre></td></tr></table></figure><p>元类可以当作class语句的挂钩，只要class语句体定义完毕，元类就会看到它的写法并尽快做出应对。在本例中，我们可以让元类自动给每个Field描述符的name与internal_name赋值，而不用再像原来那样，需要开发者把字段名称重复书写一遍并手动传给Field的构造函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> class_dict.items():</span><br><span class="line">      <span class="keyword">if</span> isinstance(value, Field):</span><br><span class="line">        value.name = key</span><br><span class="line">        value.internal_name = <span class="string">'_'</span> + key</span><br><span class="line">    cls = type.__new__(meta, name, bases, class_dict)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure><p>下面定义一个基类，让该基类把刚才定义好的Meta当成元类。凡是表示数据库某行的类都继承自该基类，以确保它们可以利用元类所提供的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseRow</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为了跟元类配合，Field描述符需要稍加调整。它的大部分代码都可以沿用，只是现在已经不用再要求调用者把名称传给构造函数了，因为这次，元类的<code>__new__</code>方法会自动设置名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="literal">None</span></span><br><span class="line">    self.internal_name = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">return</span> getattr(instance, self.internal_name, <span class="string">''</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    setattr(instance, self.internal_name, value)</span><br></pre></td></tr></table></figure><p>有了元类、DatabaseRow基类以及修改过的Field描述符，我们在给客户类定义字段时，就不用手工传入字段名了，代码也不像之前那样冗余了。</p><p>这个办法的缺点是，要想在类中声明Field字段，这个类必须从DatabaseRow继承。假如忘了继承，或者所面对的类体系在结构上不方便这样继承，那么代码就无法正常运行。</p><p>这个问题可以通过给描述符定义<code>__set_name__</code>特殊方法来解决。这是Python 3.6引入的新功能：如果某个类用这种描述符的实例来定义字段，那么系统就会在描述符上面触发这个特殊方法。系统会把采用这个描述符实例作字段的那个类以及字段的名称，当成参数传给<code>__set_name__</code>。下面我们将<code>Meta.__new__</code>之中的逻辑移动到Field描述符的<code>__set_name__</code>里面，这样一来，就不用定义元类了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="literal">None</span></span><br><span class="line">    self.internal_name = <span class="literal">None</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.internal_name = <span class="string">'_'</span> + name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">return</span> getattr(instance, self.internal_name, <span class="string">''</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    setattr(instance, self.internal_name, value)</span><br></pre></td></tr></table></figure><p>现在，我们可以直接在类里通过Field描述符来定义字段，而不用再让这个类继承某个基类，还能把元类给省掉。</p><h3 id="第51条、优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类"><a href="#第51条、优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类" class="headerlink" title="第51条、优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类"></a>第51条、优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</h3><p>通过元类自动修饰那个类的所有方法。例如，下面的就是这样一个元类，它可以拦截利用本类所写的新类型，并把那个类型里面的每个函数或方法都分别封装到trace_func修饰器之中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">trace_types = (</span><br><span class="line">types.MethodType,</span><br><span class="line">  types.FunctionType,</span><br><span class="line">  types.BuiltinFunctionType,</span><br><span class="line">  types.BuiltinMethodType,</span><br><span class="line">  types.MethodDescriptorType,</span><br><span class="line">  types.ClassMethodDescriptorType</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">    klass = super().__new__(meta, name, bases, class_dict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dir(klass):</span><br><span class="line">      value = getattr(klass, key)</span><br><span class="line">      <span class="keyword">if</span> isinstance(value, trace_types):</span><br><span class="line">        wrapped = trace_func(value)</span><br><span class="line">        setattr(klass, key, wrapped)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> klass</span><br></pre></td></tr></table></figure><p>现在，我们只需要让子类继承dict，并把刚写的TraceMeta当作子类的metaclass就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceDict</span><span class="params">(dict, metaclass=TraceMeta)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">trace_dict = TraceDict([(<span class="string">'hi'</span>, <span class="number">1</span>)])</span><br><span class="line">trace_dict[<span class="string">'there'</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这种办法确实有效，而且还把前面的实现方案中忘记修饰的<strong>new</strong>方法也自动修饰了。但如果子类所继承的那个超类本身已经指定了它自己的metaclass，这次程序无法运行，因为子类的metaclass是TraceMeta，而超类的metaclass是OtherMeta，但TraceMeta并不是从OtherMeta里面继承来的。从理论上讲，我们可以让TraceMeta继承OtherMeta，从而解决这个问题。</p><p>然而，如果TraceMeta不是我们自己写的，而是来自某个程序库，那就没办法手工修改它了。另外，如果想同时使用多个像TraceMeta这样的元类所提供的逻辑，那么这套方案无法满足需求，因为在定义类的时候，metaclass后面只能写一个元类。总之，这个方案对受元类控制的子类提出了过多的要求。</p><p>为此，我们可以换一种方案，也就是改用类修饰器（class decorator）来实现。这种修饰器与函数修饰器相似，都通过@符号来施加，但它并不施加在函数上面，而是施加在类的上面。编写类修饰器时，我们可以修改或重建它所修饰的类，并通过return语句返回处理结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_class_decorator</span><span class="params">(klass)</span>:</span></span><br><span class="line">  klass.extra_param = <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">return</span> klass</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_class_decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>现在就来实现这样一个类修饰器，它可以施加在类上面，让该类的所有方法与函数都能自动封装在trace_func之中。这个类修饰器本身是个独立的函数，它的代码基本上可以沿用早前所写的<code>TraceMeta.__new__</code>。这套方案要比采用元类实现的方案简单得多。</p><p>类修饰器其实就是个函数，只不过它可以通过参数获知自己所修饰的类，从而重建或调整这个类并返回修改结果。如果要给类中的每个方法或属性都施加一套逻辑，而且还想尽量少写一些例行代码，那么类修饰器是个很值得考虑的方案。元类之间很难组合，而类修饰器则比较灵活，它们可以施加在同一个类上，并且不会发生冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-31-～-51-条（函数、类）读书笔记&quot;&gt;&lt;a href=&quot;#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="http://blog.michealwayne.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 1 ～ 30 条读书笔记</title>
    <link href="http://blog.michealwayne.cn/2024/03/17/python/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E4%BB%A3%E7%A0%81%E7%9A%8490%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B-1%E8%87%B330/"/>
    <id>http://blog.michealwayne.cn/2024/03/17/python/【笔记】《编写高质量Python代码的90个有效方法》-1至30/</id>
    <published>2024-03-17T03:39:54.000Z</published>
    <updated>2024-04-16T10:54:12.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-1-～-30-条读书笔记"><a href="#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-1-～-30-条读书笔记" class="headerlink" title="【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 1 ～ 30 条读书笔记"></a>【笔记】Effective Python《编写高质量 Python 代码的 90 个有效方法》——第 1 ～ 30 条读书笔记</h1><p>（书基于 Python 3.7+ 语法规范）</p><p>知识点概括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pythonic、PEP 8、Pylint</span><br><span class="line">插值格式字符串(f-string)</span><br><span class="line">enumerate、zip函数</span><br><span class="line">海象操作符（walrus operator）</span><br><span class="line">切片somelist[start:end:stride]</span><br><span class="line">带星号的表达式（starred expression）</span><br><span class="line">Dict setdefault()、defaultdict</span><br><span class="line">闭包、nonlocal、关键字来指定的参数、按位置传递的参数</span><br><span class="line">functools.wraps、修饰器</span><br></pre></td></tr></table></figure><h2 id="1-培养-Pythonic-思维"><a href="#1-培养-Pythonic-思维" class="headerlink" title="1.培养 Pythonic 思维"></a>1.培养 Pythonic 思维</h2><p>Python 开发界用 Pythonic 这个词形容具有特定风格的代码，是大家在使用 Python 语言及合作的过程中逐渐形成的习惯。</p><h3 id="1-1-第-1-条、查询自己使用的-Python-版本"><a href="#1-1-第-1-条、查询自己使用的-Python-版本" class="headerlink" title="1.1 第 1 条、查询自己使用的 Python 版本"></a>1.1 第 1 条、查询自己使用的 Python 版本</h3><p>命令行：</p><p>Python 2.x：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>Python 3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.version_info)</span><br><span class="line">print(sys.version)</span><br></pre></td></tr></table></figure><blockquote><p>最后一个稳定的 Python 2 版本是 2.7.17</p></blockquote><h3 id="第-2-条、遵循-PEP-8-风格指南"><a href="#第-2-条、遵循-PEP-8-风格指南" class="headerlink" title="第 2 条、遵循 PEP 8 风格指南"></a>第 2 条、遵循 PEP 8 风格指南</h3><p>Python Enhancement Proposal #8 叫作 PEP 8，它是一份针对 Python 代码格式而编订的风格指南。地址：<a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008</a></p><p>采用一致的风格可以使代码更易读、更易懂。</p><p>比如以下几条规则：</p><h4 id="与空白有关的建议"><a href="#与空白有关的建议" class="headerlink" title="与空白有关的建议"></a>与空白有关的建议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用空格（space）表示缩进，而不要用制表符（tab）。</span><br><span class="line">和语法相关的每一层缩进都用4个空格表示。每行不超过79个字符。</span><br><span class="line">对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常的缩进级别之上再加4个空格。</span><br><span class="line">在同一份文件中，函数与类之间用两个空行隔开。</span><br><span class="line">在同一个类中，方法与方法之间用一个空行隔开。</span><br><span class="line">使用字典时，键与冒号之间不加空格，写在同一行的冒号和值之间应该加一个空格。</span><br><span class="line">给变量赋值时，赋值符号的左边和右边各加一个空格，并且只加一个空格就好。</span><br><span class="line">给变量的类型做注解（annotation）时，不要把变量名和冒号隔开，但在类型信息前应该有一个空格。</span><br></pre></td></tr></table></figure><h4 id="与命名有关的建议"><a href="#与命名有关的建议" class="headerlink" title="与命名有关的建议"></a>与命名有关的建议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数、变量及属性用小写字母来拼写，各单词之间用下划线相连，例如：lowercase_underscore。</span><br><span class="line">受保护的实例属性，用一个下划线开头，例如：_leading_underscore。</span><br><span class="line">私有的实例属性，用两个下划线开头，例如：__double_leading_underscore。</span><br><span class="line">类（包括异常）命名时，每个单词的首字母均大写，例如：CapitalizedWord。</span><br><span class="line">模块级别的常量，所有字母都大写，各单词之间用下划线相连，例如：ALL_CAPS。</span><br><span class="line">类中的实例方法，应该把第一个参数命名为self，用来表示该对象本身。</span><br><span class="line">类方法的第一个参数，应该命名为cls，用来表示这个类本身。</span><br></pre></td></tr></table></figure><h4 id="与表达式和语句有关的建议"><a href="#与表达式和语句有关的建议" class="headerlink" title="与表达式和语句有关的建议"></a>与表达式和语句有关的建议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用行内否定，即把否定词直接写在要否定的内容前面，而不要放在整个表达式的前面，例如应该写if a is not b，而不是if not a is b。</span><br><span class="line">不要通过长度判断容器或序列是不是空的，例如不要通过if len(somelist) == 0判断somelist是否为[]或&apos;&apos;等空值，而是应该采用if not somelist这样的写法来判断，因为Python会把空值自动评估为False。</span><br><span class="line">如果要判断容器或序列里面有没有内容（比如要判断somelist是否为[1]或&apos;hi&apos;这样非空的值），也不应该通过长度来判断，而是应该采用if somelist语句，因为Python会把非空的值自动判定为True。</span><br><span class="line">不要把if语句、for循环、while循环及except复合语句挤在一行。应该把这些语句分成多行来写，这样更加清晰。如果表达式一行写不下，可以用括号将其括起来，而且要适当地添加换行与缩进以便于阅读。</span><br><span class="line">多行的表达式，应该用括号括起来，而不要用\符号续行。</span><br></pre></td></tr></table></figure><h4 id="与引入有关的建议"><a href="#与引入有关的建议" class="headerlink" title="与引入有关的建议"></a>与引入有关的建议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import语句（含from x import y）总是应该放在文件开头。</span><br><span class="line">引入模块时，总是应该使用绝对名称，而不应该根据当前模块路径来使用相对名称。例如，要引入bar包中的foo模块，应该完整地写出from bar import foo，即便当前路径为bar包里，也不应该简写为import foo。</span><br><span class="line">如果一定要用相对名称来编写import语句，那就应该明确地写成：from . import foo。</span><br><span class="line">文件中的import语句应该按顺序划分成三个部分：首先引入标准库里的模块，然后引入第三方模块，最后引入自己的模块。属于同一个部分的import语句按字母顺序排列。</span><br></pre></td></tr></table></figure><blockquote><p>Pylint（<a href="https://www.pylint.org/）是一款流行的Python源码静态分析工具。它可以自动检查受测代码是否符合PEP" target="_blank" rel="noopener">https://www.pylint.org/）是一款流行的Python源码静态分析工具。它可以自动检查受测代码是否符合PEP</a> 8 风格指南</p></blockquote><h3 id="第-3-条、了解-bytes-与-str-的区别"><a href="#第-3-条、了解-bytes-与-str-的区别" class="headerlink" title="第 3 条、了解 bytes 与 str 的区别"></a>第 3 条、了解 bytes 与 str 的区别</h3><p>Python 有两种类型可以表示字符序列：一种是 bytes，另一种是 str。bytes 实例包含的是原始数据，即 8 位的无符号值（通常按照 ASCII 编码标准来显示）。</p><p>str 实例包含的是 Unicode 码点（code point，也叫作代码点），这些码点与人类语言之中的文本字符相对应。</p><p>str 实例不一定非要用某一种固定的方案编码成二进制数据，bytes 实例也不一定非要按照某一种固定的方案解码成字符串。要把 Unicode 数据转换成二进制数据，必须调用 str 的 encode 方法。要把二进制数据转换成 Unicode 数据，必须调用 bytes 的 decode 方法。</p><p>编写 Python 程序的时候，一定要把解码和编码操作放在界面最外层来做，让程序的核心部分可以使用 Unicode 数据来运作，这种办法通常叫作 Unicode 三明治（Unicode sandwich）。程序的核心部分，应该用 str 类型来表示 Unicode 数据，并且不要锁定到某种字符编码上面。这样可以让程序接受许多种文本编码（例如 Latin-1、Shift JIS 及 Big5），并把它们都转化成 Unicode，也能保证输出的文本信息都是用同一种标准（最好是 UTF-8）编码的。</p><p>两种不同的字符类型与 Python 中两种常见的使用情况相对应：</p><ul><li>开发者需要操作原始的 8 位值序列，序列里面的这些 8 位值合起来表示一个应该按 UTF-8 或其他标准编码的字符串。开发者需要操作通用的 Unicode 字符串，而不是操作某种特定编码的字符串。</li></ul><p>我们通常需要编写两个辅助函数（helper function），以便在这两种情况之间转换，确保输入值类型符合开发者的预期形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辅助函数接受bytes或str实例，并返回str：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> isinstance(bytes_or_str, bytes):</span><br><span class="line">    value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    value = bytes_or_str</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">print(repr(to_str(<span class="string">b'foo'</span>)));<span class="comment"># 'foo'</span></span><br><span class="line">print(repr(to_str(<span class="string">'bar'</span>)));<span class="comment"># 'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也接受bytes或str实例，但它返回的是bytes：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">    value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    value = bytes_or_str</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">print(repr(to_bytes(<span class="string">b'foo'</span>)));</span><br><span class="line">print(repr(to_bytes(<span class="string">'bar'</span>)))</span><br></pre></td></tr></table></figure><p>可以用<code>+</code>操作符将 bytes 添加到 bytes，str 也可以这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">b'one'</span> + <span class="string">b'two'</span>);<span class="comment"># b'onetwo'</span></span><br><span class="line">print(<span class="string">'one'</span> + <span class="string">'two'</span>); <span class="comment"># 'onetwo'</span></span><br></pre></td></tr></table></figure><p>但是不能将 str 实例添加到 bytes 实例，但是不能将 str 实例添加到 bytes 实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'one'</span> + <span class="string">'two'</span>  <span class="comment"># TypeError</span></span><br><span class="line"><span class="string">'one'</span> + <span class="string">b'two'</span><span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure><p>判断 bytes 与 str 实例是否相等，总是会评估为假（<code>False</code>），即便这两个实例表示的字符完全相同，它们也不相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'foo'</span> == <span class="string">'foo'</span>  <span class="comment"># false</span></span><br></pre></td></tr></table></figure><p>如果格式字符串是 bytes 类型，那么不能用 str 实例来替换其中的<code>%s</code>，因为 Python 不知道这个 str 应该按照什么方案来编码。但反过来却可以，也就是说如果格式字符串是 str 类型，则可以用 bytes 实例来替换其中的%s，问题是，这可能跟你想要的结果不一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'red %s'</span> % <span class="string">b'blue'</span>)  <span class="comment"># red b'blue'</span></span><br></pre></td></tr></table></figure><p>这样做，会让系统在 bytes 实例上面调用<code>__repr__</code>方法，然后用这次调用所得到的结果替换格式字符串里的%s，因此程序会直接输出<code>b&#39;blue&#39;</code>，而不是像你想的那样，输出 blue 本身。</p><p>第二个问题发生在操作文件句柄的时候，这里的句柄指由内置的 open 函数返回的句柄。这样的句柄默认需要使用 Unicode 字符串操作，而不能采用原始的 bytes。</p><p>从文件中读取二进制数据（或者把二进制数据写入文件）时，应该用<code>&#39;rb&#39;</code>（<code>&#39;wb&#39;</code>）这样的二进制模式打开文件。如果要从文件中读取（或者要写入文件之中）的是 Unicode 数据，那么必须注意系统默认的文本编码方案。若无法肯定，可通过 encoding 参数明确指定。</p><h3 id="第-4-条、用支持插值的-f-string-取代-C-风格的格式字符串与-str-format-方法"><a href="#第-4-条、用支持插值的-f-string-取代-C-风格的格式字符串与-str-format-方法" class="headerlink" title="第 4 条、用支持插值的 f-string 取代 C 风格的格式字符串与 str.format 方法"></a>第 4 条、用支持插值的 f-string 取代 C 风格的格式字符串与 str.format 方法</h3><p>格式化（formatting）是指把数据填写到预先定义的文本模板里面，形成一条用户可读的消息，并把这条消息保存成字符串的过程。</p><p>Python 里面最常用的字符串格式化方式是采用%格式化操作符。这个操作符左边的文本模板叫作格式字符串（format string），我们可以在操作符右边写上某个值或者由多个值所构成的元组（tuple），用来替换格式字符串里的相关符号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过%操作符把难以阅读的二进制和十六进制数值，显示成十进制的形式。</span></span><br><span class="line">a = <span class="number">0b10111011</span></span><br><span class="line">b = <span class="number">0xc5f</span></span><br><span class="line">print(<span class="string">'Binary is %d, hex is %d'</span> % (a, b))<span class="comment"># Binary is 187, hex is 3167</span></span><br></pre></td></tr></table></figure><p>格式字符串里面可以出现%d 这样的格式说明符，这些说明符的意思是，<code>%</code>右边的对应数值会以这样的格式来替换这一部分内容。</p><p>C 风格的格式字符串，在 Python 里有四个缺点。</p><ul><li>如果%右侧那个元组里面的值在类型或顺序上有变化，那么程序可能会因为转换类型时发生不兼容问题而出现错误。要想避免这种问题，必须经常检查%操作符左右两侧的写法是否相互兼容。这个过程很容易出错，因为每次修改完之后都要手工检查一遍。</li><li>在填充模板之前，经常要先对准备填写进去的这个值稍微做一些处理，但这样一来，整个表达式可能就会写得很长，让人觉得比较混乱。</li><li>如果想用同一个值来填充格式字符串里的多个位置，那么必须在%操作符右侧的元组中相应地多次重复该值。</li><li>把 dict 写到格式化表达式里面会让代码变多。</li></ul><p>为了解决上面提到的一些问题，Python 的<code>%</code>操作符允许我们用 dict 取代 tuple</p><p>例如<code>%(key)s</code>这个说明符，意思就是用字符串（<code>s</code>）来表示 dict 里面名为 key 的那个键所保存的值。但是，这种写法会让刚才讲的第二个缺点变得更加严重，因为字典格式字符串的引入，我们必须给每一个值都定义键名，而且要在键名的右侧加冒号，格式化表达式变得更加冗长，看起来也更加混乱。</p><h4 id="内置的-format-函数与-str-类的-format-方法："><a href="#内置的-format-函数与-str-类的-format-方法：" class="headerlink" title="内置的 format 函数与 str 类的 format 方法："></a>内置的 format 函数与 str 类的 format 方法：</h4><p>Python 3 添加了高级字符串格式化（advanced string formatting）机制，它的表达能力比老式 C 风格的格式字符串要强，且不再使用<code>%</code>操作符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1234.5678</span></span><br><span class="line">formatted = format(a, <span class="string">',.2f'</span>)</span><br><span class="line">print(formatted)<span class="comment"># 1,234.57</span></span><br><span class="line"></span><br><span class="line">b = <span class="string">'my string'</span></span><br><span class="line">formatted = format(b, <span class="string">'^20s'</span>)</span><br><span class="line">print(<span class="string">'*'</span>, formatted, <span class="string">'*'</span>)<span class="comment"># *       my string       *</span></span><br></pre></td></tr></table></figure><p>但是<code>str.format</code>方法还是没有能够把 Python 表达式的优势充分发挥出来。</p><h4 id="插值格式字符串："><a href="#插值格式字符串：" class="headerlink" title="插值格式字符串："></a>插值格式字符串：</h4><p>插值格式字符串（interpolated format string，简称 f-string），可以解决上面提到的所有问题。新语法特性要求在格式字符串的前面加字母<code>f</code>作为前缀，这跟字母<code>b</code>与字母<code>r</code>的用法类似，也就是分别表示字节形式的字符串与原始的（或者说未经转义的）字符串的前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">'my_var'</span></span><br><span class="line">value = <span class="number">1.234</span></span><br><span class="line"></span><br><span class="line">formatted = <span class="string">f'<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>'</span></span><br><span class="line">print(formatted)<span class="comment"># my_var = 1.234</span></span><br></pre></td></tr></table></figure><p><code>str.format</code>方法所支持的那套迷你语言，也就是在<code>{}</code>内的冒号右侧所采用的那套规则，现在也可以用到 f-string 里面，而且还可以像早前使用<code>str.format</code>时那样，通过<code>!</code>符号把值转化成 Unicode 及 repr 形式的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formatted = <span class="string">f'<span class="subst">&#123;key!r:&lt;<span class="number">10</span>&#125;</span> = <span class="subst">&#123;value:<span class="number">.2</span>f&#125;</span>'</span></span><br><span class="line">print(formatted)<span class="comment"># 'my_var' = 1.23</span></span><br></pre></td></tr></table></figure><p><strong>如果你想把值以适当的格式填充到字符串里面，那么首先应该考虑的就是采用 f-string 来实现。</strong></p><h3 id="第-5-条、用辅助函数取代复杂的表达式"><a href="#第-5-条、用辅助函数取代复杂的表达式" class="headerlink" title="第 5 条、用辅助函数取代复杂的表达式"></a>第 5 条、用辅助函数取代复杂的表达式</h3><p>如果你发现表达式越写越复杂，那就应该考虑把它拆分成多个部分，并且把这套逻辑写到辅助函数里面。这样虽然要多编几行代码，但可以让程序更加清晰，所以总体来说还是值得的。</p><p>语法简洁的 Python 虽然可以写出很多浓缩的句式，但应该避免让这样的写法把表达式弄得太复杂。我们要遵循 DRY 原则，也就是不要重复自己写过的代码（Don’t Repeat Yourself）。</p><h3 id="第-6-条、把数据结构直接拆分到多个变量里，不要专门通过下标访问"><a href="#第-6-条、把数据结构直接拆分到多个变量里，不要专门通过下标访问" class="headerlink" title="第 6 条、把数据结构直接拆分到多个变量里，不要专门通过下标访问"></a>第 6 条、把数据结构直接拆分到多个变量里，不要专门通过下标访问</h3><p>Python 还有一种写法，叫作拆分（unpacking）。这种写法让我们只用一条语句，就可以把元组里面的元素分别赋给多个变量。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item = (<span class="string">'A'</span>, <span class="string">'B'</span>)</span><br><span class="line">first, second = item</span><br></pre></td></tr></table></figure><p>通过 unpacking 来赋值要比通过下标去访问元组内的元素更清晰，而且这种写法所需的代码量通常比较少，这样可以让代码更简洁、更清晰。</p><h3 id="第-7-条、尽量用-enumerate-取代-range"><a href="#第-7-条、尽量用-enumerate-取代-range" class="headerlink" title="第 7 条、尽量用 enumerate 取代 range"></a>第 7 条、尽量用 enumerate 取代 range</h3><p>range 函数适合用来迭代一系列整数。</p><p>enumerate 能够把任何一种迭代器（iterator）封装成惰性生成器。这样的话，每次循环的时候，它只需要从 iterator 里面获取下一个值就行了，同时还会给出本轮循环的序号，即生成器每次产生的一对输出值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flavor_list = [<span class="string">'vanilla'</span>, <span class="string">'chocolate'</span>, <span class="string">'pecan'</span>]</span><br><span class="line">it = enumerate(flavor_list)</span><br><span class="line">print(next(it))  <span class="comment"># (0, 'vanilla')</span></span><br><span class="line">print(next(it))<span class="comment"># (1, 'chocolate')</span></span><br></pre></td></tr></table></figure><p>enumerate 输出的每一对数据，都可以拆分（unpacking）到 for 语句的那两个变量里面，这样会让代码更加清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>: <span class="subst">&#123;flavor&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>另外，还可以通过 enumerate 的第二个参数指定起始序号，这样就不用在每次打印的时候去调整了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> enumerate(flavor_list, <span class="number">1</span>):</span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;flavor&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h3 id="第-8-条、用-zip-函数同时遍历两个迭代器"><a href="#第-8-条、用-zip-函数同时遍历两个迭代器" class="headerlink" title="第 8 条、用 zip 函数同时遍历两个迭代器"></a>第 8 条、用 zip 函数同时遍历两个迭代器</h3><p>写 Python 代码时，经常会根据某份列表中的对象创建许多与这份列表有关的新列表。下面这样的列表推导机制，可以把表达式运用到源列表的每个元素上面，从而生成一份派生列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilla'</span>, <span class="string">'List'</span>, <span class="string">'Marie'</span>]</span><br><span class="line">counts = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">print(counts)<span class="comment"># [7, 4, 5]</span></span><br></pre></td></tr></table></figure><p>派生列表中的元素与源列表中对应位置上面的元素有着一定的关系。如果想同时遍历这两份列表，那可以根据源列表的长度做迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(names)):</span><br><span class="line">  count = counts[i]</span><br><span class="line">  <span class="keyword">if</span> count &gt; max_count:</span><br><span class="line">    longest_name = names[i]</span><br><span class="line">    max_count = count</span><br><span class="line"></span><br><span class="line">print(longest_name)// Cecilia</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，整个循环代码看起来很乱。我们要通过下标访问 names 与 counts 这两个列表里的元素，所以表示下标的那个循环变量 i 在循环体里必须出现两次，这让代码变得不太好懂。改用 enumerate 实现会稍微好一些，但仍然不够理想。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names):</span><br><span class="line">  count = counts[i]</span><br><span class="line">  <span class="keyword">if</span> count &gt; max_count:</span><br><span class="line">    longest_name = name</span><br><span class="line">    max_count = count</span><br></pre></td></tr></table></figure><p>为了把代码写得更清楚，可以用 Python 内置的 zip 函数来实现。这个函数能把两个或更多的 iterator 封装成惰性生成器（lazy generator）。每次循环时，它会分别从这些迭代器里获取各自的下一个元素，并把这些值放在一个元组里面。而这个元组可以拆分到 for 语句里的那些变量之中。这样写出来的代码，比通过下标访问多个列表的那种代码要清晰得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, counts):</span><br><span class="line">  <span class="keyword">if</span> count &gt; max_count:</span><br><span class="line">    longest_name = name</span><br><span class="line">    max_count = count</span><br></pre></td></tr></table></figure><p>zip 每次只从它封装的那些迭代器里面各自取出一个元素，所以即便源列表很长，程序也不会因为占用内存过多而崩溃。</p><p>但是，如果输入 zip 的那些列表的长度不一致，那就得小心了。因为 zip 函数本来就是这样设计的：只要其中任何一个迭代器处理完毕，它就不再往下走了。</p><p>在列表长度不同的情况下，zip 函数的提前终止行为可能跟你想实现的效果不一样。所以，如果无法确定这些列表的长度相同，那就不要把它们传给 zip，而是应该传给另一个叫作 zip_longest 的函数，这个函数位于内置的 itertools 模块里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> itertools.zip_longest(names, counts):</span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;count&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>如果其中有些列表已经遍历完了，那么 zip_longest 会用当初传给 fillvalue 参数的那个值来填补空缺（本例中空缺的为字符串’Rosalind’的长度值），默认的参数值是<code>None</code>。</p><h3 id="第-9-条、不要在-for-与-while-循环后面写-else-块"><a href="#第-9-条、不要在-for-与-while-循环后面写-else-块" class="headerlink" title="第 9 条、不要在 for 与 while 循环后面写 else 块"></a>第 9 条、不要在 for 与 while 循环后面写 else 块</h3><p>Python 的循环有一项大多数编程语言都不支持的特性，即可以把 else 块紧跟在整个循环结构的后面。奇怪的是，程序做完整个 for 循环之后，竟然会执行 else 块里的内容。既然是这样，那为什么要叫“else”呢？这应该叫“and”才对。</p><p>如果循环没有从头到尾执行完（也就是循环提前终止了），那么 else 块里的代码是不会执行的。在循环中使用 break 语句实际上会跳过 else 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">  print(<span class="string">'Loop'</span>, i)</span><br><span class="line">  <span class="keyword">if</span> i === <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'Else block'</span>)<span class="comment"># 这条语句不会执行</span></span><br></pre></td></tr></table></figure><p>还有一个奇怪的地方是，如果对空白序列做 for 循环，那么程序立刻就会执行 else 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> []:</span><br><span class="line">  print(<span class="string">'Never runs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'For else block'</span>);  <span class="comment"># 会执行</span></span><br></pre></td></tr></table></figure><p>while 循环也是这样，如果首次循环就遇到<code>False</code>，那么程序也会立刻运行 else 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">  print(<span class="string">'Never runs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'while Else block'</span>);  <span class="comment"># 会执行</span></span><br></pre></td></tr></table></figure><p>把 else 设计成这样，是想让你利用它实现搜索逻辑。例如，如果要判断两个数是否互质（也就是除了 1 之外，是不是没有别的数能够同时整除它们），就可以用这种结构实现。先把有可能同时整除它们的数逐个试一遍，如果全都试过之后还是没找到这样的数，那么循环就会从头到尾执行完（这意味着循环没有因为 break 而提前跳出），然后程序就会执行 else 块里的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, min(a, b) + <span class="number">1</span>):</span><br><span class="line">  print(<span class="string">'Testing'</span>, i)</span><br><span class="line">  <span class="keyword">if</span> a % i == <span class="number">0</span> <span class="keyword">and</span> b % i == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'Not coprime'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'Coprime'</span>)</span><br></pre></td></tr></table></figure><p>for/else 或 while/else 结构本身虽然可以实现某些逻辑表达，但它给读者（也包括你自己）带来的困惑，已经盖过了它的好处。因为 for 与 while 循环这种简单的结构，在 Python 里面读起来应该相当明了才对，如果把 else 块紧跟在它的后面，那就会让代码产生歧义。所以，请不要这么写。</p><h3 id="第-10-条、用赋值表达式减少重复代码"><a href="#第-10-条、用赋值表达式减少重复代码" class="headerlink" title="第 10 条、用赋值表达式减少重复代码"></a>第 10 条、用赋值表达式减少重复代码</h3><p>赋值表达式（assignment expression）是 Python 3.8 新引入的语法，它会用到海象操作符（walrus operator）。这种写法可以解决某些持续已久的代码重复问题。a = b 是一条普通的赋值语句，读作 a equals b，而 a := b 则是赋值表达式，读作 a walrus b。这个符号为什么叫 walrus 呢？因为把:=顺时针旋转 90º 之后，冒号就是海象的一双眼睛，等号就是它的一对獠牙。</p><p>这种表达式很有用，可以在普通的赋值语句无法应用的场合实现赋值，例如可以用在条件表达式的 if 语句里面。赋值表达式的值，就是赋给海象操作符左侧那个标识符的值。</p><p>举个例子。如果有一筐新鲜水果要给果汁店做食材，那我们就可以这样定义其中的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fresh_fruit = &#123;</span><br><span class="line">  <span class="string">'apple'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'banana'</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="string">'lemon'</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客点柠檬汁之前，我们先得确认现在还有没有柠檬可以榨汁。所以，要先查出柠檬的数量，然后用 if 语句判断它是不是非零的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lemonade</span><span class="params">(count)</span>:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out_of_stock</span><span class="params">()</span>:</span></span><br><span class="line">  ...</span><br><span class="line">count = fresh_fruit.get(<span class="string">'lemon'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> count:</span><br><span class="line">  make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  out_of_stock()</span><br></pre></td></tr></table></figure><p>这段代码看上去虽然简单，但还是显得有点儿松散，因为 count 变量虽然定义在整个 if/else 结构之上，然而只有 if 语句才会用到它，else 块根本就不需要使用这个变量。所以，这种写法让人误以为 count 是个重要的变量，if 和 else 都要用到它，但实际上并非如此。</p><p>我们在 Python 里面经常要先获取某个值，然后判断它是否非零，如果是就执行某段代码。对于这种用法，我们以前总是要通过各种技巧，来避免 count 这样的变量重复出现在代码之中，这些技巧有时会让代码变得比较难懂（参考第 5 条里面提到的那些技巧）。Python 引入赋值表达式正是为了解决这样的问题。下面改用海象操作符来写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> count := fresh_fruit.get(<span class="string">'lemon'</span>, <span class="number">0</span>):</span><br><span class="line">  make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  out_of_stock()</span><br></pre></td></tr></table></figure><p>这种写法明确体现出 count 变量只与 if 块有关。这个赋值表达式先把:=右边的值赋给左边的 count 变量，然后对自身求值，也就是把变量的值当成整个表达式的值。由于表达式紧跟着 if，程序会根据它的值是否非零来决定该不该执行 if 块。这种先赋值再判断的做法，正是海象操作符想要表达的意思。</p><p>柠檬汁效力强，所以只需要一颗柠檬就能做完这份订单，这意味着程序只需判断非零即可。如果客人点的是苹果汁，那就至少得用四个苹果才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count := fresh_fruit.get(<span class="string">'apple'</span>, <span class="number">0</span>)) &gt;= <span class="number">4</span>:</span><br><span class="line">  make_cider(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  out_of_stock()</span><br></pre></td></tr></table></figure><p>但是这次，我们还要注意另外一个现象：赋值表达式本身是放在一对括号里面的。为什么要这样做呢？因为我们要在 if 语句里面把这个表达式的结果跟 4 这个值相比较。刚才柠檬汁的例子没有加括号，因为那时只凭赋值表达式本身的值就能决定 if/else 的走向：只要表达式的值不是 0，程序就进入 if 分支。但是这次不行，这次要把这个赋值表达式放在更大的表达式里面，所以必须用括号把它括起来。当然，在没有必要加括号的情况下，还是尽量别加括号比较好。</p><p>Python 新手经常会遇到这样一种困难，就是找不到好办法来实现 switch/case 结构。最接近这种结构的做法是在 if/else 结构里面继续嵌套 if/else 结构，或者使用 if/elif/else 结构。</p><p>例如，我们想按照一定的顺序自动给客人制作饮品，这样就不用点餐了。下面这段逻辑先判断能不能做香蕉冰沙，如果不能，就做苹果汁，还不行，就做柠檬汁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">count = fresh_fruit.get(<span class="string">'banana'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">2</span>:</span><br><span class="line">  pieces = slice_bananas(count)</span><br><span class="line">  to_enjoy = make_smoothies(pieces)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  count = fresh_fruit.get(<span class="string">'apple'</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> count &gt; <span class="number">4</span>:</span><br><span class="line">    to_enjoy = make_cider(count)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    count = fresh_fruit.get(<span class="string">'lemon'</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> count:</span><br><span class="line">      to_enjoy = make_lemonade(count)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      to_enjoy = <span class="string">'Nothing'</span></span><br></pre></td></tr></table></figure><p>幸好现在有了海象操作符，让我们能够轻松地模拟出很接近 switch/case 的方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count := fresh_fruit.get(<span class="string">'banana'</span>, <span class="number">0</span>)) &gt;= <span class="number">2</span>:</span><br><span class="line">  pieces = slice_bananas(count)</span><br><span class="line">  to_enjoy = make_smoothies(pieces)</span><br><span class="line"><span class="keyword">elif</span> (count := fresh_fruit.get(<span class="string">'apple'</span>, <span class="number">0</span>)) &gt;= <span class="number">4</span>:</span><br><span class="line">  to_enjoy = make_cider(count)</span><br><span class="line"><span class="keyword">elif</span> count := fresh_fruit.get(<span class="string">'lemon'</span>, <span class="number">0</span>):</span><br><span class="line">  to_enjoy = make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  to_enjoy = <span class="string">'Nothing'</span></span><br></pre></td></tr></table></figure><p>只要碰到刚才那种难看的结构，我们就应该考虑能不能改用海象操作符来写。</p><p>Python 新手还会遇到一个困难，就是缺少 do/while 循环结构。例如，我们要把新来的水果做成果汁并且装到瓶子里面，直到水果用完为止。下面先用普通的 while 循环来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick_fruit</span><span class="params">()</span>:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_juice</span><span class="params">(fruit, count)</span>:</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">bottles = []</span><br><span class="line">fresh_fruit = pick_fruit()</span><br><span class="line"><span class="keyword">while</span> fresh_fruit:</span><br><span class="line">  <span class="keyword">for</span> fruit, count <span class="keyword">in</span> fresh_fruit.items()</span><br><span class="line">  batch = make_juice(fruit, count)</span><br><span class="line">    botties.extend(batch)</span><br><span class="line">  fresh_fruit = pick_fruit()</span><br></pre></td></tr></table></figure><p>有了海象操作符，我们可以在每轮循环的开头给 fresh_fruit 变量赋值，并根据变量的值来决定要不要继续循环。这个写法简单易读，所以应该成为首选方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bottles = []</span><br><span class="line"><span class="keyword">while</span> fresh_fruit := pick_fruit():</span><br><span class="line">    <span class="keyword">for</span> fruit, count <span class="keyword">in</span> fresh_fruit.items():</span><br><span class="line">      batch = make_juice(fruit, count)</span><br><span class="line">      bottles.extend(batch)</span><br></pre></td></tr></table></figure><p>总之，如果某个表达式或赋值操作多次出现在一组代码里面，那就可以考虑用赋值表达式把这段代码改得简单一些。</p><hr><h2 id="2-列表与字典"><a href="#2-列表与字典" class="headerlink" title="2. 列表与字典"></a>2. 列表与字典</h2><h3 id="第-11-条、学会对序列做切片"><a href="#第-11-条、学会对序列做切片" class="headerlink" title="第 11 条、学会对序列做切片"></a>第 11 条、学会对序列做切片</h3><p>Python 有这样一种写法，可以从序列里面切割（slice）出一部分内容，让我们能够轻松地获取原序列的某个子集合。最简单的用法就是切割内置的 list、str 与 bytes。其实，凡是实现了<code>__getitem__</code>与<code>__setitem__</code>这两个特殊方法的类都可以切割。</p><p>最基本的写法是用<code>somelist[start:end]</code>这一形式来切割，也就是从 start 开始一直取到 end 这个位置，但不包含 end 本身的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</span><br><span class="line">print(<span class="string">'Middle two:  '</span>, a[<span class="number">3</span>:<span class="number">5</span>])<span class="comment"># Middle two:  ['d', 'e']</span></span><br><span class="line">print(<span class="string">'All but ends:'</span>, a[<span class="number">1</span>:<span class="number">7</span>])<span class="comment"># All but ends: ['b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure><p>如果是从头开始切割列表，那就应该省略冒号左侧的下标 0，这样看起来更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> a[:<span class="number">5</span>] == a[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>如果一直取到列表末尾，那就应该省略冒号右侧的下标，因为用不着专门把它写出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> a[<span class="number">5</span>:] == a[<span class="number">5</span>:len(a)]</span><br></pre></td></tr></table></figure><p>用负数作下标表示从列表末尾往前算。</p><p>如果起点与终点所确定的范围超出了列表的边界，那么系统会自动忽略不存在的元素。利用这项特性，很容易就能构造出一个最多只有若干元素的输入序列。</p><p>用带负号的下标来切割列表，只有在个别情况下才会出现奇怪的效果。只要 n 大于或等于 1，<code>somelist[-n:]</code>总是可以切割出你想要的切片。只有当 n 为 0 的时候，才需要特别注意。此时<code>somelist[-0:]</code>其实相当于<code>somelist[0:]</code>，所以跟<code>somelist[:]</code>一样，会制作出原列表的一份副本。</p><h3 id="第-12-条、不要在切片里同时指定起止下标与步进"><a href="#第-12-条、不要在切片里同时指定起止下标与步进" class="headerlink" title="第 12 条、不要在切片里同时指定起止下标与步进"></a>第 12 条、不要在切片里同时指定起止下标与步进</h3><p>Python 还有一种特殊的步进切片形式，也就是<code>somelist[start:end:stride]</code>。这种形式会在每 n 个元素里面选取一个，这样很容易就能把奇数位置上的元素与偶数位置上的元素分别通过<code>x[::2]</code>与<code>x[1::2]</code>选取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'purple'</span>]</span><br><span class="line">odds = x[::<span class="number">2</span>]<span class="comment"># ['red', 'yellow', 'blue']</span></span><br><span class="line">evens = x[<span class="number">1</span>::<span class="number">2</span>]<span class="comment"># ['orange', 'green', 'purple']</span></span><br></pre></td></tr></table></figure><p>带有步进的切片经常会引发意外的效果，并且使程序出现 bug。例如，Python 里面有个常见的技巧，就是把-1 当成步进值对 bytes 类型的字符串做切片，这样就能将字符串反转过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'mongooose'</span></span><br><span class="line">y = x[::<span class="number">-1</span>]<span class="comment"># b'esoognom'</span></span><br></pre></td></tr></table></figure><p>Unicode 形式字符串也可以这样反转，但如果把这种字符串编码成 UTF-8 标准的字节数据，就不能用这个技巧来反转了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="string">'寿司'</span></span><br><span class="line">x = w.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">y = x[::<span class="number">-1</span>]<span class="comment"># UnicodeDecodeError</span></span><br><span class="line">z = y.decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>同时使用起止下标与步进会让切片很难懂。方括号里面写三个值显得太过拥挤，读起来不大容易，而且在指定了步进值（尤其是负数步进值）的时候，我们必须很仔细地考虑：这究竟是从前往后取，还是从后往前取。</p><p>建议大家不要把起止下标和步进值同时写在切片里。如果必须指定步进，那么尽量采用正数，而且要把起止下标都留空。即便必须同时使用步进值与起止下标，也应该考虑分成两次来写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x[::<span class="number">2</span>]<span class="comment"># ['a', 'c', 'e', 'g']</span></span><br><span class="line">z = y[<span class="number">1</span>:<span class="number">-1</span>]<span class="comment"># ['c', 'e']</span></span><br></pre></td></tr></table></figure><p>像刚才那样先隔位选取然后再切割，会让程序多做一次浅拷贝（shallow copy）。所以，应该把最能缩减列表长度的那个切片操作放在前面。如果程序实在没有那么多时间或内存去分两步操作，那么可以改用内置的<code>itertools</code>模块中的<code>islice</code>方法，这个方法用起来更清晰，因为它的起止位置与步进值都不能是负数。</p><h3 id="第-13-条、通过带星号的-unpacking-操作来捕获多个元素，不要用切片"><a href="#第-13-条、通过带星号的-unpacking-操作来捕获多个元素，不要用切片" class="headerlink" title="第 13 条、通过带星号的 unpacking 操作来捕获多个元素，不要用切片"></a>第 13 条、通过带星号的 unpacking 操作来捕获多个元素，不要用切片</h3><p>基本的 unpacking 操作有一项限制，就是必须提前确定需要拆解的序列的长度。</p><p>Python 新手经常通过下标与切片来处理这个问题。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car_ages = [<span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">15</span>]</span><br><span class="line">car_ages_descending = sorted(car_ages, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">oldest = car_ages_descending[<span class="number">0</span>]</span><br><span class="line">second_oldest = car_ages_descending[<span class="number">1</span>]</span><br><span class="line">other = car_age_descending[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><p>这样做没问题，但是下标与切片会让代码看起来很乱。而且，用这种办法把序列中的元素分成多个子集合，其实很容易出错，因为我们通常容易把下标多写或少写一个位置。</p><p>这个问题通过带星号的表达式（starred expression）来解决会更好一些，这也是一种 unpacking 操作，它可以把无法由普通变量接收的那些元素全都囊括进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldest, second_oldest, *others = car_ages_descending</span><br></pre></td></tr></table></figure><p>这样写简短易读，而且不容易出错，因为它不要求我们在修改完其中一个下标之后，还必须记得同步更新其他的下标。这种带星号的表达式可以出现在任意位置，所以它能够捕获序列中的任何一段元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldest, *others, youngest = car_ages_descending</span><br></pre></td></tr></table></figure><p>只不过，在使用这种写法时，至少要有一个普通的接收变量与它搭配，否则就会出现<code>SyntaxError</code>。</p><p>另外，对于单层结构来说，同一级里面最多只能出现一次带星号的 unpacking。</p><p>这种带星号的表达式可以出现在赋值符号左侧的任意位置，它总是会形成一份含有零个或多个值的列表。在把列表拆解成互相不重叠的多个部分时，这种带星号的 unpacking 方式比较清晰，而通过下标与切片来实现的方式则很容易出错。</p><h3 id="第-14-条、用-sort-方法的-key-参数来表示复杂的排序逻辑"><a href="#第-14-条、用-sort-方法的-key-参数来表示复杂的排序逻辑" class="headerlink" title="第 14 条、用 sort 方法的 key 参数来表示复杂的排序逻辑"></a>第 14 条、用 sort 方法的 key 参数来表示复杂的排序逻辑</h3><p>内置的列表类型提供了名叫 sort 的方法，可以根据多项指标给 list 实例中的元素排序。</p><p>但是，一般的对象又该如何排序呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight)</span>:</span></span><br><span class="line">    self.name = name;</span><br><span class="line">    self.weight = weight</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Tool(<span class="subst">&#123;self.name!r&#125;</span>, <span class="subst">&#123;self.weight&#125;</span>)'</span></span><br><span class="line">tools = [</span><br><span class="line">  Tool(<span class="string">'level'</span>, <span class="number">3.5</span>),</span><br><span class="line">  Tool(<span class="string">'hammer'</span>, <span class="number">1.25</span>),</span><br><span class="line">  Tool(<span class="string">'screwdriver'</span>, <span class="number">0.5</span>),</span><br><span class="line">  Tool(<span class="string">'chisel'</span>, <span class="number">0.25</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果仅仅这样写，那么这个由该类的对象所构成的列表是没办法用 sort 方法排序的，因为 sort 方法发现，排序所需要的特殊方法并没有定义在 Tool 类中。</p><p>这些排序标准通常是针对对象中的某个属性（attribute）。我们可以把这样的排序逻辑定义成函数，然后将这个函数传给 sort 方法的 key 参数。key 所表示的函数本身应该带有一个参数，这个参数指代列表中有待排序的对象，函数返回的应该是个可比较的值（也就是具备自然顺序的值），以便 sort 方法以该值为标准给这些对象排序。下面用 lambda 关键字定义这样的一个函数，把它传给 sort 方法的 key 参数，让我们能够按照 name 的字母顺序排列这些 Tool 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools.sort(key=<span class="keyword">lambda</span> x: x.name)</span><br></pre></td></tr></table></figure><p>如果想改用另一项标准（比如 weight）来排序，那只需要再定义一个 lambda 函数并将其传给 sort 方法的 key 参数就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools.sort(key=<span class="keyword">lambda</span> x: x.weight)</span><br></pre></td></tr></table></figure><p>对于字符串这样的基本类型，我们可能需要通过 key 函数先对它的内容做一些变换，并根据变换之后的结果来排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">places = [<span class="string">'home'</span>, <span class="string">'work'</span>, <span class="string">'New York'</span>, <span class="string">'Paris'</span>]</span><br><span class="line">places.sort(key=<span class="keyword">lambda</span> x: x.lower())</span><br></pre></td></tr></table></figure><p>有时我们可能需要用多个标准来排序，最简单的方案是利用元组（tuple）类型实现。两个元组之间是可以比较的，因为这种类型本身已经定义了自然顺序。</p><p>元组在实现这些特殊方法时会依次比较每个位置的那两个对应元素，直到能够确定大小为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drill = (<span class="number">4</span>, <span class="string">'drill'</span>)</span><br><span class="line">sander = (<span class="number">4</span>, <span class="string">'sander'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> drill &lt; sander</span><br></pre></td></tr></table></figure><p>利用元组的这项特性，我们可以用工具的 weight 与 name 构造一个元组。下面就定义这样一个 lambda 函数，让它返回这种元组，把首要指标（也就是 weight）写在前面，把次要指标（也就是 name）写在后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power_tools.sort(key=<span class="keyword">lambda</span> x: (x.weight, x.name))</span><br></pre></td></tr></table></figure><p>这种做法有个缺点，就是 key 函数所构造的这个元组只能按同一个排序方向来对比它所表示的各项指标（要是升序，就都得是升序；要是降序，就都得是降序），所以不太好实现 weight 按降序排而 name 按升序排的效果。</p><p>sort 方法可以指定 reverse 参数，这个参数会同时影响元组中的各项指标（例如在下面的例子中，weight 与 name 都会按照降序处理，所以’sander’会出现在’drill’的前面，而不是像刚才的例子那样出现在后面）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">power_tools.sort(key=<span class="keyword">lambda</span> x:(x.weight, x.name),</span><br><span class="line">reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>如果其中一项指标是数字，那么可以在实现 key 函数时，利用一元减操作符让两个指标按照不同的方向排序。也就是说，key 函数在返回这个元组时，可以单独对这项指标取相反数，并保持其他指标不变，这就相当于让排序算法单独在这项指标上采用逆序。下面就演示怎样按照重量从大到小、名称从小到大的顺序排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power_tools.sort(key=<span class="keyword">lambda</span> x: (-x.weight, x.name))</span><br></pre></td></tr></table></figure><p>我们应该考虑 sort 方法的一项特征，那就是这个方法是个稳定的排序算法。这意味着，如果 key 函数认定两个值相等，那么这两个值在排序结果中的先后顺序会与它们在排序前的顺序一致。于是，我们可以在同一个列表上多次调用 sort 方法，每次指定不同的排序指标。下面我们就利用这项特征实现刚才想要达成的那种效果。把首要指标（也就是重量）降序放在第二轮，把次要指标（也就是名称）升序放在第一轮。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">power_tools.sort(key=<span class="keyword">lambda</span> x: x.name)</span><br><span class="line">power_tools.sort(key=<span class="keyword">lambda</span> x: x.weight,</span><br><span class="line">                 reverse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在实现多个指标按不同方向排序时，应该优先考虑让 key 函数返回元组，并对元组中的相应指标取相反数。只有在万不得已的时候，才可以考虑多次调用 sort 方法。</p><h3 id="第-15-条、不要过分依赖给字典添加条目时所用的顺序"><a href="#第-15-条、不要过分依赖给字典添加条目时所用的顺序" class="headerlink" title="第 15 条、不要过分依赖给字典添加条目时所用的顺序"></a>第 15 条、不要过分依赖给字典添加条目时所用的顺序</h3><p>在 Python 3.5 与之前的版本中，迭代字典（dict）时所看到的顺序好像是任意的，不一定与当初把这些键值对添加到字典时的顺序相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baby_names = &#123;</span><br><span class="line">  <span class="string">'cat'</span>: <span class="string">'kitten'</span>,</span><br><span class="line">  <span class="string">'dog'</span>: <span class="string">'puppy'</span>,</span><br><span class="line">&#125;</span><br><span class="line">print(baby_names)<span class="comment"># &#123;'dog': 'puppy', 'cat': 'kitten'&#125;</span></span><br></pre></td></tr></table></figure><p>每次看到的顺序不固定，因此很难在测试用例中使用。这会让调试工作变得困难，尤其是容易使 Python 新手感到困惑。</p><p>之所以出现这种效果，是因为字典类型以前是用哈希表算法来实现的（这个算法通过内置的 hash 函数与一个随机的种子数来运行，而该种子数会在每次启动 Python 解释器时确定）。所以，这样的机制导致这些键值对在字典中的存放顺序不一定会与添加时的顺序相同，而且每次运行程序的时候，存放顺序可能都不一样。</p><p><strong>从 Python 3.6 开始，字典会保留这些键值对在添加时所用的顺序，而且 Python 3.7 版的语言规范正式确立了这条规则。</strong></p><blockquote><p>其实，内置的 collections 模块早就提供了这种能够保留插入顺序的字典，叫作 OrderedDict。它的行为跟（Python 3.7 以来的）标准 dict 类型很像，但性能上有很大区别。如果要频繁插入或弹出键值对（例如要实现 least-recently-used 缓存），那么 OrderedDict 可能比标准的 Python dict 类型更合适</p></blockquote><p>但处理字典的时候，不能总是假设所有的字典都能保留键值对插入时的顺序。</p><p>如果不想把这种跟标准字典很相似的类型也当成标准字典来处理，那么可以考虑这样三种办法。第一，不要依赖插入时的顺序编写代码；第二，在程序运行时明确判断它是不是标准的字典；第三，给代码添加类型注解并做静态分析。</p><h3 id="第-16-条、用-get-处理键不在字典中的情况，不要使用-in-与-KeyError"><a href="#第-16-条、用-get-处理键不在字典中的情况，不要使用-in-与-KeyError" class="headerlink" title="第 16 条、用 get 处理键不在字典中的情况，不要使用 in 与 KeyError"></a>第 16 条、用 get 处理键不在字典中的情况，不要使用 in 与 KeyError</h3><p>字典有三种基本的交互操作：访问、赋值以及删除键值对。</p><p>Python 内置的字典（dict）类型提供了 get 方法，可以通过第一个参数指定自己想查的键，并通过第二个参数指定这个键不存在时应返回的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = counters.get(key, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>dict 类型提供了<code>setdefault</code>方法，能够继续简化代码。这个方法会查询字典里有没有这个键，如果有，就返回对应的值；如果没有，就先把用户提供的默认值跟这个键关联起来并插入字典，然后返回这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = votes.setdefault(key, [])</span><br></pre></td></tr></table></figure><p>这样写是正确的，而且要比采用赋值表达式的 get 方案少一行。但这种写法不太好懂，因为该方法的名字 setdefault（设置默认值）没办法让人立即明白它的作用。如果字典里本身就有这个键，那么这个方法要做的，其实仅仅是返回相关的值而已，这时它并不会 set（设置）什么数据。</p><p>还有个关键的地方要注意：在字典里面没有这个键时，setdefault 方法会把默认值直接放到字典里，而不是先给它做副本，然后把副本放到字典中。这有可能产生比较大的性能开销。</p><p>只有在少数几种情况下用 setdefault 处理缺失的键才是最简短的方式，例如这种情况：与键相关联的默认值构造起来开销很低且可以变化，而且不用担心异常问题。</p><p>即使看上去最应该使用 setdefault 方案，也不一定要真的使用 setdefault 方案，而是可以考虑用 defaultdict 取代普通的 dict。</p><h3 id="第-17-条、用-defaultdict-处理内部状态中缺失的元素，而不要用-setdefault"><a href="#第-17-条、用-defaultdict-处理内部状态中缺失的元素，而不要用-setdefault" class="headerlink" title="第 17 条、用 defaultdict 处理内部状态中缺失的元素，而不要用 setdefault"></a>第 17 条、用 defaultdict 处理内部状态中缺失的元素，而不要用 setdefault</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">visits = &#123;</span><br><span class="line">  <span class="string">'Mexico'</span>: &#123;<span class="string">'Tulum'</span>, <span class="string">'Puerto Vallarta'</span>&#125;,</span><br><span class="line">  <span class="string">'Japan'</span>: &#123;<span class="string">'Hakone'</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 内置的<code>collections</code>模块提供了<code>defaultdict</code>类，它会在键缺失的情况下，自动添加这个键以及键所对应的默认值。我们只需要在构造这种字典时提供一个函数就行了，每次发现键不存在时，该字典都会调用这个函数返回一份新的默认值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visits</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = defaultdict(set)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, country, city)</span>:</span></span><br><span class="line">    self.data[country].add(city)</span><br><span class="line"></span><br><span class="line">visits = Visits();</span><br><span class="line">visits.add(<span class="string">'England'</span>, <span class="string">'Bath'</span>)</span><br><span class="line">visits.add(<span class="string">'England'</span>, <span class="string">'London'</span>)</span><br></pre></td></tr></table></figure><p>这次的 add 方法相当简短。因为我们可以确定，访问这种字典的任意键时，总能得到一个已经存在的 set 实例。</p><h3 id="第-18-条、学会利用missing构造依赖键的默认值"><a href="#第-18-条、学会利用missing构造依赖键的默认值" class="headerlink" title="第 18 条、学会利用missing构造依赖键的默认值"></a>第 18 条、学会利用<strong>missing</strong>构造依赖键的默认值</h3><p>有一些任务是 setdefault 和 defaultdict 都处理不好的。</p><p>例如，我们要写一个程序，在文件系统里管理社交网络账号中的图片。这个程序应该用字典把这些图片的路径名跟相关的文件句柄（file handle）关联起来，这样我们就能方便地读取并写入图像了。</p><p>Python 内置了一种解决方案，可以通过继承 dict 类型并实现<code>__missing__</code>特殊方法来解决这个问题。我们可以把字典里不存在这个键时所要执行的逻辑写在这个方法中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pictures</span><span class="params">(dict)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    value = open_picture(key)</span><br><span class="line">    self[key] = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">pictures = Pictures()</span><br><span class="line">handle = pictures[path]</span><br><span class="line">handle.seek(<span class="number">0</span>)</span><br><span class="line">image_data = handle.read()</span><br></pre></td></tr></table></figure><p>访问<code>pictures[path]</code>时，如果 pictures 字典里没有 path 这个键，那就会调用<code>__missing__</code>方法。这个方法必须根据 key 参数创建一份新的默认值，系统会把这个默认值插入字典并返回给调用方。以后再访问<code>pictures[path]</code>，就不会调用<code>__missing__</code>了，因为字典里已经有了对应的键与值。</p><hr><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="第-19-条、不要把函数返回的多个数值拆分到三个以上的变量中"><a href="#第-19-条、不要把函数返回的多个数值拆分到三个以上的变量中" class="headerlink" title="第 19 条、不要把函数返回的多个数值拆分到三个以上的变量中"></a>第 19 条、不要把函数返回的多个数值拆分到三个以上的变量中</h3><p>在返回多个值的时候，可以用带星号的表达式接收那些没有被普通变量捕获到的值。</p><p>我们不应该把函数返回的多个值拆分到三个以上的变量里。一个三元组最多只拆成三个普通变量，或两个普通变量与一个万能变量（带星号的变量）。当然用于接收的变量个数也可以比这更少。假如要拆分的值确实很多，那最好还是定义一个轻便的类或 namedtuple，并让函数返回这样的实例。</p><h3 id="第-20-条、遇到意外状况时应该抛出异常，不要返回-None"><a href="#第-20-条、遇到意外状况时应该抛出异常，不要返回-None" class="headerlink" title="第 20 条、遇到意外状况时应该抛出异常，不要返回 None"></a>第 20 条、遇到意外状况时应该抛出异常，不要返回 None</h3><p>函数的返回值有时可能会用在 if 条件语句里面，那时可能会根据值本身是否相当于 False 来做判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">careful_divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">  <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>用 None 来表示特殊状况的函数是很容易出错的。有两种办法可以减少这样的错误。第一种办法是，利用二元组把计算结果分成两部分返回。元组的首个元素表示操作是否成功，第二个元素表示计算的实际值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carefult_divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>, a / b</span><br><span class="line"> <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>这样写，会促使调用函数者去拆分返回值，他可以先看看这次运算是否成功，然后再决定怎么处理运算结果。但问题是，有些调用方总喜欢忽略返回元组的第一个部分。</p><p>第二种办法比刚才那种更好，那就是不采用<code>None</code>表示特例，而是向调用方抛出异常（Exception），让他自己去处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">careful_divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">  <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure><p>这个办法也可以扩展到那些使用类型注解的代码中，我们可以把函数的返回值指定为<code>float</code>类型，这样它就不可能返回<code>None</code>了。</p><p>然而，Python 采用的是动态类型与静态类型相搭配的 gradual 类型系统，我们不能在函数的接口上指定函数可能抛出哪些异常（有的编程语言支持这样的受检异常（checked exception），调用方必须应对这些异常）。所以，我们只好把有可能抛出的异常写在文档里面，并希望调用方能够根据这份文档适当地捕获相关的异常，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">careful_divide</span><span class="params">(a: float, b: float)</span> -&gt; float:</span></span><br><span class="line">  <span class="string">"""Divides a by b.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Raises:</span></span><br><span class="line"><span class="string">  ValueError: When the inputs cannot be divided.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">  <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>)</span><br></pre></td></tr></table></figure><p>这样写，输入、输出与异常都显得很清晰，所以调用方出错的概率就变得很小了。</p><h3 id="第-21-条、了解如何在闭包里面使用外围作用域中的变量"><a href="#第-21-条、了解如何在闭包里面使用外围作用域中的变量" class="headerlink" title="第 21 条、了解如何在闭包里面使用外围作用域中的变量"></a>第 21 条、了解如何在闭包里面使用外围作用域中的变量</h3><p>有时，我们要给列表中的元素排序，而且要优先把某个群组之中的元素放在其他元素的前面。例如，渲染用户界面时，可能就需要这样做，因为关键的消息和特殊的事件应该优先显示在其他信息之前。</p><p>实现这种做法的一种常见方案，是把辅助函数通过 key 参数传给列表的 sort 方法，让这个方法根据辅助函数所返回的值来决定元素在列表中的先后顺序。辅助函数先判断当前元素是否处在重要群组里，如果在，就把返回值的第一项写成 0，让它能够排在不属于这个组的那些元素之前。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, group)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">  values.sort(key=helper)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">sort_priority(numbers, group)</span><br></pre></td></tr></table></figure><p>它为什么能够实现这个功能呢？</p><p>Python 支持闭包（closure），这让定义在大函数里面的小函数也能引用大函数之中的变量。下面有个错误的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(numbers, group)</span>:</span></span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">      found = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">  numbers.sort(key=helper)</span><br><span class="line">  <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><p>在表达式中引用某个变量时，Python 解释器会按照下面的顺序，在各个作用域（scope）里面查找这个变量，以解析（resolve）这次引用</p><ul><li>当前函数的作用域。</li><li>外围作用域（例如包含当前函数的其他函数所对应的作用域）。</li><li>包含当前代码的那个模块所对应的作用域（也叫全局作用域，global scope）。</li><li>内置作用域（built-in scope，也就是包含 len 与 str 等函数的那个作用域）。</li></ul><p>如果这些作用域中都没有定义名称相符的变量，那么程序就抛出 NameError 异常。</p><p>Python 会把包含赋值操作的这个函数当成新定义的这个变量的作用域。这可以解释刚才那种写法错在何处。sort_priority2 函数里面的 helper 闭包函数是把 True 赋给了 found 变量。当前作用域里没有这样一个叫作 found 的变量，所以就算外围的 sort_priority2 函数里面有 found 变量，系统也还是会把这次赋值当成定义，也就是会在 helper 里面定义一个新的 found 变量，而不是把它当成给 sort_priority2 已有的那个 found 变量赋值。</p><p>这种问题有时也称作作用域 bug（scoping bug），Python 新手可能认为这样的赋值规则很奇怪，但实际上 Python 是故意这么设计的。因为这样可以防止函数中的局部变量污染外围模块。假如不这样做，那么函数里的每条赋值语句都有可能影响全局作用域的变量，这样不仅混乱，而且会让全局变量之间彼此交互影响，从而导致很多难以探查的 bug。</p><p><strong>Python 有一种特殊的写法，可以把闭包里面的数据赋给闭包外面的变量。用 nonlocal 语句描述变量，就可以让系统在处理针对这个变量的赋值操作时，去外围作用域查找。</strong>然而，nonlocal 有个限制，就是不能侵入模块级别的作用域（以防污染全局作用域）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority3</span><span class="params">(numbers, group)</span>:</span></span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> found</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">      found = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">  numbers.sort(key=helper)</span><br><span class="line">  <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><p>nonlocal 语句清楚地表明，我们要把数据赋给闭包之外的变量。有一种跟它互补的语句，叫作<code>global</code>，用这种语句描述某个变量后，在给这个变量赋值时，系统会直接把它放到模块作用域（或者说全局作用域）中。</p><p>我们都知道全局变量不应该滥用，其实 nonlocal 也这样。除比较简单的函数外，大家尽量不要用这个语句，因为它造成的副作用有时很难发现。尤其是在那种比较长的函数里，nonlocal 语句与其关联变量的赋值操作之间可能隔得很远。</p><p>如果 nonlocal 的用法比较复杂，那最好是改用辅助类来封装状态。下面就定义了这样一个类，用来实现与刚才那种写法相同的效果。这样虽然稍微长一点，但看起来更清晰易读</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">    self.group = group</span><br><span class="line">    self.found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">      self.found = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">   <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br></pre></td></tr></table></figure><h3 id="第-22-条、用数量可变的位置参数给函数设计清晰的参数列表"><a href="#第-22-条、用数量可变的位置参数给函数设计清晰的参数列表" class="headerlink" title="第 22 条、用数量可变的位置参数给函数设计清晰的参数列表"></a>第 22 条、用数量可变的位置参数给函数设计清晰的参数列表</h3><p>让函数接受数量可变的位置参数（positional argument），可以把函数设计得更加清晰（这些位置参数通常简称 varargs，或者叫作 star args，因为我们习惯用*args 指代）。</p><p>例如，假设我们要记录调试信息。如果采用参数数量固定的方案来设计，那么函数应该接受一个表示信息的 message 参数和一个 values 列表（这个列表用于存放需要填充到信息里的那些值）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, values)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">    print(message)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    values_str = <span class="string">', '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="string">'test'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">log(<span class="string">'test 2'</span>, [])</span><br></pre></td></tr></table></figure><p>即便没有值需要填充到信息里面，也必须专门传一个空白的列表进去，这样显得多余，而且让代码看起来比较乱。最好是能允许调用者把第二个参数留空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, *values)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">    print(message)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    values_str = <span class="string">', '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="string">'test'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">log(<span class="string">'test 2'</span>)</span><br></pre></td></tr></table></figure><p>这种写法与拆解数据时用在赋值语句左边带星号的 unpacking 操作非常类似。</p><p>如果想把已有序列（例如某列表）里面的元素当成参数传给像 log 这样的参数个数可变的函数（variadic function），那么可以在传递序列的时采用*操作符。这会让 Python 把序列中的元素都当成位置参数传给这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">log(<span class="string">'test3'</span>, *nums);  // test3 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><p>令函数接受数量可变的位置参数，可能导致两个问题。第一个问题是，程序总是必须先把这些参数转化成一个元组，然后才能把它们当成可选的位置参数传给函数。这意味着，如果调用函数时，把带*操作符的生成器传了过去，那么程序必须先把这个生成器里的所有元素迭代完（以便形成元组），然后才能继续往下执行。这个元组包含生成器所给出的每个值，这可能耗费大量内存，甚至会让程序崩溃。</p><p>接受<code>*args</code>参数的函数，适合处理输入值不太多，而且数量可以提前预估的情况。在调用这种函数时，传给<code>*args</code>这一部分的应该是许多个字面值或变量名才对。这种机制，主要是为了让代码写起来更方便、读起来更清晰。</p><p>第二个问题是，如果用了<code>*args</code>之后，又要给函数添加新的位置参数，那么原有的调用操作就需要全都更新。例如给参数列表开头添加新的位置参数 sequence，那么没有据此更新的那些调用代码就会出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">'test4'</span>, <span class="number">7</span>, <span class="number">233</span>)</span><br></pre></td></tr></table></figure><p>第三次调用 log 函数的那个地方并没有根据新的参数列表传入 sequence 参数，这样的 bug 很难排查，因为程序不会抛出异常，只会采用错误的数据继续运行下去。为了彻底避免这种漏洞，在给这种*arg 函数添加参数时，应该使用只能通过关键字来指定的参数（keyword-only argument）。要是想做得更稳妥一些，可以考虑添加类型注解。</p><h3 id="第-23-条、用关键字参数来表示可选的行为"><a href="#第-23-条、用关键字参数来表示可选的行为" class="headerlink" title="第 23 条、用关键字参数来表示可选的行为"></a>第 23 条、用关键字参数来表示可选的行为</h3><p>与大多数其他编程语言一样，Python 允许在调用函数时，按照位置传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(number, divisor)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> number % divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> remainder(<span class="number">20</span>, <span class="number">7</span>) == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>Python 函数里面的所有普通参数，除了按位置传递外，还可以按关键字传递。调用函数时，在调用括号内可以把关键字的名称写在<code>=</code>左边，把参数值写在右边。这种写法不在乎参数的顺序，只要把必须指定的所有位置参数全都传过去即可。另外，关键字形式与位置形式也可以混用。下面这四种写法的效果相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remainder(<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line">remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(divisor=<span class="number">7</span>, number=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>如果混用，那么位置参数必须出现在关键字参数之前，否则就会出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remainder(number=<span class="number">20</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>每个参数只能指定一次，不能既通过位置形式指定，又通过关键字形式指定。</p><p>如果有一份字典，而且字典里面的内容能够用来调用 remainder 这样的函数，那么可以把<code>**</code>运算符加在字典前面，这会让 Python 把字典里面的键值以关键字参数的形式传给函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">  <span class="string">'number'</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="string">'divisor'</span>: <span class="number">7</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> remainder(**my_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>调用函数时，带<code>**</code>操作符的参数可以和位置参数或关键字参数混用，只要不重复指定就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">  <span class="string">'divisor'</span>: <span class="number">7</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> remainder(number=<span class="number">20</span>, **my_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>也可以对多个字典分别施加<code>**</code>操作，只要这些字典所提供的参数不重叠就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_kwargs = &#123;</span><br><span class="line">  <span class="string">'number'</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">other_kwargs = &#123;</span><br><span class="line">  <span class="string">'divisor'</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> remainder(**my_kwargs, **other_kwargs) == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>定义函数时，如果想让这个函数接受任意数量的关键字参数，那么可以在参数列表里写上万能形参<code>**kwargs</code>，它会把调用者传进来的参数收集合到一个字典里面稍后处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_parameters</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print_parameters(alpha=<span class="number">1.5</span>, beta=<span class="number">9</span>, gamma=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>关键字参数的灵活用法可以带来三个好处。</p><ul><li>第一个好处是，用关键字参数调用函数可以让初次阅读代码的人更容易看懂。</li><li>关键字参数的第二个好处是，它可以带有默认值，该值是在定义函数时指定的。在大多数情况下，调用者只需要沿用这个值就好，但有时也可以明确指定自己想要传的值。这样能够减少重复代码，让程序看上去干净一些。</li><li>关键字参数的第三个好处是，我们可以很灵活地扩充函数的参数，而不用担心会影响原有的函数调用代码。</li></ul><h3 id="第-24-条、用-None-和-docstring-来描述默认值会变的参数"><a href="#第-24-条、用-None-和-docstring-来描述默认值会变的参数" class="headerlink" title="第 24 条、用 None 和 docstring 来描述默认值会变的参数"></a>第 24 条、用 None 和 docstring 来描述默认值会变的参数</h3><p>有时，我们想把那种不能够提前固定的值，当作关键字参数的默认值。例如，记录日志消息时，默认的时间应该是触发事件的那一刻。所以，如果调用者没有明确指定时间，那么就默认把调用函数的那一刻当成这条日志的记录时间。</p><p>要想在 Python 里实现这种效果，惯用的办法是把参数的默认值设为 None，同时在 docstring 文档里面写清楚，这个参数为 None 时，函数会怎么运作。</p><p>给函数写实现代码时，要判断该参数是不是 None，如果是，就把它改成相应的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, when=None)</span>:</span></span><br><span class="line">  <span class="string">"""Log a message with a timestamp.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  message: Message to print.</span></span><br><span class="line"><span class="string">  WHen: datatime of when the message occurred.</span></span><br><span class="line"><span class="string">  Defaults to the present time.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">if</span> when <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    when = datetime.now()</span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;when&#125;</span>: <span class="subst">&#123;message&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>把参数的默认值写成 None 还有个重要的意义，就是用来表示那种以后可能由调用者修改内容的默认值。</p><p>这个思路可以跟类型注解搭配起来。下面这种写法把 when 参数标注成可选（Optional）值，并限定其类型为 datetime。于是，它的取值就只有两种可能，要么是 None，要么是 datetime 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_typed</span><span class="params">(message: str,</span></span></span><br><span class="line"><span class="function"><span class="params">              when: Optional[datetime]=None)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">  <span class="string">"""Log a message with a timestamp.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">  message: Message to print.</span></span><br><span class="line"><span class="string">  WHen: datatime of when the message occurred.</span></span><br><span class="line"><span class="string">  Defaults to the present time.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">if</span> when <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    when = datetime.now()</span><br><span class="line">  print(<span class="string">f'<span class="subst">&#123;when&#125;</span>: <span class="subst">&#123;message&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h3 id="第-25-条、用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"><a href="#第-25-条、用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表" class="headerlink" title="第 25 条、用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"></a>第 25 条、用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h3><p>例如，计算两数相除的结果时，可能需要仔细考虑各种特殊情况。例如，在除数为 0 的情况下，是抛出<code>ZeroDivisionError</code>异常，还是返回无穷（<code>infinity</code>）；在结果溢出的情况下，是抛出<code>OverflowError</code>异常，还是返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span><span class="params">(number, divisor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ignore_overflow,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ignore_zero_division)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">return</span> number / divisor</span><br><span class="line">  <span class="keyword">except</span> OverflowError:</span><br><span class="line">    <span class="keyword">if</span> ignore_overflow:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span></span><br><span class="line">  <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">if</span> ignore_zero_division:</span><br><span class="line">      <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>表示要不要忽略异常的那两个参数都是<code>Boolean</code>值，所以容易弄错位置，这会让程序出现难以查找的 bug。要想让代码看起来更清晰，一种办法是给这两个参数都指定默认值。按照默认值，该函数只要遇到特殊情况，就会抛出异常。然而，由于这些关键参数是可选的，我们没办法要求调用者必须按照关键字形式来指定这两个参数。</p><p>对于这种参数比较复杂的函数，我们可以声明只能通过关键字指定的参数（keyword-only argument），这样的话，写出来的代码就能清楚地反映调用者的想法了。这种参数只能用关键字来指定，不能按位置传递。</p><p>参数列表里的*符号把参数分成两组，左边是位置参数，右边是只能用关键字指定的参数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_c</span><span class="params">(number, divisor, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_overflow=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_zero_division=False)</span></span></span><br><span class="line"><span class="function"># ...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">result = safe_division_c(1.0, 0, ignore_zero_division=True)</span><br></pre></td></tr></table></figure><p>其实最重要的问题在于，我们根本就没打算把 number 和 divisor 这两个名称纳入函数的接口。</p><p>Python 3.8 引入了一项新特性，可以解决这个问题，这就是只能<code>按位置传递的参数（positional-only argument）</code>。这种参数与刚才的只能通过关键字指定的参数（keyword-only argument）相反，它们必须按位置指定，绝不能通过关键字形式指定。</p><p>参数列表中的<code>/</code>符号，表示它左边的那些参数只能按位置指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_c</span><span class="params">(number, divisor, /, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_overflow=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_zero_division=False)</span></span></span><br><span class="line"><span class="function"># ...</span></span><br><span class="line"><span class="function"><span class="title">safe_division_c</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure><p>在函数的参数列表之中，<code>/</code>符号左侧的参数是只能按位置指定的参数，<code>*</code>符号右侧的参数则是只能按关键字形式指定的参数。</p><p>在设计 API 时，为了体现某编程风格或者实现某些需求，可能会允许某些参数既可以按位置传递，也可以用关键字形式指定，这样可以让代码简单易读。例如，给下面这个 safe_division 函数的参数列表添加一个可选的 ndigits 参数，允许调用者指定这次除法应该精确到小数点后第几位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_e</span><span class="params">(numberator, denominator, /,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ndigits=<span class="number">10</span>, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ignore_overflow,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ignore_zero_division)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    fraction = numerator / denominator</span><br><span class="line">    <span class="keyword">return</span> round(fraction, ndigits)</span><br><span class="line">  <span class="keyword">except</span> OverflowError:</span><br><span class="line">    <span class="keyword">if</span> ignore_overflow:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span></span><br><span class="line">  <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">if</span> ignore_zero_division:</span><br><span class="line">      <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">safe_division_e(<span class="number">22</span>, <span class="number">7</span>)</span><br><span class="line">safe_division_e(<span class="number">22</span>, <span class="number">7</span>, <span class="number">5</span>)</span><br><span class="line">safe_division_e(<span class="number">22</span>, <span class="number">7</span>, ndigits=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="第-26-条、用-functools-wraps-定义函数修饰器"><a href="#第-26-条、用-functools-wraps-定义函数修饰器" class="headerlink" title="第 26 条、用 functools.wraps 定义函数修饰器"></a>第 26 条、用 functools.wraps 定义函数修饰器</h3><p>用修饰器（decorator）来封装某个函数，从而让程序在执行这个函数之前与执行完这个函数之后，分别运行某些代码。这意味着，调用者传给函数的参数值、函数返回给调用者的值，以及函数抛出的异常，都可以由修饰器访问并修改。这是个很有用的机制，<strong>能够确保用户以正确的方式使用函数，也能够用来调试程序或实现函数注册功能，此外还有许多用途。</strong></p><p>例如，假设我们要把函数执行时收到的参数与返回的值记录下来。这在调试递归函数时是很有用的，因为我们需要知道，这个函数执行每一层递归时，输入的是什么参数，返回的是什么值。下面我们就定义这样一个修饰器，在实现这个修饰器时，用<code>*args</code>与<code>**kwargs</code>表示受修饰的原函数 func 所收到的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    result = func(*args, **kwargs)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>, <span class="subst">&#123;kwargs!r&#125;</span>)'</span></span><br><span class="line">          <span class="string">f'-&gt; <span class="subst">&#123;result!r&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>写好之后，我们用@符号把修饰器运用在想要调试的函数上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="string">"""Return the n-th Fibonacci number"""</span></span><br><span class="line">  <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">return</span> (fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这样写，相当于先把受修饰的函数传给修饰器，然后将修饰器所返回的值赋给原来那个函数。这样的话，如果我们继续通过原来那个名字调用函数，那么执行的就是修饰之后的函数。</p><p>修饰过的 fibonacci 函数，会在执行自身的代码前，先执行 wrapper 里位于<code>func(*args, **kwargs)</code>那一行之前的逻辑；并且在执行完自身的代码后，执行 wrapper 里位于<code>func(*args,**kwargs)</code>那一行之后的逻辑。</p><p>这样写确实能满足需求，但是会带来一个我们不愿意看到的副作用。修饰器返回的那个值，也就是刚才调用的 fibonacci，它的名字并不叫“fibonacci”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(fibonacci)  <span class="comment"># &lt;function trace.&lt;locals&gt;.wrapper at )xsfjoisdjf2&gt;</span></span><br></pre></td></tr></table></figure><p>trace 函数返回的，是它里面定义的 wrapper 函数，所以，当我们把这个返回值赋给 fibonacci 之后，fibonacci 这个名称所表示的自然就是 wrapper 了。问题在于，这样可能会干扰那些需要利用 introspection 机制来运作的工具，例如调试器（debugger）</p><p>例如，如果用内置的 help 函数来查看修饰后的 fibonacci，那么打印出来的并不是我们想看的帮助文档，它本来应该打印前面定义时写的那行’Return the n-th Fibonacci number’文本才对。</p><p>对象序列化器（object serializer）也无法正常运作，因为它不能确定受修饰的那个原始函数的位置。</p><p>要想解决这些问题，可以改用 functools 内置模块之中的 wraps 辅助函数来实现。wraps 本身也是个修饰器，它可以帮助你编写自己的修饰器。把它运用到 wrapper 函数上面，它就会将重要的元数据（metadata）全都从内部函数复制到外部函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">  @wraps(func)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>虽然原来的 fibonacci 函数现在封装在修饰器里面，但我们还是可以看到它的文档。对象序列化器，现在也正常了。</p><p>除了这里讲到的几个方面之外，Python 函数还有很多标准属性（例如<code>__name__</code>、<code>__module__</code>、<code>__annotations__</code>）也应该在受到封装时得以保留，这样才能让相关的接口正常运作。wraps 可以帮助保留这些属性，使程序表现出正确的行为。</p><hr><h2 id="4-推导与生成"><a href="#4-推导与生成" class="headerlink" title="4.推导与生成"></a>4.推导与生成</h2><p>我们经常需要处理列表（list）、含有键值对的字典（dict），以及集合（set）等数据结构，并且要以这种处理逻辑为基础来构建程序。Python 提供了一种特殊的写法，叫作推导（comprehension），可以简洁地迭代这些结构，并根据迭代结果派生出另一套数据。这种写法能够让我们用相当清晰的代码实现许多常见任务，而且还有一些其他好处。</p><h3 id="第-27-条、用列表推导取代-map-与-filter"><a href="#第-27-条、用列表推导取代-map-与-filter" class="headerlink" title="第 27 条、用列表推导取代 map 与 filter"></a>第 27 条、用列表推导取代 map 与 filter</h3><p>Python 里面有一种很精简的写法，可以根据某个序列或可迭代对象派生出一份新的列表。用这种写法写成的表达式，叫作列表推导（list comprehension）。假设我们要用列表中每个元素的平方值构建一份新的列表。传统的写法是，采用下面这个简单的 for 循环来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">  squares.append(x**<span class="number">2</span>)</span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure><p>上面那段代码可以改用列表推导来写，这样可以在迭代列表的过程中，根据表达式算出新列表中的对应元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure><p>这种功能当然也可以用内置函数 map 实现，它能够从多个列表中分别取出当前位置上的元素，并把它们当作参数传给映射函数，以求出新列表在这个位置上的元素值。如果映射关系比较简单（例如只是把一个列表映射到另一个列表），那么用列表推导来写还是比用 map 简单一些，因为用 map 的时候，必须先把映射逻辑定义成 lambda 函数，这看上去稍微有点烦琐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt = map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, a)</span><br></pre></td></tr></table></figure><p>列表推导还有一个地方比 map 好，就是它能够方便地过滤原列表，把某些输入值对应的计算结果从输出结果中排除。</p><p>字典与集合也有相应的推导机制，分别叫作字典推导（dictionary comprehension）与集合推导（set comprehension）。编写算法时，可以利用这些机制根据原字典与原集合创建新字典与新集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_squares_dict = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">threes_cubed_set = &#123;x**<span class="number">3</span> <span class="keyword">or</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &amp; <span class="number">3</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>如果改用 map 与 filter 实现，那么还必须调用相应的构造器（constructor），这会让代码变得很长，需要分成多行才能写得下。这样看起来比较乱，不如使用推导机制的代码清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alt_dict = dict(map(<span class="keyword">lambda</span> x: (x, x ** <span class="number">2</span>),</span><br><span class="line">                filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a)))</span><br><span class="line">alt_set = set(map(<span class="keyword">lambda</span> x: x **<span class="number">3</span>,</span><br><span class="line">                  filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, a)))</span><br></pre></td></tr></table></figure><h3 id="第-28-条、控制推导逻辑的子表达式不要超过两个"><a href="#第-28-条、控制推导逻辑的子表达式不要超过两个" class="headerlink" title="第 28 条、控制推导逻辑的子表达式不要超过两个"></a>第 28 条、控制推导逻辑的子表达式不要超过两个</h3><p>列表推导还支持多层循环。例如，要把矩阵（一种二维列表，它的每个元素本身也是列表）转化成普通的一维列表，那么可以在推导时，使用两条 for 子表达式。这些子表达式会按照从左到右的顺序解读。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><p>这样写简单易懂，这也正是多层循环在列表推导之中的合理用法。多层循环还可以用来重制那种两层深的结构。例如，如果要根据二维矩阵里每个元素的平方值构建一个新的二维矩阵，那么可以采用下面这种写法。这看上去有点儿复杂，因为它把小的推导逻辑<code>[x**2 for x in row]</code>嵌到了大的推导逻辑<code>[1]</code>里面，不过，这行语句总体上不难理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squared = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[1,4,9],[16,25,36],[49,64.81]]</span></span><br></pre></td></tr></table></figure><p>如果推导过程中还要再加一层循环，那么语句就会变得很长，必须把它分成多行来写，例如下面是把一个三维矩阵转化成普通一维列表的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">  [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line">flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists</span><br><span class="line">       <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</span><br><span class="line">       <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br></pre></td></tr></table></figure><p>在这种情况下，采用列表推导来实现，其实并不会比传统的 for 循环节省多少代码。下面用常见的 for 循环改写刚才的例子。这次我们通过级别不同的缩进表示每一层循环的深度，这要比刚才那种三层矩阵的列表推导更加清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists:</span><br><span class="line">  <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</span><br><span class="line">    flat.extend(sublist2)</span><br></pre></td></tr></table></figure><p>推导的时候，可以使用多个 if 条件。如果这些 if 条件出现在同一层循环内，那么它们之间默认是 and 关系，也就是必须同时成立。例如，如果要用原列表中大于 4 且是偶数的值来构建新列表，那么既可以连用两个 if，也可以只用一个 if，下面两种写法效果相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x. &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这个逻辑用列表推导来写，并不需要太多的代码，但是这些代码理解起来会很困难。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[6], [9]]</span></span><br></pre></td></tr></table></figure><p>总之，在表示推导逻辑时，最多只应该写两个子表达式（例如两个 if 条件、两个 for 循环，或者一个 if 条件与一个 for 循环）。只要实现的逻辑比这还复杂，那就应该采用普通的 if 与 for 语句来实现，并且可以考虑编写辅助函数。</p><h3 id="第-29-条、用赋值表达式消除推导中的重复代码"><a href="#第-29-条、用赋值表达式消除推导中的重复代码" class="headerlink" title="第 29 条、用赋值表达式消除推导中的重复代码"></a>第 29 条、用赋值表达式消除推导中的重复代码</h3><p>推导 list、dict 与 set 等变体结构时，经常要在多个地方用到同一个计算结果。例如，我们要给制作紧固件的公司编写程序以管理订单。顾客下单后，我们要判断当前的库存能否满足这份订单，也就是说，要核查每种产品的数量有没有达到可以发货的最低限制（8 个为一批，至少要有一批，才能发货）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">stock = &#123;</span><br><span class="line">  <span class="string">'nails'</span>: <span class="number">125</span>,</span><br><span class="line">  <span class="string">'screws'</span>: <span class="number">35</span>,</span><br><span class="line">  <span class="string">'wingnuts'</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="string">'washers'</span>: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order = [<span class="string">'screws'</span>, <span class="string">'wingnuts'</span>, <span class="string">'clips'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batches</span><span class="params">(count, size)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> order:</span><br><span class="line">  count = stock.get(name, <span class="number">0</span>)</span><br><span class="line">  batches = get_batches(count, <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">if</span> batches:</span><br><span class="line">    result[name] = batches</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;'screws': 4, 'wingnuts': 1&#125;</span></span><br></pre></td></tr></table></figure><p>这段循环逻辑，如果改用字典推导来写，会简单一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">found = &#123;name: get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">        <span class="keyword">if</span> get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;'screws': 4, 'wingnuts': 1&#125;</span></span><br></pre></td></tr></table></figure><p>这样写虽然比刚才简短，但问题是，它把<code>get_batches(stock.get(name, 0), 8)</code>写了两遍。这样会让代码看起来比较乱，而且实际上，程序也没有必要把这个结果计算两遍。另外，如果这两个地方忘了同步更新，那么程序就会出现 bug。</p><p>有个简单的办法可以解决这个问题，那就是在推导的过程中使用 Python 3.8 新引入的<code>:=</code>操作符进行赋值表达</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">found = &#123;name: batches <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">         <span class="keyword">if</span> (batches := get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>))&#125;</span><br></pre></td></tr></table></figure><p>这条<code>batches := get_batches(...)</code>赋值表达式，能够从 stock 字典里查到对应产品一共有几批，并把这个批数放在 batches 变量里。</p><p>在推导过程中，描述新值的那一部分也可以出现赋值表达式。但如果在其他部分引用了定义在那一部分的变量，那么程序可能就会在运行时出错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: (tenth := count // <span class="number">10</span>)</span><br><span class="line">          <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items() <span class="keyword">if</span> tenth &gt; <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># NameError</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，可以把赋值表达式移动到 if 条件里面，然后在描述新值的这一部分引用已经定义过的 tenth 变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;name: tenth <span class="keyword">for</span> name, count <span class="keyword">in</span> stock.items()</span><br><span class="line">          <span class="keyword">if</span> (tenth := count // <span class="number">10</span>) &gt; <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>如果推导逻辑不带条件，而表示新值的那一部分又使用了:=操作符，那么操作符左边的变量就会泄漏到包含这条推导语句的那个作用域里。</p><p>建议赋值表达式只出现在推导逻辑的条件之中。</p><p>赋值表达式不仅可以用在推导过程中，而且可以用来编写生成器表达式（generator expression）。下面这种写法创建的是迭代器，而不是字典实例，该迭代器每次会给出一对数值，其中第一个元素为产品的名字，第二个元素为这种产品的库存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">found = ((name, batches) <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">         <span class="keyword">if</span> (batches := get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('screws', 4)</span></span><br><span class="line"><span class="comment"># ('wingnuts', 1)</span></span><br></pre></td></tr></table></figure><h3 id="第-30-条、不要让函数直接返回列表，应该让它逐个生成列表里的值"><a href="#第-30-条、不要让函数直接返回列表，应该让它逐个生成列表里的值" class="headerlink" title="第 30 条、不要让函数直接返回列表，应该让它逐个生成列表里的值"></a>第 30 条、不要让函数直接返回列表，应该让它逐个生成列表里的值</h3><p>如果函数要返回的是个包含许多结果的序列，那么最简单的办法就是把这些结果放到列表中。例如，我们要返回字符串里每个单词的首字母所对应的下标。下面这种写法，会把每次遇到的新单词所在的位置追加（append）到存放结果的 result 列表中，在函数末尾返回这份列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">if</span> text:</span><br><span class="line">    result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">      <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">        result.append(index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>index_words 函数有两个缺点。第一个缺点是，它的代码看起来有点杂乱。每找到一个新单词，它都要调用 append 方法，而调用这个方法时，必须写上 result.append 这样一串字符，这就把我们想要强调的重点，也就是这个新单词在字符串中的位置（index + 1）淡化了。另外，函数还必须专门用一行代码创建这个保存结果的 result 列表，并且要用一条 return 语句把它返回给调用者。这样算下来，虽然函数的主体部分大约有 130 个字符（非空白的），但真正重要的只有 75 个左右。</p><p>这种函数改用生成器（generator）来实现会比较好。生成器由包含 yield 表达式的函数创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words_iter</span><span class="params">(text)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> text:</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">      <span class="keyword">yield</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调用生成器函数并不会让其中的代码立刻得到执行，它会返回一个迭代器（iterator）。把迭代器传给 Python 内置的 next 函数，就可以将生成器函数推进到它的下一条 yield 表达式。生成器会把 yield 表达式的值通过迭代器返回给调用者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = index_words_iter(address)</span><br><span class="line">next(it) <span class="comment"># 0</span></span><br><span class="line">next(it) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>这次的 index_words_iter 函数，比刚才那个函数好懂得多，因为它把涉及列表的那些操作全都简化掉了。它通过 yield 表达式来传递结果，而不像刚才那样，要把结果追加到列表之中。如果确实要制作一份列表，那可以把生成器函数返回的迭代器传给内置的 list 函数。</p><p>index_words 函数的第二个缺点是，它必须把所有的结果都保存到列表中，然后才能返回列表。如果输入的数据特别多，那么程序可能会因为耗尽内存而崩溃。</p><p>相反，用生成器函数来实现，就不会有这个问题了。它可以接受长度任意的输入信息，并把内存消耗量压得比较低。例如下面这个生成器，只需要把当前这行文字从文件中读进来就行，每次推进的时候，它都只处理一个单词，直到把当前这行文字处理完毕，才读入下一行文字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_file</span><span class="params">(handle)</span>:</span></span><br><span class="line">  offset = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> handle:</span><br><span class="line">    <span class="keyword">if</span> line:</span><br><span class="line">      <span class="keyword">yield</span> offset</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> line:</span><br><span class="line">      offset += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">yield</span> offset</span><br></pre></td></tr></table></figure><p>该函数运行时所耗的内存，取决于文件中最长的那一行所包含的字符数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-1-～-30-条读书笔记&quot;&gt;&lt;a href=&quot;#【笔记】Effective-Python《编写高质量-Python-代码的-90-个有效方法》——第-1-～-30
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.michealwayne.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="http://blog.michealwayne.cn/tags/python/"/>
    
  </entry>
  
</feed>
