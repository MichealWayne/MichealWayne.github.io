<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【笔记】ServiceWorker总结篇 | Wayne的博客</title><meta name="description" content="【笔记】ServiceWorker总结篇 - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><script>(function (w) {w.frontjsConfig={token:"81a82620fb0dca7680f2f06be134fa4f",behaviour:8,FPSThreshold:10};w.frontjsTmpData = {r:[],e:[],l:[]};w.frontjsTmpCollector = function (ev) {(ev.message ? window.frontjsTmpData.e : window.frontjsTmpData.r).push([new Date().getTime(), ev])};w.FrontJS = {addEventListener: function (t, f) {w.frontjsTmpData.l.push([t, f]);return f;},removeEventListener: function (t, f) {for (var i = 0; i < w.frontjsTmpData.l.length; i++) {t === w.frontjsTmpData.l[i][0] && f === w.frontjsTmpData.l[i][1] && w.frontjsTmpData.l.splice(i, 1);}return f;}};w.document.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("error", w.frontjsTmpCollector, true);w.addEventListener("load", function () {var n = w.document.createElement("script");n.src = "https://frontjs-static.pgyer.com/dist/current/frontjs.web.min.js"; w.document.body.appendChild(n);}, true);})(window);</script><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">主页</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">归档</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">关于</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">【笔记】ServiceWorker总结篇</h1><span class="post-date">Aug 7, 2020</span><span class="post-tag"><a href="/tags/笔记/">笔记</a><a href="/tags/webApi/">webApi</a><a href="/tags/serviceWorker/">serviceWorker</a></span><img src="/images/sw/logo.png" class="bgimage"><div class="post-content"><h1 id="ServiceWorker总结篇"><a href="#ServiceWorker总结篇" class="headerlink" title="ServiceWorker总结篇"></a>ServiceWorker总结篇</h1><p>Service Worker 是 Chrome 团队提出和力推的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">WEB API</a>，用于给 web 应用提供高级的可持续的后台处理能力。该 WEB API 标准起草于 2013 年，于 2014 年纳入 W3C WEB 标准草案，当前还在草案阶段。</p>
<p>基于 Service Worker API 的特性，结合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">Cache API</a>、Push API、postMessage API 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notifications_API" target="_blank" rel="noopener">Notification API</a>，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。因此，Service Worker也是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener">PWA</a>中最核心的部分。</p>
<p>本文内容分为以下模块：</p>
<ul>
<li><a href="#概念">概念</a><ul>
<li><a href="#主要作用">主要作用</a></li>
<li><a href="#基本兼容情况">基本兼容情况</a></li>
<li><a href="#关于AppCache和Service Worker对比">关于AppCache和Service Worker对比</a></li>
</ul>
</li>
<li><a href="#使用">使用</a><ul>
<li><a href="#注册">注册</a></li>
<li><a href="#下载、安装和激活">下载、安装和激活</a></li>
<li><a href="#相关事件">相关事件</a></li>
</ul>
</li>
<li><a href="#相关API">相关API</a></li>
<li><a href="#安全">安全</a></li>
<li><a href="#demos">demos</a></li>
<li><a href="#项目使用">项目使用</a></li>
<li><a href="#常见问题">常见问题</a></li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Service workers 本质上<strong>充当Web应用程序与浏览器之间的代理服务器</strong>，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。    ——mdn</p>
</blockquote>
<p>Service worker是一个注册在指定源和路径下的事件驱动<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker" target="_blank" rel="noopener">worker</a>。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。</p>
<p>Service worker运行在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker" target="_blank" rel="noopener">worker</a>上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。<strong>它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用</strong>。</p>
<p>出于安全考量，Service workers<strong>只能由HTTPS承载</strong>，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在Firefox浏览器的用户隐私模式，Service Worker不可用。</p>
<blockquote>
<p>为了便于本地开发，localhost 也被浏览器认为是安全源。</p>
</blockquote>
<h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><ul>
<li>解决web离线问题</li>
<li>后台数据同步</li>
<li>响应来自其它源的资源请求</li>
<li>集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据</li>
<li>在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的）</li>
<li>后台服务钩子</li>
<li>自定义模板用于特定URL模式</li>
<li>性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片</li>
</ul>
<p>未来service workers能够用来做更多使web平台接近原生应用的事。 值得关注的是，其他标准也能并且将会使用service worker，例如:</p>
<ul>
<li><a href="https://github.com/WICG/background-sync" target="_blank" rel="noopener">后台同步</a>：启动一个service worker即使没有用户访问特定站点，也可以更新缓存</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="noopener">响应推送</a>：启动一个service worker向用户发送一条信息通知新的内容可用</li>
<li>对时间或日期作出响应</li>
<li>进入地理围栏</li>
</ul>
<h4 id="Service-Worker能做的事"><a href="#Service-Worker能做的事" class="headerlink" title="Service Worker能做的事"></a>Service Worker能做的事</h4><ul>
<li>1.预缓存HTML、JavaScript和CSS文件，使其能在页面断网离线的时候也能展示</li>
<li>2.当缓存名更新的时候清理之前的预缓存内容</li>
<li>拦截网络请求，当缓存的响应内容有效时直接返回这个缓存响应</li>
<li>如果没有缓存的响应，获取来自网络的响应并将其添加到缓存中，以供将来使用。</li>
</ul>
<h4 id="Service-Worker不能做的事"><a href="#Service-Worker不能做的事" class="headerlink" title="Service Worker不能做的事"></a>Service Worker不能做的事</h4><ul>
<li>自动对预缓存资源进行版本处理。你必须手动更新缓存。</li>
<li>破坏预缓存请求。<code>cache.addAll()</code>调用可能实现HTTP缓存的响应,这取决于您所使用的HTTP缓存头。如果您正在使用HTTP缓存和未版本化的资源源,它可以安全破坏预缓存请求。</li>
<li>在运行时更新缓存内容。一旦一个条目被添加到运行时缓存，这是无限期使用，没有咨询网络来检查更新。如果您的运行时缓存用于资源可能会被更新，一个不同的策略,就像<code>stale-while-revalidate</code>可能更合适。</li>
<li>在运行时清理缓存内容。运行时缓存将成长为新的资源的url请求。在这个例子中，只有5个不同的图像可能加载，所以缓存大小不是一个问题。如果您的web应用程序可能要求任意数量的独特的资源url，然后使用一个如sw-toolbox的封装库来提供缓存过期。</li>
</ul>
<p>更多demo可见<a href="https://github.com/w3c-webmob/ServiceWorkersDemos" target="_blank" rel="noopener">w3c-ServiceWorkersDemos</a></p>
<h3 id="基本兼容情况"><a href="#基本兼容情况" class="headerlink" title="基本兼容情况"></a>基本兼容情况</h3><p><img src="/images/sw/i-c1.png" alt="i-c1.png"></p>
<h3 id="关于AppCache和Service-Worker对比"><a href="#关于AppCache和Service-Worker对比" class="headerlink" title="关于AppCache和Service Worker对比"></a>关于AppCache和Service Worker对比</h3><ul>
<li>AppCache仅仅在离线的时候才能发挥用处（无法解决网络慢的用户体验问题），而SW不是，可以通过拦截请求，并且返回合适的数据。</li>
<li>AppCache无法支持当操作出错时终止操作。SW可以更细致地控制每一件事情。</li>
<li>AppCache的浏览器兼容性相比更好。见下图</li>
</ul>
<p><img src="/images/sw/i-c2.png" alt="i-c2.png"></p>
<blockquote>
<p><a href="https://github.com/w3c/ServiceWorker/blob/master/why_not_appcache%2B%2B.md" target="_blank" rel="noopener">《Why Not AppCache++?》</a>、<a href="https://www.cnblogs.com/hellohello/p/8335808.html#db" target="_blank" rel="noopener">AppCache的问题</a></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>使用 <code>ServiceWorkerContainer.register()</code> 方法首次注册service worker。<br>如果注册成功，service worker就会被下载到客户端并尝试安装或激活（见后文），这将作用于整个域内用户可访问的URL，或者其特定子集。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">        .register(<span class="string">'/sw/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">registration</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>service worker 只能抓取在 service worker scope 里从客户端发出的请求。</li>
<li>最大的 scope 是 service worker 所在的地址</li>
<li>如果你的 service worker 被激活在一个有 Service-Worker-Allowed header 的客户端，你可以为service worker 指定一个最大的 scope 的列表。</li>
<li>在 Firefox, Service Worker APIs 在用户在 private browsing mode 下会被隐藏而且无法使用。</li>
</ul>
<h4 id="注册失败可能的原因"><a href="#注册失败可能的原因" class="headerlink" title="注册失败可能的原因"></a>注册失败可能的原因</h4><ul>
<li>你没有在 HTTPS 下运行你的程序</li>
<li>service worker文件的地址没有写对— 需要相对于 origin , 而不是 app 的根目录。在我们的例子例， service worker 是在 <a href="https://mdn.github.io/sw-test/sw.js，app" target="_blank" rel="noopener">https://mdn.github.io/sw-test/sw.js，app</a> 的根目录是 <a href="https://mdn.github.io/sw-test/。应该写成" target="_blank" rel="noopener">https://mdn.github.io/sw-test/。应该写成</a> /sw-test/sw.js 而非 /sw.js.</li>
<li>service worker 在不同的 origin 而不是你的app的，这是不被允许的。</li>
</ul>
<blockquote>
<p>chrome 浏览器下，注册成功后，可以打开 chrome://serviceworker-internals/ 查看浏览器的 Service Worker 信息。</p>
</blockquote>
<blockquote>
<p>Service Worker 的注册路径决定了其 scope 默认作用范围。示例中 sw.js 是在 /sw/ 路径下，这使得该 Service Worker 默认只会收到 /sw/ 路径下的 fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。<br>如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。</p>
</blockquote>
<p>另外应意识到这一点：Service Worker 没有页面作用域的概念，作用域范围内的所有页面请求都会被当前激活的 Service Worker 所监控。</p>
<h3 id="下载、安装和激活"><a href="#下载、安装和激活" class="headerlink" title="下载、安装和激活"></a>下载、安装和激活</h3><ul>
<li>1.service worker URL 通过 <code>serviceWorkerContainer.register()</code> 来获取和注册。</li>
<li>2.如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 woker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。</li>
<li>3.service worker 现在可以处理事件了。</li>
<li>4.受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。</li>
<li>5.当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。<br>下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。</li>
<li>6.Service Worker 现在可以控制页面了，但仅是在 register()  成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -&gt; installed -&gt; actvating -&gt; Active -&gt; Activated -&gt; Redundant</span><br></pre></td></tr></table></figure>
<p>下图则展示了service worker的生命周期<br><img src="/images/sw/sw-lifecycle.png" alt="sw-lifecycle.png"></p>
<p>特别说明，进入 Redundant (废弃)状态的原因可能为这几种：</p>
<ul>
<li>安装(install)失败</li>
<li>激活(activating)失败</li>
<li>新版本的 Service Worker 替换了它并成为激活状态</li>
</ul>
<p>下图展示了 service worker 所有支持的事件：<br><img src="/images/sw/sw-events.png" alt="sw-events.png"></p>
<h4 id="安装和激活：填充你的缓存"><a href="#安装和激活：填充你的缓存" class="headerlink" title="安装和激活：填充你的缓存"></a>安装和激活：填充你的缓存</h4><p>在你的 service worker 注册之后，浏览器会尝试为你的页面或站点安装并激活它。 </p>
<p>install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 的 新的标志性的存储 API — cache — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是特定你的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/star-wars-logo.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/bountyHunters.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/snowTroopers.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，只有 addAll 中数组的文件全部安装成功，Service Worker 才会认为安装完成。否则会认为安装失败，安装失败则进入 redundant (废弃)状态。所以这里应当尽量少地缓存资源(一般为离线时需要但联网时不会访问到的内容)，以提升成功率。<br>安装成功后，即进入等待(waiting)或激活(active)状态。在激活状态可通过监听各种事件，实现更为复杂的逻辑需求。具体参见后文事件处理部分。</p>
<ul>
<li>这里我们 新增了一个 install 事件监听器，接着在事件上接了一个<code>ExtendableEvent.waitUntil()</code>方法——这会确保Service Worker 不会在 <code>waitUntil()</code> 里面的代码执行完毕之前安装完成。</li>
<li>在 <code>waitUntil()</code> 内，我们使用了 <code>caches.open()</code> 方法来创建了一个叫做 v1 的新的缓存，将会是我们的站点资源缓存的第一个版本。它返回了一个创建缓存的 promise，当它 resolved的时候，我们接着会调用在创建的缓存示例上的一个方法  <code>addAll()</code>，这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表。</li>
<li>如果 promise 被 rejected，安装就会失败，这个 worker 不会做任何事情。这也是可以的，因为你可以修复你的代码，在下次注册发生的时候，又可以进行尝试。</li>
<li>当安装成功完成之后， service worker 就会激活。在第一次你的 service worker 注册／激活时，这并不会有什么不同。但是当  service worker 更新 (稍后查看 Updating your service worker 部分) 的时候 ，就不太一样了。</li>
</ul>
<h4 id="自定义请求的响应"><a href="#自定义请求的响应" class="headerlink" title="自定义请求的响应"></a>自定义请求的响应</h4><p>现在你已经将你的站点资源缓存了，你需要告诉 service worker 让它用这些缓存内容来做点什么。有了 fetch 事件，这是很容易做到的。</p>
<p><img src="/images/sw/sw-fetch.png" alt="sw-fetch.png"></p>
<p>每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源（比如 index.html 发起了一个跨域的请求来嵌入一个图片，这个也会通过 service worker）。</p>
<p>你可以给 service worker 添加一个 fetch 的事件监听器，接着调用 event 上的 <code>respondWith()</code> 方法来劫持我们的 HTTP 响应，然后你用可以用自己的魔法来更新他们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="comment">// magic goes here</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以用一个简单的例子开始，在任何情况下我们只是简单的响应这些缓存中的 url 和网络请求匹配的资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>caches.match(event.request)</code> 允许我们对网络请求的资源和 cache 里可获取的资源进行匹配，查看是否缓存中有相应的资源。这个匹配通过 url 和 vary header进行，就像正常的 http 请求一样。</p>
<p>失败请求的处理：在有 service worker cache 里匹配的资源时， caches.match(event.request) 是非常棒的。但是如果没有匹配资源呢？如果我们不提供任何错误处理，promise 就会 reject，同时也会出现一个网络错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(event.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果 promise reject了， <code>catch()</code>函数会执行默认的网络请求，意味着在网络可用的时候可以直接像服务器请求资源。</p>
<p>如果我们足够聪明的话，我们就不会只是从服务器请求资源，而且还会把请求到的资源保存到缓存中，以便将来离线时所用！这意味着如果其他额外的图片被加入到  Star Wars 图库里，我们的 app 会自动抓取它们。下面就是这个诀窍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> resp || fetch(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, response.clone());</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;);  </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们用 <code>fetch(event.request)</code> 返回了默认的网络请求，它返回了一个 promise 。当网络请求的 promise 成功的时候，我们 通过执行一个函数用 <code>caches.open(&#39;v1&#39;)</code> 来抓取我们的缓存，它也返回了一个 promise。当这个 promise 成功的时候， <code>cache.put()</code> 被用来把这些资源加入缓存中。资源是从  <code>event.request</code> 抓取的，它的响应会被  <code>response.clone()</code>克隆一份然后被加入缓存。这个克隆被放到缓存中，它的原始响应则会返回给浏览器来给调用它的页面。</p>
<p>为什么要这样做？这是因为请求和响应流只能被读取一次。为了给浏览器返回响应以及把它缓存起来，我们不得不克隆一份。所以原始的会返回给浏览器，克隆的会发送到缓存中。它们都是读取了一次。</p>
<p>我们现在唯一的问题是当请求没有匹配到缓存中的任何资源的时候，以及网络不可用的时候，我们的请求依然会失败。让我们提供一个默认的回退方案以便不管发生了什么，用户至少能得到些东西：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fetch(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, response.clone());</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;);  </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为只有新图片会失败，我们已经选择了回退的图片，一切都依赖我们之前看到的  install  事件侦听器中的安装过程。</p>
<h4 id="更新你的-service-worker"><a href="#更新你的-service-worker" class="headerlink" title="更新你的 service worker"></a>更新你的 service worker</h4><p>如果你的 service worker 已经被安装，但是刷新页面时有一个新版本的可用，新版的 service worker 会在后台安装，但是还没激活。当不再有任何已加载的页面在使用旧版的 service worker 的时候，新版本才会激活。一旦再也没有更多的这样已加载的页面，新的 service worker 就会被激活。</p>
<p>你想把你的新版的 service worker 里的  install 事件监听器改成下面这样（注意新的版本号）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v2'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">// include other new resources for the new version...</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当安装发生的时候，前一个版本依然在响应请求，新的版本正在后台安装，我们调用了一个新的缓存 v2，所以前一个 v1 版本的缓存不会被扰乱。</p>
<p>当没有页面在使用当前的版本的时候，这个新的 service worker 就会激活并开始响应请求。</p>
<h5 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h5><p>其实在页面中，也可以手动来管理更新。参考如下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> version = <span class="string">'1.0.1'</span>;</span><br><span class="line"> </span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="params">reg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'sw_version'</span>) !== version) &#123;</span><br><span class="line">        reg.update().then(<span class="function"><span class="params">()</span> =&gt;</span> localStorage.setItem(<span class="string">'sw_version'</span>, version));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="删除旧缓存"><a href="#删除旧缓存" class="headerlink" title="删除旧缓存"></a>删除旧缓存</h4><p>你还有个 activate 事件。当之前版本还在运行的时候，一般被用来做些会破坏它的事情，比如摆脱旧版的缓存。在避免占满太多磁盘空间清理一些不再需要的数据的时候也是非常有用的，每个浏览器都对 service worker 可以用的缓存空间有个硬性的限制。浏览器尽力管理磁盘空间，但它可能会删除整个域的缓存。浏览器通常会删除域下面的所有的数据。</p>
<p>传给 waitUntil() 的 promise 会阻塞其他的事件，直到它完成。所以你可以确保你的清理操作会在你的的第一次 fetch 事件之前会完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h3><h4 id="install-事件"><a href="#install-事件" class="headerlink" title="install 事件"></a>install 事件</h4><p>当前脚本被安装时，会触发 install 事件，具体参考前文的 安装 部分的示例。</p>
<h4 id="fetch-事件"><a href="#fetch-事件" class="headerlink" title="fetch 事件"></a>fetch 事件</h4><p>当浏览器发起请求时，会触发 fetch 事件。</p>
<p>Service Worker 安装成功并进入激活状态后即运行于浏览器后台，可以通过 fetch 事件可以拦截到当前作用域范围内的 http/https 请求，并且给出自己的响应。结合 Fetch API ，可以简单方便地处理请求响应，实现对网络请求的控制。</p>
<h4 id="activate-事件"><a href="#activate-事件" class="headerlink" title="activate 事件"></a>activate 事件</h4><p>当安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对于旧版本的更新、对于无用缓存的清理等。</p>
<h4 id="push-事件"><a href="#push-事件" class="headerlink" title="push 事件"></a>push 事件</h4><p>push 事件是为推送准备的。不过首先你需要了解一下 Notification API 和 PUSH API(相关链接见后文)。</p>
<p>通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 ServiceWorker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</p>
<p>推送的实现有两步：</p>
<p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<gcm> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</gcm></p>
<p>在页面上，使用 <code>PushManager.subscribe()</code> 来订阅推送服务。第二步比较简单，是在 Service Worker 中通过监听 push 事件对推送的消息作处理。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向用户申请通知权限，用户可以选择允许或禁止</span></span><br><span class="line"><span class="comment">// Notification.requestPermission 只有在页面上才可执行，Service Worker 内部不可申请权限</span></span><br><span class="line">Notification.requestPermission().then(<span class="function"><span class="params">grant</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(grant); <span class="comment">// 如果获得权限，会得到 granted</span></span><br><span class="line">    <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户拒绝了通知权限</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Permission for Notifications was denied'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> reg;</span><br><span class="line"><span class="keyword">const</span> applicationServerKey = <span class="string">'xxx'</span>; <span class="comment">// 应用服务器的公钥（base64 网址安全编码）</span></span><br><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="params">_reg</span> =&gt;</span> &#123;</span><br><span class="line">    reg = _reg;</span><br><span class="line">    <span class="comment">// 获取当前订阅的推送</span></span><br><span class="line">    <span class="keyword">return</span> reg.pushManager.getSubscription();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取的结果没有任何订阅，发起一个订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!subscription) &#123;</span><br><span class="line">        <span class="keyword">return</span> reg.pushManager.subscribe(&#123;</span><br><span class="line">            userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">            applicationServerKey: applicationServerKey</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 每一个会话会有一个独立的端点(endpoint)，用于推送时后端识别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"已订阅 endpoint:"</span>, subscription.endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscription) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 订阅成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'订阅成功！'</span>, subscription.endpoint);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做更多的事情，如将订阅信息发送给后端，用于后端推送识别</span></span><br><span class="line">    <span class="comment">// const key = subscription.getKey('p256dh');</span></span><br><span class="line">    <span class="comment">// updateStatus(subscription.endpoint, key, 'subscribe');</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Unable to subscribe to push.'</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息处理</span></span><br><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 event.data 获取传递过来的数据，根据该数据做进一步的逻辑处理</span></span><br><span class="line">    <span class="keyword">const</span> obj = event.data.json();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 逻辑处理示例</span></span><br><span class="line">    <span class="keyword">if</span>(Notification.permission === <span class="string">'granted'</span> &amp;&amp; obj.action === <span class="string">'subscribe'</span>) &#123;</span><br><span class="line">        self.registration.showNotification(<span class="string">"Hi："</span>, &#123;</span><br><span class="line">            body: <span class="string">'订阅成功 ~'</span>,</span><br><span class="line">            icon: <span class="string">'//lzw.me/images/avatar/lzwme-80x80.png'</span>,</span><br><span class="line">            tag: <span class="string">'push'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="sync-事件"><a href="#sync-事件" class="headerlink" title="sync 事件"></a>sync 事件</h4><p>sync 事件由 background sync (后台同步)发出。background sync 是 Google 配合 SW 推出的 API，用于为 SW 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C WEB API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。</p>
<p>后台同步功能允许你一次性或按间隔请求后台数据同步，即使用户没有打开网站，仅唤醒了 ServiceWorker，也会如此。</p>
<p>当你从页面请求执行此操作的权限，用户将收到提示。后台同步适合于： 非紧急更新，特别是那些需要定期进行的更新，每次更新都发送一个推送通知会显得太频繁，如在某个时间推送一篇特色文章或一条消息通知，这在 native 应用中非常常见。</p>
<p>如：<br>页面中注册<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">swRegistration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> swRegistration.sync.register(<span class="string">'myFirstSync'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>SW中监听<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'sync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.tag === <span class="string">'myFirstSync'</span>) &#123;</span><br><span class="line">        event.waitUntil(doSomething());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="message-事件-postMessage"><a href="#message-事件-postMessage" class="headerlink" title="message 事件(postMessage)"></a>message 事件(postMessage)</h4><p>ServiceWorker 运行于独立的沙盒中，无法直接访问当前页面的 DOM 等信息，但是通过 postMessage API，可以实现他们之间的消息传递。</p>
<p>跨文档的 postMessage 消息传输，需要获取接收方的文档句柄。那么当需要将消息从页面传输给 ServiceWorker 或从 ServiceWorker 传输给页面时，如何获取对应的文档句柄？如下。</p>
<p>A. 页面发消息给 serviceWorker</p>
<p>在页面上通过 navigator.serviceWorker.controller 获得 ServiceWorker 的句柄。但只有 ServiceWorker 注册成功后该句柄才会存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> controller = navigator.serviceWorker.controller;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!controller) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    controller.postMessage(msg, []);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在 serviceWorker 注册成功后，页面上即可通过 navigator.serviceWorker.controller 发送消息给它</span></span><br><span class="line">navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'/test/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/test/'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">registration</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> sendMsg(<span class="string">'hello sw!'</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err));</span><br></pre></td></tr></table></figure>
<p>在 ServiceWorker 内部，可以通过监听 message 事件即可获得消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ev.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>B. ServiceWorker 发消息给页面</p>
<p>ServiceWorker 内部需要获取页面句柄，这个句柄要从 self.clients 上得到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.clients.matchAll().then(<span class="function"><span class="params">clientList</span> =&gt;</span> &#123;</span><br><span class="line">    clientList.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">        client.postMessage(<span class="string">'Hi, I am send from Service worker！'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="online-offline-事件"><a href="#online-offline-事件" class="headerlink" title="online/offline 事件"></a>online/offline 事件</h4><p>当网络状态发生变化时，会触发 online 或 offline 事件。结合这两个事件，可以与 Service Worker 结合实现更好的离线使用体验，例如当网络发生改变时，替换/隐藏需要在线状态才能使用的链接导航等。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Notification.requestPermission().then(<span class="function"><span class="params">grant</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(<span class="string">"Hi，网络不给力哟"</span>, &#123;</span><br><span class="line">            body: <span class="string">'您的网络貌似离线了，不过在志文工作室里访问过的页面还可以继续打开~'</span>,</span><br><span class="line">            icon: <span class="string">'//lzw.me/images/avatar/lzwme-80x80.png'</span></span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        notification.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            notification.close();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="error-和-unhandledrejection-事件"><a href="#error-和-unhandledrejection-事件" class="headerlink" title="error 和 unhandledrejection 事件"></a>error 和 unhandledrejection 事件</h4><p>当 JS 执行发生错误，会触发 error 事件；当 Promise 类型的回调发生 reject 却没有 catch 处理，会触发 unhandledrejection 事件。</p>
<p>对于这类事件，前端应当作埋点上报，以便于统计监控和及时发现处理。一般情况下上报的信息应从 error 中读取，主要包括错误堆栈相关信息以便定位。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">errorMessage, scriptURI, lineNumber, columnNumber, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reportError(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reportError(&#123;</span><br><span class="line">            message: errorMessage,</span><br><span class="line">            script: scriptURI,</span><br><span class="line">            line: lineNumber，</span><br><span class="line">            column: columnNumber</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听unhandledrejection事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    reportError(&#123;</span><br><span class="line">        message: event.reason</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="beforeinstallprompt-事件"><a href="#beforeinstallprompt-事件" class="headerlink" title="beforeinstallprompt 事件"></a>beforeinstallprompt 事件</h4><p>当发生 Add to Homescreen (A2HS, 添加到主屏幕)行为的请求时，会触发该事件。它发生于页面中，与 Service Worker 并没有直接关系。</p>
<p>如果你的站点符合 A2HS 的条件(具体参见后文介绍)，浏览器(chrome) 会根据默认的行为算法，来决定何时主动的向用户展示添加到首屏提示。另外，用户也可以通过 chrome 菜单中的 添加到主屏幕 选项主动添加。</p>
<p>可以在页面中通过监听 beforeinstallprompt 事件，决定是否屏蔽/延迟该行为，或者统计用户选择了允许还是拒绝。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deferredPrompt; <span class="comment">// 用于缓存 beforeinstallprompt 的事件对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeinstallprompt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 阻止该行为，只需要返回 false</span></span><br><span class="line">    <span class="comment">// event.preventDefault();</span></span><br><span class="line">    <span class="comment">// deferredPrompt = event;</span></span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 统计用户的选择</span></span><br><span class="line">    event.userChoice.then(<span class="function"><span class="keyword">function</span>(<span class="params">choiceResult</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(choiceResult.outcome); <span class="comment">// 为 dismissed 或 accepted</span></span><br><span class="line">        <span class="keyword">if</span>(choiceResult.outcome === <span class="string">'dismissed'</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'User cancelled home screen install'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'User added to home screen'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在 beforeinstallprompt 事件中屏蔽了浏览器的默认行为，在页面中通过按钮让用户主动选择</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'addToHomeScreen'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deferredPrompt) &#123;</span><br><span class="line">        deferredPrompt.prompt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a></h3><p>Cache 接口为缓存的 Request / Response  对象对提供存储机制，例如，作为ServiceWorker 生命周期的一部分。请注意，Cache 接口像 workers 一样，是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用.</p>
<p>一个域可以有多个命名 Cache 对象。你需要在你的脚本 (例如，在 ServiceWorker 中)中处理缓存更新的方式。除非明确地更新缓存，否则缓存将不会被更新；除非删除，否则缓存数据不会过期。使用 CacheStorage.open(cacheName) 打开一个Cache 对象，再使用 Cache 对象的方法去处理缓存.</p>
<p>你需要定期地清理缓存条目，因为每个浏览器都硬性限制了一个域下缓存数据的大小。缓存配额使用估算值，可以使用 StorageEstimate API 获得。浏览器尽其所能去管理磁盘空间，但它有可能删除一个域下的缓存数据。浏览器要么自动删除特定域的全部缓存，要么全部保留。确保按名称安装版本缓存，并仅从可以安全操作的脚本版本中使用缓存。查看 Deleting old caches 获取更多信息.</p>
<h4 id="Cache-match-request-options"><a href="#Cache-match-request-options" class="headerlink" title="Cache.match(request, options)"></a>Cache.match(request, options)</h4><p>返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。</p>
<p>语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.match(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 操作response</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>request：想要在Cache对象中查找的Request对象。</li>
<li>options：（可选）一个为 match 操作设置选项的对象。有效的选项如下:<ul>
<li>ignoreSearch: 一个 Boolean 值用来设置是否忽略url中的query部分。例如, 如果该参数设置为 true ，那么 <a href="http://foo.com/?value=bar中的" target="_blank" rel="noopener">http://foo.com/?value=bar中的</a> ?value=bar 部分就会在匹配中被忽略. 该选项默认为 false。</li>
<li>ignoreMethod: 一个 Boolean 值，如果设置为 true在匹配时就不会验证 Request 对象的http 方法 (通常只允许是 GET 或 HEAD 。) 该参数默认值为 false。</li>
<li>ignoreVary: 一个 Boolean 值，该值如果为 true 则匹配时不进行 VARY 部分的匹配。例如，如果一个URL匹配，此时无论Response对象是否包含VARY头部，都会认为是成功匹配。该参数默认为 false。</li>
<li>cacheName: 一个 DOMString ，代表一个具体的要被搜索的缓存。注意该选项被 Cache.match()方法忽略。</li>
</ul>
</li>
</ul>
<p>下面的例子在请求失败时提供特定的数据。 catch() 在 fetch() 的调用抛出异常时触发。在 catch() 语句中, match()用来返回正确的响应。</p>
<p>在这个例子中，我们决定只缓存通过GET取得的HTML文档. 如果 if() 条件是 false，那么这个fetch处理器就不会处理这个请求。如果还有其他的fetch处理器被注册，它们将有机会调用 event.respondWith() 如果没有fetch处理器调用 event.respondWith() ，该请求就会像没有 service worker 介入一样由浏览器处理。如果 fetch() 返回了有效的HTTP响应，相应码是4xx或5xx，那么catch() 就不会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们只想在用GET方法请求HTML文档时调用 event.respondWith()。</span></span><br><span class="line">  <span class="keyword">if</span> (event.request.method === <span class="string">'GET'</span> &amp;&amp;</span><br><span class="line">      event.request.headers.get(<span class="string">'accept'</span>).indexOf(<span class="string">'text/html'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling fetch event for'</span>, event.request.url);</span><br><span class="line">    event.respondWith(</span><br><span class="line">      fetch(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'Fetch failed; returning offline page instead.'</span>, e);</span><br><span class="line">        <span class="keyword">return</span> caches.open(OFFLINE_CACHE).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cache.match(OFFLINE_URL);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Cache-matchAll-request-options"><a href="#Cache-matchAll-request-options" class="headerlink" title="Cache.matchAll(request, options)"></a>Cache.matchAll(request, options)</h4><p>返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。</p>
<p><code>Cache.match()</code> 基本上与 <code>Cache.matchAll()</code> 相同，除了它 resolve 为 response[0] (即第一个匹配响应) 而不是 response (数组中所有匹配的响应)。</p>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.matchAll(<span class="string">'/images/'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">      cache.delete(element);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="Cache-add-request"><a href="#Cache-add-request" class="headerlink" title="Cache.add(request)"></a>Cache.add(request)</h4><p>抓取这个URL, 检索并把返回的response对象添加到给定的Cache对象.这在功能上等同于调用 <code>fetch()</code>, 然后使用 <code>Cache.put()</code> 将response添加到cache中.</p>
<p>Cache接口的 <code>add()</code>方法接受一个URL作为参数，请求参数指定的URL，并将返回的response对象添加到给定的cache中。 <code>add()</code> 方法在功能上等同于以下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad response status'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.put(url, response);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之前的Cache  (Blink 和 Gecko内核版本) 在实现Cache.add, Cache.addAll, 和 Cache.put 的策略是在response结果完全写入缓存后才会resolve当前的promise。更新后的规范版本中一旦条目被记录到数据库就会resolve当前的promise，即使当前response结果还在传输中。</p>
</blockquote>
<p>语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.add(request).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request has been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>request：要添加到cache的request。它可以是一个 Request 对象，也可以是 URL。</li>
</ul>
<p>返回值</p>
<ul>
<li>void返回值的 Promise </li>
</ul>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.add(<span class="string">'/sw-test/index.html'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Cache-addAll-requests"><a href="#Cache-addAll-requests" class="headerlink" title="Cache.addAll(requests)"></a>Cache.addAll(requests)</h4><p>抓取一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</p>
<p>语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.addAll(requests[]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// requests have been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>requests：要获取并添加到缓存的字符串URL数组。</li>
</ul>
<p>返回值</p>
<ul>
<li>A Promise that resolves with void.</li>
</ul>
<p>如下。此代码块等待一个 InstallEvent 事件触发，然后运行 waitUntil 来处理该应用程序的安装进程。 包括调用 <code>CacheStorage.open</code> 创建一个新的cache，然后使用 <code>addAll()</code> 添加一系列资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/star-wars-logo.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/bountyHunters.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/snowTroopers.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Cache-put-request-response"><a href="#Cache-put-request-response" class="headerlink" title="Cache.put(request, response)"></a>Cache.put(request, response)</h4><p>同时抓取一个请求及其响应，并将其添加到给定的cache。</p>
<p>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.put(request, response).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request/response pair has been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>request：你想缓存的请求</li>
<li>response：你想匹配的请求响应</li>
</ul>
<p>返回值</p>
<ul>
<li>A Promise that resolves with void.</li>
</ul>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response;</span><br><span class="line"><span class="keyword">var</span> cachedResponse = caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  response = r;</span><br><span class="line">  caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    cache.put(event.request, response);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> response.clone();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Cache-delete-request-options"><a href="#Cache-delete-request-options" class="headerlink" title="Cache.delete(request, options)"></a>Cache.delete(request, options)</h4><p>搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。</p>
<p>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.delete(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">true</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your cache entry has been deleted</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>request：请求删除的 Request。</li>
<li>options：（可选）一个对象，其属性控制删除操作中如何处理匹配缓存。可用的选项是：<ul>
<li>ignoreSearch: 一个 Boolean 值，指定匹配进程中是否忽略url中的查询字符串。如果设置为true，<a href="http://foo.com/?value=bar" target="_blank" rel="noopener">http://foo.com/?value=bar</a> 中的 ?value=bar 部分在执行匹配时会被忽略。默认为false。</li>
<li>ignoreMethod: 一个 Boolean 值，当设置为true时，将阻止匹配操作验证{domxref(“Request”)}} HTTP方法（通常只允许GET和HEAD）。默认为false。</li>
<li>ignoreVary: 一个 Boolean 值，当设置为true时，告诉匹配操作不执行VARY头匹配，默认为false。</li>
<li>cacheName: DOMString代表一个特定的缓存中搜索。注意,这个选项是忽视了Cache.delete()。</li>
</ul>
</li>
</ul>
<p>返回值</p>
<ul>
<li>如果cache条目被删除，则返回resolve为true的Promise，否则，返回resolve为false的 Promise。</li>
</ul>
<h4 id="Cache-keys-request-options"><a href="#Cache-keys-request-options" class="headerlink" title="Cache.keys(request, options)"></a>Cache.keys(request, options)</h4><p>返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。</p>
<p>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.keys(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">keys</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with your array of requests</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>request：（可选）如果一个相关键被指定，则返对应的 Request 。</li>
<li>options：（可选）一个对象，它的属性决定了 keys 操作中的匹配操作是如何执行的。可选的属性有：<ul>
<li>ignoreSearch: 一个 Boolean 值，指定了匹配操作是否忽略url中的查询部分。如果为 true ，在执行匹配操作时， <a href="http://foo.com/?value=bar" target="_blank" rel="noopener">http://foo.com/?value=bar</a> 的 ?value=bar 部分将会被忽。默认为 false 。</li>
<li>ignoreMethod: 一个 Boolean 值，当为 true 时， 将会阻止匹配操作验证 Request 的 HTTP 方法（通常只有 GET 和 HEAD 方法被允许）。默认为 false 。</li>
<li>ignoreVary: 一个 Boolean 值，当为 true 时，告诉匹配操作不要验证 VARY 头部。换句话说，如果 URL 匹配，你会得到一个匹配而不管 Response 对象是否有 VARY 头部。默认为 false 。</li>
<li>cacheName: 一个 DOMString 值，描述了在一个特定的 cache 中进行匹配。注意这个选项会被 Cache.keys()方法忽略。</li>
</ul>
</li>
</ul>
<p>返回值</p>
<ul>
<li>返回一个解析为 Cache 键数组的 Promise。</li>
</ul>
<p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keys</span>) </span>&#123;</span><br><span class="line">    keys.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">request, index, array</span>) </span>&#123;</span><br><span class="line">      cache.delete(request);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><p>此代码段来自 service worker selective caching sample。该代码使用CacheStorage.open(cacheName) 打开任何具有以font/开始的Content-Type头的Cache对象。</p>
<p>代码然后使用<code>Cache.match(request, options)</code>查看缓存中是否已经有一个匹配的font，如果是，则返回它。 如果没有匹配的字体，代码将通过网络获取字体，并使用 <code>Cache.put(request, response)</code>来缓存获取的资源。</p>
<p>代码处理从<code>fetch()</code> 操作抛出的异常。 请注意，HTTP错误响应（例如404）不会触发异常。 它将返回一个具有相应错误代码集的正常响应对象。</p>
<p>该代码片段还展示了服务工作线程使用的缓存版本控制的最佳实践。 虽然在这个例子中只有一个缓存，但同样的方法可用于多个缓存。 它将缓存的速记标识符映射到特定的版本化缓存名称。 代码还会删除命名不在CURRENT_CACHES中的所有缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写标识符映射到特定版本的缓存。</span></span><br><span class="line"><span class="keyword">var</span> CURRENT_CACHES = &#123;</span><br><span class="line">  font: <span class="string">'font-cache-v'</span> + CACHE_VERSION</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> expectedCacheNames = <span class="built_in">Object</span>.keys(CURRENT_CACHES).map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CURRENT_CACHES[key];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在promise成功完成之前，活跃的worker不会被视作已激活。</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (expectedCacheNames.indexOf(cacheName) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Deleting out of date cache:'</span>, cacheName);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Handling fetch event for'</span>, event.request.url);</span><br><span class="line"></span><br><span class="line">  event.respondWith(</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开以'font'开头的Cache对象。</span></span><br><span class="line">    caches.open(CURRENT_CACHES[<span class="string">'font'</span>]).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">' Found response in cache:'</span>, response);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理match()或fetch()引起的异常。</span></span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'  Error in fetch handler:'</span>, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener">CacheStorage</a></h3><p>CacheStorage 接口表示 Cache 对象的存储。它提供了一个 ServiceWorker 、其它类型worker或者 window 范围内可以访问到的所有命名cache的主目录（它并不是一定要和service workers一起使用，即使它是在service workers规范中定义的），并维护一份字符串名称到相应 Cache 对象的映射。</p>
<p>CacheStorage  同样暴露了 <code>CacheStorage.open()</code> 和 <code>CacheStorage.match()</code> 方法。使用 <code>CacheStorage.open()</code> 获取 Cache 实例。使用 <code>CacheStorage.match()</code> 检查给定的 Request 是否是 CacheStorage 对象跟踪的任何 Cache 对象中的键。</p>
<p>你可以通过 caches 属性访问 CacheStorage .</p>
<h4 id="CacheStorage-match"><a href="#CacheStorage-match" class="headerlink" title="CacheStorage.match()"></a>CacheStorage.match()</h4><p>检查给定的 Request 是否是 CacheStorage 对象跟踪的任何 Cache 对象的键，并返回一个resolve为该匹配的 Promise .</p>
<h4 id="CacheStorage-has"><a href="#CacheStorage-has" class="headerlink" title="CacheStorage.has()"></a>CacheStorage.has()</h4><p>如果存在与 cacheName 匹配的 Cache 对象，则返回一个resolve为true的 Promise .<br><code>CacheStorage.open()</code><br>返回一个 Promise ，resolve为匹配  cacheName （如果不存在则创建一个新的cache）的 Cache 对象</p>
<h4 id="CacheStorage-delete"><a href="#CacheStorage-delete" class="headerlink" title="CacheStorage.delete()"></a>CacheStorage.delete()</h4><p>查找匹配 cacheName 的 Cache 对象，如果找到，则删除 Cache 对象并返回一个resolve为true的 Promise 。如果没有找到 Cache 对象，则返回 false.</p>
<h4 id="CacheStorage-keys"><a href="#CacheStorage-keys" class="headerlink" title="CacheStorage.keys()"></a>CacheStorage.keys()</h4><p>返回一个 Promise ，它将使用一个包含与 CacheStorage 追踪的所有命名 Cache 对象对应字符串的数组来resolve. 使用该方法迭代所有 Cache 对象的列表。</p>
<h4 id="综合示例-1"><a href="#综合示例-1" class="headerlink" title="综合示例"></a>综合示例</h4><p>此 service worker 脚本等待 InstallEvent 触发，然后运行 waitUntil 来处理应用程序的安装过程。这包括调用 CacheStorage.open 创建一个新的cache，然后使用 Cache.addAll 向其添加一系列资源。</p>
<p>在第二个代码块，我们等待 FetchEvent 触发。我们构建自定义相应，像这样：</p>
<p>检查CacheStorage中是否找到了匹配请求的内容。如果是，使用匹配内容。<br>如果没有，从网络获取请求，然后同样打开第一个代码块中创建的cache，并使用 Cache.put (cache.put(event.request, response.clone()).) 将请求的clone副本添加到它。<br>如果此操作失败（例如，因为网络关闭），返回备用相应。<br>最后，使用 FetchEvent.respondWith 返回自定义响应最终等于的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/star-wars-logo.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/bountyHunters.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/snowTroopers.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> response;</span><br><span class="line">  event.respondWith(caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    response = r;</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.clone();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Client" target="_blank" rel="noopener">Client</a></h3><p>Client 接口表示一个可执行的上下文，如Worker或SharedWorker。Window 客户端由更具体的WindowClient表示。 你可以从<code>Clients.matchAll()</code> 和<code>Clients.get()</code>等方法获取Client/WindowClient对象。</p>
<h4 id="Client-postMessage"><a href="#Client-postMessage" class="headerlink" title="Client.postMessage()"></a>Client.postMessage()</h4><p>向client发送一条消息。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>Client.id：只读。客户端的唯一通用标识符，字符串形式。</li>
<li>Client.type：只读。客户端的类型，字符串形式。可能是”window”, “worker”, 或 “sharedworker”。</li>
<li>Client.url：只读。客户端的URL，字符串形式。</li>
</ul>
<h3 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clients" target="_blank" rel="noopener">Clients</a></h3><p>Clients 接口提供对 Client 对象的访问. 通过在  service worker 中使用 self.clients 访问它.</p>
<h4 id="Clients-get"><a href="#Clients-get" class="headerlink" title="Clients.get()"></a>Clients.get()</h4><p>返回一个匹配给定 id 的 Client 的 Promise .</p>
<h4 id="Clients-matchAll"><a href="#Clients-matchAll" class="headerlink" title="Clients.matchAll()"></a>Clients.matchAll()</h4><p>返回一个 Client 对象数组的 Promise . options参数允许您控制返回的clients类型.<br><code>Clients.openWindow()</code><br>打开给定URL的新浏览器窗口，并返回新 WindowClient a 的 Promise .</p>
<h4 id="Clients-claim"><a href="#Clients-claim" class="headerlink" title="Clients.claim()"></a>Clients.claim()</h4><p>允许一个激活的 service worker 将自己设置为其scope 内所有 clients 的 controller . </p>
<h4 id="综合示例-2"><a href="#综合示例-2" class="headerlink" title="综合示例"></a>综合示例</h4><p>下面示例显示一个已有的聊天窗口，或者当用户点击通知时创建新的窗口.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'notificationclick'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> allClients = <span class="keyword">await</span> clients.matchAll(&#123;</span><br><span class="line">      includeUncontrolled: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's see if we already have a chat window open:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> allClients) &#123;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="keyword">new</span> URL(client.url);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (url.pathname == <span class="string">'/chat/'</span>) &#123;</span><br><span class="line">        <span class="comment">// Excellent, let's use it!</span></span><br><span class="line">        client.focus();</span><br><span class="line">        chatClient = client;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we didn't find an existing chat window,</span></span><br><span class="line">    <span class="comment">// open a new one:</span></span><br><span class="line">    <span class="keyword">if</span> (!chatClient) &#123;</span><br><span class="line">      chatClient = <span class="keyword">await</span> clients.openWindow(<span class="string">'/chat/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Message the client:</span></span><br><span class="line">    chatClient.postMessage(<span class="string">"New chat messages!"</span>);</span><br><span class="line">  &#125;());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ExtendableEvent"><a href="#ExtendableEvent" class="headerlink" title="ExtendableEvent"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent" target="_blank" rel="noopener">ExtendableEvent</a></h3><p>作为 service worker 生命周期的一部分，ExtendableEvent接口延长了在全局范围上install和activate事件的生命周期。这样可以确保在升级数据库架构并删除过时的caches之前，不会调度任何函数事件（如FetchEvent）。<br>如果在ExtendableEvent处理程序之外调用<code>waitUntil()</code>，浏览器应该抛出一个InvalidStateError；还要注意，多个调用将堆积起来，结果promises 将添加到extend lifetime promises.</p>
<h4 id="综合示例-3"><a href="#综合示例-3" class="headerlink" title="综合示例"></a>综合示例</h4><p>代码在ServiceWorkerGlobalScope.oninstall中调用ExtendableEvent.waitUntil()，延迟将ServiceWorkerRegistration.installing Worker视为已安装，直到传递的promise resolve(在所有资源都已被提取和缓存的情况，或者发生任何异常时的问题.)</p>
<p>代码段还显示了对service worker使用的缓存进行版本控制的最佳实践。虽然在这个例子中只有一个缓存，但是相同的方法可以用于多个缓存。它将缓存的速记标识符映射到特定的、版本化的缓存名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_VERSION = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> CURRENT_CACHES = &#123;</span><br><span class="line">  prefetch: <span class="string">'prefetch-cache-v'</span> + CACHE_VERSION</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> urlsToPrefetch = [</span><br><span class="line">    <span class="string">'./static/pre_fetched.txt'</span>,</span><br><span class="line">    <span class="string">'./static/pre_fetched.html'</span>,</span><br><span class="line">    <span class="string">'https://www.chromium.org/_/rsrc/1302286216006/config/customLogo.gif'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Handling install event. Resources to pre-fetch:'</span>, urlsToPrefetch);</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CURRENT_CACHES[<span class="string">'prefetch'</span>]).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.addAll(urlsToPrefetch.map(<span class="function"><span class="keyword">function</span>(<span class="params">urlToPrefetch</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Request(urlToPrefetch, &#123;<span class="attr">mode</span>: <span class="string">'no-cors'</span>&#125;);</span><br><span class="line">      &#125;)).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'All resources have been fetched and cached.'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Pre-fetching failed:'</span>, error);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ExtendableMessageEvent"><a href="#ExtendableMessageEvent" class="headerlink" title="ExtendableMessageEvent"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableMessageEvent" target="_blank" rel="noopener">ExtendableMessageEvent</a></h3><h3 id="FetchEvent"><a href="#FetchEvent" class="headerlink" title="FetchEvent"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent" target="_blank" rel="noopener">FetchEvent</a></h3><p>使用ServiceWorker技术时,页面的提取动作会在ServiceWorker作用域(ServiceWorkerGlobalScope)中触发fetch事件.</p>
<p>使用 ServiceWorkerGlobalScope.onfetch或addEventListener监听.<br>该事件回调会注入FetchEvent参数.它携带了有关请求和结果响应的信息以及方法FetchEvent.respondWith() ,允许我们向受控页面提供任意响应.</p>
<h3 id="InstallEvent"><a href="#InstallEvent" class="headerlink" title="InstallEvent"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/InstallEvent" target="_blank" rel="noopener">InstallEvent</a></h3><p>该参数传递到 oninstall 事件处理程序，InstallEvent接口表示一个 ServiceWorker 的 ServiceWorkerGlobalScope 上分派的安装操作。作为 ExtendableEvent 的一个子类，它确保在安装期间不调度诸如 FetchEvent 之类的功能事件。</p>
<h3 id="serviceWorker"><a href="#serviceWorker" class="headerlink" title="serviceWorker"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/serviceWorker" target="_blank" rel="noopener">serviceWorker</a></h3><p>Navigator.serviceWorker 只读属性，返回关联文件的 ServiceWorkerContainer 对象，它提供对ServiceWorker 的注册、删除、升级和通信的访问。</p>
<h3 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker" target="_blank" rel="noopener">ServiceWorker</a></h3><p>ServiceWorker API 的 ServiceWorker接口 提供一个对一个服务工作者的引用。 多个浏览上下文（例如页面，工作者等）可以与相同的服务工作者相关联，每个都通过唯一的ServiceWorker对象。</p>
<p>一个ServiceWorker对象在 ServiceWorkerRegistration.active 属性和 ServiceWorkerContainer.controller 属性中可用 — 这是一个激活并在控制页面的service worker(service worker成功注册,被控页面已经重新加载完毕.)</p>
<p>ServiceWorker接口被分配了一系列生命周期事件 — 安装和激活 — 以及功能型的事件,包括 fetch.一个ServiceWorker对象有一个与之关联的 ServiceWorker.state,指示着它的生命周期.</p>
<p>属性<br>ServiceWorker 接口继承它父类Worker的属性.</p>
<ul>
<li>ServiceWorker.scriptURL：只读。返回作为 ServiceWorkerRegistration 一部分所定义的ServiceWorker序列化脚本URL.这个URL必须和注册该ServiceWorker的文档处于同一域.</li>
<li>ServiceWorker.state：只读。返回service worker的状态.其值可能是如下之一:installing,installed,activating,activated或者是redundant.</li>
</ul>
<p>事件</p>
<ul>
<li>ServiceWorker.onstatechange：只读<br>一个一旦 ServiceWorker.state 发生改变时,即一个类型为statechange事件触发时就会被调用的 EventListener 属性.</li>
</ul>
<h4 id="综合示例-4"><a href="#综合示例-4" class="headerlink" title="综合示例"></a>综合示例</h4><p>这段代码监听了ServiceWorker.state 的变化并且返回它的值.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>, &#123;</span><br><span class="line">        scope: <span class="string">'./'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> serviceWorker;</span><br><span class="line">        <span class="keyword">if</span> (registration.installing) &#123;</span><br><span class="line">            serviceWorker = registration.installing;</span><br><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'#kind'</span>).textContent = <span class="string">'installing'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.waiting) &#123;</span><br><span class="line">            serviceWorker = registration.waiting;</span><br><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'#kind'</span>).textContent = <span class="string">'waiting'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.active) &#123;</span><br><span class="line">            serviceWorker = registration.active;</span><br><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'#kind'</span>).textContent = <span class="string">'active'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serviceWorker) &#123;</span><br><span class="line">            <span class="comment">// logState(serviceWorker.state);</span></span><br><span class="line">            serviceWorker.addEventListener(<span class="string">'statechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// logState(e.target.state);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch (<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Something went wrong during registration. The service-worker.js file</span></span><br><span class="line">        <span class="comment">// might be unavailable or contain a syntax error.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The current browser doesn't support service workers.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ServiceWorkerContainer"><a href="#ServiceWorkerContainer" class="headerlink" title="ServiceWorkerContainer"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer" target="_blank" rel="noopener">ServiceWorkerContainer</a></h3><p>ServiceWorkerContainer接口为 service worker提供一个容器般的功能，包括对service worker的注册，卸载 ，更新和访问service worker的状态，以及他们的注册者</p>
<p>主要是<code>ServiceWorkerContainer.register(scriptURL, scope[, base])</code>提供一个注册service worker的方法，ServiceWorkerContainer.controller将获取当前控制页面网络的service worker。</p>
<h3 id="ServiceWorkerGlobalScope"><a href="#ServiceWorkerGlobalScope" class="headerlink" title="ServiceWorkerGlobalScope"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerGlobalScope" target="_blank" rel="noopener">ServiceWorkerGlobalScope</a></h3><h3 id="ServiceWorkerRegistration"><a href="#ServiceWorkerRegistration" class="headerlink" title="ServiceWorkerRegistration"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerRegistration" target="_blank" rel="noopener">ServiceWorkerRegistration</a></h3><h3 id="WindowClient"><a href="#WindowClient" class="headerlink" title="WindowClient"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowClient" target="_blank" rel="noopener">WindowClient</a></h3><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>有一篇较为著名的文章<a href="http://sakurity.com/blog/2015/08/13/middlekit.html" target="_blank" rel="noopener">《Using Appcache and ServiceWorker for Evil》</a>，文章讲述黑下服务器后，通过 Middlekit 技术，污染每个访问者的浏览器cache，通过这个方法，我们能够改变请求的响应，将请求代理到我们的server，造成持久的session hijacking 和 XSS。</p>
<p><img src="/images/sw/i-sw-xss.png" alt="i-sw-xss.png"></p>
<p>其中 Appcache 主要利用的是 cache-manifest 文件也被缓存时，从站点方面无法进行更新，那么网站方面即使知道了这种问题，也是无能为力。</p>
<p>对于 ServiceWorker 的利用，则是通过构造 ServiceWorker 的脚本并向用户注册。<br>想象一下，如果站点方面还没有 ServiceWorker 的意识，却被中间人提前利用了，用户被攻击了一次，却导致后续的访问都会被该 ServiceWorker 劫持。</p>
<h2 id="demos"><a href="#demos" class="headerlink" title="demos"></a>demos</h2><h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo 1"></a>demo 1</h3><p>下面的例子说明了service worker的运行时加载图像缓存的响应。（<a href="https://github.com/googlechrome/samples/tree/gh-pages/service-worker/basic" target="_blank" rel="noopener">github访问源码&gt;&gt;</a>）</p>
<p>第一次请求给定的图像,服务人员将从网络请求,但每个随后的时间,它将从缓存中检索。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#show'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> iconUrl = <span class="built_in">document</span>.querySelector(<span class="string">'select'</span>).selectedOptions[<span class="number">0</span>].value;</span><br><span class="line">  <span class="keyword">let</span> imgElement = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  imgElement.src = iconUrl;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>).appendChild(imgElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service-worker.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Names of the two caches used in this version of the service worker.</span></span><br><span class="line"><span class="comment">// Change to v2, etc. when you update any of the local resources, which will</span></span><br><span class="line"><span class="comment">// in turn trigger the install event again.</span></span><br><span class="line"><span class="keyword">const</span> PRECACHE = <span class="string">'precache-v1'</span>;</span><br><span class="line"><span class="keyword">const</span> RUNTIME = <span class="string">'runtime'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们想缓存的本地资源列表</span></span><br><span class="line"><span class="keyword">const</span> PRECACHE_URLS = [</span><br><span class="line">  <span class="string">'index.html'</span>,</span><br><span class="line">  <span class="string">'./'</span>, <span class="comment">// Alias for index.html</span></span><br><span class="line">  <span class="string">'styles.css'</span>,</span><br><span class="line">  <span class="string">'../../styles/main.css'</span>,</span><br><span class="line">  <span class="string">'demo.js'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装控制器处理我们需要预缓存的资源</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(PRECACHE)</span><br><span class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> cache.addAll(PRECACHE_URLS))</span><br><span class="line">      .then(self.skipWaiting())</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活控制器处理要清除的旧缓存</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> currentCaches = [PRECACHE, RUNTIME];</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="params">cacheNames</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheNames.filter(<span class="function"><span class="params">cacheName</span> =&gt;</span> !currentCaches.includes(cacheName));</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">cachesToDelete</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(cachesToDelete.map(<span class="function"><span class="params">cacheToDelete</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> caches.delete(cacheToDelete);</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> self.clients.claim())</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求控制器从缓存中提供同源资源响应</span></span><br><span class="line"><span class="comment">// 如果没有发现任何响应,它填充运行时缓存响应</span></span><br><span class="line"><span class="comment">// 从网络返回之前页面。</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// Skip cross-origin requests, like those for Google Analytics.</span></span><br><span class="line">  <span class="keyword">if</span> (event.request.url.startsWith(self.location.origin)) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">      caches.match(event.request).then(<span class="function"><span class="params">cachedResponse</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedResponse) &#123;</span><br><span class="line">          <span class="keyword">return</span> cachedResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> caches.open(RUNTIME).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fetch(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Put a copy of the response in the runtime cache.</span></span><br><span class="line">            <span class="keyword">return</span> cache.put(event.request, response.clone()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h2><h3 id="webpack接入"><a href="#webpack接入" class="headerlink" title="webpack接入"></a>webpack接入</h3><p>插件<a href="https://www.npmjs.com/package/serviceworker-webpack-plugin" target="_blank" rel="noopener">npm serviceworker-webpack-plugin</a></p>
<p>用 Webpack 构建接入 Service Workers 的离线应用要解决的关键问题在于如何生成上面提到的 sw.js 文件， 并且sw.js文件中的 cacheFileList 变量，代表需要被缓存文件的 URL 列表，需要根据输出文件列表所对应的 URL 来决定，而不是像上面那样写成静态值。</p>
<p>假如构建输出的文件目录结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── app_4c3e186f.js</span><br><span class="line">├── app_7cc98ad0.css</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure></p>
<p>那么 sw.js 文件中 cacheFileList 的值应该是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheFileList = [</span><br><span class="line">  <span class="string">'/index.html'</span>,</span><br><span class="line">  <span class="string">'app_4c3e186f.js'</span>,</span><br><span class="line">  <span class="string">'app_7cc98ad0.css'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>使用该插件后的 Webpack 配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; WebPlugin &#125; = <span class="built_in">require</span>(<span class="string">'web-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ServiceWorkerWebpackPlugin = <span class="built_in">require</span>(<span class="string">'serviceworker-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./main.js'</span><span class="comment">// Chunk app 的 JS 执行入口文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    publicPath: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,<span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">        <span class="comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [<span class="string">'css-loader'</span>] <span class="comment">// 压缩 CSS 代码</span></span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 一个 WebPlugin 对应一个 HTML 文件</span></span><br><span class="line">    <span class="keyword">new</span> WebPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./template.html'</span>, <span class="comment">// HTML 模版文件所在的文件路径</span></span><br><span class="line">      filename: <span class="string">'index.html'</span> <span class="comment">// 输出的 HTML 的文件名称</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      filename: <span class="string">`[name].css`</span>,<span class="comment">// 给输出的 CSS 文件名称加上 Hash 值</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ServiceWorkerWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 自定义的 sw.js 文件所在路径</span></span><br><span class="line">      <span class="comment">// ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中</span></span><br><span class="line">      entry: path.join(__dirname, <span class="string">'sw.js'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。</span></span><br><span class="line">    https: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：serviceworker-webpack-plugin 插件为了保证灵活性，允许使用者自定义 sw.js，构建输出的 sw.js 文件中会在头部注入一个变量 serviceWorkerOption.assets 到全局，里面存放着所有需要被缓存的文件的 URL 列表。</p>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><p><a href="https://github.com/facebook/create-react-app#readme" target="_blank" rel="noopener">create-react-app</a>的默认模板支持。</p>
<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><p><a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> 3起在模板选择时选择<code>PWA Support</code>即可。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="如果把HTML给cache了，如何进行更新？"><a href="#如果把HTML给cache了，如何进行更新？" class="headerlink" title="如果把HTML给cache了，如何进行更新？"></a>如果把HTML给cache了，如何进行更新？</h3><p>如果把页面html也缓存了，例如把首页缓存了，就会有一个尴尬的问题——Service Worker是在页面注册的，但是现在获取页面的时候是从缓存取的，每次都是一样的，所以就导致无法更新Service Worker，如变成sw-5.js，但是PWA又要求我们能缓存页面html。那怎么办呢？谷歌的开发者文档它只是提到会存在这个问题，但并没有说明怎么解决这个问题。这个的问题的解决就要求我们要有一个机制能知道html更新了，从而把缓存里的html给替换掉。</p>
<p>Manifest更新缓存的机制是去看Manifest的文本内容有没有发生变化，如果发生变化了，则会去更新缓存，Service Worker也是根据sw.js的文本内容有没有发生变化，我们可以借鉴这个思想，如果请求的是html并从缓存里取出来后，再发个请求获取一个文件看html更新时间是否发生变化，如果发生变化了则说明发生更改了，进而把缓存给删了。所以可以在服务端通过控制这个文件从而去更新客户端的缓存。如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">"fetch"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// cache hit</span></span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="comment">//如果取的是html，则看发个请求看html是否更新了</span></span><br><span class="line">                <span class="keyword">if</span> (response.headers.get(<span class="string">"Content-Type"</span>).indexOf(<span class="string">"text/html"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"update html"</span>);</span><br><span class="line">                    <span class="keyword">let</span> url = <span class="keyword">new</span> URL(event.request.url);</span><br><span class="line">                    util.updateHtmlPage(url, event.request.clone(), event.clientId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> util.fetchPut(event.request.clone());</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过响应头header的content-type是否为text/html，如果是的话就去发个请求获取一个文件，根据这个文件的内容决定是否需要删除缓存，这个更新的函数util.updateHtmlPage是这么实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageUpdateTime = &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> util = &#123;</span><br><span class="line">    updateHtmlPage: <span class="function"><span class="keyword">function</span> (<span class="params">url, htmlRequest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pageName = util.getPageName(url);</span><br><span class="line">        <span class="keyword">let</span> jsonRequest = <span class="keyword">new</span> Request(<span class="string">"/html/service-worker/cache-json/"</span> + pageName + <span class="string">".sw.json"</span>);</span><br><span class="line">        fetch(jsonRequest).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            response.json().then(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pageUpdateTime[pageName] !== content.updateTime) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"update page html"</span>);</span><br><span class="line">                    <span class="comment">// 如果有更新则重新获取html</span></span><br><span class="line">                    util.fetchPut(htmlRequest);</span><br><span class="line">                    pageUpdateTime[pageName] = content.updateTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    delCache: <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        caches.open(CACHE_NAME).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"delete cache "</span> + url);</span><br><span class="line">            cache.delete(url, &#123;<span class="attr">ignoreVary</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码先去获取一个json文件，一个页面会对应一个json文件，这个json的内容是这样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"updateTime":"10/2/2017, 3:23:57 PM","resources": &#123;img: [], css: []&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面主要有一个updateTime的字段，如果本地内存没有这个页面的updateTime的数据或者是和最新updateTime不一样，则重新去获取 html，然后放到缓存里。接着需要通知页面线程数据发生变化了，你刷新下页面吧。这样就不用等用户刷新页面才能生效了。所以当刷新完页面后用postMessage通知页面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> util = &#123;</span><br><span class="line">    postMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> allClients = <span class="keyword">await</span> clients.matchAll();</span><br><span class="line">        allClients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> client.postMessage(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">util.fetchPut(htmlRequest, <span class="literal">false</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    util.postMessage(&#123;<span class="attr">type</span>: <span class="number">1</span>, <span class="attr">desc</span>: <span class="string">"html found updated"</span>, <span class="attr">url</span>: url.href&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>并规定type: 1就表示这是一个更新html的消息，然后在页面监听message事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> msg = event.data;</span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="number">1</span> &amp;&amp; <span class="built_in">window</span>.location.href === msg.url) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"recv from service worker"</span>, event.data);</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后当我们需要更新html的时候就更新json文件，这样用户就能看到最新的页面了。或者是当用户重新启动浏览器的时候会导致Service Worker的运行内存都被清空了，即存储页面更新时间的变量被清空了，这个时候也会重新请求页面。</p>
<p>需要注意的是，要把这个json文件的http cache时间设置成0，这样浏览器就不会缓存了，如下nginx的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .sw.json$ &#123;</span><br><span class="line">    expires <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这个文件是需要实时获取的，不能被缓存，firefox默认会缓存，Chrome不会，加上http缓存时间为0，firefox也不会缓存了。</p>
<p>还有一种更新是用户更新的，例如用户发表了评论，需要在页面通知service worker把html缓存删了重新获取，这是一个反过来的消息通知：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">".comment-form"</span>).addEventListener(<span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            navigator.serviceWorker.controller.postMessage(&#123;</span><br><span class="line">                type: <span class="number">1</span>, </span><br><span class="line">                desc: <span class="string">"remove html cache"</span>, </span><br><span class="line">                url: <span class="built_in">window</span>.location.href&#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service Worker也监听message事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> messageProcess = &#123;</span><br><span class="line">    <span class="comment">// 删除html index</span></span><br><span class="line">    <span class="number">1</span>: <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        util.delCache(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> util = &#123;</span><br><span class="line">    delCache: <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        caches.open(CACHE_NAME).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"delete cache "</span> + url);</span><br><span class="line">            cache.delete(url, &#123;<span class="attr">ignoreVary</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> messageProcess[msg.type] === <span class="string">"function"</span>) &#123;</span><br><span class="line">        messageProcess[msg.type](msg.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>根据不同的消息类型调不同的回调函数，如果是1的话就是删除cache。用户发表完评论后会触发刷新页面，刷新的时候缓存已经被删了就会重新去请求了。</p>
<p>这样就解决了实时更新的问题。</p>
<h3 id="我们知道http也有缓存，如果都用了会如何？"><a href="#我们知道http也有缓存，如果都用了会如何？" class="headerlink" title="我们知道http也有缓存，如果都用了会如何？"></a>我们知道http也有缓存，如果都用了会如何？</h3><p>要缓存可以使用三种手段，使用Http Cache设置缓存时间，也可以用Manifest的Application Cache，还可以用Service Worker缓存，如果三者都用上了会怎么样呢？</p>
<p>会以Service Worker为优先，因为Service Worker把请求拦截了，它最先做处理，如果它缓存库里有的话直接返回，没有的话正常请求，就相当于没有Service Worker了，这个时候就到了Manifest层，Manifest缓存里如果有的话就取这个缓存，如果没有的话就相当于没有Manifest了，于是就会从Http缓存里取了，如果Http缓存里也没有就会发请求去获取，服务端根据Http的etag或者Modified Time可能会返回304 Not Modified，否则正常返回200和数据内容。这就是整一个获取的过程。</p>
<p>所以如果既用了Manifest又用Service Worker的话应该会导致同一个资源存了两次。但是可以让支持Service Worker的浏览器使用Service Worker，而不支持的使用Manifest.</p>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul>
<li><a href="https://serviceworke.rs/" target="_blank" rel="noopener">https://serviceworke.rs/</a></li>
<li><a href="https://github.com/w3c/ServiceWorker" target="_blank" rel="noopener">https://github.com/w3c/ServiceWorker</a></li>
<li><a href="https://googlechrome.github.io/samples/service-worker/basic/" target="_blank" rel="noopener">https://googlechrome.github.io/samples/service-worker/basic/</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API</a></li>
<li><a href="https://lzw.me/a/pwa-service-worker.html#1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Service%20Worker" target="_blank" rel="noopener">https://lzw.me/a/pwa-service-worker.html</a></li>
<li><a href="http://sakurity.com/blog/2015/08/13/middlekit.html" target="_blank" rel="noopener">http://sakurity.com/blog/2015/08/13/middlekit.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache</a></li>
<li><a href="https://github.com/w3c-webmob/ServiceWorkersDemos" target="_blank" rel="noopener">https://github.com/w3c-webmob/ServiceWorkersDemos</a></li>
<li><a href="https://github.com/TalAter/awesome-service-workers" target="_blank" rel="noopener">https://github.com/TalAter/awesome-service-workers</a></li>
</ul>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2020/08/08/tools/【工具】性能测试中QPS、TPS等字段含义/" class="prev">上一篇<span>【工具】性能测试中QPS、TPS等字段含义</span></a></div><div class="post-next"><a href="/2020/07/14/notes/【笔记】前端业务开发的注意点/" class="next">下一篇<span>【笔记】前端业务开发的注意点整理</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> 近期文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/12/17/notes/【笔记】《演进式架构》（二）/">【笔记】《演进式架构》学习笔记（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/10/notes/【笔记】《演进式架构》（一）/">【笔记】《演进式架构》学习笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/19/typescript/浅谈TypeScript的图灵完备性/">浅谈TypeScript的图灵完备性</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/23/notes/【笔记】《我的架构思想：基本模型、理论与原则》编三/">【笔记】《我的架构思想：基本模型、理论与原则》编三——架构原则，技艺、艺术与美</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/04/notes/【笔记】《我的架构思想：基本模型、理论与原则》编二/">【笔记】《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> 标签</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/">prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serviceWorker/">serviceWorker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形处理/">图形处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> 归档</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2022 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-92791318-1",'auto');ga('send','pageview');</script></body></html>