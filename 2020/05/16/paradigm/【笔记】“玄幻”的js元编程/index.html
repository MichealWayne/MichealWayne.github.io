<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【笔记】“玄幻”的js元编程 | Wayne的博客</title><meta name="description" content="【笔记】“玄幻”的js元编程 - Micheal Wayne"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.michealwayne.cn/atom.xml" title="Wayne的博客"></head><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">Home</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">Archive</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">About</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="search" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">【笔记】“玄幻”的js元编程</h1><span class="post-date">May 16, 2020</span><span class="post-tag"><a href="/tags/js/">js</a><a href="/tags/概念/">概念</a><a href="/tags/es6/">es6</a></span><img src="/images/icons/js.png" class="bgimage"><div class="post-content"><h1 id="“玄幻”的js元编程"><a href="#“玄幻”的js元编程" class="headerlink" title="“玄幻”的js元编程"></a>“玄幻”的js元编程</h1><h2 id="1-元编程"><a href="#1-元编程" class="headerlink" title="1.元编程"></a>1.元编程</h2><p>元编程是指操作目标是程序本身的行为特性的编程。</p>
<blockquote>
<p>元编程（Metaprogramming）是指某类<a href="https://baike.baidu.com/item/计算机程序/3220205" target="_blank" rel="noopener">计算机程序</a>的编写，这类计算机程序编写或者操纵其他<a href="https://baike.baidu.com/item/程序/13831935" target="_blank" rel="noopener">程序</a>（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为<a href="https://baike.baidu.com/item/元语言/8251488" target="_blank" rel="noopener">元语言</a>，被操作的语言称之为<a href="https://baike.baidu.com/item/目标语言/88379" target="_blank" rel="noopener">目标语言</a>。一门语言同时也是自身的元语言的能力称之为反射。</p>
</blockquote>
<p>反射是促进元编程的一种很有价值的语言特性。把编程语言自身作为头等对象（如Lisp或Rebol）也很有用。支持<a href="https://baike.baidu.com/item/泛型编程" target="_blank" rel="noopener">泛型编程</a>的语言也使用元编程能力。</p>
<p>元编程通常有两种方式起作用。一种方式是通过<a href="https://baike.baidu.com/item/应用程序接口" target="_blank" rel="noopener">应用程序接口</a>（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。</p>
<p>看起来很玄幻。。。</p>
<h2 id="2-js-与-元编程"><a href="#2-js-与-元编程" class="headerlink" title="2.js 与 元编程"></a>2.js 与 元编程</h2><h3 id="继续理解概念"><a href="#继续理解概念" class="headerlink" title="继续理解概念"></a>继续理解概念</h3><p>以例子来看，比如我们想要查看对象 a 和另外一个对象 b 的关系是否是 <code>[[Prototype]]</code> 链接的，可以使用 <code>a.isPrototype(b)</code>，这就是一种元编程形式，通常称为<strong>内省（introspection）</strong>。另外一个明显的元编程例子是宏（在 js 中还不支持）——代码在编译时修改自身。用<code>for..in</code> 循环枚举对象的键，或者检查一个对象是否是某个“类构造器”的实例，也都是常见的元编程例子。</p>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>元编程关注以下一点或几点：</p>
<ul>
<li><strong>代码查看自身</strong></li>
<li><strong>代码修改自身</strong></li>
<li><strong>代码修改默认语言特性，以此影响其他代码。</strong></li>
</ul>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>元编程的目标是利用语言自身的内省能力使代码的其余部分<strong>更具描述性、表达性和灵活性</strong>。因为元编程的元（meta）本质，我们有点难以给出比上面提到的更精确的定义。</p>
<h3 id="ES5-与-元编程"><a href="#ES5-与-元编程" class="headerlink" title="ES5 与 元编程"></a>ES5 与 元编程</h3><h4 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h4><p>你的代码在有些情况下可能想要了解自身，想要知道某个函数的名称是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test.name);	<span class="comment">// 'test'</span></span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="noopener">name 属性</a>是用于元编程目的的，这里比较混乱，因为默认情况下函数的词法名称（如果有的话）也会被设为它的 name 属性。实际上，ES5（和之前的）规范对这一行为并没有正式要求。name 属性的设定是非标准的，但还是比较可靠的。而在 ES6 中这一点已经得到了标准化。</p>
<blockquote>
<p>如果函数设定了 name 值，那么这个值通常也就是开发者工具中栈踪迹使用的名称。</p>
</blockquote>
<p>默认情况下，name 属性不可写，但可配置，也就是说如果需要的话，可使用 <code>Object.defineProperty(..)</code> 来手动修改。</p>
<h3 id="ES6-与-元编程"><a href="#ES6-与-元编程" class="headerlink" title="ES6 与 元编程"></a>ES6 与 元编程</h3><p>从ECMAScript 2015 开始，JavaScript 获得了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener"><code>Proxy</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener"><code>Reflect</code></a> 对象的支持，允许你拦截并定义基本语言操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。借助这两个对象，你可以在 JavaScript 元级别进行编程。</p>
<h3 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h3><p>元属性以属性访问的形式提供特殊的其他方法无法获取的元信息。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new.target</a> 为例，关键字 new 用作属性访问的上下文。显然，new 本身并不是一个对象，因此这个功能很特殊。而在构造器调用（通过 new 触发的函数 / 方法）内部使用 new.target 时，new 成了一个虚拟上下文，使得 new.target 能够指向调用 new 的目标构造器。</p>
<p>这个是元编程操作的一个明显示例，因为它的目的是从构造器调用内部确定最初 new 的目标是什么，通用地说就是用于内省（检查类型 / 结构）或者静态属性访问。<br>举例来说，你可能需要在构造器内部根据是直接调用还是通过子类调用采取不同的动作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span> () &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'parent'</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'child'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Parent();	<span class="comment">// parent</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Child();	<span class="comment">// child</span></span><br></pre></td></tr></table></figure>
<h3 id="公开符号"><a href="#公开符号" class="headerlink" title="公开符号"></a>公开符号</h3><p>除了在自己的程序中定义符号之外，JavaScript 预先定义了一些内置符号，称为<strong>公开符号（Well-Known Symbol，WKS）</strong>。<br>定义这些符号主要是为了提供专门的元属性，以便把这些元属性暴露给 JavaScript 程序以获取对 JavaScript 行为更多的控制。</p>
<p>公开符号主要涉及到 ES6 新增的基本数据类型<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">Symbol</a>。</p>
<h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" target="_blank" rel="noopener">Symbol.iterator</a></h4><p>Symbol.iterator 表示任意对象上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的默认值。</p>
<p>然而，也可以通过定义 Symbol.iterator 属性为任意对象值定义自己的迭代器逻辑，即使这会覆盖默认的迭代器。这里的元编程特性在于我们定义了一个行为特性，供 JavaScript 其他部分（也就是运算符和循环结构）在处理定义的对象时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个只在奇数索引值产生值的迭代器</span></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> idx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="keyword">this</span>[idx];</span><br><span class="line">	&#125; <span class="keyword">while</span> ((idx += <span class="number">2</span>) &lt; <span class="keyword">this</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 7 9</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol-toStringTag-与-Symbol-hasInstance"><a href="#Symbol-toStringTag-与-Symbol-hasInstance" class="headerlink" title="Symbol.toStringTag 与 Symbol.hasInstance"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag" target="_blank" rel="noopener">Symbol.toStringTag</a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance" target="_blank" rel="noopener">Symbol.hasInstance</a></h4><p>最常见的一个元编程任务，就是在一个值上进行内省来找出它是什么种类，这通常是为了确定其上适合执行何种运算。对于对象来说，最常用的内省技术是 toString() 和 instanceof。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.toString(); <span class="comment">// [object Object]</span></span><br><span class="line">a <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在 ES6 中，可以控制这些操作的行为特性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">greeting</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'Foo'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( Foo, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value (inst) &#123;</span><br><span class="line">		<span class="keyword">return</span> inst.greeting == <span class="string">"hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Foo(<span class="string">'hello'</span>),</span><br><span class="line">    b = <span class="keyword">new</span> Foo(<span class="string">'world'</span>);</span><br><span class="line">b[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'cool'</span>;</span><br><span class="line">a.toString(); <span class="comment">// [object Foo]</span></span><br><span class="line"><span class="built_in">String</span>(b); <span class="comment">// [object cool]</span></span><br><span class="line">a <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>原型（或实例本身）的 <code>@@toStringTag</code> 符号指定了在 <code>[object __]</code> 字符串化时使用的字符串值。</p>
<p><code>@@hasInstance</code> 符号是在构造器函数上的一个方法，接受实例对象值，通过返回 <code>true</code> 或 <code>false</code> 来指示这个值是否可以被认为是一个实例。</p>
<blockquote>
<p>要在一个函数上设定 <code>@@hasInstance</code>，必须使用<code>Object.defineProperty(..)</code>，因为 Function.prototype 上默认的那一个是 writable: false（不可写的）。</p>
</blockquote>
<h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species" target="_blank" rel="noopener">Symbol.species</a></h4><p>符号 @@species，这个符号控制要生成新实例时，类的内置方法使用哪一个构造器。<br>最常见的例子是，在创建 Array 的子类并想要定义继承的方法（比如 slice(..)）时使用哪一个构造器（是 Array(..) 还是自定义的子类）。默认情况下，调用 Array 子类实例上的slice(..) 会创建这个子类的新实例，坦白说这很可能就是你想要的。<br>但是，你可以通过覆盖一个类的默认 @@species 定义来进行元编程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cool</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 把@@species推迟到子类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">	again() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species]();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span> <span class="keyword">extends</span> <span class="title">Cool</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> <span class="keyword">extends</span> <span class="title">Cool</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 强制指定@@species为父构造器</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> Cool; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Fun(),</span><br><span class="line">	b = <span class="keyword">new</span> Awesome(),</span><br><span class="line">	c = a.again(),</span><br><span class="line">	d = b.again();</span><br><span class="line">c <span class="keyword">instanceof</span> Fun; <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> Awesome; <span class="comment">// false</span></span><br><span class="line">d <span class="keyword">instanceof</span> Cool; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>就像前面代码中 Cool 的定义那样，内置原生构造器上 Symbol.species 的默认行为是return this。在用户类上没有默认值，但是就像展示的那样，这个行为特性很容易模拟。如果需要定义生成新实例的方法，使用 new this.constructor<a href="..">Symbol.species</a> 模式元编程，而不要硬编码 new this.constructor(..) 或 new XYZ(..)。然后继承类就能够自定义 Symbol.species 来控制由哪个构造器产生这些实例。</p>
<h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" target="_blank" rel="noopener">Symbol.toPrimitive</a></h4><p>抽象类型转换运算 ToPrimitive，它用在对象为了某个操作（比如比较 == 或者相加 +）必须被强制转换为一个原生类型值的时候。在 ES6 之前，没有办法控制这一行为。<br>而在 ES6 中，在任意对象值上作为属性的符号 <code>@@toPrimitivesymbol</code> 都可以通过指定一个方法来定制这个 ToPrimitive 强制转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr + <span class="number">10</span>; <span class="comment">// 1,2,3,4,510</span></span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hint == <span class="string">'default'</span> || hint == <span class="string">'number'</span>) &#123;</span><br><span class="line">		<span class="comment">// 求所有数字之和</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.reduce( <span class="function"><span class="keyword">function</span>(<span class="params">acc,curr</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> acc + curr;</span><br><span class="line">		&#125;, <span class="number">0</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">arr + <span class="number">10</span>; <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>Symbol.toPrimitive 方法根据调用 ToPrimitive 的运算期望的类型，会提供一个提示（hint）指定 “string”、”number” 或 “default”（这应该被解释为 “number”）。在前面的代码中，加法 + 运算没有提示（传入 “default”）。而乘法 * 运算提示为 “number”，String(arr)提示为 “string”。</p>
<blockquote>
<p>如果一个对象与另一个非对象值比较，<code>==</code> 运算符调用这个对象上的ToPrimitive 方法时不指定提示——如果有 @@toPrimitive 方法的话，调用时提示为 “default”。但是，如果比较的两个值都是对象，<code>==</code> 的行为和 <code>===</code> 一样，也就是直接比较其引用。这种情况下完全不会调用 @@toPrimitive。</p>
</blockquote>
<h4 id="正则表达式符号"><a href="#正则表达式符号" class="headerlink" title="正则表达式符号"></a>正则表达式符号</h4><p>对于正则表达式对象，有 4 个公开符号可以被覆盖，它们控制着这些正则表达式在 4 个对应的同名 String.prototype 函数中如何被使用。</p>
<ul>
<li><code>@@match</code>：正则表达式的 Symbol.match 值是一个用于利用给定的正则表达式匹配一个字符串值的部分或全部内容的方法。如果传给 String.prototype.match(..) 一个正则表达式，那么用它来进行模式匹配。</li>
<li><code>@@replace</code>：正则表达式的 Symbol.replace 值是一个方法，String.prototype.replace(..) 用它来替换一个字符串内匹配给定的正则表达式模式的一个或多个字符序列。</li>
<li><code>@@search</code>：正则表达式的 Symbol.search 值是一个方法，String.prototype.search(..) 用它来在另一个字符串中搜索一个匹配给定正则表达式的子串。</li>
<li><code>@@split</code>：正则表达式的 Symbol.split 值是一个方法，String.prototype.split(..) 用它把字符串在匹配给定正则表达式的分隔符处<br>分割为子串。</li>
</ul>
<blockquote>
<p>如果你不够艺高人胆大的话，就不要覆盖内置正则表达式算法了！ JavaScript 的正则表达式引擎经过高度优化，所以你自己的用户代码很可能会慢上许多。这类元编程简洁强大，但是只应该在确实需要或能带来收益的时候才使用。</p>
</blockquote>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable" target="_blank" rel="noopener">Symbol.isConcatSpreadable</a></h4><p>符号 @@isConcatSpreadable 可以被定义为任意对象（比如数组或其他可迭代对象）的布尔型属性（Symbol.isConcatSpreadable），用来指示如果把它传给一个数组的 concat(..) 是否应该将其展开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">b[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[].concat( a, b ); <span class="comment">// [1,2,3,[4,5,6]]</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables" target="_blank" rel="noopener">Symbol.unscopables</a></h4><p>符号 @@unscopables 可以被定义为任意对象的对象属性（Symbol.unscopables），用来指示使用 with 语句时哪些属性可以或不可以暴露为词法变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;,</span><br><span class="line">	a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">	a: <span class="literal">false</span>,</span><br><span class="line">	b: <span class="literal">true</span>,</span><br><span class="line">	c: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a, b, c ); <span class="comment">// 1 20 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@@unscopables 对象中的 true 表示这个属性应该是 unscopable 的，因此会从词法作用域变量中被过滤出去。false 表示可以将其包含到词法作用域变量中。</p>
<blockquote>
<p>strict 模式下不允许 with 语句，因此应当被认为是语言的过时特性。不要使用它。</p>
</blockquote>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种由你创建的特殊的对象，它“封装”另一个普通对象——或者说挡在这个普通对象的前面。你可以在代理对象上注册特殊的处理函数（也就是 trap），代理上执行各种操作的时候会调用这个程序。这些处理函数除了把操作转发给原始目标 / 被封装对象之外，还有机会执行额外的逻辑。</p>
<p>你可以在代理上定义的 trap 处理函数的一个例子是 get，当你试图访问对象属性的时候，它拦截 <code>[[Get]]</code> 运算。</p>
<p>在 ECMAScript 6 中引入的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener"><code>Proxy</code></a> 对象可以拦截某些操作并实现自定义行为。例如获取一个对象上的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">	<span class="keyword">get</span>: function(target, name)&#123;</span><br><span class="line">		<span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">42</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b); <span class="comment">// 1, 42</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy</code> 对象定义了一个目标（这里是一个空对象）和一个实现了 <code>get</code> 陷阱的 handle 对象。这里，代理的对象在获取未定义的属性时不会返回 <code>undefined</code>，而是返回 42。</p>
<h4 id="在目标对象-函数代理上可以定义的处理函数，以及如何-何时被触发。"><a href="#在目标对象-函数代理上可以定义的处理函数，以及如何-何时被触发。" class="headerlink" title="在目标对象 / 函数代理上可以定义的处理函数，以及如何 / 何时被触发。"></a>在目标对象 / 函数代理上可以定义的处理函数，以及如何 / 何时被触发。</h4><ul>
<li><code>get(..)</code>：通过 <code>[[Get]]</code>，在代理上访问一个属性（Reflect.get(..)、. 属性运算符或 [ .. ] 属性运算符）；</li>
<li><code>set(..)</code>：通过 <code>[[Set]]</code>，在代理上设置一个属性值（Reflect.set(..)、赋值运算符 = 或目标为对象属性的解构赋值）</li>
<li><code>deleteProperty(..)</code>：通过 <code>[[Delete]]</code>， 从代理对象上删除一个属性（Reflect.deleteProperty(..) 或delete）</li>
<li><code>apply(..)</code>：（如果目标为函数）通过 <code>[[Call]]</code>，将代理作为普通函数 / 方 法 调 用（Reflect.apply(..)、call(..)、apply(..) 或 (..) 调用运算符）</li>
<li><code>construct(..)</code>：（如果目标为构造函数）通过 <code>[[Construct]]</code>，将代理作为构造函数调用（Reflect.construct(..) 或 new）</li>
<li><code>getOwnPropertyDescriptor(..)</code>：通过 <code>[[GetOwnProperty]]</code>，从代理中提取一个属性描述符（Object.getOwnPropertyDescriptor(..)或 Reflect.getOwnPropertyDescriptor(..)）</li>
<li><code>defineProperty(..)</code>：通过 <code>[[DefineOwnProperty]]</code>，在代理上设置一个属性描述符（Object.defineProperty(..)或 Reflect.defineProperty(..)）</li>
<li><code>getPrototypeOf(..)</code>：通过 <code>[[GetPrototypeOf]]</code>，得到代理的 <code>[[Prototype]]</code>（Object.getPrototypeOf(..)、Reflect.getPrototypeOf(..)、<strong>proto</strong>、Object#isPrototypeOf(..) 或 instanceof）</li>
<li><code>setPrototypeOf(..)</code>：通过 <code>[[SetPrototypeOf]]</code>，设置代理的 <code>[[Prototype]]</code>（Object.setPrototypeOf(..)、Reflect.setPrototypeOf(..) 或 <strong>proto</strong>）</li>
<li><code>preventExtensions(..)</code>：通过 <code>[[PreventExtensions]]</code>，使得代理变成不可扩展的（Object.prevent Extensions(..)或 Reflect.preventExtensions(..)）</li>
<li><code>isExtensible(..)</code>：通过 <code>[[IsExtensible]]</code>，检测代理是否可扩展（Object.isExtensible(..) 或 Reflect.isExtensible(..)）</li>
<li><code>ownKeys(..)</code>：通过 <code>[[OwnPropertyKeys]]</code>，提取代理自己的属性和 / 或符号属性（Object.keys(..)、Object.getOwnPropertyNames(..)、Object.getOwnSymbolProperties(..)、Reflect.ownKeys(..) 或 JSON.stringify(..)）</li>
<li><code>enumerate(..)</code>：通过 <code>[[Enumerate]]</code>，取得代理拥有的和“继承来的”可枚举属性的迭代器（Reflect.enumerate(..) 或 for..in）</li>
<li><code>has(..)</code>：通过 <code>[[HasProperty]]</code>，检查代理是否拥有或者“继承了”某个属性（Reflect.has(..)、Object#hasOwnProperty(..) 或 “prop” in obj）</li>
</ul>
<p>除了上面列出的会触发各种 trap 的动作，某些 trap 是由其他 trap 的默认动作间接触发的。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">	getOwnPropertyDescriptor(target, prop) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'getOwnPropertyDescriptor'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, prop);</span><br><span class="line">	&#125;,</span><br><span class="line">	defineProperty(target, prop, desc) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"defineProperty"</span> );</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(target, prop, desc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">	proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>( &#123;&#125;, handlers );</span><br><span class="line"></span><br><span class="line">proxy.a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure></p>
<p>getOwnPropertyDescriptor(..) 和 defineProperty(..) 处理函数是在设定属性值（不管是新增的还是更新已有的）时由默认 set(..)处理函数的步骤触发的。如果你也自定义了set(..) 处理函数，那么在 context（不是 target ！）上可以（也可以不）进行相应的调用，这些调用会触发这些代理 trap。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>在讨论代理的功能时会用到以下术语。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener"><code>handler</code></a>：包含陷阱的占位符对象。</li>
<li><code>traps</code>：提供属性访问的方法。这类似于操作系统中陷阱的概念。</li>
<li><code>target</code>：代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li>
<li><code>invariants</code>：实现自定义操作时保持不变的语义称为不变量。如果你违反处理程序的不变量，则会抛出一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</li>
</ul>
<h3 id="撤销-Proxy"><a href="#撤销-Proxy" class="headerlink" title="撤销 Proxy"></a>撤销 <code>Proxy</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable" target="_blank" rel="noopener"><code>Proxy.revocable()</code></a> 方法被用来创建可撤销的 <code>Proxy</code> 对象。这意味着 proxy 可以通过 <code>revoke</code> 函数来撤销，并且关闭代理。此后，代理上的任意的操作都会导致<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> revocable = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">	<span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[["</span> + name + <span class="string">"]]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> proxy = revocable.proxy;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// "[[foo]]"</span></span><br><span class="line"></span><br><span class="line">revocable.revoke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError is thrown</span></span><br><span class="line">proxy.foo = <span class="number">1</span>           <span class="comment">// TypeError again</span></span><br><span class="line"><span class="keyword">delete</span> proxy.foo;       <span class="comment">// still TypeError</span></span><br><span class="line"><span class="keyword">typeof</span> proxy            <span class="comment">// "object", typeof doesn't trigger any trap</span></span><br></pre></td></tr></table></figure>
<p>它接收同样的两个参数：<code>target</code> 和 <code>handlers</code>。和 new Proxy(..) 不一样，Proxy.revocable(..) 的返回值不是代理本身。而是一个有两个属性——<code>proxy</code> 和 <code>revode</code> 的对象。</p>
<p><strong>一旦可取消代理被取消，任何对它的访问（触发它的任意 trap）都会抛出 TypeError。</strong>可取消代理的一个可能应用场景是，在你的应用中把代理分发到第三方，其中管理你的模型数据，而不是给出真实模型本身的引用。如果你的模型对象改变或者被替换，就可以使分发出去的代理失效，这样第三方能够（通过错误！）知晓变化并请求更新到这个模型的引用。</p>
<h4 id="代理在先"><a href="#代理在先" class="headerlink" title="代理在先"></a>代理在先</h4><p>通常可以把代理看作是对目标对象的“包装”。在这种意义上，代理成为了代码交互的主要对象，而实际目标对象保持隐藏 / 被保护的状态。<br>你可能这么做是因为你想要把对象传入到某个无法被完全“信任”的环境，因此需要为对它的访问增强规范性，而不是把对象本身传入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = [],</span><br><span class="line">	handlers = &#123;</span><br><span class="line">		<span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">			<span class="comment">// 字符串值？</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> target[key] === <span class="string">'string'</span>) &#123;</span><br><span class="line">				<span class="comment">// 过滤掉标点符号</span></span><br><span class="line">				<span class="keyword">return</span> target[key].replace( <span class="regexp">/[^\w]/g</span>, <span class="string">""</span> );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 所有其他的传递下去</span></span><br><span class="line">			<span class="keyword">return</span> target[key];</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">			<span class="comment">// 设定唯一字符串，改为小写</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">				val = val.toLowerCase();</span><br><span class="line">				<span class="keyword">if</span> (target.indexOf( val ) === <span class="number">-1</span>) &#123;</span><br><span class="line">					target.push(val.toLowerCase());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	messages_proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(messages, handlers);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 其他某处：</span></span><br><span class="line">messages_proxy.push(<span class="string">'heLLo...'</span>, <span class="number">42</span>, <span class="string">'wOrlD!!'</span>, <span class="string">'WoRld!!'</span>);</span><br><span class="line"></span><br><span class="line">messages_proxy.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line">messages.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// hello... world!!</span></span><br></pre></td></tr></table></figure>
<p>通过与 messages_proxy 交互来增加某些特殊的规则，这些是 messages 本身没有的。我们只在值为字符串并且是唯一值的时候才添加这个元素；我们还将这个值变为小写。在从messages_proxy 提取值的时候，我们过滤掉了字符串中的所有标点符号。</p>
<h4 id="代理在后"><a href="#代理在后" class="headerlink" title="代理在后"></a>代理在后</h4><p>另外，我们也可以完全反转这个模式，让目标与代理交流，而不是代理与目标交流。这样，代码只能与主对象交互。这个回退方式的最简单实现就是把 proxy 对象放到主对象的 <code>[[Prototype]]</code> 链中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">	<span class="keyword">get</span>(target, key, context) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			context.speak(key + <span class="string">"!"</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">	catchall = <span class="keyword">new</span> <span class="built_in">Proxy</span>( &#123;&#125;, handlers ),</span><br><span class="line">	greeter = &#123;</span><br><span class="line">		speak(who = <span class="string">"someone"</span>) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"hello"</span>, who );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 设定greeter回退到catchall</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( greeter, catchall );</span><br><span class="line">greeter.speak(); <span class="comment">// hello someone</span></span><br><span class="line">greeter.speak( <span class="string">"world"</span> ); <span class="comment">// hello world</span></span><br><span class="line">greeter.everyone(); <span class="comment">// hello everyone!</span></span><br></pre></td></tr></table></figure>
<p>这里直接与 greeter 而不是 catchall 交流。当我们调用 speak(..) 的时候，它在 greeter 上被找到并直接使用。但是当我们试图访问像 everyone() 这样的方法的时候，这个函数在 greeter 上并不存在。<br>默认的对象属性行为是检查 <code>[[Prototype]]</code> 链，所以会查看 catchall 是否有 everyone 属性。然后代理的 get() 处理函数介入并返回一个用访问的属性名（”everyone”）调用 speak(..) 的函数。<br>我把这个模式称为代理在后（proxy last），因为在这里代理只作为最后的保障。</p>
<h5 id="“No-Such-Property-Method”"><a href="#“No-Such-Property-Method”" class="headerlink" title="“No Such Property/Method”"></a>“No Such Property/Method”</h5><p>有一个关于 JavaScript 的常见抱怨，在你试着访问或设置一个还不存在的属性时，默认情况下对象不是非常具有防御性。你可能希望预先定义好一个对象的所有属性 / 方法之后，访问不存在的属性名时能够抛出一个错误。</p>
<p>我们可以通过代理实现这一点，代理在先或代理在后设计都可以。两种情况我们都考虑一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	foo() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"a:"</span>, <span class="keyword">this</span>.a );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">	handlers = &#123;</span><br><span class="line">		<span class="keyword">get</span>(target, key, context) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Reflect</span>.has( target, key )) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, context);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"No such property/method!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span>(target, key, val, context) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Reflect</span>.has( target, key )) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, val, context);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"No such property/method!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	pobj = <span class="keyword">new</span> <span class="built_in">Proxy</span>( obj, handlers );</span><br><span class="line">	</span><br><span class="line">pobj.a = <span class="number">3</span>;</span><br><span class="line">pobj.foo(); <span class="comment">// a: 3 </span></span><br><span class="line">pobj.b = <span class="number">4</span>; <span class="comment">// Error: No such property/method!</span></span><br><span class="line">pobj.bar(); <span class="comment">// Error: No such property/method!</span></span><br></pre></td></tr></table></figure></p>
<p>对于 get(..) 和 set(..)，我们都只在目标对象的属性存在的时候才转发这个操作；否则抛出错误。主对象代码应该与代理对象（pobj）交流，因为它截获这些动作以提供保护。<br>现在，考虑转换为代理在后设计：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"No such property/method!"</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>() &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"No such property/method!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">	pobj = <span class="keyword">new</span> <span class="built_in">Proxy</span>( &#123;&#125;, handlers ),</span><br><span class="line">	obj = &#123;</span><br><span class="line">		a: <span class="number">1</span>,</span><br><span class="line">		foo() &#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"a:"</span>, <span class="keyword">this</span>.a );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 设定obj回退到pobj</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( obj, pobj );</span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line">obj.foo(); <span class="comment">// a: 3</span></span><br><span class="line">obj.b = <span class="number">4</span>; <span class="comment">// Error: No such property/method!</span></span><br><span class="line">obj.bar(); <span class="comment">// Error: No such property/method!</span></span><br></pre></td></tr></table></figure></p>
<p>考虑到处理函数的定义方式，这里的代理在后设计更简单一些。与截获 <code>[[Get]]</code> 和 <code>[[Set]]</code>操作并且只在目标属性存在情况下才转发不同，我们依赖于这样一个事实：如果 <code>[[Get]]</code> 或 <code>[[Set]]</code> 进入我们的 pobj 回退，此时这个动作已经遍历了整个 <code>[[Prototype]]</code> 链并且没有发现匹配的属性。</p>
<h5 id="代理-hack-Prototype-链"><a href="#代理-hack-Prototype-链" class="headerlink" title="代理 hack [[Prototype]] 链"></a>代理 hack <code>[[Prototype]]</code> 链</h5><p><code>[[Prototype]]</code> 机制运作的主要通道是 <code>[[Get]]</code> 运算。当直接对象中没有找到一个属性的时候，<code>[[Get]]</code> 会自动把这个运算转给 <code>[[Prototype]]</code> 对象处理。<br>这意味着你可以使用代理的 get(..) trap 来模拟或扩展这个 [[Prototype]] 机制的概念。<br>我们将考虑的第一个 hack 就是创建两个对象，通过 <code>[[Prototype]]</code> 连成环状（或者，至少看起来是这样！）。实际上并不能创建一个真正的 <code>[[Prototype]]</code> 环，因为引擎会抛出错误。但是可以用代理模拟。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">	<span class="keyword">get</span>(target, key, context) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Reflect</span>.has( target, key )) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 伪环状[[Prototype]]</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target[<span class="built_in">Symbol</span>.for(<span class="string">'[[Prototype]]'</span>)], key, context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">	obj1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">		name: <span class="string">'obj-1'</span>,</span><br><span class="line">		foo() &#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"foo:"</span>, <span class="keyword">this</span>.name );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, handlers),</span><br><span class="line">	obj2 = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create( obj1 ), &#123;</span><br><span class="line">		name: <span class="string">"obj-2"</span>,</span><br><span class="line">		bar() &#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"bar:"</span>, <span class="keyword">this</span>.name );</span><br><span class="line">			<span class="keyword">this</span>.foo();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 伪环状[[Prototype]]链接</span></span><br><span class="line">obj1[<span class="built_in">Symbol</span>.for(<span class="string">'[[Prototype]]'</span>)] = obj2;</span><br><span class="line">obj1.bar();</span><br><span class="line"><span class="comment">// bar: obj-1 &lt;-- 通过代理伪装[[Prototype]]</span></span><br><span class="line"><span class="comment">// foo: obj-1 &lt;-- this上下文依然保留着</span></span><br><span class="line">obj2.foo();</span><br><span class="line"><span class="comment">// foo: obj-2 &lt;-- 通过[[Prototype]]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="代理局限性"><a href="#代理局限性" class="headerlink" title="代理局限性"></a>代理局限性</h4><p>可以在对象上执行的很广泛的一组基本操作都可以通过这些元编程处理函数 trap。但有一些操作是无法（至少现在）拦截的。<br>比如，下面这些操作都不会 trap 并从代理 pobj 转发到目标 obj：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span> &#125;,</span><br><span class="line">	handlers = &#123; .. &#125;,</span><br><span class="line">	pobj = <span class="keyword">new</span> <span class="built_in">Proxy</span>( obj, handlers );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> obj;</span><br><span class="line"><span class="built_in">String</span>( obj ); </span><br><span class="line">obj + <span class="string">""</span>;</span><br><span class="line">obj == pobj;</span><br><span class="line">obj === pobj</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代理处理函数总会有一些不变性（invariant），亦即不能被覆盖的行为。比如，isExtensible(..) 处理函数的返回值总会被类型转换为 boolean。这些不变性限制了自定义代理行为的能力，但它们的目的只是为了防止你创建诡异或罕见（或者不一致）的行为。</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener"><code>Reflect</code></a> 是一个内置对象，它提供了可拦截 JavaScript 操作的方法。该方法和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener"><code>代理句柄</code></a>类似，但 <code>Reflect</code> 方法并不是一个函数对象。</p>
<p><code>Reflect</code> 有助于将默认操作从处理程序转发到目标。</p>
<p>以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has" target="_blank" rel="noopener"><code>Reflect.has()</code></a> 为例，你可以将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener"><code>in</code> 运算符</a>作为函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">"assign"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Reflect 对象是一个平凡对象（就像 Math），不像其他内置原生值一样是函数 / 构造器。<br>它持有对应于各种可控的元编程任务的静态函数。这些函数一对一对应着代理可以定义的处理函数方法（trap）。<br>这些函数中的一部分看起来和 Object 上的同名函数类似：</p>
<ul>
<li>Reflect.getOwnPropertyDescriptor(..);</li>
<li>Reflect.defineProperty(..);</li>
<li>Reflect.getPrototypeOf(..);</li>
<li>Reflect.setPrototypeOf(..);</li>
<li>Reflect.preventExtensions(..);</li>
<li>Reflect.isExtensible(..)。</li>
</ul>
<p>一般来说这些工具和 Object.<em> 的对应工具行为方式类似。但是，有一个区别是如果第一个参数（目标对象）不是对象的话，Object.</em>相应工具会试图把它类型转换为一个对象。而这种情况下 Reflect.* 方法只会抛出一个错误。</p>
<p>可以使用下面这些工具访问 / 查看一个对象键：</p>
<ul>
<li>Reflect.ownKeys(..)：返回所有“拥有”的（不是“继承”的）键的列表，就像 Object.getOwnPropertyNames(..) 和 Object.getOwnPropertySymbols(..)返回的一样。</li>
<li>Reflect.enumerate(..)：返回一个产生所有（拥有的和“继承的”）可枚举的（enumerable）非符号键集合的迭代器。本质上说，这个键的集合和 for..in 循环处理的那个键的集合是一样的。</li>
<li>Reflect.has(..)：实质上和 in 运算符一样，用于检查某个属性是否在某个对象上或者在它的<code>[[Prototype]]</code> 链上。比如，Reflect.has(o, “foo”)实质上就是执行 “foo” in o。</li>
</ul>
<p>函数调用和构造器调用可以通过使用下面这些工具手动执行，与普通的语法（比如，(..)和 new）分开 :</p>
<ul>
<li>Reflect.apply(..)：举例来说，Reflect.apply(foo,thisObj,[42,”bar”]) 以 thisObj 作为 this 调用 foo(..)函数，传入参数 42 和 “bar”。</li>
<li>Reflect.construct(..)：举例来说，Reflect.construct(foo,[42,”bar”]) 实质上就是调用 new foo(42,”bar”)。</li>
</ul>
<p>可以使用下面这些工具来手动执行对象属性访问、设置和删除。</p>
<ul>
<li>Reflect.get(..)：举例来说，Reflect.get(o,”foo”) 提取 o.foo。</li>
<li>Reflect.set(..)：举例来说，Reflect.set(o,”foo”,42) 实质上就是执行 o.foo = 42。</li>
<li>Reflect.deleteProperty(..)：举例来说，Reflect.deleteProperty(o,”foo”) 实质上就是执行 delete o.foo。</li>
</ul>
<p>Reflect 的元编程能力提供了模拟各种语法特性的编程等价物，把之前隐藏的抽象操作暴露出来。比如，你可以利用这些能力扩展功能和 API，以实现领域特定语言（DSL）。</p>
<h4 id="更好的-apply-函数"><a href="#更好的-apply-函数" class="headerlink" title="更好的 apply 函数"></a>更好的 <code>apply</code> 函数</h4><p>在 ES5 中，我们通常使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>Function.prototype.apply()</code></a> 方法调用一个具有给定 <code>this</code> 值和 <code>arguments</code> 数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]);</span><br></pre></td></tr></table></figure>
<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply" target="_blank" rel="noopener"><code>Reflect.apply</code></a>，这变得不那么冗长和容易理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]); </span><br><span class="line"><span class="comment">// 1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">String</span>.fromCharCode, <span class="literal">undefined</span>, [<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]);</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">RegExp</span>.prototype.exec, /ab/, [<span class="string">'confabulation'</span>]).index;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="string">''</span>.charAt, <span class="string">'ponies'</span>, [<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
<h4 id="检查属性定义是否成功"><a href="#检查属性定义是否成功" class="headerlink" title="检查属性定义是否成功"></a>检查属性定义是否成功</h4><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty</code></a>，如果成功返回一个对象，否则抛出一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，你将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener"><code>try...catch</code></a> 块来捕获定义属性时发生的任何错误。因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty" target="_blank" rel="noopener"><code>Reflect.defineProperty</code></a> 返回一个布尔值表示的成功状态，你可以在这里使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener"><code>if...else</code></a> 块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性排序"><a href="#属性排序" class="headerlink" title="属性排序"></a>属性排序</h4><p>在 ES6 之前，一个对象键 / 属性的列出顺序是依赖于具体实现，并未在规范中定义。一般来说，多数引擎按照创建的顺序进行枚举，虽然开发者们一直被强烈建议不要依赖于这个顺序。<br>对于 ES6 来说，拥有属性的列出顺序是由 <code>[[OwnPropertyKeys]]</code> 算法定义的，这个算法产生所有拥有的属性（字符串或符号），不管是否可枚举。这个顺序只对 Reflect.ownKeys(..)（以及扩展的 Object.getOwnPropertyNames(..) 和 Object.getOwnPropertySymbols(..)）有保证。<br>其顺序为：</p>
<ul>
<li>(1) 首先，按照数字上升排序，枚举所有整数索引拥有的属性；</li>
<li>(2) 然后，按照创建顺序枚举其余的拥有的字符串属性名；</li>
<li>(3) 最后，按照创建顺序枚举拥有的符号属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="built_in">Symbol</span>(<span class="string">'c'</span>)] = <span class="string">'yay'</span>; </span><br><span class="line">o[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">o[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">o.b = <span class="string">"awesome"</span>;</span><br><span class="line">o.a = <span class="string">"cool"</span>;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys( o ); <span class="comment">// [1,2,"b","a",Symbol(c)]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames( o ); <span class="comment">// [1,2,"b","a"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols( o ); <span class="comment">// [Symbol(c)]</span></span><br></pre></td></tr></table></figure>
<p>另一方面，<code>[[Enumerate]]</code> 算法只从目标对象和它的 <code>[[Prototype]]</code>链产生可枚举属性。它用于 Reflect.enumerate(..) 和 for..in。可以观察到的顺序和具体<br>的实现相关，不由规范控制。<br>与之对比，Object.keys(..) 调用 <code>[[OwnPropertyKeys]]</code> 算法取得拥有的所有键的列表。但是，它会过滤掉不可枚举属性，然后把这个列表重新排序来遵循遗留的与实现相关的行为特性，特别是 JSON.stringify(..) 和 for..in。因此通过扩展，这个顺序也和 Reflect.enumerate(..) 顺序相匹配。<br>换句话说，所有这 4 种机制（Reflect.enumerate(..)、Object.keys(..)、for..in 和 JSON.stringify(..)）都会匹配同样的与具体实现相关的排序，尽管严格上说是通过不同的路径。<br>把这 4 种机制与 <code>[[OwnPropertyKeys]]</code> 的排序匹配的具体实现是允许的，但并不是必须的。<br>尽管如此，你很可能会看到它们的排序特性是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Object</span>.create( o );</span><br><span class="line">p.c = <span class="number">3</span>;</span><br><span class="line">p.d = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="built_in">Reflect</span>.enumerate( p )) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( prop );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c d a b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( prop );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c d a b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( p );</span><br><span class="line"><span class="comment">// &#123;"c":3,"d":4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys( p );</span><br><span class="line"><span class="comment">// ["c","d"]</span></span><br></pre></td></tr></table></figure>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li>
<li><a href="https://www.zhihu.com/question/23856985" target="_blank" rel="noopener">https://www.zhihu.com/question/23856985</a></li>
<li>[《你不知道的js（下）》]</li>
</ul>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2020/06/06/mind/【笔记】okr/" class="prev">Previous Post<span>【笔记】OKR小记《黄勇的OKR实战笔记》</span></a></div><div class="post-next"><a href="/2020/05/09/SE/各种部署方式小记/" class="next">Next Post<span>【笔记】各种部署方式小记</span></a></div></div></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> Recent Posts</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/19/typescript/浅谈TypeScript的图灵完备性/">浅谈TypeScript的图灵完备性</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/23/notes/【笔记】《我的架构思想：基本模型、理论与原则》编三/">【笔记】《我的架构思想：基本模型、理论与原则》编三——架构原则，技艺、艺术与美</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/04/notes/【笔记】《我的架构思想：基本模型、理论与原则》编二/">【笔记】《我的架构思想：基本模型、理论与原则》编二——架构是过程，而非结果</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/12/notes/【笔记】《我的架构思想：基本模型、理论与原则》编一/">【笔记】《我的架构思想：基本模型、理论与原则》编一——你所关注的系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/20/notes/【笔记】Browserslist和使用/">【笔记】Browserslist 信息和使用整理</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> Author</h3><div class="widget-content"><div class="m-author"><div class="u-avatar"><img src="data:image/jpeg;base64,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"></div><div class="u-author_tit"><p>My name is Micheal Wayne and this is my blog.<br>I am a front-end software engineer.<br>Contact: <a href="mailto:michealwayne@163.com"> <span>michealwayne@163.com</span></a></p></div></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> Tags</h3><div class="widget-content"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BOM/">BOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bun/">Bun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKR/">OKR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UX/">UX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lerna/">lerna</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/">prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serviceWorker/">serviceWorker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sketch/">sketch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/taro/">taro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tslint/">tslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webApi/">webApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动效/">动效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图形处理/">图形处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程/">工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微前端/">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思维逻辑/">思维逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户体验/">用户体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/质量/">质量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工程/">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目管理/">项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul></div></div><div class="archive-lists widget"><h3 class="widget-title"> Archive</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">5</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2022 <a href="http://blog.michealwayne.cn">Micheal Wayne</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/MichealWayne" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="mailto:michealwayne@163.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://code.jquery.com/jquery-3.1.0.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-92791318-1",'auto');ga('send','pageview');</script></body></html>